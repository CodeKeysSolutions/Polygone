
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    /**
     * List of attributes that should always be set through the attr method,
     * because updating them through the property setter doesn't work reliably.
     * In the example of `width`/`height`, the problem is that the setter only
     * accepts numeric values, but the attribute can also be set to a string like `50%`.
     * If this list becomes too big, rethink this approach.
     */
    const always_set_through_set_attribute = ['width', 'height'];
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                /** #7364  target for <template> may be provided as #document-fragment(11) */
                else
                    this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));
                this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        const options = { direction: 'both' };
        let config = fn(node, params, options);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config(options);
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        const updates = [];
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                // defer updates until all the DOM shuffling is done
                updates.push(() => block.p(child_ctx, dirty));
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        run_all(updates);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /** Dispatch event on click outside of node */
    function clickOutside(node) {
        const handleClick = event => {
            if (node && !node.contains(event.target) && !event.defaultPrevented) {
                node.dispatchEvent(
                    new CustomEvent('clickOutside', node)
                );
            }
        };

        document.addEventListener('click', handleClick, true);

        return {
            destroy() {
                document.removeEventListener('click', handleClick, true);
            }
        }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=} start
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0 && stop) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    // Misc
    const ImageHoverData = writable({Show: false, Source: '', Top: 0, Left: 0});
    const DropdownData = writable({Show: false});
    const ShowLoader = writable(false);

    // Global
    const IsGov = writable(true);
    const IsEms = writable(true);
    const IsJudge = writable(true);
    const IsHighcommand = writable(true);

    // MDW
    const CurrentTab = writable("Dashboard");
    const IsPublic = writable(false);
    const MdwProfile = writable({
        department: "public",
        callsign: "N.T.B",
        name: "",
        alias: "",
        roles: []
    });

    const MdwCharges = writable([]);
    const MdwTags = writable([]);
    const MdwCerts = writable([]);
    const MdwRanks = writable([]);
    const MdwRoles = writable([]);
    const MdwEvidence = writable([]);

    // MDW - Modals
    const MdwModalsTags = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsCerts = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsRoles = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsUnits = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsPerson = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsEvidence = writable({
        Show: false,
        Form: { Type: 'Foto', Identifier: '', Description: '', Cid: '' },
        Cb: () => {}
    });

    const MdwModalsProfiles = writable({
        Show: false,
        IgnoreFilter: [],
        Cb: () => {}
    });

    const MdwModalsCharges = writable({
        Show: false,
        Charges: [],
        Cb: () => {}
    });

    const MdwModalsPermissions = writable({
        Show: false,
        Role: [],
        Cb: () => {}
    });

    const MdwModalsExport$1 = writable({
        Show: false,
        Msg: '',
    });

    const MdwModalsChargeEditor = writable({
        Show: false,
        Charge: {},
    });

    const MdwModalsVehicleHistory = writable({
        Show: false,
        Plate: ""
    });


    // MDW - Reports
    const CurrentReport = writable({
        category: 'Accident Rapport',
        title: '',
        report: '',
        evidence: [],
        tags: [],
        officers: [],
        persons: [],
        vehicles: [],
        scums: [],
    });

    // MDW - Profiles
    const CurrentProfile = writable({
        citizenid: "",
        name: "",
        image: "",
        notes: "",
    });

    // MDW - Evidence
    const CurrentEvidence = writable({
        type: "",
        identifier: "",
        description: "",
        citizenid: "",
    });

    // MDW - Properties
    const CurrentProperty = writable({
        adress: "",
        owned: "Nee",
    });

    // MDW - Staff
    const CurrentStaff = writable({
        citizenid: "",
        name: "",
        image: "",
        callsign: "",
        alias: "",
        phonenumber: "",
        department: "",
        rank: "",
        certs: [],
        strikes: [],
    });

    // MDW - Legislation
    const CurrentLegislation = writable({
        title: "",
        content: "",
    });

    // MDW - Businesses
    const CurrentBusiness = writable({ Employees: [] });

    // MDW - Config

    async function FetchNui(Resource, EventName, Data) {
        const ResourceName = Resource || (GetParentResourceName ? (window).GetParentResourceName() : "nui-frame-app");
        const Response = await fetch(`https://${ResourceName}/${EventName}`, {
            method: "post",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            },
            body: JSON.stringify(Data),
        });

        return await Response.json();
    }

    const UseNuiEvent = (action, handler) => {
        const eventListener = (event) => {
            const { Action: eventAction, Data } = event.data;
            if (`${eventAction}` === action) {
                handler(Data);
            }
        };

        onMount(() => window.addEventListener("message", eventListener));
        onDestroy(() => window.removeEventListener("message", eventListener));
    };

    // NUI Functions

    const SendEvent = (Event, Data, Cb) => {
        if (!Cb) Cb = () => {};

        FetchNui("fw-mdw", Event, Data || {}).then((ReturnData) => {
            Cb(true, ReturnData);
        }).catch((e) => {
            Cb(false, e);
        });
    };

    const AsyncSendEvent = (Event, Data) => {
        return new Promise((Res) => {
            SendEvent(Event, Data, (Success, Data) => {
                Res([Success, Data]);
            });
        })
    };

    const OnEvent = (Event, Cb) => {
        UseNuiEvent(Event, Cb);
    };

    const Debug$1 = (Message) => {
        // Disabled for PROD.
        // console.log(`[MDW-UI]: ${Message}`);
    };

    const SetExitHandler = (Event, NuiEvent, IsActive, Data) => {
        // Event = NUI Event, so you can reset data or smth
        // NuiEvent = NUI Callback in LUA
        // IsActive = Function Callback if the UI is focused (or active)
        // Data = Data to be sent to the Event & NUIEvent

        window.addEventListener("keyup", (e) => {
            if (e.key != 'Escape') return;
            if (!IsActive()) return;

            SendEvent(NuiEvent, Data);
            window.dispatchEvent(
                new MessageEvent("message", {
                    data: {
                        Action: Event,
                        Data: Data || {},
                    },
                })
            );
        });
    };

    const SetDropdown = (Show, Options, Positioning) => {
        if (!Positioning) Positioning = {};
        Positioning.Width = Positioning?.Width || 'max-content';

        DropdownData.set({
            Show: Show,
            Options: Options,
            Positioning: Positioning
        });
    };

    // JS Functions
    const IsEnvBrowser = () => !(window).invokeNative;
    const Delay = Sec => new Promise( Res => setTimeout(Res, Sec * 1000) );

    const FormatCurrency = new Intl.NumberFormat('nl-NL', {
        style: 'currency',
        currency: 'EUR',
    });

    const GetTimeLabel = (date, nowDate = Date.now(), rft = new Intl.RelativeTimeFormat('nl', { numeric: "auto" })) => {
        const SECOND = 1000;
        const MINUTE = 60 * SECOND;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        const WEEK = 7 * DAY;
        const MONTH = 30 * DAY;
        const YEAR = 365 * DAY;
        const intervals = [
            { ge: YEAR, divisor: YEAR, unit: 'year' },
            { ge: MONTH, divisor: MONTH, unit: 'month' },
            { ge: WEEK, divisor: WEEK, unit: 'week' },
            { ge: DAY, divisor: DAY, unit: 'day' },
            { ge: HOUR, divisor: HOUR, unit: 'hour' },
            { ge: MINUTE, divisor: MINUTE, unit: 'minute' },
            { ge: 30 * SECOND, divisor: SECOND, unit: 'seconds' },
            { ge: 0, divisor: 1, text: 'zojuist' },
        ];
        const now = typeof nowDate === 'object' ? nowDate.getTime() : new Date(nowDate).getTime();
        const diff = now - (typeof date === 'object' ? date : new Date(date)).getTime();
        const diffAbs = Math.abs(diff);
        for (const interval of intervals) {
            if (diffAbs >= interval.ge) {
                const x = Math.round(Math.abs(diff) / interval.divisor);
                const isFuture = diff < 0;
                return interval.unit ? rft.format(isFuture ? x : -x, interval.unit) : interval.text;
            }
        }
    };

    const GetLongTimeLabel = (timestamp) => new Date(timestamp).toLocaleString('nl-NL', {
        day: 'numeric',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });

    const CopyToClipboard = (text) => {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
    };


    // MDW Functions
    const GetRankById = Id => {
        return get_store_value(MdwRanks).filter(Val => Val.id == Id)[0];
    };

    const GetChargeById = Id => {
        return get_store_value(MdwCharges).filter(Val => Val.id == Id)[0];
    };

    const GetCertById = Id => {
        return get_store_value(MdwCerts).filter(Val => Val.id == Id)[0];
    };

    const GetRoleById = Id => {
        return get_store_value(MdwRoles).filter(Val => Val.id == Id)[0] || { name: "Incorrect", Icon: "exclamation-circle", color: "#ff0000", permissions: {} };
    };

    const GetTagById = Id => {
        return get_store_value(MdwTags).filter(Val => Val.id == Id)[0];
    };

    const GetEvidenceById = Type => {
        return get_store_value(MdwEvidence).filter(Val => Val.Text == Type)[0];
    };

    const HasCidPermission = (Permission) => {
        if (!get_store_value(MdwProfile)) return;

        const ProfileRoles = get_store_value(MdwProfile).roles;
        const Roles = get_store_value(MdwRoles);

        for (let i = 0; i < ProfileRoles.length; i++) {
            const RoleIndex = Roles.findIndex(Val => Val.id == ProfileRoles[i]);
            if (RoleIndex >= 0 && Roles[RoleIndex].permissions[Permission]) {
                return true;
            }    }
        return false;
    };

    /* src\components\Dropdown\Dropdown.svelte generated by Svelte v3.59.2 */
    const file$M = "src\\components\\Dropdown\\Dropdown.svelte";

    function get_each_context$o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (80:12) {#if Data.Icon}
    function create_if_block$y(ctx) {
    	let i;
    	let i_class_value;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "fas " + /*Data*/ ctx[14].Icon + " svelte-1vrqvf5");
    			add_location(i, file$M, 80, 16, 2268);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Options*/ 2 && i_class_value !== (i_class_value = "fas " + /*Data*/ ctx[14].Icon + " svelte-1vrqvf5")) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(80:12) {#if Data.Icon}",
    		ctx
    	});

    	return block;
    }

    // (64:4) {#each Options as Data, Key}
    function create_each_block$o(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*Data*/ ctx[14].Text + "";
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;
    	let if_block = /*Data*/ ctx[14].Icon && create_if_block$y(ctx);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[5](/*Data*/ ctx[14], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(div, "class", "dropdown-option svelte-1vrqvf5");
    			add_location(div, file$M, 64, 8, 1744);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler*/ ctx[4], false, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*Data*/ ctx[14].Icon) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$y(ctx);
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*Options*/ 2 && t1_value !== (t1_value = /*Data*/ ctx[14].Text + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$o.name,
    		type: "each",
    		source: "(64:4) {#each Options as Data, Key}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let div;
    	let mounted;
    	let dispose;
    	let each_value = /*Options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "dropdown-container svelte-1vrqvf5");
    			set_style(div, "width", /*Positioning*/ ctx[2]?.Width);
    			set_style(div, "top", /*Positioning*/ ctx[2]?.Top + "px");
    			set_style(div, "left", /*Positioning*/ ctx[2]?.Left + "px");
    			add_location(div, file$M, 54, 0, 1439);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			/*div_binding*/ ctx[7](div);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(clickOutside.call(null, div)),
    					listen_dev(div, "clickOutside", /*clickOutside_handler*/ ctx[6], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Value, Options, SetDropdown*/ 3) {
    				each_value = /*Options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$o(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$o(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*Positioning*/ 4) {
    				set_style(div, "width", /*Positioning*/ ctx[2]?.Width);
    			}

    			if (dirty & /*Positioning*/ 4) {
    				set_style(div, "top", /*Positioning*/ ctx[2]?.Top + "px");
    			}

    			if (dirty & /*Positioning*/ 4) {
    				set_style(div, "left", /*Positioning*/ ctx[2]?.Left + "px");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			/*div_binding*/ ctx[7](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dropdown', slots, []);
    	let { Value = "" } = $$props;
    	let { Options = [] } = $$props;
    	let { Positioning = {} } = $$props;
    	const Dispatch = createEventDispatcher();
    	let DropdownContainer;
    	let WindowHeight;
    	let MaxTop;
    	let DropdownContainerHeight = 0;

    	function handleDropdown() {
    		if (!DropdownContainer) return;
    		Dispatch("dropdownClosed");
    		MaxTop = WindowHeight - DropdownContainerHeight - 25;

    		if (Positioning?.Top > MaxTop) {
    			return DropdownContainer.style.setProperty("top", `${MaxTop}px`);
    		}

    		DropdownContainer.style.setProperty("top", `${Positioning?.Top}px`);
    	}

    	function handleOptionsUpdate() {
    		if (!DropdownContainer) return;
    		DropdownContainerHeight = DropdownContainer.offsetHeight;
    		MaxTop = WindowHeight - DropdownContainerHeight - 25;
    		handleDropdown();
    	}

    	onMount(() => {
    		WindowHeight = window.innerHeight;
    		handleOptionsUpdate();
    	});

    	afterUpdate(() => {
    		handleOptionsUpdate();
    	});

    	onDestroy(() => {
    		$$invalidate(3, DropdownContainer = null);
    	});

    	const writable_props = ['Value', 'Options', 'Positioning'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dropdown> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = (Data, e) => {
    		$$invalidate(0, Value = Data.Value);

    		if (Data.Cb) {
    			if (Data.ValueIsReal) {
    				Data.Cb(Data.Value, Data.Value);
    			} else {
    				Data.Cb(Data.Value || Data.Text, Data.Text);
    			}

    			SetDropdown(false);
    		}
    	};

    	const clickOutside_handler = () => {
    		SetDropdown(false);
    	};

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			DropdownContainer = $$value;
    			$$invalidate(3, DropdownContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('Value' in $$props) $$invalidate(0, Value = $$props.Value);
    		if ('Options' in $$props) $$invalidate(1, Options = $$props.Options);
    		if ('Positioning' in $$props) $$invalidate(2, Positioning = $$props.Positioning);
    	};

    	$$self.$capture_state = () => ({
    		clickOutside,
    		SetDropdown,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		createEventDispatcher,
    		Value,
    		Options,
    		Positioning,
    		Dispatch,
    		DropdownContainer,
    		WindowHeight,
    		MaxTop,
    		DropdownContainerHeight,
    		handleDropdown,
    		handleOptionsUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ('Value' in $$props) $$invalidate(0, Value = $$props.Value);
    		if ('Options' in $$props) $$invalidate(1, Options = $$props.Options);
    		if ('Positioning' in $$props) $$invalidate(2, Positioning = $$props.Positioning);
    		if ('DropdownContainer' in $$props) $$invalidate(3, DropdownContainer = $$props.DropdownContainer);
    		if ('WindowHeight' in $$props) WindowHeight = $$props.WindowHeight;
    		if ('MaxTop' in $$props) MaxTop = $$props.MaxTop;
    		if ('DropdownContainerHeight' in $$props) DropdownContainerHeight = $$props.DropdownContainerHeight;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	{
    		handleDropdown();
    	}

    	return [
    		Value,
    		Options,
    		Positioning,
    		DropdownContainer,
    		keyup_handler,
    		click_handler,
    		clickOutside_handler,
    		div_binding
    	];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$N, create_fragment$N, safe_not_equal, { Value: 0, Options: 1, Positioning: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get Value() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Value(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Options() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Options(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Positioning() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Positioning(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const DebugData = (events, timer) => {
        if (IsEnvBrowser()) {
            for (const event of events) {
                setTimeout(() => {
                    window.dispatchEvent(
                        new MessageEvent("message", {
                            data: {
                                Action: event.action,
                                Data: event.data,
                            },
                        })
                    );
                }, timer || 1000);
            }
        }
    };

    /* src\apps\Debug\Debug.svelte generated by Svelte v3.59.2 */
    const file$L = "src\\apps\\Debug\\Debug.svelte";

    // (32:0) {:else}
    function create_else_block$e(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-chevron-right debug-focus svelte-ojwy29");
    			add_location(i, file$L, 32, 4, 991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*SetVisible*/ ctx[4], false, false, false, false),
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[6], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(32:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:0) {#if Visible}
    function create_if_block$x(ctx) {
    	let i;
    	let t0;
    	let div;
    	let input;
    	let t1;
    	let textarea;
    	let t2;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			t0 = space();
    			div = element("div");
    			input = element("input");
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			button = element("button");
    			button.textContent = "Execute";
    			attr_dev(i, "class", "fas fa-chevron-left debug-focus svelte-ojwy29");
    			add_location(i, file$L, 25, 4, 531);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "NUI Event");
    			attr_dev(input, "class", "debug-event-action svelte-ojwy29");
    			add_location(input, file$L, 27, 8, 652);
    			attr_dev(textarea, "placeholder", "(VALID) JSON Message example: " + '{"Visible":true}');
    			attr_dev(textarea, "class", "debug-event-json svelte-ojwy29");
    			attr_dev(textarea, "cols", "30");
    			attr_dev(textarea, "rows", "10");
    			add_location(textarea, file$L, 28, 8, 752);
    			attr_dev(button, "class", "svelte-ojwy29");
    			add_location(button, file$L, 29, 8, 914);
    			attr_dev(div, "class", "debug-wrapper svelte-ojwy29");
    			add_location(div, file$L, 26, 4, 615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*Action*/ ctx[1]);
    			append_dev(div, t1);
    			append_dev(div, textarea);
    			set_input_value(textarea, /*Message*/ ctx[2]);
    			append_dev(div, t2);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*SetVisible*/ ctx[4], false, false, false, false),
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[5], false, false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[8]),
    					listen_dev(button, "click", /*SendDebugEvent*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Action*/ 2 && input.value !== /*Action*/ ctx[1]) {
    				set_input_value(input, /*Action*/ ctx[1]);
    			}

    			if (dirty & /*Message*/ 4) {
    				set_input_value(textarea, /*Message*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(25:0) {#if Visible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*Visible*/ ctx[0]) return create_if_block$x;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Debug', slots, []);
    	var Visible = false;
    	var Action = '';
    	var Message = '{}';

    	var SendDebugEvent = Element => {
    		if (!Message || Message.length == 0) $$invalidate(2, Message = "{}");

    		DebugData(
    			[
    				{
    					app: App,
    					action: Action,
    					data: JSON.parse(Message)
    				}
    			],
    			5
    		);
    	};

    	var SetVisible = () => {
    		$$invalidate(0, Visible = !Visible);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Debug> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_input_handler() {
    		Action = this.value;
    		$$invalidate(1, Action);
    	}

    	function textarea_input_handler() {
    		Message = this.value;
    		$$invalidate(2, Message);
    	}

    	$$self.$capture_state = () => ({
    		DebugData,
    		Visible,
    		Action,
    		Message,
    		SendDebugEvent,
    		SetVisible
    	});

    	$$self.$inject_state = $$props => {
    		if ('Visible' in $$props) $$invalidate(0, Visible = $$props.Visible);
    		if ('Action' in $$props) $$invalidate(1, Action = $$props.Action);
    		if ('Message' in $$props) $$invalidate(2, Message = $$props.Message);
    		if ('SendDebugEvent' in $$props) $$invalidate(3, SendDebugEvent = $$props.SendDebugEvent);
    		if ('SetVisible' in $$props) $$invalidate(4, SetVisible = $$props.SetVisible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Visible,
    		Action,
    		Message,
    		SendDebugEvent,
    		SetVisible,
    		keyup_handler,
    		keyup_handler_1,
    		input_input_handler,
    		textarea_input_handler
    	];
    }

    class Debug extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Debug",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src\apps\Mdw\MdwDepartmentLogo.svelte generated by Svelte v3.59.2 */
    const file$K = "src\\apps\\Mdw\\MdwDepartmentLogo.svelte";

    function create_fragment$L(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "mdw-department-logo svelte-zi7prn");
    			if (!src_url_equal(img.src, img_src_value = "./images/" + (/*DepartmentLogos*/ ctx[1][/*$MdwProfile*/ ctx[0].department] || "mdw-generic") + ".png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$K, 12, 0, 250);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$MdwProfile*/ 1 && !src_url_equal(img.src, img_src_value = "./images/" + (/*DepartmentLogos*/ ctx[1][/*$MdwProfile*/ ctx[0].department] || "mdw-generic") + ".png")) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $MdwProfile;
    	validate_store(MdwProfile, 'MdwProfile');
    	component_subscribe($$self, MdwProfile, $$value => $$invalidate(0, $MdwProfile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwDepartmentLogo', slots, []);

    	const DepartmentLogos = {
    		LSPD: "mdw-lspd",
    		BCSO: "mdw-bcso",
    		SASP: "mdw-sasp",
    		SDSO: "mdw-sdso",
    		RANGER: "mdw-ranger"
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwDepartmentLogo> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ MdwProfile, DepartmentLogos, $MdwProfile });
    	return [$MdwProfile, DepartmentLogos];
    }

    class MdwDepartmentLogo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwDepartmentLogo",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src\apps\Mdw\MdwTopbar.svelte generated by Svelte v3.59.2 */
    const file$J = "src\\apps\\Mdw\\MdwTopbar.svelte";

    // (12:8) {#if $MdwProfile.alias}
    function create_if_block_1$k(ctx) {
    	let t0;
    	let t1_value = /*$MdwProfile*/ ctx[0].alias + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("\"");
    			t1 = text(t1_value);
    			t2 = text("\"");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwProfile*/ 1 && t1_value !== (t1_value = /*$MdwProfile*/ ctx[0].alias + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(12:8) {#if $MdwProfile.alias}",
    		ctx
    	});

    	return block;
    }

    // (18:8) {:else}
    function create_else_block$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No profile found");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(18:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:8) {#if $MdwProfile.name}
    function create_if_block$w(ctx) {
    	let t_value = /*$MdwProfile*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwProfile*/ 1 && t_value !== (t_value = /*$MdwProfile*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(16:8) {#if $MdwProfile.name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div;
    	let mdwdepartmentlogo;
    	let t0;
    	let p;
    	let t1_value = (/*$MdwProfile*/ ctx[0].rank && GetRankById(/*$MdwProfile*/ ctx[0].rank).rank || "") + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	mdwdepartmentlogo = new MdwDepartmentLogo({ $$inline: true });
    	let if_block0 = /*$MdwProfile*/ ctx[0].alias && create_if_block_1$k(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*$MdwProfile*/ ctx[0].name) return create_if_block$w;
    		return create_else_block$d;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(mdwdepartmentlogo.$$.fragment);
    			t0 = space();
    			p = element("p");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if_block1.c();
    			attr_dev(p, "class", "mdw-profile-name svelte-1vgd0mv");
    			add_location(p, file$J, 8, 4, 274);
    			attr_dev(div, "class", "mdw-topbar svelte-1vgd0mv");
    			add_location(div, file$J, 5, 0, 188);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(mdwdepartmentlogo, div, null);
    			append_dev(div, t0);
    			append_dev(div, p);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			if (if_block0) if_block0.m(p, null);
    			append_dev(p, t3);
    			if_block1.m(p, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[1], false, false, false, false),
    					listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$MdwProfile*/ 1) && t1_value !== (t1_value = (/*$MdwProfile*/ ctx[0].rank && GetRankById(/*$MdwProfile*/ ctx[0].rank).rank || "") + "")) set_data_dev(t1, t1_value);

    			if (/*$MdwProfile*/ ctx[0].alias) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$k(ctx);
    					if_block0.c();
    					if_block0.m(p, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(p, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwdepartmentlogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwdepartmentlogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(mdwdepartmentlogo);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $MdwProfile;
    	validate_store(MdwProfile, 'MdwProfile');
    	component_subscribe($$self, MdwProfile, $$value => $$invalidate(0, $MdwProfile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwTopbar', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwTopbar> was created with unknown prop '${key}'`);
    	});

    	function mouseenter_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$capture_state = () => ({
    		MdwProfile,
    		GetRankById,
    		MdwDepartmentLogo,
    		$MdwProfile
    	});

    	return [$MdwProfile, mouseenter_handler, mouseleave_handler];
    }

    class MdwTopbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwTopbar",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    const DefaultReport = `<p><strong>[DEPARTMENT] Report</strong></p><p>[DATE_TIMESTAMP]</p><p>&nbsp;</p><p><strong>Reporting Officer:</strong></p><p>[REPORTING_OFFICER]</p><p>&nbsp;</p><p><strong>Assisting Officer(s):</strong></p><p>&nbsp;</p><p><strong>Suspect(s):</strong></p><p>&nbsp;</p><p><strong>Victim(s):</strong></p><p>&nbsp;</p><p><strong>Witness(es):</strong></p><p>&nbsp;</p><p><strong>Location:</strong></p><p>&nbsp;</p><p><strong>Debrief:</strong></p><p></p>`;
    const DefaultMedicalReport = `<p><strong>Los Santos Medical Group Report</strong></p><p>[DATE_TIMESTAMP]</p><p>&nbsp;</p><p><strong>Is there suspicion of internal/external blood loss:</strong> Yes/No</p><p>&nbsp;</p><p><strong>Is there suspicion of non-visible injury:</strong> Yes/No</p><p>&nbsp;</p><p><strong>Is there suspicion of visible internal injury:</strong> Yes/No</p><p>&nbsp;</p><p><strong>Treating Physician:</strong></p><p>[REPORTING_OFFICER]</p><p>&nbsp;</p><p><strong>Co-treating Physician(s):</strong></p><p>&nbsp;</p><p><strong>Patient(s):</strong></p><p>&nbsp;</p><p><strong>Location of incident:</strong></p><p>&nbsp;</p><p><strong>What is the patient suffering from?</strong></p><p>&nbsp;</p><p><strong>Treatment:</strong></p>`;
    const MCUReport = `<figure class="image"><img src="https://lh3.googleusercontent.com/HhFsWBEKklEsPQRgiKgHl23r8_hllz4s3pgmPxkQRgWxU4QU1D3m6wuAIDqJzi9ITN17-s_-9CT1hl1zPBmw-enXqw8oRmnA9UdEcZNoNXCRmBeBDv2xax-dfd8PSQlr5IAEW28R6EPGGH3CNrrJHec"></figure><p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOS SANTOS&nbsp;</strong></p><p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAJOR CRIME DIVISION</strong></p><p>&nbsp;</p><h2><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CASE REPORT</strong></h2><p>&nbsp;</p><p>&nbsp;</p><p><strong>FILE INFORMATION </strong><i><strong>#000-0000-G</strong></i></p><p>SUBJECT:&nbsp;</p><p>DETECTIVE(S):</p><p>[REPORTING_OFFICER]</p><p>DATE: [DATE_TIMESTAMP]</p><p>LOCATION:</p><p>&nbsp;</p><p><strong>SUSPECT (1) INFORMATION:</strong></p><p>NAME:</p><p>SURNAME:</p><p>STATE-ID:</p><p>&nbsp;</p><p><strong>REPORT FINDINGS:</strong></p><p>&nbsp;</p><p>&nbsp;</p>`;
    const CivilianReport = `<p><strong>[DEPARTMENT] Statement</strong></p><p>[DATE_TIMESTAMP]</p><p>&nbsp;</p><p><strong>Reporting Officer:</strong></p><p>[REPORTING_OFFICER]</p><p>&nbsp;</p><p><strong>Complainant:</strong></p><p>#[bsn] - [first and last name] ([phone number])</p><p>&nbsp;</p><p><strong>Debrief:</strong></p><p>Between [date and time] and [date and time] in the vicinity of [location], the incident mentioned in the introduction occurred and the complainant stated the following about the incident:</p><p>&nbsp;</p>`;

    const MdwTabs = [
        { Hidden: true, Permission: "Dashboard.Visible", Label: "Dashboard", Destination: "Dashboard" },
        { Hidden: true, Permission: "Reports.Visible", Label: "Reports", Destination: "Reports" },
        { Hidden: false, Label: "Profiles", Destination: "Profiles" },
        { Hidden: true, Permission: "Evidence.Visible", Label: "Evidence", Destination: "Evidence" },
        { Hidden: false, Label: "Properties", Destination: "Properties" },
        { Hidden: false, Label: "Charges", Destination: "Charges" },
        { Hidden: false, Label: "Staff", Destination: "Staff" },
        { Hidden: false, Label: "Legislation", Destination: "Legislation" },
        { Hidden: false, Label: "Businesses", Destination: "Businesses" },
        { Hidden: true, Permission: "Dashboard.Visible", Label: "Roster", Destination: "Roster" },
    ];

    const LicensesLocale = {
        "driver": "Driver's License",
        "hunting": "Hunting License",
        "weapon": "Weapon License",
        "fishing": "Fishing License",
        "flying": "Pilot License",
        "business": "Business License",
    };

    const PermissionsLocale = {
        "Dashboard.Visible": "Dashboard: Tab Visible",
        "Dashboard.ShowWarrents": "Dashboard: Show Warrants",
        "Dashboard.ShowBulletin": "Dashboard: Show Bulletin",
        "Reports.Visible": "Reports: Tab Visible",
        "Reports.Edit": "Reports: Edit Report",
        "Reports.Create": "Reports: Create Report",
        "Reports.Delete": "Reports: Delete Report",
        "Reports.Export": "Reports: Export Report",
        "Profiles.Visible": "Profiles: Tab Visible",
        "Profiles.Edit": "Profiles: Edit Profile",
        "Profiles.Create": "Profiles: Create Profile",
        "Profiles.Delete": "Profiles: Delete Profile",
        "Profiles.ShowHousing": "Profiles: Show Housing",
        "Profiles.ShowNotes": "Profiles: Show Notes",
        "Evidence.Visible": "Evidence: Tab Visible",
        "Evidence.Edit": "Evidence: Edit Evidence",
        "Evidence.Create": "Evidence: Create Evidence",
        "Evidence.Delete": "Evidence: Delete Evidence",
        "Staff.Visible": "Staff: Tab Visible",
        "Staff.GiveCerts": "Staff: Give/Remove Officer Certs",
        "Staff.ShowStrikes": "Staff: Show Officer Strikes",
        "Staff.GiveStrikes": "Staff: Give Officer Strike",
        "Legislation.Visible": "Legislation: Tab Visible",
        "Legislation.Edit": "Legislation: Edit Legislation",
        "Legislation.Create": "Legislation: Create Legislation",
        "Legislation.Delete": "Legislation: Delete Legislation",
        "Config.EditCharges": "Config: Edit Charges",
        "Config.DeleteCharges": "Config: Delete Charges",
    };

    const ReportTypes = [
        { Label: "Physio Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Prescription Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Medical Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Burn Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Gunshot Wound Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Mental Status Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Vehicle Accident Report", Jobs: ["ems", "judge"], Certs: false },
        { Label: "Incident Report", Jobs: ["pd", "judge"], Certs: false },
        { Label: "Investigation Report", Jobs: ["pd", "judge"], Certs: false },
        { Label: "MCU Investigation Report", Jobs: ["pd", "judge"], Certs: [7, 8] },
        { Label: "Seizure Report", Jobs: ["pd", "judge"], Certs: false },
        { Label: "Civilian Report", Jobs: ["pd", "judge"], Certs: false },
        { Label: "Bulletin Board", Jobs: ["pd", "ems", "judge"], Certs: false },
        { Label: "BOLO", Jobs: ["pd", "judge"], Certs: false },
        { Label: "Note", Jobs: ["pd", "judge"], Certs: false },
    ];

    const GetReportTypes = (Certs, JustArray) => {
        let Retval = [];

        const _IsGov = get_store_value(IsGov);
        const _IsJudge = get_store_value(IsJudge);
        const _IsEms = get_store_value(IsEms);
        const Job = (_IsGov || _IsJudge) ? ( _IsEms ? "ems" : "pd"  ) : "";

        for (let i = 0; i < ReportTypes.length; i++) {
            const Type = ReportTypes[i];

            if (Type.Jobs.includes(Job) && (!Type.Certs || Type.Certs.some(item => Certs.includes(item)))) {
                if (JustArray) {
                    Retval.push(Type.Label);
                } else {
                    Retval.push({ Text: Type.Label, Value: Type.Label });
                }
            }    }
        return Retval;
    };

    /* src\apps\Mdw\MdwNavbar.svelte generated by Svelte v3.59.2 */
    const file$I = "src\\apps\\Mdw\\MdwNavbar.svelte";

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (18:8) {#if ($IsPublic && !Tab.Hidden) || (!$IsPublic && (!Tab.Permission || HasCidPermission(Tab.Permission)))}
    function create_if_block_1$j(ctx) {
    	let div;
    	let h6;
    	let t_value = /*GetNavbarLabel*/ ctx[4](/*Tab*/ ctx[10]) + "";
    	let t;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*Tab*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h6 = element("h6");
    			t = text(t_value);
    			attr_dev(h6, "class", "svelte-brky2v");
    			add_location(h6, file$I, 19, 16, 784);

    			attr_dev(div, "class", div_class_value = "mdw-navbar-item " + (/*$CurrentTab*/ ctx[1] == /*Tab*/ ctx[10].Destination
    			? "active"
    			: "") + " svelte-brky2v");

    			add_location(div, file$I, 18, 12, 639);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);
    			append_dev(h6, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler*/ ctx[6], false, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$CurrentTab*/ 2 && div_class_value !== (div_class_value = "mdw-navbar-item " + (/*$CurrentTab*/ ctx[1] == /*Tab*/ ctx[10].Destination
    			? "active"
    			: "") + " svelte-brky2v")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(18:8) {#if ($IsPublic && !Tab.Hidden) || (!$IsPublic && (!Tab.Permission || HasCidPermission(Tab.Permission)))}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#each MdwTabs as Tab, Key}
    function create_each_block$n(ctx) {
    	let show_if = /*$IsPublic*/ ctx[0] && !/*Tab*/ ctx[10].Hidden || !/*$IsPublic*/ ctx[0] && (!/*Tab*/ ctx[10].Permission || HasCidPermission(/*Tab*/ ctx[10].Permission));
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_1$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$IsPublic*/ 1) show_if = /*$IsPublic*/ ctx[0] && !/*Tab*/ ctx[10].Hidden || !/*$IsPublic*/ ctx[0] && (!/*Tab*/ ctx[10].Permission || HasCidPermission(/*Tab*/ ctx[10].Permission));

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$j(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$n.name,
    		type: "each",
    		source: "(17:4) {#each MdwTabs as Tab, Key}",
    		ctx
    	});

    	return block;
    }

    // (27:4) {#if $IsHighcommand}
    function create_if_block$v(ctx) {
    	let div;
    	let h6;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h6 = element("h6");
    			h6.textContent = "Config";
    			attr_dev(h6, "class", "svelte-brky2v");
    			add_location(h6, file$I, 28, 12, 1120);
    			attr_dev(div, "class", div_class_value = "mdw-navbar-item " + (/*$CurrentTab*/ ctx[1] == "Config" ? "active" : "") + " svelte-brky2v");
    			set_style(div, "margin-top", "auto");
    			add_location(div, file$I, 27, 8, 940);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler_1*/ ctx[5], false, false, false, false),
    					listen_dev(div, "click", /*click_handler_1*/ ctx[8], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CurrentTab*/ 2 && div_class_value !== (div_class_value = "mdw-navbar-item " + (/*$CurrentTab*/ ctx[1] == "Config" ? "active" : "") + " svelte-brky2v")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(27:4) {#if $IsHighcommand}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div;
    	let t;
    	let each_value = MdwTabs;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
    	}

    	let if_block = /*$IsHighcommand*/ ctx[2] && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-navbar svelte-brky2v");
    			add_location(div, file$I, 15, 0, 453);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$CurrentTab, MdwTabs, OnNavbarClick, GetNavbarLabel, $IsPublic, HasCidPermission*/ 27) {
    				each_value = MdwTabs;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$n(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$n(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*$IsHighcommand*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $IsEms;
    	let $IsPublic;
    	let $CurrentTab;
    	let $IsHighcommand;
    	validate_store(IsEms, 'IsEms');
    	component_subscribe($$self, IsEms, $$value => $$invalidate(9, $IsEms = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(0, $IsPublic = $$value));
    	validate_store(CurrentTab, 'CurrentTab');
    	component_subscribe($$self, CurrentTab, $$value => $$invalidate(1, $CurrentTab = $$value));
    	validate_store(IsHighcommand, 'IsHighcommand');
    	component_subscribe($$self, IsHighcommand, $$value => $$invalidate(2, $IsHighcommand = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwNavbar', slots, []);

    	const OnNavbarClick = Tab => {
    		CurrentTab.set(Tab.Destination);
    	};

    	const GetNavbarLabel = Tab => {
    		if (!$IsPublic && $IsEms && Tab.Destination == "Charges") return "Facturen";
    		return Tab.Label;
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwNavbar> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Tab => {
    		OnNavbarClick(Tab);
    	};

    	const click_handler_1 = () => {
    		OnNavbarClick({ Destination: "Config" });
    	};

    	$$self.$capture_state = () => ({
    		MdwTabs,
    		CurrentTab,
    		IsEms,
    		IsHighcommand,
    		IsPublic,
    		HasCidPermission,
    		OnNavbarClick,
    		GetNavbarLabel,
    		$IsEms,
    		$IsPublic,
    		$CurrentTab,
    		$IsHighcommand
    	});

    	return [
    		$IsPublic,
    		$CurrentTab,
    		$IsHighcommand,
    		OnNavbarClick,
    		GetNavbarLabel,
    		keyup_handler_1,
    		keyup_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class MdwNavbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwNavbar",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src\apps\Mdw\components\MdwPanel.svelte generated by Svelte v3.59.2 */

    const file$H = "src\\apps\\Mdw\\components\\MdwPanel.svelte";

    function create_fragment$I(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[0],
    		{
    			class: div_class_value = "mdw-box-container " + /*$$restProps*/ ctx[0].class
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			toggle_class(div, "svelte-bo15gx", true);
    			add_location(div, file$H, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
    				(!current || dirty & /*$$restProps*/ 1 && div_class_value !== (div_class_value = "mdw-box-container " + /*$$restProps*/ ctx[0].class)) && { class: div_class_value }
    			]));

    			toggle_class(div, "svelte-bo15gx", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwPanel', slots, ['default']);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	return [$$restProps, $$scope, slots];
    }

    class MdwPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwPanel",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src\apps\Mdw\components\MdwPanel.Header.svelte generated by Svelte v3.59.2 */

    const file$G = "src\\apps\\Mdw\\components\\MdwPanel.Header.svelte";

    function create_fragment$H(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	let div_levels = [/*$$restProps*/ ctx[0], { class: "mdw-box-title" }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			toggle_class(div, "svelte-1bopthw", true);
    			add_location(div, file$G, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
    				{ class: "mdw-box-title" }
    			]));

    			toggle_class(div, "svelte-1bopthw", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwPanel_Header', slots, ['default']);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	return [$$restProps, $$scope, slots];
    }

    class MdwPanel_Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwPanel_Header",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\apps\Mdw\components\MdwPanel.List.svelte generated by Svelte v3.59.2 */

    const file$F = "src\\apps\\Mdw\\components\\MdwPanel.List.svelte";

    function create_fragment$G(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[0],
    		{
    			class: div_class_value = "mdw-card-list-container " + /*$$restProps*/ ctx[0]?.class
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			toggle_class(div, "svelte-xortk4", true);
    			add_location(div, file$F, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
    				(!current || dirty & /*$$restProps*/ 1 && div_class_value !== (div_class_value = "mdw-card-list-container " + /*$$restProps*/ ctx[0]?.class)) && { class: div_class_value }
    			]));

    			toggle_class(div, "svelte-xortk4", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwPanel_List', slots, ['default']);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	return [$$restProps, $$scope, slots];
    }

    class MdwPanel_List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwPanel_List",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*!
     * jQuery JavaScript Library v3.7.0
     * https://jquery.com/
     *
     * Copyright OpenJS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2023-05-11T18:29Z
     */

    var jquery = createCommonjsModule(function (module) {
    ( function( global, factory ) {

    	{

    		// For CommonJS and CommonJS-like environments where a proper `window`
    		// is present, execute the factory and get jQuery.
    		// For environments that do not have a `window` with a `document`
    		// (such as Node.js), expose a factory as module.exports.
    		// This accentuates the need for the creation of a real `window`.
    		// e.g. var jQuery = require("jquery")(window);
    		// See ticket trac-14549 for more info.
    		module.exports = global.document ?
    			factory( global, true ) :
    			function( w ) {
    				if ( !w.document ) {
    					throw new Error( "jQuery requires a window with a document" );
    				}
    				return factory( w );
    			};
    	}

    // Pass this if window is not defined yet
    } )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

    var arr = [];

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var flat = arr.flat ? function( array ) {
    	return arr.flat.call( array );
    } : function( array ) {
    	return arr.concat.apply( [], array );
    };


    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call( Object );

    var support = {};

    var isFunction = function isFunction( obj ) {

    		// Support: Chrome <=57, Firefox <=52
    		// In some browsers, typeof returns "function" for HTML <object> elements
    		// (i.e., `typeof document.createElement( "object" ) === "function"`).
    		// We don't want to classify *any* DOM node as a function.
    		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    		// Plus for old WebKit, typeof returns "function" for HTML collections
    		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
    			typeof obj.item !== "function";
    	};


    var isWindow = function isWindow( obj ) {
    		return obj != null && obj === obj.window;
    	};


    var document = window.document;



    	var preservedScriptAttributes = {
    		type: true,
    		src: true,
    		nonce: true,
    		noModule: true
    	};

    	function DOMEval( code, node, doc ) {
    		doc = doc || document;

    		var i, val,
    			script = doc.createElement( "script" );

    		script.text = code;
    		if ( node ) {
    			for ( i in preservedScriptAttributes ) {

    				// Support: Firefox 64+, Edge 18+
    				// Some browsers don't support the "nonce" property on scripts.
    				// On the other hand, just using `getAttribute` is not enough as
    				// the `nonce` attribute is reset to an empty string whenever it
    				// becomes browsing-context connected.
    				// See https://github.com/whatwg/html/issues/2369
    				// See https://html.spec.whatwg.org/#nonce-attributes
    				// The `node.getAttribute` check was added for the sake of
    				// `jQuery.globalEval` so that it can fake a nonce-containing node
    				// via an object.
    				val = node[ i ] || node.getAttribute && node.getAttribute( i );
    				if ( val ) {
    					script.setAttribute( i, val );
    				}
    			}
    		}
    		doc.head.appendChild( script ).parentNode.removeChild( script );
    	}


    function toType( obj ) {
    	if ( obj == null ) {
    		return obj + "";
    	}

    	// Support: Android <=2.3 only (functionish RegExp)
    	return typeof obj === "object" || typeof obj === "function" ?
    		class2type[ toString.call( obj ) ] || "object" :
    		typeof obj;
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module



    var version = "3.7.0",

    	rhtmlSuffix = /HTML$/i,

    	// Define a local copy of jQuery
    	jQuery = function( selector, context ) {

    		// The jQuery object is actually just the init constructor 'enhanced'
    		// Need init if jQuery is called (just allow error to be thrown if not included)
    		return new jQuery.fn.init( selector, context );
    	};

    jQuery.fn = jQuery.prototype = {

    	// The current version of jQuery being used
    	jquery: version,

    	constructor: jQuery,

    	// The default length of a jQuery object is 0
    	length: 0,

    	toArray: function() {
    		return slice.call( this );
    	},

    	// Get the Nth element in the matched element set OR
    	// Get the whole matched element set as a clean array
    	get: function( num ) {

    		// Return all the elements in a clean array
    		if ( num == null ) {
    			return slice.call( this );
    		}

    		// Return just the one element from the set
    		return num < 0 ? this[ num + this.length ] : this[ num ];
    	},

    	// Take an array of elements and push it onto the stack
    	// (returning the new matched element set)
    	pushStack: function( elems ) {

    		// Build a new jQuery matched element set
    		var ret = jQuery.merge( this.constructor(), elems );

    		// Add the old object onto the stack (as a reference)
    		ret.prevObject = this;

    		// Return the newly-formed element set
    		return ret;
    	},

    	// Execute a callback for every element in the matched set.
    	each: function( callback ) {
    		return jQuery.each( this, callback );
    	},

    	map: function( callback ) {
    		return this.pushStack( jQuery.map( this, function( elem, i ) {
    			return callback.call( elem, i, elem );
    		} ) );
    	},

    	slice: function() {
    		return this.pushStack( slice.apply( this, arguments ) );
    	},

    	first: function() {
    		return this.eq( 0 );
    	},

    	last: function() {
    		return this.eq( -1 );
    	},

    	even: function() {
    		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
    			return ( i + 1 ) % 2;
    		} ) );
    	},

    	odd: function() {
    		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
    			return i % 2;
    		} ) );
    	},

    	eq: function( i ) {
    		var len = this.length,
    			j = +i + ( i < 0 ? len : 0 );
    		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
    	},

    	end: function() {
    		return this.prevObject || this.constructor();
    	},

    	// For internal use only.
    	// Behaves like an Array's method, not like a jQuery method.
    	push: push,
    	sort: arr.sort,
    	splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[ 0 ] || {},
    		i = 1,
    		length = arguments.length,
    		deep = false;

    	// Handle a deep copy situation
    	if ( typeof target === "boolean" ) {
    		deep = target;

    		// Skip the boolean and the target
    		target = arguments[ i ] || {};
    		i++;
    	}

    	// Handle case when target is a string or something (possible in deep copy)
    	if ( typeof target !== "object" && !isFunction( target ) ) {
    		target = {};
    	}

    	// Extend jQuery itself if only one argument is passed
    	if ( i === length ) {
    		target = this;
    		i--;
    	}

    	for ( ; i < length; i++ ) {

    		// Only deal with non-null/undefined values
    		if ( ( options = arguments[ i ] ) != null ) {

    			// Extend the base object
    			for ( name in options ) {
    				copy = options[ name ];

    				// Prevent Object.prototype pollution
    				// Prevent never-ending loop
    				if ( name === "__proto__" || target === copy ) {
    					continue;
    				}

    				// Recurse if we're merging plain objects or arrays
    				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
    					( copyIsArray = Array.isArray( copy ) ) ) ) {
    					src = target[ name ];

    					// Ensure proper type for the source value
    					if ( copyIsArray && !Array.isArray( src ) ) {
    						clone = [];
    					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
    						clone = {};
    					} else {
    						clone = src;
    					}
    					copyIsArray = false;

    					// Never move original objects, clone them
    					target[ name ] = jQuery.extend( deep, clone, copy );

    				// Don't bring in undefined values
    				} else if ( copy !== undefined ) {
    					target[ name ] = copy;
    				}
    			}
    		}
    	}

    	// Return the modified object
    	return target;
    };

    jQuery.extend( {

    	// Unique for each copy of jQuery on the page
    	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

    	// Assume jQuery is ready without the ready module
    	isReady: true,

    	error: function( msg ) {
    		throw new Error( msg );
    	},

    	noop: function() {},

    	isPlainObject: function( obj ) {
    		var proto, Ctor;

    		// Detect obvious negatives
    		// Use toString instead of jQuery.type to catch host objects
    		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
    			return false;
    		}

    		proto = getProto( obj );

    		// Objects with no prototype (e.g., `Object.create( null )`) are plain
    		if ( !proto ) {
    			return true;
    		}

    		// Objects with prototype are plain iff they were constructed by a global Object function
    		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
    		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
    	},

    	isEmptyObject: function( obj ) {
    		var name;

    		for ( name in obj ) {
    			return false;
    		}
    		return true;
    	},

    	// Evaluates a script in a provided context; falls back to the global one
    	// if not specified.
    	globalEval: function( code, options, doc ) {
    		DOMEval( code, { nonce: options && options.nonce }, doc );
    	},

    	each: function( obj, callback ) {
    		var length, i = 0;

    		if ( isArrayLike( obj ) ) {
    			length = obj.length;
    			for ( ; i < length; i++ ) {
    				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
    					break;
    				}
    			}
    		} else {
    			for ( i in obj ) {
    				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
    					break;
    				}
    			}
    		}

    		return obj;
    	},


    	// Retrieve the text value of an array of DOM nodes
    	text: function( elem ) {
    		var node,
    			ret = "",
    			i = 0,
    			nodeType = elem.nodeType;

    		if ( !nodeType ) {

    			// If no nodeType, this is expected to be an array
    			while ( ( node = elem[ i++ ] ) ) {

    				// Do not traverse comment nodes
    				ret += jQuery.text( node );
    			}
    		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
    			return elem.textContent;
    		} else if ( nodeType === 3 || nodeType === 4 ) {
    			return elem.nodeValue;
    		}

    		// Do not include comment or processing instruction nodes

    		return ret;
    	},

    	// results is for internal usage only
    	makeArray: function( arr, results ) {
    		var ret = results || [];

    		if ( arr != null ) {
    			if ( isArrayLike( Object( arr ) ) ) {
    				jQuery.merge( ret,
    					typeof arr === "string" ?
    						[ arr ] : arr
    				);
    			} else {
    				push.call( ret, arr );
    			}
    		}

    		return ret;
    	},

    	inArray: function( elem, arr, i ) {
    		return arr == null ? -1 : indexOf.call( arr, elem, i );
    	},

    	isXMLDoc: function( elem ) {
    		var namespace = elem && elem.namespaceURI,
    			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

    		// Assume HTML when documentElement doesn't yet exist, such as inside
    		// document fragments.
    		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
    	},

    	// Support: Android <=4.0 only, PhantomJS 1 only
    	// push.apply(_, arraylike) throws on ancient WebKit
    	merge: function( first, second ) {
    		var len = +second.length,
    			j = 0,
    			i = first.length;

    		for ( ; j < len; j++ ) {
    			first[ i++ ] = second[ j ];
    		}

    		first.length = i;

    		return first;
    	},

    	grep: function( elems, callback, invert ) {
    		var callbackInverse,
    			matches = [],
    			i = 0,
    			length = elems.length,
    			callbackExpect = !invert;

    		// Go through the array, only saving the items
    		// that pass the validator function
    		for ( ; i < length; i++ ) {
    			callbackInverse = !callback( elems[ i ], i );
    			if ( callbackInverse !== callbackExpect ) {
    				matches.push( elems[ i ] );
    			}
    		}

    		return matches;
    	},

    	// arg is for internal usage only
    	map: function( elems, callback, arg ) {
    		var length, value,
    			i = 0,
    			ret = [];

    		// Go through the array, translating each of the items to their new values
    		if ( isArrayLike( elems ) ) {
    			length = elems.length;
    			for ( ; i < length; i++ ) {
    				value = callback( elems[ i ], i, arg );

    				if ( value != null ) {
    					ret.push( value );
    				}
    			}

    		// Go through every key on the object,
    		} else {
    			for ( i in elems ) {
    				value = callback( elems[ i ], i, arg );

    				if ( value != null ) {
    					ret.push( value );
    				}
    			}
    		}

    		// Flatten any nested arrays
    		return flat( ret );
    	},

    	// A global GUID counter for objects
    	guid: 1,

    	// jQuery.support is not used in Core but other projects attach their
    	// properties to it so it needs to exist.
    	support: support
    } );

    if ( typeof Symbol === "function" ) {
    	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
    }

    // Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
    	function( _i, name ) {
    		class2type[ "[object " + name + "]" ] = name.toLowerCase();
    	} );

    function isArrayLike( obj ) {

    	// Support: real iOS 8.2 only (not reproducible in simulator)
    	// `in` check used to prevent JIT error (gh-2145)
    	// hasOwn isn't used here due to false negatives
    	// regarding Nodelist length in IE
    	var length = !!obj && "length" in obj && obj.length,
    		type = toType( obj );

    	if ( isFunction( obj ) || isWindow( obj ) ) {
    		return false;
    	}

    	return type === "array" || length === 0 ||
    		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }


    function nodeName( elem, name ) {

    	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    }
    var pop = arr.pop;


    var sort = arr.sort;


    var splice = arr.splice;


    var whitespace = "[\\x20\\t\\r\\n\\f]";


    var rtrimCSS = new RegExp(
    	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
    	"g"
    );




    // Note: an element does not contain itself
    jQuery.contains = function( a, b ) {
    	var bup = b && b.parentNode;

    	return a === bup || !!( bup && bup.nodeType === 1 && (

    		// Support: IE 9 - 11+
    		// IE doesn't have `contains` on SVG.
    		a.contains ?
    			a.contains( bup ) :
    			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
    	) );
    };




    // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

    function fcssescape( ch, asCodePoint ) {
    	if ( asCodePoint ) {

    		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
    		if ( ch === "\0" ) {
    			return "\uFFFD";
    		}

    		// Control characters and (dependent upon position) numbers get escaped as code points
    		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
    	}

    	// Other potentially-special ASCII characters get backslash-escaped
    	return "\\" + ch;
    }

    jQuery.escapeSelector = function( sel ) {
    	return ( sel + "" ).replace( rcssescape, fcssescape );
    };




    var preferredDoc = document,
    	pushNative = push;

    ( function() {

    var i,
    	Expr,
    	outermostContext,
    	sortInput,
    	hasDuplicate,
    	push = pushNative,

    	// Local document vars
    	document,
    	documentElement,
    	documentIsHTML,
    	rbuggyQSA,
    	matches,

    	// Instance-specific data
    	expando = jQuery.expando,
    	dirruns = 0,
    	done = 0,
    	classCache = createCache(),
    	tokenCache = createCache(),
    	compilerCache = createCache(),
    	nonnativeSelectorCache = createCache(),
    	sortOrder = function( a, b ) {
    		if ( a === b ) {
    			hasDuplicate = true;
    		}
    		return 0;
    	},

    	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
    		"loop|multiple|open|readonly|required|scoped",

    	// Regular expressions

    	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
    		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

    	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
    	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

    		// Operator (capture 2)
    		"*([*^$|!~]?=)" + whitespace +

    		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
    		whitespace + "*\\]",

    	pseudos = ":(" + identifier + ")(?:\\((" +

    		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    		// 1. quoted (capture 3; capture 4 or capture 5)
    		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

    		// 2. simple (capture 6)
    		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

    		// 3. anything else (capture 2)
    		".*" +
    		")\\)|)",

    	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    	rwhitespace = new RegExp( whitespace + "+", "g" ),

    	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
    		whitespace + "*" ),
    	rdescend = new RegExp( whitespace + "|>" ),

    	rpseudo = new RegExp( pseudos ),
    	ridentifier = new RegExp( "^" + identifier + "$" ),

    	matchExpr = {
    		ID: new RegExp( "^#(" + identifier + ")" ),
    		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
    		TAG: new RegExp( "^(" + identifier + "|[*])" ),
    		ATTR: new RegExp( "^" + attributes ),
    		PSEUDO: new RegExp( "^" + pseudos ),
    		CHILD: new RegExp(
    			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
    				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
    				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

    		// For use in libraries implementing .is()
    		// We use this for POS matching in `select`
    		needsContext: new RegExp( "^" + whitespace +
    			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
    			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    	},

    	rinputs = /^(?:input|select|textarea|button)$/i,
    	rheader = /^h\d$/i,

    	// Easily-parseable/retrievable ID or TAG or CLASS selectors
    	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

    	rsibling = /[+~]/,

    	// CSS escapes
    	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
    		"?|\\\\([^\\r\\n\\f])", "g" ),
    	funescape = function( escape, nonHex ) {
    		var high = "0x" + escape.slice( 1 ) - 0x10000;

    		if ( nonHex ) {

    			// Strip the backslash prefix from a non-hex escape sequence
    			return nonHex;
    		}

    		// Replace a hexadecimal escape sequence with the encoded Unicode code point
    		// Support: IE <=11+
    		// For values outside the Basic Multilingual Plane (BMP), manually construct a
    		// surrogate pair
    		return high < 0 ?
    			String.fromCharCode( high + 0x10000 ) :
    			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    	},

    	// Used for iframes; see `setDocument`.
    	// Support: IE 9 - 11+, Edge 12 - 18+
    	// Removing the function wrapper causes a "Permission Denied"
    	// error in IE/Edge.
    	unloadHandler = function() {
    		setDocument();
    	},

    	inDisabledFieldset = addCombinator(
    		function( elem ) {
    			return elem.disabled === true && nodeName( elem, "fieldset" );
    		},
    		{ dir: "parentNode", next: "legend" }
    	);

    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
    	try {
    		return document.activeElement;
    	} catch ( err ) { }
    }

    // Optimize for push.apply( _, NodeList )
    try {
    	push.apply(
    		( arr = slice.call( preferredDoc.childNodes ) ),
    		preferredDoc.childNodes
    	);

    	// Support: Android <=4.0
    	// Detect silently failing push.apply
    	// eslint-disable-next-line no-unused-expressions
    	arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
    	push = {
    		apply: function( target, els ) {
    			pushNative.apply( target, slice.call( els ) );
    		},
    		call: function( target ) {
    			pushNative.apply( target, slice.call( arguments, 1 ) );
    		}
    	};
    }

    function find( selector, context, results, seed ) {
    	var m, i, elem, nid, match, groups, newSelector,
    		newContext = context && context.ownerDocument,

    		// nodeType defaults to 9, since context defaults to document
    		nodeType = context ? context.nodeType : 9;

    	results = results || [];

    	// Return early from calls with invalid selector or context
    	if ( typeof selector !== "string" || !selector ||
    		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

    		return results;
    	}

    	// Try to shortcut find operations (as opposed to filters) in HTML documents
    	if ( !seed ) {
    		setDocument( context );
    		context = context || document;

    		if ( documentIsHTML ) {

    			// If the selector is sufficiently simple, try using a "get*By*" DOM method
    			// (excepting DocumentFragment context, where the methods don't exist)
    			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

    				// ID selector
    				if ( ( m = match[ 1 ] ) ) {

    					// Document context
    					if ( nodeType === 9 ) {
    						if ( ( elem = context.getElementById( m ) ) ) {

    							// Support: IE 9 only
    							// getElementById can match elements by name instead of ID
    							if ( elem.id === m ) {
    								push.call( results, elem );
    								return results;
    							}
    						} else {
    							return results;
    						}

    					// Element context
    					} else {

    						// Support: IE 9 only
    						// getElementById can match elements by name instead of ID
    						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
    							find.contains( context, elem ) &&
    							elem.id === m ) {

    							push.call( results, elem );
    							return results;
    						}
    					}

    				// Type selector
    				} else if ( match[ 2 ] ) {
    					push.apply( results, context.getElementsByTagName( selector ) );
    					return results;

    				// Class selector
    				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
    					push.apply( results, context.getElementsByClassName( m ) );
    					return results;
    				}
    			}

    			// Take advantage of querySelectorAll
    			if ( !nonnativeSelectorCache[ selector + " " ] &&
    				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

    				newSelector = selector;
    				newContext = context;

    				// qSA considers elements outside a scoping root when evaluating child or
    				// descendant combinators, which is not what we want.
    				// In such cases, we work around the behavior by prefixing every selector in the
    				// list with an ID selector referencing the scope context.
    				// The technique has to be used as well when a leading combinator is used
    				// as such selectors are not recognized by querySelectorAll.
    				// Thanks to Andrew Dupont for this technique.
    				if ( nodeType === 1 &&
    					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

    					// Expand context for sibling selectors
    					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
    						context;

    					// We can use :scope instead of the ID hack if the browser
    					// supports it & if we're not changing the context.
    					// Support: IE 11+, Edge 17 - 18+
    					// IE/Edge sometimes throw a "Permission denied" error when
    					// strict-comparing two documents; shallow comparisons work.
    					// eslint-disable-next-line eqeqeq
    					if ( newContext != context || !support.scope ) {

    						// Capture the context ID, setting it first if necessary
    						if ( ( nid = context.getAttribute( "id" ) ) ) {
    							nid = jQuery.escapeSelector( nid );
    						} else {
    							context.setAttribute( "id", ( nid = expando ) );
    						}
    					}

    					// Prefix every selector in the list
    					groups = tokenize( selector );
    					i = groups.length;
    					while ( i-- ) {
    						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
    							toSelector( groups[ i ] );
    					}
    					newSelector = groups.join( "," );
    				}

    				try {
    					push.apply( results,
    						newContext.querySelectorAll( newSelector )
    					);
    					return results;
    				} catch ( qsaError ) {
    					nonnativeSelectorCache( selector, true );
    				} finally {
    					if ( nid === expando ) {
    						context.removeAttribute( "id" );
    					}
    				}
    			}
    		}
    	}

    	// All others
    	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
    }

    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */
    function createCache() {
    	var keys = [];

    	function cache( key, value ) {

    		// Use (key + " ") to avoid collision with native prototype properties
    		// (see https://github.com/jquery/sizzle/issues/157)
    		if ( keys.push( key + " " ) > Expr.cacheLength ) {

    			// Only keep the most recent entries
    			delete cache[ keys.shift() ];
    		}
    		return ( cache[ key + " " ] = value );
    	}
    	return cache;
    }

    /**
     * Mark a function for special use by jQuery selector module
     * @param {Function} fn The function to mark
     */
    function markFunction( fn ) {
    	fn[ expando ] = true;
    	return fn;
    }

    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */
    function assert( fn ) {
    	var el = document.createElement( "fieldset" );

    	try {
    		return !!fn( el );
    	} catch ( e ) {
    		return false;
    	} finally {

    		// Remove from its parent by default
    		if ( el.parentNode ) {
    			el.parentNode.removeChild( el );
    		}

    		// release memory in IE
    		el = null;
    	}
    }

    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo( type ) {
    	return function( elem ) {
    		return nodeName( elem, "input" ) && elem.type === type;
    	};
    }

    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo( type ) {
    	return function( elem ) {
    		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
    			elem.type === type;
    	};
    }

    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */
    function createDisabledPseudo( disabled ) {

    	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
    	return function( elem ) {

    		// Only certain elements can match :enabled or :disabled
    		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
    		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
    		if ( "form" in elem ) {

    			// Check for inherited disabledness on relevant non-disabled elements:
    			// * listed form-associated elements in a disabled fieldset
    			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
    			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
    			// * option elements in a disabled optgroup
    			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
    			// All such elements have a "form" property.
    			if ( elem.parentNode && elem.disabled === false ) {

    				// Option elements defer to a parent optgroup if present
    				if ( "label" in elem ) {
    					if ( "label" in elem.parentNode ) {
    						return elem.parentNode.disabled === disabled;
    					} else {
    						return elem.disabled === disabled;
    					}
    				}

    				// Support: IE 6 - 11+
    				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
    				return elem.isDisabled === disabled ||

    					// Where there is no isDisabled, check manually
    					elem.isDisabled !== !disabled &&
    						inDisabledFieldset( elem ) === disabled;
    			}

    			return elem.disabled === disabled;

    		// Try to winnow out elements that can't be disabled before trusting the disabled property.
    		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
    		// even exist on them, let alone have a boolean value.
    		} else if ( "label" in elem ) {
    			return elem.disabled === disabled;
    		}

    		// Remaining elements are neither :enabled nor :disabled
    		return false;
    	};
    }

    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo( fn ) {
    	return markFunction( function( argument ) {
    		argument = +argument;
    		return markFunction( function( seed, matches ) {
    			var j,
    				matchIndexes = fn( [], seed.length, argument ),
    				i = matchIndexes.length;

    			// Match elements found at the specified indexes
    			while ( i-- ) {
    				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
    					seed[ j ] = !( matches[ j ] = seed[ j ] );
    				}
    			}
    		} );
    	} );
    }

    /**
     * Checks a node for validity as a jQuery selector context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext( context ) {
    	return context && typeof context.getElementsByTagName !== "undefined" && context;
    }

    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [node] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    function setDocument( node ) {
    	var subWindow,
    		doc = node ? node.ownerDocument || node : preferredDoc;

    	// Return early if doc is invalid or already selected
    	// Support: IE 11+, Edge 17 - 18+
    	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    	// two documents; shallow comparisons work.
    	// eslint-disable-next-line eqeqeq
    	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
    		return document;
    	}

    	// Update global variables
    	document = doc;
    	documentElement = document.documentElement;
    	documentIsHTML = !jQuery.isXMLDoc( document );

    	// Support: iOS 7 only, IE 9 - 11+
    	// Older browsers didn't support unprefixed `matches`.
    	matches = documentElement.matches ||
    		documentElement.webkitMatchesSelector ||
    		documentElement.msMatchesSelector;

    	// Support: IE 9 - 11+, Edge 12 - 18+
    	// Accessing iframe documents after unload throws "permission denied" errors (see trac-13936)
    	// Support: IE 11+, Edge 17 - 18+
    	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    	// two documents; shallow comparisons work.
    	// eslint-disable-next-line eqeqeq
    	if ( preferredDoc != document &&
    		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

    		// Support: IE 9 - 11+, Edge 12 - 18+
    		subWindow.addEventListener( "unload", unloadHandler );
    	}

    	// Support: IE <10
    	// Check if getElementById returns elements by name
    	// The broken getElementById methods don't pick up programmatically-set names,
    	// so use a roundabout getElementsByName test
    	support.getById = assert( function( el ) {
    		documentElement.appendChild( el ).id = jQuery.expando;
    		return !document.getElementsByName ||
    			!document.getElementsByName( jQuery.expando ).length;
    	} );

    	// Support: IE 9 only
    	// Check to see if it's possible to do matchesSelector
    	// on a disconnected node.
    	support.disconnectedMatch = assert( function( el ) {
    		return matches.call( el, "*" );
    	} );

    	// Support: IE 9 - 11+, Edge 12 - 18+
    	// IE/Edge don't support the :scope pseudo-class.
    	support.scope = assert( function() {
    		return document.querySelectorAll( ":scope" );
    	} );

    	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
    	// Make sure the `:has()` argument is parsed unforgivingly.
    	// We include `*` in the test to detect buggy implementations that are
    	// _selectively_ forgiving (specifically when the list includes at least
    	// one valid selector).
    	// Note that we treat complete lack of support for `:has()` as if it were
    	// spec-compliant support, which is fine because use of `:has()` in such
    	// environments will fail in the qSA path and fall back to jQuery traversal
    	// anyway.
    	support.cssHas = assert( function() {
    		try {
    			document.querySelector( ":has(*,:jqfake)" );
    			return false;
    		} catch ( e ) {
    			return true;
    		}
    	} );

    	// ID filter and find
    	if ( support.getById ) {
    		Expr.filter.ID = function( id ) {
    			var attrId = id.replace( runescape, funescape );
    			return function( elem ) {
    				return elem.getAttribute( "id" ) === attrId;
    			};
    		};
    		Expr.find.ID = function( id, context ) {
    			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
    				var elem = context.getElementById( id );
    				return elem ? [ elem ] : [];
    			}
    		};
    	} else {
    		Expr.filter.ID =  function( id ) {
    			var attrId = id.replace( runescape, funescape );
    			return function( elem ) {
    				var node = typeof elem.getAttributeNode !== "undefined" &&
    					elem.getAttributeNode( "id" );
    				return node && node.value === attrId;
    			};
    		};

    		// Support: IE 6 - 7 only
    		// getElementById is not reliable as a find shortcut
    		Expr.find.ID = function( id, context ) {
    			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
    				var node, i, elems,
    					elem = context.getElementById( id );

    				if ( elem ) {

    					// Verify the id attribute
    					node = elem.getAttributeNode( "id" );
    					if ( node && node.value === id ) {
    						return [ elem ];
    					}

    					// Fall back on getElementsByName
    					elems = context.getElementsByName( id );
    					i = 0;
    					while ( ( elem = elems[ i++ ] ) ) {
    						node = elem.getAttributeNode( "id" );
    						if ( node && node.value === id ) {
    							return [ elem ];
    						}
    					}
    				}

    				return [];
    			}
    		};
    	}

    	// Tag
    	Expr.find.TAG = function( tag, context ) {
    		if ( typeof context.getElementsByTagName !== "undefined" ) {
    			return context.getElementsByTagName( tag );

    		// DocumentFragment nodes don't have gEBTN
    		} else {
    			return context.querySelectorAll( tag );
    		}
    	};

    	// Class
    	Expr.find.CLASS = function( className, context ) {
    		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
    			return context.getElementsByClassName( className );
    		}
    	};

    	/* QSA/matchesSelector
    	---------------------------------------------------------------------- */

    	// QSA and matchesSelector support

    	rbuggyQSA = [];

    	// Build QSA regex
    	// Regex strategy adopted from Diego Perini
    	assert( function( el ) {

    		var input;

    		documentElement.appendChild( el ).innerHTML =
    			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
    			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
    			"<option selected=''></option></select>";

    		// Support: iOS <=7 - 8 only
    		// Boolean attributes and "value" are not treated correctly in some XML documents
    		if ( !el.querySelectorAll( "[selected]" ).length ) {
    			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
    		}

    		// Support: iOS <=7 - 8 only
    		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
    			rbuggyQSA.push( "~=" );
    		}

    		// Support: iOS 8 only
    		// https://bugs.webkit.org/show_bug.cgi?id=136851
    		// In-page `selector#id sibling-combinator selector` fails
    		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
    			rbuggyQSA.push( ".#.+[+~]" );
    		}

    		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
    		// In some of the document kinds, these selectors wouldn't work natively.
    		// This is probably OK but for backwards compatibility we want to maintain
    		// handling them through jQuery traversal in jQuery 3.x.
    		if ( !el.querySelectorAll( ":checked" ).length ) {
    			rbuggyQSA.push( ":checked" );
    		}

    		// Support: Windows 8 Native Apps
    		// The type and name attributes are restricted during .innerHTML assignment
    		input = document.createElement( "input" );
    		input.setAttribute( "type", "hidden" );
    		el.appendChild( input ).setAttribute( "name", "D" );

    		// Support: IE 9 - 11+
    		// IE's :disabled selector does not pick up the children of disabled fieldsets
    		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
    		// In some of the document kinds, these selectors wouldn't work natively.
    		// This is probably OK but for backwards compatibility we want to maintain
    		// handling them through jQuery traversal in jQuery 3.x.
    		documentElement.appendChild( el ).disabled = true;
    		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
    			rbuggyQSA.push( ":enabled", ":disabled" );
    		}

    		// Support: IE 11+, Edge 15 - 18+
    		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
    		// Adding a temporary attribute to the document before the selection works
    		// around the issue.
    		// Interestingly, IE 10 & older don't seem to have the issue.
    		input = document.createElement( "input" );
    		input.setAttribute( "name", "" );
    		el.appendChild( input );
    		if ( !el.querySelectorAll( "[name='']" ).length ) {
    			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
    				whitespace + "*(?:''|\"\")" );
    		}
    	} );

    	if ( !support.cssHas ) {

    		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
    		// Our regular `try-catch` mechanism fails to detect natively-unsupported
    		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
    		// in browsers that parse the `:has()` argument as a forgiving selector list.
    		// https://drafts.csswg.org/selectors/#relational now requires the argument
    		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
    		rbuggyQSA.push( ":has" );
    	}

    	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

    	/* Sorting
    	---------------------------------------------------------------------- */

    	// Document order sorting
    	sortOrder = function( a, b ) {

    		// Flag for duplicate removal
    		if ( a === b ) {
    			hasDuplicate = true;
    			return 0;
    		}

    		// Sort on method existence if only one input has compareDocumentPosition
    		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    		if ( compare ) {
    			return compare;
    		}

    		// Calculate position if both inputs belong to the same document
    		// Support: IE 11+, Edge 17 - 18+
    		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    		// two documents; shallow comparisons work.
    		// eslint-disable-next-line eqeqeq
    		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
    			a.compareDocumentPosition( b ) :

    			// Otherwise we know they are disconnected
    			1;

    		// Disconnected nodes
    		if ( compare & 1 ||
    			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

    			// Choose the first element that is related to our preferred document
    			// Support: IE 11+, Edge 17 - 18+
    			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    			// two documents; shallow comparisons work.
    			// eslint-disable-next-line eqeqeq
    			if ( a === document || a.ownerDocument == preferredDoc &&
    				find.contains( preferredDoc, a ) ) {
    				return -1;
    			}

    			// Support: IE 11+, Edge 17 - 18+
    			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    			// two documents; shallow comparisons work.
    			// eslint-disable-next-line eqeqeq
    			if ( b === document || b.ownerDocument == preferredDoc &&
    				find.contains( preferredDoc, b ) ) {
    				return 1;
    			}

    			// Maintain original order
    			return sortInput ?
    				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
    				0;
    		}

    		return compare & 4 ? -1 : 1;
    	};

    	return document;
    }

    find.matches = function( expr, elements ) {
    	return find( expr, null, null, elements );
    };

    find.matchesSelector = function( elem, expr ) {
    	setDocument( elem );

    	if ( documentIsHTML &&
    		!nonnativeSelectorCache[ expr + " " ] &&
    		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

    		try {
    			var ret = matches.call( elem, expr );

    			// IE 9's matchesSelector returns false on disconnected nodes
    			if ( ret || support.disconnectedMatch ||

    					// As well, disconnected nodes are said to be in a document
    					// fragment in IE 9
    					elem.document && elem.document.nodeType !== 11 ) {
    				return ret;
    			}
    		} catch ( e ) {
    			nonnativeSelectorCache( expr, true );
    		}
    	}

    	return find( expr, document, null, [ elem ] ).length > 0;
    };

    find.contains = function( context, elem ) {

    	// Set document vars if needed
    	// Support: IE 11+, Edge 17 - 18+
    	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    	// two documents; shallow comparisons work.
    	// eslint-disable-next-line eqeqeq
    	if ( ( context.ownerDocument || context ) != document ) {
    		setDocument( context );
    	}
    	return jQuery.contains( context, elem );
    };


    find.attr = function( elem, name ) {

    	// Set document vars if needed
    	// Support: IE 11+, Edge 17 - 18+
    	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    	// two documents; shallow comparisons work.
    	// eslint-disable-next-line eqeqeq
    	if ( ( elem.ownerDocument || elem ) != document ) {
    		setDocument( elem );
    	}

    	var fn = Expr.attrHandle[ name.toLowerCase() ],

    		// Don't get fooled by Object.prototype properties (see trac-13807)
    		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
    			fn( elem, name, !documentIsHTML ) :
    			undefined;

    	if ( val !== undefined ) {
    		return val;
    	}

    	return elem.getAttribute( name );
    };

    find.error = function( msg ) {
    	throw new Error( "Syntax error, unrecognized expression: " + msg );
    };

    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    jQuery.uniqueSort = function( results ) {
    	var elem,
    		duplicates = [],
    		j = 0,
    		i = 0;

    	// Unless we *know* we can detect duplicates, assume their presence
    	//
    	// Support: Android <=4.0+
    	// Testing for detecting duplicates is unpredictable so instead assume we can't
    	// depend on duplicate detection in all browsers without a stable sort.
    	hasDuplicate = !support.sortStable;
    	sortInput = !support.sortStable && slice.call( results, 0 );
    	sort.call( results, sortOrder );

    	if ( hasDuplicate ) {
    		while ( ( elem = results[ i++ ] ) ) {
    			if ( elem === results[ i ] ) {
    				j = duplicates.push( i );
    			}
    		}
    		while ( j-- ) {
    			splice.call( results, duplicates[ j ], 1 );
    		}
    	}

    	// Clear input after sorting to release objects
    	// See https://github.com/jquery/sizzle/pull/225
    	sortInput = null;

    	return results;
    };

    jQuery.fn.uniqueSort = function() {
    	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
    };

    Expr = jQuery.expr = {

    	// Can be adjusted by the user
    	cacheLength: 50,

    	createPseudo: markFunction,

    	match: matchExpr,

    	attrHandle: {},

    	find: {},

    	relative: {
    		">": { dir: "parentNode", first: true },
    		" ": { dir: "parentNode" },
    		"+": { dir: "previousSibling", first: true },
    		"~": { dir: "previousSibling" }
    	},

    	preFilter: {
    		ATTR: function( match ) {
    			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

    			// Move the given value to match[3] whether quoted or unquoted
    			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
    				.replace( runescape, funescape );

    			if ( match[ 2 ] === "~=" ) {
    				match[ 3 ] = " " + match[ 3 ] + " ";
    			}

    			return match.slice( 0, 4 );
    		},

    		CHILD: function( match ) {

    			/* matches from matchExpr["CHILD"]
    				1 type (only|nth|...)
    				2 what (child|of-type)
    				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
    				4 xn-component of xn+y argument ([+-]?\d*n|)
    				5 sign of xn-component
    				6 x of xn-component
    				7 sign of y-component
    				8 y of y-component
    			*/
    			match[ 1 ] = match[ 1 ].toLowerCase();

    			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

    				// nth-* requires argument
    				if ( !match[ 3 ] ) {
    					find.error( match[ 0 ] );
    				}

    				// numeric x and y parameters for Expr.filter.CHILD
    				// remember that false/true cast respectively to 0/1
    				match[ 4 ] = +( match[ 4 ] ?
    					match[ 5 ] + ( match[ 6 ] || 1 ) :
    					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
    				);
    				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

    			// other types prohibit arguments
    			} else if ( match[ 3 ] ) {
    				find.error( match[ 0 ] );
    			}

    			return match;
    		},

    		PSEUDO: function( match ) {
    			var excess,
    				unquoted = !match[ 6 ] && match[ 2 ];

    			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
    				return null;
    			}

    			// Accept quoted arguments as-is
    			if ( match[ 3 ] ) {
    				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

    			// Strip excess characters from unquoted arguments
    			} else if ( unquoted && rpseudo.test( unquoted ) &&

    				// Get excess from tokenize (recursively)
    				( excess = tokenize( unquoted, true ) ) &&

    				// advance to the next closing parenthesis
    				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

    				// excess is a negative index
    				match[ 0 ] = match[ 0 ].slice( 0, excess );
    				match[ 2 ] = unquoted.slice( 0, excess );
    			}

    			// Return only captures needed by the pseudo filter method (type and argument)
    			return match.slice( 0, 3 );
    		}
    	},

    	filter: {

    		TAG: function( nodeNameSelector ) {
    			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
    			return nodeNameSelector === "*" ?
    				function() {
    					return true;
    				} :
    				function( elem ) {
    					return nodeName( elem, expectedNodeName );
    				};
    		},

    		CLASS: function( className ) {
    			var pattern = classCache[ className + " " ];

    			return pattern ||
    				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
    					"(" + whitespace + "|$)" ) ) &&
    				classCache( className, function( elem ) {
    					return pattern.test(
    						typeof elem.className === "string" && elem.className ||
    							typeof elem.getAttribute !== "undefined" &&
    								elem.getAttribute( "class" ) ||
    							""
    					);
    				} );
    		},

    		ATTR: function( name, operator, check ) {
    			return function( elem ) {
    				var result = find.attr( elem, name );

    				if ( result == null ) {
    					return operator === "!=";
    				}
    				if ( !operator ) {
    					return true;
    				}

    				result += "";

    				if ( operator === "=" ) {
    					return result === check;
    				}
    				if ( operator === "!=" ) {
    					return result !== check;
    				}
    				if ( operator === "^=" ) {
    					return check && result.indexOf( check ) === 0;
    				}
    				if ( operator === "*=" ) {
    					return check && result.indexOf( check ) > -1;
    				}
    				if ( operator === "$=" ) {
    					return check && result.slice( -check.length ) === check;
    				}
    				if ( operator === "~=" ) {
    					return ( " " + result.replace( rwhitespace, " " ) + " " )
    						.indexOf( check ) > -1;
    				}
    				if ( operator === "|=" ) {
    					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
    				}

    				return false;
    			};
    		},

    		CHILD: function( type, what, _argument, first, last ) {
    			var simple = type.slice( 0, 3 ) !== "nth",
    				forward = type.slice( -4 ) !== "last",
    				ofType = what === "of-type";

    			return first === 1 && last === 0 ?

    				// Shortcut for :nth-*(n)
    				function( elem ) {
    					return !!elem.parentNode;
    				} :

    				function( elem, _context, xml ) {
    					var cache, outerCache, node, nodeIndex, start,
    						dir = simple !== forward ? "nextSibling" : "previousSibling",
    						parent = elem.parentNode,
    						name = ofType && elem.nodeName.toLowerCase(),
    						useCache = !xml && !ofType,
    						diff = false;

    					if ( parent ) {

    						// :(first|last|only)-(child|of-type)
    						if ( simple ) {
    							while ( dir ) {
    								node = elem;
    								while ( ( node = node[ dir ] ) ) {
    									if ( ofType ?
    										nodeName( node, name ) :
    										node.nodeType === 1 ) {

    										return false;
    									}
    								}

    								// Reverse direction for :only-* (if we haven't yet done so)
    								start = dir = type === "only" && !start && "nextSibling";
    							}
    							return true;
    						}

    						start = [ forward ? parent.firstChild : parent.lastChild ];

    						// non-xml :nth-child(...) stores cache data on `parent`
    						if ( forward && useCache ) {

    							// Seek `elem` from a previously-cached index
    							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
    							cache = outerCache[ type ] || [];
    							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
    							diff = nodeIndex && cache[ 2 ];
    							node = nodeIndex && parent.childNodes[ nodeIndex ];

    							while ( ( node = ++nodeIndex && node && node[ dir ] ||

    								// Fallback to seeking `elem` from the start
    								( diff = nodeIndex = 0 ) || start.pop() ) ) {

    								// When found, cache indexes on `parent` and break
    								if ( node.nodeType === 1 && ++diff && node === elem ) {
    									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
    									break;
    								}
    							}

    						} else {

    							// Use previously-cached element index if available
    							if ( useCache ) {
    								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
    								cache = outerCache[ type ] || [];
    								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
    								diff = nodeIndex;
    							}

    							// xml :nth-child(...)
    							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
    							if ( diff === false ) {

    								// Use the same loop as above to seek `elem` from the start
    								while ( ( node = ++nodeIndex && node && node[ dir ] ||
    									( diff = nodeIndex = 0 ) || start.pop() ) ) {

    									if ( ( ofType ?
    										nodeName( node, name ) :
    										node.nodeType === 1 ) &&
    										++diff ) {

    										// Cache the index of each encountered element
    										if ( useCache ) {
    											outerCache = node[ expando ] ||
    												( node[ expando ] = {} );
    											outerCache[ type ] = [ dirruns, diff ];
    										}

    										if ( node === elem ) {
    											break;
    										}
    									}
    								}
    							}
    						}

    						// Incorporate the offset, then check against cycle size
    						diff -= last;
    						return diff === first || ( diff % first === 0 && diff / first >= 0 );
    					}
    				};
    		},

    		PSEUDO: function( pseudo, argument ) {

    			// pseudo-class names are case-insensitive
    			// https://www.w3.org/TR/selectors/#pseudo-classes
    			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
    			// Remember that setFilters inherits from pseudos
    			var args,
    				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
    					find.error( "unsupported pseudo: " + pseudo );

    			// The user may use createPseudo to indicate that
    			// arguments are needed to create the filter function
    			// just as jQuery does
    			if ( fn[ expando ] ) {
    				return fn( argument );
    			}

    			// But maintain support for old signatures
    			if ( fn.length > 1 ) {
    				args = [ pseudo, pseudo, "", argument ];
    				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
    					markFunction( function( seed, matches ) {
    						var idx,
    							matched = fn( seed, argument ),
    							i = matched.length;
    						while ( i-- ) {
    							idx = indexOf.call( seed, matched[ i ] );
    							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
    						}
    					} ) :
    					function( elem ) {
    						return fn( elem, 0, args );
    					};
    			}

    			return fn;
    		}
    	},

    	pseudos: {

    		// Potentially complex pseudos
    		not: markFunction( function( selector ) {

    			// Trim the selector passed to compile
    			// to avoid treating leading and trailing
    			// spaces as combinators
    			var input = [],
    				results = [],
    				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

    			return matcher[ expando ] ?
    				markFunction( function( seed, matches, _context, xml ) {
    					var elem,
    						unmatched = matcher( seed, null, xml, [] ),
    						i = seed.length;

    					// Match elements unmatched by `matcher`
    					while ( i-- ) {
    						if ( ( elem = unmatched[ i ] ) ) {
    							seed[ i ] = !( matches[ i ] = elem );
    						}
    					}
    				} ) :
    				function( elem, _context, xml ) {
    					input[ 0 ] = elem;
    					matcher( input, null, xml, results );

    					// Don't keep the element
    					// (see https://github.com/jquery/sizzle/issues/299)
    					input[ 0 ] = null;
    					return !results.pop();
    				};
    		} ),

    		has: markFunction( function( selector ) {
    			return function( elem ) {
    				return find( selector, elem ).length > 0;
    			};
    		} ),

    		contains: markFunction( function( text ) {
    			text = text.replace( runescape, funescape );
    			return function( elem ) {
    				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
    			};
    		} ),

    		// "Whether an element is represented by a :lang() selector
    		// is based solely on the element's language value
    		// being equal to the identifier C,
    		// or beginning with the identifier C immediately followed by "-".
    		// The matching of C against the element's language value is performed case-insensitively.
    		// The identifier C does not have to be a valid language name."
    		// https://www.w3.org/TR/selectors/#lang-pseudo
    		lang: markFunction( function( lang ) {

    			// lang value must be a valid identifier
    			if ( !ridentifier.test( lang || "" ) ) {
    				find.error( "unsupported lang: " + lang );
    			}
    			lang = lang.replace( runescape, funescape ).toLowerCase();
    			return function( elem ) {
    				var elemLang;
    				do {
    					if ( ( elemLang = documentIsHTML ?
    						elem.lang :
    						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

    						elemLang = elemLang.toLowerCase();
    						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
    					}
    				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
    				return false;
    			};
    		} ),

    		// Miscellaneous
    		target: function( elem ) {
    			var hash = window.location && window.location.hash;
    			return hash && hash.slice( 1 ) === elem.id;
    		},

    		root: function( elem ) {
    			return elem === documentElement;
    		},

    		focus: function( elem ) {
    			return elem === safeActiveElement() &&
    				document.hasFocus() &&
    				!!( elem.type || elem.href || ~elem.tabIndex );
    		},

    		// Boolean properties
    		enabled: createDisabledPseudo( false ),
    		disabled: createDisabledPseudo( true ),

    		checked: function( elem ) {

    			// In CSS3, :checked should return both checked and selected elements
    			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
    			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
    				( nodeName( elem, "option" ) && !!elem.selected );
    		},

    		selected: function( elem ) {

    			// Support: IE <=11+
    			// Accessing the selectedIndex property
    			// forces the browser to treat the default option as
    			// selected when in an optgroup.
    			if ( elem.parentNode ) {
    				// eslint-disable-next-line no-unused-expressions
    				elem.parentNode.selectedIndex;
    			}

    			return elem.selected === true;
    		},

    		// Contents
    		empty: function( elem ) {

    			// https://www.w3.org/TR/selectors/#empty-pseudo
    			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
    			//   but not by others (comment: 8; processing instruction: 7; etc.)
    			// nodeType < 6 works because attributes (2) do not appear as children
    			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
    				if ( elem.nodeType < 6 ) {
    					return false;
    				}
    			}
    			return true;
    		},

    		parent: function( elem ) {
    			return !Expr.pseudos.empty( elem );
    		},

    		// Element/input types
    		header: function( elem ) {
    			return rheader.test( elem.nodeName );
    		},

    		input: function( elem ) {
    			return rinputs.test( elem.nodeName );
    		},

    		button: function( elem ) {
    			return nodeName( elem, "input" ) && elem.type === "button" ||
    				nodeName( elem, "button" );
    		},

    		text: function( elem ) {
    			var attr;
    			return nodeName( elem, "input" ) && elem.type === "text" &&

    				// Support: IE <10 only
    				// New HTML5 attribute values (e.g., "search") appear
    				// with elem.type === "text"
    				( ( attr = elem.getAttribute( "type" ) ) == null ||
    					attr.toLowerCase() === "text" );
    		},

    		// Position-in-collection
    		first: createPositionalPseudo( function() {
    			return [ 0 ];
    		} ),

    		last: createPositionalPseudo( function( _matchIndexes, length ) {
    			return [ length - 1 ];
    		} ),

    		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
    			return [ argument < 0 ? argument + length : argument ];
    		} ),

    		even: createPositionalPseudo( function( matchIndexes, length ) {
    			var i = 0;
    			for ( ; i < length; i += 2 ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		} ),

    		odd: createPositionalPseudo( function( matchIndexes, length ) {
    			var i = 1;
    			for ( ; i < length; i += 2 ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		} ),

    		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
    			var i;

    			if ( argument < 0 ) {
    				i = argument + length;
    			} else if ( argument > length ) {
    				i = length;
    			} else {
    				i = argument;
    			}

    			for ( ; --i >= 0; ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		} ),

    		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
    			var i = argument < 0 ? argument + length : argument;
    			for ( ; ++i < length; ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		} )
    	}
    };

    Expr.pseudos.nth = Expr.pseudos.eq;

    // Add button/input type pseudos
    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    	Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
    	Expr.pseudos[ i ] = createButtonPseudo( i );
    }

    // Easy API for creating new setFilters
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    function tokenize( selector, parseOnly ) {
    	var matched, match, tokens, type,
    		soFar, groups, preFilters,
    		cached = tokenCache[ selector + " " ];

    	if ( cached ) {
    		return parseOnly ? 0 : cached.slice( 0 );
    	}

    	soFar = selector;
    	groups = [];
    	preFilters = Expr.preFilter;

    	while ( soFar ) {

    		// Comma and first run
    		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
    			if ( match ) {

    				// Don't consume trailing commas as valid
    				soFar = soFar.slice( match[ 0 ].length ) || soFar;
    			}
    			groups.push( ( tokens = [] ) );
    		}

    		matched = false;

    		// Combinators
    		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
    			matched = match.shift();
    			tokens.push( {
    				value: matched,

    				// Cast descendant combinators to space
    				type: match[ 0 ].replace( rtrimCSS, " " )
    			} );
    			soFar = soFar.slice( matched.length );
    		}

    		// Filters
    		for ( type in Expr.filter ) {
    			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
    				( match = preFilters[ type ]( match ) ) ) ) {
    				matched = match.shift();
    				tokens.push( {
    					value: matched,
    					type: type,
    					matches: match
    				} );
    				soFar = soFar.slice( matched.length );
    			}
    		}

    		if ( !matched ) {
    			break;
    		}
    	}

    	// Return the length of the invalid excess
    	// if we're just parsing
    	// Otherwise, throw an error or return tokens
    	if ( parseOnly ) {
    		return soFar.length;
    	}

    	return soFar ?
    		find.error( selector ) :

    		// Cache the tokens
    		tokenCache( selector, groups ).slice( 0 );
    }

    function toSelector( tokens ) {
    	var i = 0,
    		len = tokens.length,
    		selector = "";
    	for ( ; i < len; i++ ) {
    		selector += tokens[ i ].value;
    	}
    	return selector;
    }

    function addCombinator( matcher, combinator, base ) {
    	var dir = combinator.dir,
    		skip = combinator.next,
    		key = skip || dir,
    		checkNonElements = base && key === "parentNode",
    		doneName = done++;

    	return combinator.first ?

    		// Check against closest ancestor/preceding element
    		function( elem, context, xml ) {
    			while ( ( elem = elem[ dir ] ) ) {
    				if ( elem.nodeType === 1 || checkNonElements ) {
    					return matcher( elem, context, xml );
    				}
    			}
    			return false;
    		} :

    		// Check against all ancestor/preceding elements
    		function( elem, context, xml ) {
    			var oldCache, outerCache,
    				newCache = [ dirruns, doneName ];

    			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
    			if ( xml ) {
    				while ( ( elem = elem[ dir ] ) ) {
    					if ( elem.nodeType === 1 || checkNonElements ) {
    						if ( matcher( elem, context, xml ) ) {
    							return true;
    						}
    					}
    				}
    			} else {
    				while ( ( elem = elem[ dir ] ) ) {
    					if ( elem.nodeType === 1 || checkNonElements ) {
    						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

    						if ( skip && nodeName( elem, skip ) ) {
    							elem = elem[ dir ] || elem;
    						} else if ( ( oldCache = outerCache[ key ] ) &&
    							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

    							// Assign to newCache so results back-propagate to previous elements
    							return ( newCache[ 2 ] = oldCache[ 2 ] );
    						} else {

    							// Reuse newcache so results back-propagate to previous elements
    							outerCache[ key ] = newCache;

    							// A match means we're done; a fail means we have to keep checking
    							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
    								return true;
    							}
    						}
    					}
    				}
    			}
    			return false;
    		};
    }

    function elementMatcher( matchers ) {
    	return matchers.length > 1 ?
    		function( elem, context, xml ) {
    			var i = matchers.length;
    			while ( i-- ) {
    				if ( !matchers[ i ]( elem, context, xml ) ) {
    					return false;
    				}
    			}
    			return true;
    		} :
    		matchers[ 0 ];
    }

    function multipleContexts( selector, contexts, results ) {
    	var i = 0,
    		len = contexts.length;
    	for ( ; i < len; i++ ) {
    		find( selector, contexts[ i ], results );
    	}
    	return results;
    }

    function condense( unmatched, map, filter, context, xml ) {
    	var elem,
    		newUnmatched = [],
    		i = 0,
    		len = unmatched.length,
    		mapped = map != null;

    	for ( ; i < len; i++ ) {
    		if ( ( elem = unmatched[ i ] ) ) {
    			if ( !filter || filter( elem, context, xml ) ) {
    				newUnmatched.push( elem );
    				if ( mapped ) {
    					map.push( i );
    				}
    			}
    		}
    	}

    	return newUnmatched;
    }

    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    	if ( postFilter && !postFilter[ expando ] ) {
    		postFilter = setMatcher( postFilter );
    	}
    	if ( postFinder && !postFinder[ expando ] ) {
    		postFinder = setMatcher( postFinder, postSelector );
    	}
    	return markFunction( function( seed, results, context, xml ) {
    		var temp, i, elem, matcherOut,
    			preMap = [],
    			postMap = [],
    			preexisting = results.length,

    			// Get initial elements from seed or context
    			elems = seed ||
    				multipleContexts( selector || "*",
    					context.nodeType ? [ context ] : context, [] ),

    			// Prefilter to get matcher input, preserving a map for seed-results synchronization
    			matcherIn = preFilter && ( seed || !selector ) ?
    				condense( elems, preMap, preFilter, context, xml ) :
    				elems;

    		if ( matcher ) {

    			// If we have a postFinder, or filtered seed, or non-seed postFilter
    			// or preexisting results,
    			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

    				// ...intermediate processing is necessary
    				[] :

    				// ...otherwise use results directly
    				results;

    			// Find primary matches
    			matcher( matcherIn, matcherOut, context, xml );
    		} else {
    			matcherOut = matcherIn;
    		}

    		// Apply postFilter
    		if ( postFilter ) {
    			temp = condense( matcherOut, postMap );
    			postFilter( temp, [], context, xml );

    			// Un-match failing elements by moving them back to matcherIn
    			i = temp.length;
    			while ( i-- ) {
    				if ( ( elem = temp[ i ] ) ) {
    					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
    				}
    			}
    		}

    		if ( seed ) {
    			if ( postFinder || preFilter ) {
    				if ( postFinder ) {

    					// Get the final matcherOut by condensing this intermediate into postFinder contexts
    					temp = [];
    					i = matcherOut.length;
    					while ( i-- ) {
    						if ( ( elem = matcherOut[ i ] ) ) {

    							// Restore matcherIn since elem is not yet a final match
    							temp.push( ( matcherIn[ i ] = elem ) );
    						}
    					}
    					postFinder( null, ( matcherOut = [] ), temp, xml );
    				}

    				// Move matched elements from seed to results to keep them synchronized
    				i = matcherOut.length;
    				while ( i-- ) {
    					if ( ( elem = matcherOut[ i ] ) &&
    						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

    						seed[ temp ] = !( results[ temp ] = elem );
    					}
    				}
    			}

    		// Add elements to results, through postFinder if defined
    		} else {
    			matcherOut = condense(
    				matcherOut === results ?
    					matcherOut.splice( preexisting, matcherOut.length ) :
    					matcherOut
    			);
    			if ( postFinder ) {
    				postFinder( null, results, matcherOut, xml );
    			} else {
    				push.apply( results, matcherOut );
    			}
    		}
    	} );
    }

    function matcherFromTokens( tokens ) {
    	var checkContext, matcher, j,
    		len = tokens.length,
    		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
    		implicitRelative = leadingRelative || Expr.relative[ " " ],
    		i = leadingRelative ? 1 : 0,

    		// The foundational matcher ensures that elements are reachable from top-level context(s)
    		matchContext = addCombinator( function( elem ) {
    			return elem === checkContext;
    		}, implicitRelative, true ),
    		matchAnyContext = addCombinator( function( elem ) {
    			return indexOf.call( checkContext, elem ) > -1;
    		}, implicitRelative, true ),
    		matchers = [ function( elem, context, xml ) {

    			// Support: IE 11+, Edge 17 - 18+
    			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    			// two documents; shallow comparisons work.
    			// eslint-disable-next-line eqeqeq
    			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
    				( checkContext = context ).nodeType ?
    					matchContext( elem, context, xml ) :
    					matchAnyContext( elem, context, xml ) );

    			// Avoid hanging onto element
    			// (see https://github.com/jquery/sizzle/issues/299)
    			checkContext = null;
    			return ret;
    		} ];

    	for ( ; i < len; i++ ) {
    		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
    			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
    		} else {
    			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

    			// Return special upon seeing a positional matcher
    			if ( matcher[ expando ] ) {

    				// Find the next relative operator (if any) for proper handling
    				j = ++i;
    				for ( ; j < len; j++ ) {
    					if ( Expr.relative[ tokens[ j ].type ] ) {
    						break;
    					}
    				}
    				return setMatcher(
    					i > 1 && elementMatcher( matchers ),
    					i > 1 && toSelector(

    						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
    						tokens.slice( 0, i - 1 )
    							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
    					).replace( rtrimCSS, "$1" ),
    					matcher,
    					i < j && matcherFromTokens( tokens.slice( i, j ) ),
    					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
    					j < len && toSelector( tokens )
    				);
    			}
    			matchers.push( matcher );
    		}
    	}

    	return elementMatcher( matchers );
    }

    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    	var bySet = setMatchers.length > 0,
    		byElement = elementMatchers.length > 0,
    		superMatcher = function( seed, context, xml, results, outermost ) {
    			var elem, j, matcher,
    				matchedCount = 0,
    				i = "0",
    				unmatched = seed && [],
    				setMatched = [],
    				contextBackup = outermostContext,

    				// We must always have either seed elements or outermost context
    				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

    				// Use integer dirruns iff this is the outermost matcher
    				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
    				len = elems.length;

    			if ( outermost ) {

    				// Support: IE 11+, Edge 17 - 18+
    				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    				// two documents; shallow comparisons work.
    				// eslint-disable-next-line eqeqeq
    				outermostContext = context == document || context || outermost;
    			}

    			// Add elements passing elementMatchers directly to results
    			// Support: iOS <=7 - 9 only
    			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
    			// elements by id. (see trac-14142)
    			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
    				if ( byElement && elem ) {
    					j = 0;

    					// Support: IE 11+, Edge 17 - 18+
    					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    					// two documents; shallow comparisons work.
    					// eslint-disable-next-line eqeqeq
    					if ( !context && elem.ownerDocument != document ) {
    						setDocument( elem );
    						xml = !documentIsHTML;
    					}
    					while ( ( matcher = elementMatchers[ j++ ] ) ) {
    						if ( matcher( elem, context || document, xml ) ) {
    							push.call( results, elem );
    							break;
    						}
    					}
    					if ( outermost ) {
    						dirruns = dirrunsUnique;
    					}
    				}

    				// Track unmatched elements for set filters
    				if ( bySet ) {

    					// They will have gone through all possible matchers
    					if ( ( elem = !matcher && elem ) ) {
    						matchedCount--;
    					}

    					// Lengthen the array for every element, matched or not
    					if ( seed ) {
    						unmatched.push( elem );
    					}
    				}
    			}

    			// `i` is now the count of elements visited above, and adding it to `matchedCount`
    			// makes the latter nonnegative.
    			matchedCount += i;

    			// Apply set filters to unmatched elements
    			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
    			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
    			// no element matchers and no seed.
    			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
    			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
    			// numerically zero.
    			if ( bySet && i !== matchedCount ) {
    				j = 0;
    				while ( ( matcher = setMatchers[ j++ ] ) ) {
    					matcher( unmatched, setMatched, context, xml );
    				}

    				if ( seed ) {

    					// Reintegrate element matches to eliminate the need for sorting
    					if ( matchedCount > 0 ) {
    						while ( i-- ) {
    							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
    								setMatched[ i ] = pop.call( results );
    							}
    						}
    					}

    					// Discard index placeholder values to get only actual matches
    					setMatched = condense( setMatched );
    				}

    				// Add matches to results
    				push.apply( results, setMatched );

    				// Seedless set matches succeeding multiple successful matchers stipulate sorting
    				if ( outermost && !seed && setMatched.length > 0 &&
    					( matchedCount + setMatchers.length ) > 1 ) {

    					jQuery.uniqueSort( results );
    				}
    			}

    			// Override manipulation of globals by nested matchers
    			if ( outermost ) {
    				dirruns = dirrunsUnique;
    				outermostContext = contextBackup;
    			}

    			return unmatched;
    		};

    	return bySet ?
    		markFunction( superMatcher ) :
    		superMatcher;
    }

    function compile( selector, match /* Internal Use Only */ ) {
    	var i,
    		setMatchers = [],
    		elementMatchers = [],
    		cached = compilerCache[ selector + " " ];

    	if ( !cached ) {

    		// Generate a function of recursive functions that can be used to check each element
    		if ( !match ) {
    			match = tokenize( selector );
    		}
    		i = match.length;
    		while ( i-- ) {
    			cached = matcherFromTokens( match[ i ] );
    			if ( cached[ expando ] ) {
    				setMatchers.push( cached );
    			} else {
    				elementMatchers.push( cached );
    			}
    		}

    		// Cache the compiled function
    		cached = compilerCache( selector,
    			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

    		// Save selector and tokenization
    		cached.selector = selector;
    	}
    	return cached;
    }

    /**
     * A low-level selection function that works with jQuery's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with jQuery selector compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    function select( selector, context, results, seed ) {
    	var i, tokens, token, type, find,
    		compiled = typeof selector === "function" && selector,
    		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

    	results = results || [];

    	// Try to minimize operations if there is only one selector in the list and no seed
    	// (the latter of which guarantees us context)
    	if ( match.length === 1 ) {

    		// Reduce context if the leading compound selector is an ID
    		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
    		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
    				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

    			context = ( Expr.find.ID(
    				token.matches[ 0 ].replace( runescape, funescape ),
    				context
    			) || [] )[ 0 ];
    			if ( !context ) {
    				return results;

    			// Precompiled matchers will still verify ancestry, so step up a level
    			} else if ( compiled ) {
    				context = context.parentNode;
    			}

    			selector = selector.slice( tokens.shift().value.length );
    		}

    		// Fetch a seed set for right-to-left matching
    		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
    		while ( i-- ) {
    			token = tokens[ i ];

    			// Abort if we hit a combinator
    			if ( Expr.relative[ ( type = token.type ) ] ) {
    				break;
    			}
    			if ( ( find = Expr.find[ type ] ) ) {

    				// Search, expanding context for leading sibling combinators
    				if ( ( seed = find(
    					token.matches[ 0 ].replace( runescape, funescape ),
    					rsibling.test( tokens[ 0 ].type ) &&
    						testContext( context.parentNode ) || context
    				) ) ) {

    					// If seed is empty or no tokens remain, we can return early
    					tokens.splice( i, 1 );
    					selector = seed.length && toSelector( tokens );
    					if ( !selector ) {
    						push.apply( results, seed );
    						return results;
    					}

    					break;
    				}
    			}
    		}
    	}

    	// Compile and execute a filtering function if one is not provided
    	// Provide `match` to avoid retokenization if we modified the selector above
    	( compiled || compile( selector, match ) )(
    		seed,
    		context,
    		!documentIsHTML,
    		results,
    		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
    	);
    	return results;
    }

    // One-time assignments

    // Support: Android <=4.0 - 4.1+
    // Sort stability
    support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

    // Initialize against the default document
    setDocument();

    // Support: Android <=4.0 - 4.1+
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert( function( el ) {

    	// Should return 1, but returns 4 (following)
    	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
    } );

    jQuery.find = find;

    // Deprecated
    jQuery.expr[ ":" ] = jQuery.expr.pseudos;
    jQuery.unique = jQuery.uniqueSort;

    // These have always been private, but they used to be documented
    // as part of Sizzle so let's maintain them in the 3.x line
    // for backwards compatibility purposes.
    find.compile = compile;
    find.select = select;
    find.setDocument = setDocument;

    find.escape = jQuery.escapeSelector;
    find.getText = jQuery.text;
    find.isXML = jQuery.isXMLDoc;
    find.selectors = jQuery.expr;
    find.support = jQuery.support;
    find.uniqueSort = jQuery.uniqueSort;

    	/* eslint-enable */

    } )();


    var dir = function( elem, dir, until ) {
    	var matched = [],
    		truncate = until !== undefined;

    	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
    		if ( elem.nodeType === 1 ) {
    			if ( truncate && jQuery( elem ).is( until ) ) {
    				break;
    			}
    			matched.push( elem );
    		}
    	}
    	return matched;
    };


    var siblings = function( n, elem ) {
    	var matched = [];

    	for ( ; n; n = n.nextSibling ) {
    		if ( n.nodeType === 1 && n !== elem ) {
    			matched.push( n );
    		}
    	}

    	return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
    	if ( isFunction( qualifier ) ) {
    		return jQuery.grep( elements, function( elem, i ) {
    			return !!qualifier.call( elem, i, elem ) !== not;
    		} );
    	}

    	// Single element
    	if ( qualifier.nodeType ) {
    		return jQuery.grep( elements, function( elem ) {
    			return ( elem === qualifier ) !== not;
    		} );
    	}

    	// Arraylike of elements (jQuery, arguments, Array)
    	if ( typeof qualifier !== "string" ) {
    		return jQuery.grep( elements, function( elem ) {
    			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
    		} );
    	}

    	// Filtered directly for both simple and complex selectors
    	return jQuery.filter( qualifier, elements, not );
    }

    jQuery.filter = function( expr, elems, not ) {
    	var elem = elems[ 0 ];

    	if ( not ) {
    		expr = ":not(" + expr + ")";
    	}

    	if ( elems.length === 1 && elem.nodeType === 1 ) {
    		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
    	}

    	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
    		return elem.nodeType === 1;
    	} ) );
    };

    jQuery.fn.extend( {
    	find: function( selector ) {
    		var i, ret,
    			len = this.length,
    			self = this;

    		if ( typeof selector !== "string" ) {
    			return this.pushStack( jQuery( selector ).filter( function() {
    				for ( i = 0; i < len; i++ ) {
    					if ( jQuery.contains( self[ i ], this ) ) {
    						return true;
    					}
    				}
    			} ) );
    		}

    		ret = this.pushStack( [] );

    		for ( i = 0; i < len; i++ ) {
    			jQuery.find( selector, self[ i ], ret );
    		}

    		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
    	},
    	filter: function( selector ) {
    		return this.pushStack( winnow( this, selector || [], false ) );
    	},
    	not: function( selector ) {
    		return this.pushStack( winnow( this, selector || [], true ) );
    	},
    	is: function( selector ) {
    		return !!winnow(
    			this,

    			// If this is a positional/relative selector, check membership in the returned set
    			// so $("p:first").is("p:last") won't return true for a doc with two "p".
    			typeof selector === "string" && rneedsContext.test( selector ) ?
    				jQuery( selector ) :
    				selector || [],
    			false
    		).length;
    	}
    } );


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

    	// A simple way to check for HTML strings
    	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
    	// Strict HTML recognition (trac-11290: must start with <)
    	// Shortcut simple #id case for speed
    	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

    	init = jQuery.fn.init = function( selector, context, root ) {
    		var match, elem;

    		// HANDLE: $(""), $(null), $(undefined), $(false)
    		if ( !selector ) {
    			return this;
    		}

    		// Method init() accepts an alternate rootjQuery
    		// so migrate can support jQuery.sub (gh-2101)
    		root = root || rootjQuery;

    		// Handle HTML strings
    		if ( typeof selector === "string" ) {
    			if ( selector[ 0 ] === "<" &&
    				selector[ selector.length - 1 ] === ">" &&
    				selector.length >= 3 ) {

    				// Assume that strings that start and end with <> are HTML and skip the regex check
    				match = [ null, selector, null ];

    			} else {
    				match = rquickExpr.exec( selector );
    			}

    			// Match html or make sure no context is specified for #id
    			if ( match && ( match[ 1 ] || !context ) ) {

    				// HANDLE: $(html) -> $(array)
    				if ( match[ 1 ] ) {
    					context = context instanceof jQuery ? context[ 0 ] : context;

    					// Option to run scripts is true for back-compat
    					// Intentionally let the error be thrown if parseHTML is not present
    					jQuery.merge( this, jQuery.parseHTML(
    						match[ 1 ],
    						context && context.nodeType ? context.ownerDocument || context : document,
    						true
    					) );

    					// HANDLE: $(html, props)
    					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
    						for ( match in context ) {

    							// Properties of context are called as methods if possible
    							if ( isFunction( this[ match ] ) ) {
    								this[ match ]( context[ match ] );

    							// ...and otherwise set as attributes
    							} else {
    								this.attr( match, context[ match ] );
    							}
    						}
    					}

    					return this;

    				// HANDLE: $(#id)
    				} else {
    					elem = document.getElementById( match[ 2 ] );

    					if ( elem ) {

    						// Inject the element directly into the jQuery object
    						this[ 0 ] = elem;
    						this.length = 1;
    					}
    					return this;
    				}

    			// HANDLE: $(expr, $(...))
    			} else if ( !context || context.jquery ) {
    				return ( context || root ).find( selector );

    			// HANDLE: $(expr, context)
    			// (which is just equivalent to: $(context).find(expr)
    			} else {
    				return this.constructor( context ).find( selector );
    			}

    		// HANDLE: $(DOMElement)
    		} else if ( selector.nodeType ) {
    			this[ 0 ] = selector;
    			this.length = 1;
    			return this;

    		// HANDLE: $(function)
    		// Shortcut for document ready
    		} else if ( isFunction( selector ) ) {
    			return root.ready !== undefined ?
    				root.ready( selector ) :

    				// Execute immediately if ready is not present
    				selector( jQuery );
    		}

    		return jQuery.makeArray( selector, this );
    	};

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery( document );


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

    	// Methods guaranteed to produce a unique set when starting from a unique set
    	guaranteedUnique = {
    		children: true,
    		contents: true,
    		next: true,
    		prev: true
    	};

    jQuery.fn.extend( {
    	has: function( target ) {
    		var targets = jQuery( target, this ),
    			l = targets.length;

    		return this.filter( function() {
    			var i = 0;
    			for ( ; i < l; i++ ) {
    				if ( jQuery.contains( this, targets[ i ] ) ) {
    					return true;
    				}
    			}
    		} );
    	},

    	closest: function( selectors, context ) {
    		var cur,
    			i = 0,
    			l = this.length,
    			matched = [],
    			targets = typeof selectors !== "string" && jQuery( selectors );

    		// Positional selectors never match, since there's no _selection_ context
    		if ( !rneedsContext.test( selectors ) ) {
    			for ( ; i < l; i++ ) {
    				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

    					// Always skip document fragments
    					if ( cur.nodeType < 11 && ( targets ?
    						targets.index( cur ) > -1 :

    						// Don't pass non-elements to jQuery#find
    						cur.nodeType === 1 &&
    							jQuery.find.matchesSelector( cur, selectors ) ) ) {

    						matched.push( cur );
    						break;
    					}
    				}
    			}
    		}

    		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
    	},

    	// Determine the position of an element within the set
    	index: function( elem ) {

    		// No argument, return index in parent
    		if ( !elem ) {
    			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    		}

    		// Index in selector
    		if ( typeof elem === "string" ) {
    			return indexOf.call( jQuery( elem ), this[ 0 ] );
    		}

    		// Locate the position of the desired element
    		return indexOf.call( this,

    			// If it receives a jQuery object, the first element is used
    			elem.jquery ? elem[ 0 ] : elem
    		);
    	},

    	add: function( selector, context ) {
    		return this.pushStack(
    			jQuery.uniqueSort(
    				jQuery.merge( this.get(), jQuery( selector, context ) )
    			)
    		);
    	},

    	addBack: function( selector ) {
    		return this.add( selector == null ?
    			this.prevObject : this.prevObject.filter( selector )
    		);
    	}
    } );

    function sibling( cur, dir ) {
    	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
    	return cur;
    }

    jQuery.each( {
    	parent: function( elem ) {
    		var parent = elem.parentNode;
    		return parent && parent.nodeType !== 11 ? parent : null;
    	},
    	parents: function( elem ) {
    		return dir( elem, "parentNode" );
    	},
    	parentsUntil: function( elem, _i, until ) {
    		return dir( elem, "parentNode", until );
    	},
    	next: function( elem ) {
    		return sibling( elem, "nextSibling" );
    	},
    	prev: function( elem ) {
    		return sibling( elem, "previousSibling" );
    	},
    	nextAll: function( elem ) {
    		return dir( elem, "nextSibling" );
    	},
    	prevAll: function( elem ) {
    		return dir( elem, "previousSibling" );
    	},
    	nextUntil: function( elem, _i, until ) {
    		return dir( elem, "nextSibling", until );
    	},
    	prevUntil: function( elem, _i, until ) {
    		return dir( elem, "previousSibling", until );
    	},
    	siblings: function( elem ) {
    		return siblings( ( elem.parentNode || {} ).firstChild, elem );
    	},
    	children: function( elem ) {
    		return siblings( elem.firstChild );
    	},
    	contents: function( elem ) {
    		if ( elem.contentDocument != null &&

    			// Support: IE 11+
    			// <object> elements with no `data` attribute has an object
    			// `contentDocument` with a `null` prototype.
    			getProto( elem.contentDocument ) ) {

    			return elem.contentDocument;
    		}

    		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
    		// Treat the template element as a regular one in browsers that
    		// don't support it.
    		if ( nodeName( elem, "template" ) ) {
    			elem = elem.content || elem;
    		}

    		return jQuery.merge( [], elem.childNodes );
    	}
    }, function( name, fn ) {
    	jQuery.fn[ name ] = function( until, selector ) {
    		var matched = jQuery.map( this, fn, until );

    		if ( name.slice( -5 ) !== "Until" ) {
    			selector = until;
    		}

    		if ( selector && typeof selector === "string" ) {
    			matched = jQuery.filter( selector, matched );
    		}

    		if ( this.length > 1 ) {

    			// Remove duplicates
    			if ( !guaranteedUnique[ name ] ) {
    				jQuery.uniqueSort( matched );
    			}

    			// Reverse order for parents* and prev-derivatives
    			if ( rparentsprev.test( name ) ) {
    				matched.reverse();
    			}
    		}

    		return this.pushStack( matched );
    	};
    } );
    var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



    // Convert String-formatted options into Object-formatted ones
    function createOptions( options ) {
    	var object = {};
    	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
    		object[ flag ] = true;
    	} );
    	return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( options ) {

    	// Convert options from String-formatted to Object-formatted if needed
    	// (we check in cache first)
    	options = typeof options === "string" ?
    		createOptions( options ) :
    		jQuery.extend( {}, options );

    	var // Flag to know if list is currently firing
    		firing,

    		// Last fire value for non-forgettable lists
    		memory,

    		// Flag to know if list was already fired
    		fired,

    		// Flag to prevent firing
    		locked,

    		// Actual callback list
    		list = [],

    		// Queue of execution data for repeatable lists
    		queue = [],

    		// Index of currently firing callback (modified by add/remove as needed)
    		firingIndex = -1,

    		// Fire callbacks
    		fire = function() {

    			// Enforce single-firing
    			locked = locked || options.once;

    			// Execute callbacks for all pending executions,
    			// respecting firingIndex overrides and runtime changes
    			fired = firing = true;
    			for ( ; queue.length; firingIndex = -1 ) {
    				memory = queue.shift();
    				while ( ++firingIndex < list.length ) {

    					// Run callback and check for early termination
    					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
    						options.stopOnFalse ) {

    						// Jump to end and forget the data so .add doesn't re-fire
    						firingIndex = list.length;
    						memory = false;
    					}
    				}
    			}

    			// Forget the data if we're done with it
    			if ( !options.memory ) {
    				memory = false;
    			}

    			firing = false;

    			// Clean up if we're done firing for good
    			if ( locked ) {

    				// Keep an empty list if we have data for future add calls
    				if ( memory ) {
    					list = [];

    				// Otherwise, this object is spent
    				} else {
    					list = "";
    				}
    			}
    		},

    		// Actual Callbacks object
    		self = {

    			// Add a callback or a collection of callbacks to the list
    			add: function() {
    				if ( list ) {

    					// If we have memory from a past run, we should fire after adding
    					if ( memory && !firing ) {
    						firingIndex = list.length - 1;
    						queue.push( memory );
    					}

    					( function add( args ) {
    						jQuery.each( args, function( _, arg ) {
    							if ( isFunction( arg ) ) {
    								if ( !options.unique || !self.has( arg ) ) {
    									list.push( arg );
    								}
    							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

    								// Inspect recursively
    								add( arg );
    							}
    						} );
    					} )( arguments );

    					if ( memory && !firing ) {
    						fire();
    					}
    				}
    				return this;
    			},

    			// Remove a callback from the list
    			remove: function() {
    				jQuery.each( arguments, function( _, arg ) {
    					var index;
    					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
    						list.splice( index, 1 );

    						// Handle firing indexes
    						if ( index <= firingIndex ) {
    							firingIndex--;
    						}
    					}
    				} );
    				return this;
    			},

    			// Check if a given callback is in the list.
    			// If no argument is given, return whether or not list has callbacks attached.
    			has: function( fn ) {
    				return fn ?
    					jQuery.inArray( fn, list ) > -1 :
    					list.length > 0;
    			},

    			// Remove all callbacks from the list
    			empty: function() {
    				if ( list ) {
    					list = [];
    				}
    				return this;
    			},

    			// Disable .fire and .add
    			// Abort any current/pending executions
    			// Clear all callbacks and values
    			disable: function() {
    				locked = queue = [];
    				list = memory = "";
    				return this;
    			},
    			disabled: function() {
    				return !list;
    			},

    			// Disable .fire
    			// Also disable .add unless we have memory (since it would have no effect)
    			// Abort any pending executions
    			lock: function() {
    				locked = queue = [];
    				if ( !memory && !firing ) {
    					list = memory = "";
    				}
    				return this;
    			},
    			locked: function() {
    				return !!locked;
    			},

    			// Call all callbacks with the given context and arguments
    			fireWith: function( context, args ) {
    				if ( !locked ) {
    					args = args || [];
    					args = [ context, args.slice ? args.slice() : args ];
    					queue.push( args );
    					if ( !firing ) {
    						fire();
    					}
    				}
    				return this;
    			},

    			// Call all the callbacks with the given arguments
    			fire: function() {
    				self.fireWith( this, arguments );
    				return this;
    			},

    			// To know if the callbacks have already been called at least once
    			fired: function() {
    				return !!fired;
    			}
    		};

    	return self;
    };


    function Identity( v ) {
    	return v;
    }
    function Thrower( ex ) {
    	throw ex;
    }

    function adoptValue( value, resolve, reject, noValue ) {
    	var method;

    	try {

    		// Check for promise aspect first to privilege synchronous behavior
    		if ( value && isFunction( ( method = value.promise ) ) ) {
    			method.call( value ).done( resolve ).fail( reject );

    		// Other thenables
    		} else if ( value && isFunction( ( method = value.then ) ) ) {
    			method.call( value, resolve, reject );

    		// Other non-thenables
    		} else {

    			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
    			// * false: [ value ].slice( 0 ) => resolve( value )
    			// * true: [ value ].slice( 1 ) => resolve()
    			resolve.apply( undefined, [ value ].slice( noValue ) );
    		}

    	// For Promises/A+, convert exceptions into rejections
    	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
    	// Deferred#then to conditionally suppress rejection.
    	} catch ( value ) {

    		// Support: Android 4.0 only
    		// Strict mode functions invoked without .call/.apply get global-object context
    		reject.apply( undefined, [ value ] );
    	}
    }

    jQuery.extend( {

    	Deferred: function( func ) {
    		var tuples = [

    				// action, add listener, callbacks,
    				// ... .then handlers, argument index, [final state]
    				[ "notify", "progress", jQuery.Callbacks( "memory" ),
    					jQuery.Callbacks( "memory" ), 2 ],
    				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
    					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
    				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
    					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
    			],
    			state = "pending",
    			promise = {
    				state: function() {
    					return state;
    				},
    				always: function() {
    					deferred.done( arguments ).fail( arguments );
    					return this;
    				},
    				"catch": function( fn ) {
    					return promise.then( null, fn );
    				},

    				// Keep pipe for back-compat
    				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
    					var fns = arguments;

    					return jQuery.Deferred( function( newDefer ) {
    						jQuery.each( tuples, function( _i, tuple ) {

    							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
    							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

    							// deferred.progress(function() { bind to newDefer or newDefer.notify })
    							// deferred.done(function() { bind to newDefer or newDefer.resolve })
    							// deferred.fail(function() { bind to newDefer or newDefer.reject })
    							deferred[ tuple[ 1 ] ]( function() {
    								var returned = fn && fn.apply( this, arguments );
    								if ( returned && isFunction( returned.promise ) ) {
    									returned.promise()
    										.progress( newDefer.notify )
    										.done( newDefer.resolve )
    										.fail( newDefer.reject );
    								} else {
    									newDefer[ tuple[ 0 ] + "With" ](
    										this,
    										fn ? [ returned ] : arguments
    									);
    								}
    							} );
    						} );
    						fns = null;
    					} ).promise();
    				},
    				then: function( onFulfilled, onRejected, onProgress ) {
    					var maxDepth = 0;
    					function resolve( depth, deferred, handler, special ) {
    						return function() {
    							var that = this,
    								args = arguments,
    								mightThrow = function() {
    									var returned, then;

    									// Support: Promises/A+ section 2.3.3.3.3
    									// https://promisesaplus.com/#point-59
    									// Ignore double-resolution attempts
    									if ( depth < maxDepth ) {
    										return;
    									}

    									returned = handler.apply( that, args );

    									// Support: Promises/A+ section 2.3.1
    									// https://promisesaplus.com/#point-48
    									if ( returned === deferred.promise() ) {
    										throw new TypeError( "Thenable self-resolution" );
    									}

    									// Support: Promises/A+ sections 2.3.3.1, 3.5
    									// https://promisesaplus.com/#point-54
    									// https://promisesaplus.com/#point-75
    									// Retrieve `then` only once
    									then = returned &&

    										// Support: Promises/A+ section 2.3.4
    										// https://promisesaplus.com/#point-64
    										// Only check objects and functions for thenability
    										( typeof returned === "object" ||
    											typeof returned === "function" ) &&
    										returned.then;

    									// Handle a returned thenable
    									if ( isFunction( then ) ) {

    										// Special processors (notify) just wait for resolution
    										if ( special ) {
    											then.call(
    												returned,
    												resolve( maxDepth, deferred, Identity, special ),
    												resolve( maxDepth, deferred, Thrower, special )
    											);

    										// Normal processors (resolve) also hook into progress
    										} else {

    											// ...and disregard older resolution values
    											maxDepth++;

    											then.call(
    												returned,
    												resolve( maxDepth, deferred, Identity, special ),
    												resolve( maxDepth, deferred, Thrower, special ),
    												resolve( maxDepth, deferred, Identity,
    													deferred.notifyWith )
    											);
    										}

    									// Handle all other returned values
    									} else {

    										// Only substitute handlers pass on context
    										// and multiple values (non-spec behavior)
    										if ( handler !== Identity ) {
    											that = undefined;
    											args = [ returned ];
    										}

    										// Process the value(s)
    										// Default process is resolve
    										( special || deferred.resolveWith )( that, args );
    									}
    								},

    								// Only normal processors (resolve) catch and reject exceptions
    								process = special ?
    									mightThrow :
    									function() {
    										try {
    											mightThrow();
    										} catch ( e ) {

    											if ( jQuery.Deferred.exceptionHook ) {
    												jQuery.Deferred.exceptionHook( e,
    													process.error );
    											}

    											// Support: Promises/A+ section 2.3.3.3.4.1
    											// https://promisesaplus.com/#point-61
    											// Ignore post-resolution exceptions
    											if ( depth + 1 >= maxDepth ) {

    												// Only substitute handlers pass on context
    												// and multiple values (non-spec behavior)
    												if ( handler !== Thrower ) {
    													that = undefined;
    													args = [ e ];
    												}

    												deferred.rejectWith( that, args );
    											}
    										}
    									};

    							// Support: Promises/A+ section 2.3.3.3.1
    							// https://promisesaplus.com/#point-57
    							// Re-resolve promises immediately to dodge false rejection from
    							// subsequent errors
    							if ( depth ) {
    								process();
    							} else {

    								// Call an optional hook to record the error, in case of exception
    								// since it's otherwise lost when execution goes async
    								if ( jQuery.Deferred.getErrorHook ) {
    									process.error = jQuery.Deferred.getErrorHook();

    								// The deprecated alias of the above. While the name suggests
    								// returning the stack, not an error instance, jQuery just passes
    								// it directly to `console.warn` so both will work; an instance
    								// just better cooperates with source maps.
    								} else if ( jQuery.Deferred.getStackHook ) {
    									process.error = jQuery.Deferred.getStackHook();
    								}
    								window.setTimeout( process );
    							}
    						};
    					}

    					return jQuery.Deferred( function( newDefer ) {

    						// progress_handlers.add( ... )
    						tuples[ 0 ][ 3 ].add(
    							resolve(
    								0,
    								newDefer,
    								isFunction( onProgress ) ?
    									onProgress :
    									Identity,
    								newDefer.notifyWith
    							)
    						);

    						// fulfilled_handlers.add( ... )
    						tuples[ 1 ][ 3 ].add(
    							resolve(
    								0,
    								newDefer,
    								isFunction( onFulfilled ) ?
    									onFulfilled :
    									Identity
    							)
    						);

    						// rejected_handlers.add( ... )
    						tuples[ 2 ][ 3 ].add(
    							resolve(
    								0,
    								newDefer,
    								isFunction( onRejected ) ?
    									onRejected :
    									Thrower
    							)
    						);
    					} ).promise();
    				},

    				// Get a promise for this deferred
    				// If obj is provided, the promise aspect is added to the object
    				promise: function( obj ) {
    					return obj != null ? jQuery.extend( obj, promise ) : promise;
    				}
    			},
    			deferred = {};

    		// Add list-specific methods
    		jQuery.each( tuples, function( i, tuple ) {
    			var list = tuple[ 2 ],
    				stateString = tuple[ 5 ];

    			// promise.progress = list.add
    			// promise.done = list.add
    			// promise.fail = list.add
    			promise[ tuple[ 1 ] ] = list.add;

    			// Handle state
    			if ( stateString ) {
    				list.add(
    					function() {

    						// state = "resolved" (i.e., fulfilled)
    						// state = "rejected"
    						state = stateString;
    					},

    					// rejected_callbacks.disable
    					// fulfilled_callbacks.disable
    					tuples[ 3 - i ][ 2 ].disable,

    					// rejected_handlers.disable
    					// fulfilled_handlers.disable
    					tuples[ 3 - i ][ 3 ].disable,

    					// progress_callbacks.lock
    					tuples[ 0 ][ 2 ].lock,

    					// progress_handlers.lock
    					tuples[ 0 ][ 3 ].lock
    				);
    			}

    			// progress_handlers.fire
    			// fulfilled_handlers.fire
    			// rejected_handlers.fire
    			list.add( tuple[ 3 ].fire );

    			// deferred.notify = function() { deferred.notifyWith(...) }
    			// deferred.resolve = function() { deferred.resolveWith(...) }
    			// deferred.reject = function() { deferred.rejectWith(...) }
    			deferred[ tuple[ 0 ] ] = function() {
    				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
    				return this;
    			};

    			// deferred.notifyWith = list.fireWith
    			// deferred.resolveWith = list.fireWith
    			// deferred.rejectWith = list.fireWith
    			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
    		} );

    		// Make the deferred a promise
    		promise.promise( deferred );

    		// Call given func if any
    		if ( func ) {
    			func.call( deferred, deferred );
    		}

    		// All done!
    		return deferred;
    	},

    	// Deferred helper
    	when: function( singleValue ) {
    		var

    			// count of uncompleted subordinates
    			remaining = arguments.length,

    			// count of unprocessed arguments
    			i = remaining,

    			// subordinate fulfillment data
    			resolveContexts = Array( i ),
    			resolveValues = slice.call( arguments ),

    			// the primary Deferred
    			primary = jQuery.Deferred(),

    			// subordinate callback factory
    			updateFunc = function( i ) {
    				return function( value ) {
    					resolveContexts[ i ] = this;
    					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
    					if ( !( --remaining ) ) {
    						primary.resolveWith( resolveContexts, resolveValues );
    					}
    				};
    			};

    		// Single- and empty arguments are adopted like Promise.resolve
    		if ( remaining <= 1 ) {
    			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
    				!remaining );

    			// Use .then() to unwrap secondary thenables (cf. gh-3000)
    			if ( primary.state() === "pending" ||
    				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

    				return primary.then();
    			}
    		}

    		// Multiple arguments are aggregated like Promise.all array elements
    		while ( i-- ) {
    			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
    		}

    		return primary.promise();
    	}
    } );


    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
    // captured before the async barrier to get the original error cause
    // which may otherwise be hidden.
    jQuery.Deferred.exceptionHook = function( error, asyncError ) {

    	// Support: IE 8 - 9 only
    	// Console exists when dev tools are open, which can happen at any time
    	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
    		window.console.warn( "jQuery.Deferred exception: " + error.message,
    			error.stack, asyncError );
    	}
    };




    jQuery.readyException = function( error ) {
    	window.setTimeout( function() {
    		throw error;
    	} );
    };




    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function( fn ) {

    	readyList
    		.then( fn )

    		// Wrap jQuery.readyException in a function so that the lookup
    		// happens at the time of error handling instead of callback
    		// registration.
    		.catch( function( error ) {
    			jQuery.readyException( error );
    		} );

    	return this;
    };

    jQuery.extend( {

    	// Is the DOM ready to be used? Set to true once it occurs.
    	isReady: false,

    	// A counter to track how many items to wait for before
    	// the ready event fires. See trac-6781
    	readyWait: 1,

    	// Handle when the DOM is ready
    	ready: function( wait ) {

    		// Abort if there are pending holds or we're already ready
    		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
    			return;
    		}

    		// Remember that the DOM is ready
    		jQuery.isReady = true;

    		// If a normal DOM Ready event fired, decrement, and wait if need be
    		if ( wait !== true && --jQuery.readyWait > 0 ) {
    			return;
    		}

    		// If there are functions bound, to execute
    		readyList.resolveWith( document, [ jQuery ] );
    	}
    } );

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
    	document.removeEventListener( "DOMContentLoaded", completed );
    	window.removeEventListener( "load", completed );
    	jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if ( document.readyState === "complete" ||
    	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

    	// Handle it asynchronously to allow scripts the opportunity to delay ready
    	window.setTimeout( jQuery.ready );

    } else {

    	// Use the handy event callback
    	document.addEventListener( "DOMContentLoaded", completed );

    	// A fallback to window.onload, that will always work
    	window.addEventListener( "load", completed );
    }




    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    	var i = 0,
    		len = elems.length,
    		bulk = key == null;

    	// Sets many values
    	if ( toType( key ) === "object" ) {
    		chainable = true;
    		for ( i in key ) {
    			access( elems, fn, i, key[ i ], true, emptyGet, raw );
    		}

    	// Sets one value
    	} else if ( value !== undefined ) {
    		chainable = true;

    		if ( !isFunction( value ) ) {
    			raw = true;
    		}

    		if ( bulk ) {

    			// Bulk operations run against the entire set
    			if ( raw ) {
    				fn.call( elems, value );
    				fn = null;

    			// ...except when executing function values
    			} else {
    				bulk = fn;
    				fn = function( elem, _key, value ) {
    					return bulk.call( jQuery( elem ), value );
    				};
    			}
    		}

    		if ( fn ) {
    			for ( ; i < len; i++ ) {
    				fn(
    					elems[ i ], key, raw ?
    						value :
    						value.call( elems[ i ], i, fn( elems[ i ], key ) )
    				);
    			}
    		}
    	}

    	if ( chainable ) {
    		return elems;
    	}

    	// Gets
    	if ( bulk ) {
    		return fn.call( elems );
    	}

    	return len ? fn( elems[ 0 ], key ) : emptyGet;
    };


    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
    	rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase( _all, letter ) {
    	return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (trac-9572)
    function camelCase( string ) {
    	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    }
    var acceptData = function( owner ) {

    	// Accepts only:
    	//  - Node
    	//    - Node.ELEMENT_NODE
    	//    - Node.DOCUMENT_NODE
    	//  - Object
    	//    - Any
    	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };




    function Data() {
    	this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

    	cache: function( owner ) {

    		// Check if the owner object already has a cache
    		var value = owner[ this.expando ];

    		// If not, create one
    		if ( !value ) {
    			value = {};

    			// We can accept data for non-element nodes in modern browsers,
    			// but we should not, see trac-8335.
    			// Always return an empty object.
    			if ( acceptData( owner ) ) {

    				// If it is a node unlikely to be stringify-ed or looped over
    				// use plain assignment
    				if ( owner.nodeType ) {
    					owner[ this.expando ] = value;

    				// Otherwise secure it in a non-enumerable property
    				// configurable must be true to allow the property to be
    				// deleted when data is removed
    				} else {
    					Object.defineProperty( owner, this.expando, {
    						value: value,
    						configurable: true
    					} );
    				}
    			}
    		}

    		return value;
    	},
    	set: function( owner, data, value ) {
    		var prop,
    			cache = this.cache( owner );

    		// Handle: [ owner, key, value ] args
    		// Always use camelCase key (gh-2257)
    		if ( typeof data === "string" ) {
    			cache[ camelCase( data ) ] = value;

    		// Handle: [ owner, { properties } ] args
    		} else {

    			// Copy the properties one-by-one to the cache object
    			for ( prop in data ) {
    				cache[ camelCase( prop ) ] = data[ prop ];
    			}
    		}
    		return cache;
    	},
    	get: function( owner, key ) {
    		return key === undefined ?
    			this.cache( owner ) :

    			// Always use camelCase key (gh-2257)
    			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
    	},
    	access: function( owner, key, value ) {

    		// In cases where either:
    		//
    		//   1. No key was specified
    		//   2. A string key was specified, but no value provided
    		//
    		// Take the "read" path and allow the get method to determine
    		// which value to return, respectively either:
    		//
    		//   1. The entire cache object
    		//   2. The data stored at the key
    		//
    		if ( key === undefined ||
    				( ( key && typeof key === "string" ) && value === undefined ) ) {

    			return this.get( owner, key );
    		}

    		// When the key is not a string, or both a key and value
    		// are specified, set or extend (existing objects) with either:
    		//
    		//   1. An object of properties
    		//   2. A key and value
    		//
    		this.set( owner, key, value );

    		// Since the "set" path can have two possible entry points
    		// return the expected data based on which path was taken[*]
    		return value !== undefined ? value : key;
    	},
    	remove: function( owner, key ) {
    		var i,
    			cache = owner[ this.expando ];

    		if ( cache === undefined ) {
    			return;
    		}

    		if ( key !== undefined ) {

    			// Support array or space separated string of keys
    			if ( Array.isArray( key ) ) {

    				// If key is an array of keys...
    				// We always set camelCase keys, so remove that.
    				key = key.map( camelCase );
    			} else {
    				key = camelCase( key );

    				// If a key with the spaces exists, use it.
    				// Otherwise, create an array by matching non-whitespace
    				key = key in cache ?
    					[ key ] :
    					( key.match( rnothtmlwhite ) || [] );
    			}

    			i = key.length;

    			while ( i-- ) {
    				delete cache[ key[ i ] ];
    			}
    		}

    		// Remove the expando if there's no more data
    		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

    			// Support: Chrome <=35 - 45
    			// Webkit & Blink performance suffers when deleting properties
    			// from DOM nodes, so set to undefined instead
    			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
    			if ( owner.nodeType ) {
    				owner[ this.expando ] = undefined;
    			} else {
    				delete owner[ this.expando ];
    			}
    		}
    	},
    	hasData: function( owner ) {
    		var cache = owner[ this.expando ];
    		return cache !== undefined && !jQuery.isEmptyObject( cache );
    	}
    };
    var dataPriv = new Data();

    var dataUser = new Data();



    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    	rmultiDash = /[A-Z]/g;

    function getData( data ) {
    	if ( data === "true" ) {
    		return true;
    	}

    	if ( data === "false" ) {
    		return false;
    	}

    	if ( data === "null" ) {
    		return null;
    	}

    	// Only convert to a number if it doesn't change the string
    	if ( data === +data + "" ) {
    		return +data;
    	}

    	if ( rbrace.test( data ) ) {
    		return JSON.parse( data );
    	}

    	return data;
    }

    function dataAttr( elem, key, data ) {
    	var name;

    	// If nothing was found internally, try to fetch any
    	// data from the HTML5 data-* attribute
    	if ( data === undefined && elem.nodeType === 1 ) {
    		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
    		data = elem.getAttribute( name );

    		if ( typeof data === "string" ) {
    			try {
    				data = getData( data );
    			} catch ( e ) {}

    			// Make sure we set the data so it isn't changed later
    			dataUser.set( elem, key, data );
    		} else {
    			data = undefined;
    		}
    	}
    	return data;
    }

    jQuery.extend( {
    	hasData: function( elem ) {
    		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
    	},

    	data: function( elem, name, data ) {
    		return dataUser.access( elem, name, data );
    	},

    	removeData: function( elem, name ) {
    		dataUser.remove( elem, name );
    	},

    	// TODO: Now that all calls to _data and _removeData have been replaced
    	// with direct calls to dataPriv methods, these can be deprecated.
    	_data: function( elem, name, data ) {
    		return dataPriv.access( elem, name, data );
    	},

    	_removeData: function( elem, name ) {
    		dataPriv.remove( elem, name );
    	}
    } );

    jQuery.fn.extend( {
    	data: function( key, value ) {
    		var i, name, data,
    			elem = this[ 0 ],
    			attrs = elem && elem.attributes;

    		// Gets all values
    		if ( key === undefined ) {
    			if ( this.length ) {
    				data = dataUser.get( elem );

    				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
    					i = attrs.length;
    					while ( i-- ) {

    						// Support: IE 11 only
    						// The attrs elements can be null (trac-14894)
    						if ( attrs[ i ] ) {
    							name = attrs[ i ].name;
    							if ( name.indexOf( "data-" ) === 0 ) {
    								name = camelCase( name.slice( 5 ) );
    								dataAttr( elem, name, data[ name ] );
    							}
    						}
    					}
    					dataPriv.set( elem, "hasDataAttrs", true );
    				}
    			}

    			return data;
    		}

    		// Sets multiple values
    		if ( typeof key === "object" ) {
    			return this.each( function() {
    				dataUser.set( this, key );
    			} );
    		}

    		return access( this, function( value ) {
    			var data;

    			// The calling jQuery object (element matches) is not empty
    			// (and therefore has an element appears at this[ 0 ]) and the
    			// `value` parameter was not undefined. An empty jQuery object
    			// will result in `undefined` for elem = this[ 0 ] which will
    			// throw an exception if an attempt to read a data cache is made.
    			if ( elem && value === undefined ) {

    				// Attempt to get data from the cache
    				// The key will always be camelCased in Data
    				data = dataUser.get( elem, key );
    				if ( data !== undefined ) {
    					return data;
    				}

    				// Attempt to "discover" the data in
    				// HTML5 custom data-* attrs
    				data = dataAttr( elem, key );
    				if ( data !== undefined ) {
    					return data;
    				}

    				// We tried really hard, but the data doesn't exist.
    				return;
    			}

    			// Set the data...
    			this.each( function() {

    				// We always store the camelCased key
    				dataUser.set( this, key, value );
    			} );
    		}, null, value, arguments.length > 1, null, true );
    	},

    	removeData: function( key ) {
    		return this.each( function() {
    			dataUser.remove( this, key );
    		} );
    	}
    } );


    jQuery.extend( {
    	queue: function( elem, type, data ) {
    		var queue;

    		if ( elem ) {
    			type = ( type || "fx" ) + "queue";
    			queue = dataPriv.get( elem, type );

    			// Speed up dequeue by getting out quickly if this is just a lookup
    			if ( data ) {
    				if ( !queue || Array.isArray( data ) ) {
    					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
    				} else {
    					queue.push( data );
    				}
    			}
    			return queue || [];
    		}
    	},

    	dequeue: function( elem, type ) {
    		type = type || "fx";

    		var queue = jQuery.queue( elem, type ),
    			startLength = queue.length,
    			fn = queue.shift(),
    			hooks = jQuery._queueHooks( elem, type ),
    			next = function() {
    				jQuery.dequeue( elem, type );
    			};

    		// If the fx queue is dequeued, always remove the progress sentinel
    		if ( fn === "inprogress" ) {
    			fn = queue.shift();
    			startLength--;
    		}

    		if ( fn ) {

    			// Add a progress sentinel to prevent the fx queue from being
    			// automatically dequeued
    			if ( type === "fx" ) {
    				queue.unshift( "inprogress" );
    			}

    			// Clear up the last queue stop function
    			delete hooks.stop;
    			fn.call( elem, next, hooks );
    		}

    		if ( !startLength && hooks ) {
    			hooks.empty.fire();
    		}
    	},

    	// Not public - generate a queueHooks object, or return the current one
    	_queueHooks: function( elem, type ) {
    		var key = type + "queueHooks";
    		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
    			empty: jQuery.Callbacks( "once memory" ).add( function() {
    				dataPriv.remove( elem, [ type + "queue", key ] );
    			} )
    		} );
    	}
    } );

    jQuery.fn.extend( {
    	queue: function( type, data ) {
    		var setter = 2;

    		if ( typeof type !== "string" ) {
    			data = type;
    			type = "fx";
    			setter--;
    		}

    		if ( arguments.length < setter ) {
    			return jQuery.queue( this[ 0 ], type );
    		}

    		return data === undefined ?
    			this :
    			this.each( function() {
    				var queue = jQuery.queue( this, type, data );

    				// Ensure a hooks for this queue
    				jQuery._queueHooks( this, type );

    				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
    					jQuery.dequeue( this, type );
    				}
    			} );
    	},
    	dequeue: function( type ) {
    		return this.each( function() {
    			jQuery.dequeue( this, type );
    		} );
    	},
    	clearQueue: function( type ) {
    		return this.queue( type || "fx", [] );
    	},

    	// Get a promise resolved when queues of a certain type
    	// are emptied (fx is the type by default)
    	promise: function( type, obj ) {
    		var tmp,
    			count = 1,
    			defer = jQuery.Deferred(),
    			elements = this,
    			i = this.length,
    			resolve = function() {
    				if ( !( --count ) ) {
    					defer.resolveWith( elements, [ elements ] );
    				}
    			};

    		if ( typeof type !== "string" ) {
    			obj = type;
    			type = undefined;
    		}
    		type = type || "fx";

    		while ( i-- ) {
    			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
    			if ( tmp && tmp.empty ) {
    				count++;
    				tmp.empty.add( resolve );
    			}
    		}
    		resolve();
    		return defer.promise( obj );
    	}
    } );
    var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

    var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

    var documentElement = document.documentElement;



    	var isAttached = function( elem ) {
    			return jQuery.contains( elem.ownerDocument, elem );
    		},
    		composed = { composed: true };

    	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    	// Check attachment across shadow DOM boundaries when possible (gh-3504)
    	// Support: iOS 10.0-10.2 only
    	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    	// leading to errors. We need to check for `getRootNode`.
    	if ( documentElement.getRootNode ) {
    		isAttached = function( elem ) {
    			return jQuery.contains( elem.ownerDocument, elem ) ||
    				elem.getRootNode( composed ) === elem.ownerDocument;
    		};
    	}
    var isHiddenWithinTree = function( elem, el ) {

    		// isHiddenWithinTree might be called from jQuery#filter function;
    		// in that case, element will be second argument
    		elem = el || elem;

    		// Inline style trumps all
    		return elem.style.display === "none" ||
    			elem.style.display === "" &&

    			// Otherwise, check computed style
    			// Support: Firefox <=43 - 45
    			// Disconnected elements can have computed display: none, so first confirm that elem is
    			// in the document.
    			isAttached( elem ) &&

    			jQuery.css( elem, "display" ) === "none";
    	};



    function adjustCSS( elem, prop, valueParts, tween ) {
    	var adjusted, scale,
    		maxIterations = 20,
    		currentValue = tween ?
    			function() {
    				return tween.cur();
    			} :
    			function() {
    				return jQuery.css( elem, prop, "" );
    			},
    		initial = currentValue(),
    		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

    		// Starting value computation is required for potential unit mismatches
    		initialInUnit = elem.nodeType &&
    			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
    			rcssNum.exec( jQuery.css( elem, prop ) );

    	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

    		// Support: Firefox <=54
    		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
    		initial = initial / 2;

    		// Trust units reported by jQuery.css
    		unit = unit || initialInUnit[ 3 ];

    		// Iteratively approximate from a nonzero starting point
    		initialInUnit = +initial || 1;

    		while ( maxIterations-- ) {

    			// Evaluate and update our best guess (doubling guesses that zero out).
    			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
    			jQuery.style( elem, prop, initialInUnit + unit );
    			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
    				maxIterations = 0;
    			}
    			initialInUnit = initialInUnit / scale;

    		}

    		initialInUnit = initialInUnit * 2;
    		jQuery.style( elem, prop, initialInUnit + unit );

    		// Make sure we update the tween properties later on
    		valueParts = valueParts || [];
    	}

    	if ( valueParts ) {
    		initialInUnit = +initialInUnit || +initial || 0;

    		// Apply relative offset (+=/-=) if specified
    		adjusted = valueParts[ 1 ] ?
    			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
    			+valueParts[ 2 ];
    		if ( tween ) {
    			tween.unit = unit;
    			tween.start = initialInUnit;
    			tween.end = adjusted;
    		}
    	}
    	return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay( elem ) {
    	var temp,
    		doc = elem.ownerDocument,
    		nodeName = elem.nodeName,
    		display = defaultDisplayMap[ nodeName ];

    	if ( display ) {
    		return display;
    	}

    	temp = doc.body.appendChild( doc.createElement( nodeName ) );
    	display = jQuery.css( temp, "display" );

    	temp.parentNode.removeChild( temp );

    	if ( display === "none" ) {
    		display = "block";
    	}
    	defaultDisplayMap[ nodeName ] = display;

    	return display;
    }

    function showHide( elements, show ) {
    	var display, elem,
    		values = [],
    		index = 0,
    		length = elements.length;

    	// Determine new display value for elements that need to change
    	for ( ; index < length; index++ ) {
    		elem = elements[ index ];
    		if ( !elem.style ) {
    			continue;
    		}

    		display = elem.style.display;
    		if ( show ) {

    			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
    			// check is required in this first loop unless we have a nonempty display value (either
    			// inline or about-to-be-restored)
    			if ( display === "none" ) {
    				values[ index ] = dataPriv.get( elem, "display" ) || null;
    				if ( !values[ index ] ) {
    					elem.style.display = "";
    				}
    			}
    			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
    				values[ index ] = getDefaultDisplay( elem );
    			}
    		} else {
    			if ( display !== "none" ) {
    				values[ index ] = "none";

    				// Remember what we're overwriting
    				dataPriv.set( elem, "display", display );
    			}
    		}
    	}

    	// Set the display of the elements in a second loop to avoid constant reflow
    	for ( index = 0; index < length; index++ ) {
    		if ( values[ index ] != null ) {
    			elements[ index ].style.display = values[ index ];
    		}
    	}

    	return elements;
    }

    jQuery.fn.extend( {
    	show: function() {
    		return showHide( this, true );
    	},
    	hide: function() {
    		return showHide( this );
    	},
    	toggle: function( state ) {
    		if ( typeof state === "boolean" ) {
    			return state ? this.show() : this.hide();
    		}

    		return this.each( function() {
    			if ( isHiddenWithinTree( this ) ) {
    				jQuery( this ).show();
    			} else {
    				jQuery( this ).hide();
    			}
    		} );
    	}
    } );
    var rcheckableType = ( /^(?:checkbox|radio)$/i );

    var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

    var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



    ( function() {
    	var fragment = document.createDocumentFragment(),
    		div = fragment.appendChild( document.createElement( "div" ) ),
    		input = document.createElement( "input" );

    	// Support: Android 4.0 - 4.3 only
    	// Check state lost if the name is set (trac-11217)
    	// Support: Windows Web Apps (WWA)
    	// `name` and `type` must use .setAttribute for WWA (trac-14901)
    	input.setAttribute( "type", "radio" );
    	input.setAttribute( "checked", "checked" );
    	input.setAttribute( "name", "t" );

    	div.appendChild( input );

    	// Support: Android <=4.1 only
    	// Older WebKit doesn't clone checked state correctly in fragments
    	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

    	// Support: IE <=11 only
    	// Make sure textarea (and checkbox) defaultValue is properly cloned
    	div.innerHTML = "<textarea>x</textarea>";
    	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

    	// Support: IE <=9 only
    	// IE <=9 replaces <option> tags with their contents when inserted outside of
    	// the select element.
    	div.innerHTML = "<option></option>";
    	support.option = !!div.lastChild;
    } )();


    // We have to close these tags to support XHTML (trac-13200)
    var wrapMap = {

    	// XHTML parsers do not magically insert elements in the
    	// same way that tag soup parsers do. So we cannot shorten
    	// this by omitting <tbody> or other required elements.
    	thead: [ 1, "<table>", "</table>" ],
    	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

    	_default: [ 0, "", "" ]
    };

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // Support: IE <=9 only
    if ( !support.option ) {
    	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
    }


    function getAll( context, tag ) {

    	// Support: IE <=9 - 11 only
    	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
    	var ret;

    	if ( typeof context.getElementsByTagName !== "undefined" ) {
    		ret = context.getElementsByTagName( tag || "*" );

    	} else if ( typeof context.querySelectorAll !== "undefined" ) {
    		ret = context.querySelectorAll( tag || "*" );

    	} else {
    		ret = [];
    	}

    	if ( tag === undefined || tag && nodeName( context, tag ) ) {
    		return jQuery.merge( [ context ], ret );
    	}

    	return ret;
    }


    // Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
    	var i = 0,
    		l = elems.length;

    	for ( ; i < l; i++ ) {
    		dataPriv.set(
    			elems[ i ],
    			"globalEval",
    			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
    		);
    	}
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment( elems, context, scripts, selection, ignored ) {
    	var elem, tmp, tag, wrap, attached, j,
    		fragment = context.createDocumentFragment(),
    		nodes = [],
    		i = 0,
    		l = elems.length;

    	for ( ; i < l; i++ ) {
    		elem = elems[ i ];

    		if ( elem || elem === 0 ) {

    			// Add nodes directly
    			if ( toType( elem ) === "object" ) {

    				// Support: Android <=4.0 only, PhantomJS 1 only
    				// push.apply(_, arraylike) throws on ancient WebKit
    				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

    			// Convert non-html into a text node
    			} else if ( !rhtml.test( elem ) ) {
    				nodes.push( context.createTextNode( elem ) );

    			// Convert html into DOM nodes
    			} else {
    				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

    				// Deserialize a standard representation
    				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
    				wrap = wrapMap[ tag ] || wrapMap._default;
    				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

    				// Descend through wrappers to the right content
    				j = wrap[ 0 ];
    				while ( j-- ) {
    					tmp = tmp.lastChild;
    				}

    				// Support: Android <=4.0 only, PhantomJS 1 only
    				// push.apply(_, arraylike) throws on ancient WebKit
    				jQuery.merge( nodes, tmp.childNodes );

    				// Remember the top-level container
    				tmp = fragment.firstChild;

    				// Ensure the created nodes are orphaned (trac-12392)
    				tmp.textContent = "";
    			}
    		}
    	}

    	// Remove wrapper from fragment
    	fragment.textContent = "";

    	i = 0;
    	while ( ( elem = nodes[ i++ ] ) ) {

    		// Skip elements already in the context collection (trac-4087)
    		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
    			if ( ignored ) {
    				ignored.push( elem );
    			}
    			continue;
    		}

    		attached = isAttached( elem );

    		// Append to fragment
    		tmp = getAll( fragment.appendChild( elem ), "script" );

    		// Preserve script evaluation history
    		if ( attached ) {
    			setGlobalEval( tmp );
    		}

    		// Capture executables
    		if ( scripts ) {
    			j = 0;
    			while ( ( elem = tmp[ j++ ] ) ) {
    				if ( rscriptType.test( elem.type || "" ) ) {
    					scripts.push( elem );
    				}
    			}
    		}
    	}

    	return fragment;
    }


    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
    	return true;
    }

    function returnFalse() {
    	return false;
    }

    function on( elem, types, selector, data, fn, one ) {
    	var origFn, type;

    	// Types can be a map of types/handlers
    	if ( typeof types === "object" ) {

    		// ( types-Object, selector, data )
    		if ( typeof selector !== "string" ) {

    			// ( types-Object, data )
    			data = data || selector;
    			selector = undefined;
    		}
    		for ( type in types ) {
    			on( elem, type, selector, data, types[ type ], one );
    		}
    		return elem;
    	}

    	if ( data == null && fn == null ) {

    		// ( types, fn )
    		fn = selector;
    		data = selector = undefined;
    	} else if ( fn == null ) {
    		if ( typeof selector === "string" ) {

    			// ( types, selector, fn )
    			fn = data;
    			data = undefined;
    		} else {

    			// ( types, data, fn )
    			fn = data;
    			data = selector;
    			selector = undefined;
    		}
    	}
    	if ( fn === false ) {
    		fn = returnFalse;
    	} else if ( !fn ) {
    		return elem;
    	}

    	if ( one === 1 ) {
    		origFn = fn;
    		fn = function( event ) {

    			// Can use an empty set, since event contains the info
    			jQuery().off( event );
    			return origFn.apply( this, arguments );
    		};

    		// Use same guid so caller can remove using origFn
    		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    	}
    	return elem.each( function() {
    		jQuery.event.add( this, types, fn, data, selector );
    	} );
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

    	global: {},

    	add: function( elem, types, handler, data, selector ) {

    		var handleObjIn, eventHandle, tmp,
    			events, t, handleObj,
    			special, handlers, type, namespaces, origType,
    			elemData = dataPriv.get( elem );

    		// Only attach events to objects that accept data
    		if ( !acceptData( elem ) ) {
    			return;
    		}

    		// Caller can pass in an object of custom data in lieu of the handler
    		if ( handler.handler ) {
    			handleObjIn = handler;
    			handler = handleObjIn.handler;
    			selector = handleObjIn.selector;
    		}

    		// Ensure that invalid selectors throw exceptions at attach time
    		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
    		if ( selector ) {
    			jQuery.find.matchesSelector( documentElement, selector );
    		}

    		// Make sure that the handler has a unique ID, used to find/remove it later
    		if ( !handler.guid ) {
    			handler.guid = jQuery.guid++;
    		}

    		// Init the element's event structure and main handler, if this is the first
    		if ( !( events = elemData.events ) ) {
    			events = elemData.events = Object.create( null );
    		}
    		if ( !( eventHandle = elemData.handle ) ) {
    			eventHandle = elemData.handle = function( e ) {

    				// Discard the second event of a jQuery.event.trigger() and
    				// when an event is called after a page has unloaded
    				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
    					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
    			};
    		}

    		// Handle multiple events separated by a space
    		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    		t = types.length;
    		while ( t-- ) {
    			tmp = rtypenamespace.exec( types[ t ] ) || [];
    			type = origType = tmp[ 1 ];
    			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

    			// There *must* be a type, no attaching namespace-only handlers
    			if ( !type ) {
    				continue;
    			}

    			// If event changes its type, use the special event handlers for the changed type
    			special = jQuery.event.special[ type ] || {};

    			// If selector defined, determine special event api type, otherwise given type
    			type = ( selector ? special.delegateType : special.bindType ) || type;

    			// Update special based on newly reset type
    			special = jQuery.event.special[ type ] || {};

    			// handleObj is passed to all event handlers
    			handleObj = jQuery.extend( {
    				type: type,
    				origType: origType,
    				data: data,
    				handler: handler,
    				guid: handler.guid,
    				selector: selector,
    				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
    				namespace: namespaces.join( "." )
    			}, handleObjIn );

    			// Init the event handler queue if we're the first
    			if ( !( handlers = events[ type ] ) ) {
    				handlers = events[ type ] = [];
    				handlers.delegateCount = 0;

    				// Only use addEventListener if the special events handler returns false
    				if ( !special.setup ||
    					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

    					if ( elem.addEventListener ) {
    						elem.addEventListener( type, eventHandle );
    					}
    				}
    			}

    			if ( special.add ) {
    				special.add.call( elem, handleObj );

    				if ( !handleObj.handler.guid ) {
    					handleObj.handler.guid = handler.guid;
    				}
    			}

    			// Add to the element's handler list, delegates in front
    			if ( selector ) {
    				handlers.splice( handlers.delegateCount++, 0, handleObj );
    			} else {
    				handlers.push( handleObj );
    			}

    			// Keep track of which events have ever been used, for event optimization
    			jQuery.event.global[ type ] = true;
    		}

    	},

    	// Detach an event or set of events from an element
    	remove: function( elem, types, handler, selector, mappedTypes ) {

    		var j, origCount, tmp,
    			events, t, handleObj,
    			special, handlers, type, namespaces, origType,
    			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

    		if ( !elemData || !( events = elemData.events ) ) {
    			return;
    		}

    		// Once for each type.namespace in types; type may be omitted
    		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    		t = types.length;
    		while ( t-- ) {
    			tmp = rtypenamespace.exec( types[ t ] ) || [];
    			type = origType = tmp[ 1 ];
    			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

    			// Unbind all events (on this namespace, if provided) for the element
    			if ( !type ) {
    				for ( type in events ) {
    					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
    				}
    				continue;
    			}

    			special = jQuery.event.special[ type ] || {};
    			type = ( selector ? special.delegateType : special.bindType ) || type;
    			handlers = events[ type ] || [];
    			tmp = tmp[ 2 ] &&
    				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

    			// Remove matching events
    			origCount = j = handlers.length;
    			while ( j-- ) {
    				handleObj = handlers[ j ];

    				if ( ( mappedTypes || origType === handleObj.origType ) &&
    					( !handler || handler.guid === handleObj.guid ) &&
    					( !tmp || tmp.test( handleObj.namespace ) ) &&
    					( !selector || selector === handleObj.selector ||
    						selector === "**" && handleObj.selector ) ) {
    					handlers.splice( j, 1 );

    					if ( handleObj.selector ) {
    						handlers.delegateCount--;
    					}
    					if ( special.remove ) {
    						special.remove.call( elem, handleObj );
    					}
    				}
    			}

    			// Remove generic event handler if we removed something and no more handlers exist
    			// (avoids potential for endless recursion during removal of special event handlers)
    			if ( origCount && !handlers.length ) {
    				if ( !special.teardown ||
    					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

    					jQuery.removeEvent( elem, type, elemData.handle );
    				}

    				delete events[ type ];
    			}
    		}

    		// Remove data and the expando if it's no longer used
    		if ( jQuery.isEmptyObject( events ) ) {
    			dataPriv.remove( elem, "handle events" );
    		}
    	},

    	dispatch: function( nativeEvent ) {

    		var i, j, ret, matched, handleObj, handlerQueue,
    			args = new Array( arguments.length ),

    			// Make a writable jQuery.Event from the native event object
    			event = jQuery.event.fix( nativeEvent ),

    			handlers = (
    				dataPriv.get( this, "events" ) || Object.create( null )
    			)[ event.type ] || [],
    			special = jQuery.event.special[ event.type ] || {};

    		// Use the fix-ed jQuery.Event rather than the (read-only) native event
    		args[ 0 ] = event;

    		for ( i = 1; i < arguments.length; i++ ) {
    			args[ i ] = arguments[ i ];
    		}

    		event.delegateTarget = this;

    		// Call the preDispatch hook for the mapped type, and let it bail if desired
    		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
    			return;
    		}

    		// Determine handlers
    		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

    		// Run delegates first; they may want to stop propagation beneath us
    		i = 0;
    		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
    			event.currentTarget = matched.elem;

    			j = 0;
    			while ( ( handleObj = matched.handlers[ j++ ] ) &&
    				!event.isImmediatePropagationStopped() ) {

    				// If the event is namespaced, then each handler is only invoked if it is
    				// specially universal or its namespaces are a superset of the event's.
    				if ( !event.rnamespace || handleObj.namespace === false ||
    					event.rnamespace.test( handleObj.namespace ) ) {

    					event.handleObj = handleObj;
    					event.data = handleObj.data;

    					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
    						handleObj.handler ).apply( matched.elem, args );

    					if ( ret !== undefined ) {
    						if ( ( event.result = ret ) === false ) {
    							event.preventDefault();
    							event.stopPropagation();
    						}
    					}
    				}
    			}
    		}

    		// Call the postDispatch hook for the mapped type
    		if ( special.postDispatch ) {
    			special.postDispatch.call( this, event );
    		}

    		return event.result;
    	},

    	handlers: function( event, handlers ) {
    		var i, handleObj, sel, matchedHandlers, matchedSelectors,
    			handlerQueue = [],
    			delegateCount = handlers.delegateCount,
    			cur = event.target;

    		// Find delegate handlers
    		if ( delegateCount &&

    			// Support: IE <=9
    			// Black-hole SVG <use> instance trees (trac-13180)
    			cur.nodeType &&

    			// Support: Firefox <=42
    			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    			// Support: IE 11 only
    			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    			!( event.type === "click" && event.button >= 1 ) ) {

    			for ( ; cur !== this; cur = cur.parentNode || this ) {

    				// Don't check non-elements (trac-13208)
    				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
    				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
    					matchedHandlers = [];
    					matchedSelectors = {};
    					for ( i = 0; i < delegateCount; i++ ) {
    						handleObj = handlers[ i ];

    						// Don't conflict with Object.prototype properties (trac-13203)
    						sel = handleObj.selector + " ";

    						if ( matchedSelectors[ sel ] === undefined ) {
    							matchedSelectors[ sel ] = handleObj.needsContext ?
    								jQuery( sel, this ).index( cur ) > -1 :
    								jQuery.find( sel, this, null, [ cur ] ).length;
    						}
    						if ( matchedSelectors[ sel ] ) {
    							matchedHandlers.push( handleObj );
    						}
    					}
    					if ( matchedHandlers.length ) {
    						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
    					}
    				}
    			}
    		}

    		// Add the remaining (directly-bound) handlers
    		cur = this;
    		if ( delegateCount < handlers.length ) {
    			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
    		}

    		return handlerQueue;
    	},

    	addProp: function( name, hook ) {
    		Object.defineProperty( jQuery.Event.prototype, name, {
    			enumerable: true,
    			configurable: true,

    			get: isFunction( hook ) ?
    				function() {
    					if ( this.originalEvent ) {
    						return hook( this.originalEvent );
    					}
    				} :
    				function() {
    					if ( this.originalEvent ) {
    						return this.originalEvent[ name ];
    					}
    				},

    			set: function( value ) {
    				Object.defineProperty( this, name, {
    					enumerable: true,
    					configurable: true,
    					writable: true,
    					value: value
    				} );
    			}
    		} );
    	},

    	fix: function( originalEvent ) {
    		return originalEvent[ jQuery.expando ] ?
    			originalEvent :
    			new jQuery.Event( originalEvent );
    	},

    	special: {
    		load: {

    			// Prevent triggered image.load events from bubbling to window.load
    			noBubble: true
    		},
    		click: {

    			// Utilize native event to ensure correct state for checkable inputs
    			setup: function( data ) {

    				// For mutual compressibility with _default, replace `this` access with a local var.
    				// `|| data` is dead code meant only to preserve the variable through minification.
    				var el = this || data;

    				// Claim the first handler
    				if ( rcheckableType.test( el.type ) &&
    					el.click && nodeName( el, "input" ) ) {

    					// dataPriv.set( el, "click", ... )
    					leverageNative( el, "click", true );
    				}

    				// Return false to allow normal processing in the caller
    				return false;
    			},
    			trigger: function( data ) {

    				// For mutual compressibility with _default, replace `this` access with a local var.
    				// `|| data` is dead code meant only to preserve the variable through minification.
    				var el = this || data;

    				// Force setup before triggering a click
    				if ( rcheckableType.test( el.type ) &&
    					el.click && nodeName( el, "input" ) ) {

    					leverageNative( el, "click" );
    				}

    				// Return non-false to allow normal event-path propagation
    				return true;
    			},

    			// For cross-browser consistency, suppress native .click() on links
    			// Also prevent it if we're currently inside a leveraged native-event stack
    			_default: function( event ) {
    				var target = event.target;
    				return rcheckableType.test( target.type ) &&
    					target.click && nodeName( target, "input" ) &&
    					dataPriv.get( target, "click" ) ||
    					nodeName( target, "a" );
    			}
    		},

    		beforeunload: {
    			postDispatch: function( event ) {

    				// Support: Firefox 20+
    				// Firefox doesn't alert if the returnValue field is not set.
    				if ( event.result !== undefined && event.originalEvent ) {
    					event.originalEvent.returnValue = event.result;
    				}
    			}
    		}
    	}
    };

    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative( el, type, isSetup ) {

    	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
    	if ( !isSetup ) {
    		if ( dataPriv.get( el, type ) === undefined ) {
    			jQuery.event.add( el, type, returnTrue );
    		}
    		return;
    	}

    	// Register the controller as a special universal handler for all event namespaces
    	dataPriv.set( el, type, false );
    	jQuery.event.add( el, type, {
    		namespace: false,
    		handler: function( event ) {
    			var result,
    				saved = dataPriv.get( this, type );

    			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

    				// Interrupt processing of the outer synthetic .trigger()ed event
    				if ( !saved ) {

    					// Store arguments for use when handling the inner native event
    					// There will always be at least one argument (an event object), so this array
    					// will not be confused with a leftover capture object.
    					saved = slice.call( arguments );
    					dataPriv.set( this, type, saved );

    					// Trigger the native event and capture its result
    					this[ type ]();
    					result = dataPriv.get( this, type );
    					dataPriv.set( this, type, false );

    					if ( saved !== result ) {

    						// Cancel the outer synthetic event
    						event.stopImmediatePropagation();
    						event.preventDefault();

    						return result;
    					}

    				// If this is an inner synthetic event for an event with a bubbling surrogate
    				// (focus or blur), assume that the surrogate already propagated from triggering
    				// the native event and prevent that from happening again here.
    				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
    				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
    				// less bad than duplication.
    				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
    					event.stopPropagation();
    				}

    			// If this is a native event triggered above, everything is now in order
    			// Fire an inner synthetic event with the original arguments
    			} else if ( saved ) {

    				// ...and capture the result
    				dataPriv.set( this, type, jQuery.event.trigger(
    					saved[ 0 ],
    					saved.slice( 1 ),
    					this
    				) );

    				// Abort handling of the native event by all jQuery handlers while allowing
    				// native handlers on the same element to run. On target, this is achieved
    				// by stopping immediate propagation just on the jQuery event. However,
    				// the native event is re-wrapped by a jQuery one on each level of the
    				// propagation so the only way to stop it for jQuery is to stop it for
    				// everyone via native `stopPropagation()`. This is not a problem for
    				// focus/blur which don't bubble, but it does also stop click on checkboxes
    				// and radios. We accept this limitation.
    				event.stopPropagation();
    				event.isImmediatePropagationStopped = returnTrue;
    			}
    		}
    	} );
    }

    jQuery.removeEvent = function( elem, type, handle ) {

    	// This "if" is needed for plain objects
    	if ( elem.removeEventListener ) {
    		elem.removeEventListener( type, handle );
    	}
    };

    jQuery.Event = function( src, props ) {

    	// Allow instantiation without the 'new' keyword
    	if ( !( this instanceof jQuery.Event ) ) {
    		return new jQuery.Event( src, props );
    	}

    	// Event object
    	if ( src && src.type ) {
    		this.originalEvent = src;
    		this.type = src.type;

    		// Events bubbling up the document may have been marked as prevented
    		// by a handler lower down the tree; reflect the correct value.
    		this.isDefaultPrevented = src.defaultPrevented ||
    				src.defaultPrevented === undefined &&

    				// Support: Android <=2.3 only
    				src.returnValue === false ?
    			returnTrue :
    			returnFalse;

    		// Create target properties
    		// Support: Safari <=6 - 7 only
    		// Target should not be a text node (trac-504, trac-13143)
    		this.target = ( src.target && src.target.nodeType === 3 ) ?
    			src.target.parentNode :
    			src.target;

    		this.currentTarget = src.currentTarget;
    		this.relatedTarget = src.relatedTarget;

    	// Event type
    	} else {
    		this.type = src;
    	}

    	// Put explicitly provided properties onto the event object
    	if ( props ) {
    		jQuery.extend( this, props );
    	}

    	// Create a timestamp if incoming event doesn't have one
    	this.timeStamp = src && src.timeStamp || Date.now();

    	// Mark it as fixed
    	this[ jQuery.expando ] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
    	constructor: jQuery.Event,
    	isDefaultPrevented: returnFalse,
    	isPropagationStopped: returnFalse,
    	isImmediatePropagationStopped: returnFalse,
    	isSimulated: false,

    	preventDefault: function() {
    		var e = this.originalEvent;

    		this.isDefaultPrevented = returnTrue;

    		if ( e && !this.isSimulated ) {
    			e.preventDefault();
    		}
    	},
    	stopPropagation: function() {
    		var e = this.originalEvent;

    		this.isPropagationStopped = returnTrue;

    		if ( e && !this.isSimulated ) {
    			e.stopPropagation();
    		}
    	},
    	stopImmediatePropagation: function() {
    		var e = this.originalEvent;

    		this.isImmediatePropagationStopped = returnTrue;

    		if ( e && !this.isSimulated ) {
    			e.stopImmediatePropagation();
    		}

    		this.stopPropagation();
    	}
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each( {
    	altKey: true,
    	bubbles: true,
    	cancelable: true,
    	changedTouches: true,
    	ctrlKey: true,
    	detail: true,
    	eventPhase: true,
    	metaKey: true,
    	pageX: true,
    	pageY: true,
    	shiftKey: true,
    	view: true,
    	"char": true,
    	code: true,
    	charCode: true,
    	key: true,
    	keyCode: true,
    	button: true,
    	buttons: true,
    	clientX: true,
    	clientY: true,
    	offsetX: true,
    	offsetY: true,
    	pointerId: true,
    	pointerType: true,
    	screenX: true,
    	screenY: true,
    	targetTouches: true,
    	toElement: true,
    	touches: true,
    	which: true
    }, jQuery.event.addProp );

    jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

    	function focusMappedHandler( nativeEvent ) {
    		if ( document.documentMode ) {

    			// Support: IE 11+
    			// Attach a single focusin/focusout handler on the document while someone wants
    			// focus/blur. This is because the former are synchronous in IE while the latter
    			// are async. In other browsers, all those handlers are invoked synchronously.

    			// `handle` from private data would already wrap the event, but we need
    			// to change the `type` here.
    			var handle = dataPriv.get( this, "handle" ),
    				event = jQuery.event.fix( nativeEvent );
    			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
    			event.isSimulated = true;

    			// First, handle focusin/focusout
    			handle( nativeEvent );

    			// ...then, handle focus/blur
    			//
    			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
    			// invoking the handler at the lower level.
    			if ( event.target === event.currentTarget ) {

    				// The setup part calls `leverageNative`, which, in turn, calls
    				// `jQuery.event.add`, so event handle will already have been set
    				// by this point.
    				handle( event );
    			}
    		} else {

    			// For non-IE browsers, attach a single capturing handler on the document
    			// while someone wants focusin/focusout.
    			jQuery.event.simulate( delegateType, nativeEvent.target,
    				jQuery.event.fix( nativeEvent ) );
    		}
    	}

    	jQuery.event.special[ type ] = {

    		// Utilize native event if possible so blur/focus sequence is correct
    		setup: function() {

    			var attaches;

    			// Claim the first handler
    			// dataPriv.set( this, "focus", ... )
    			// dataPriv.set( this, "blur", ... )
    			leverageNative( this, type, true );

    			if ( document.documentMode ) {

    				// Support: IE 9 - 11+
    				// We use the same native handler for focusin & focus (and focusout & blur)
    				// so we need to coordinate setup & teardown parts between those events.
    				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
    				attaches = dataPriv.get( this, delegateType );
    				if ( !attaches ) {
    					this.addEventListener( delegateType, focusMappedHandler );
    				}
    				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
    			} else {

    				// Return false to allow normal processing in the caller
    				return false;
    			}
    		},
    		trigger: function() {

    			// Force setup before trigger
    			leverageNative( this, type );

    			// Return non-false to allow normal event-path propagation
    			return true;
    		},

    		teardown: function() {
    			var attaches;

    			if ( document.documentMode ) {
    				attaches = dataPriv.get( this, delegateType ) - 1;
    				if ( !attaches ) {
    					this.removeEventListener( delegateType, focusMappedHandler );
    					dataPriv.remove( this, delegateType );
    				} else {
    					dataPriv.set( this, delegateType, attaches );
    				}
    			} else {

    				// Return false to indicate standard teardown should be applied
    				return false;
    			}
    		},

    		// Suppress native focus or blur if we're currently inside
    		// a leveraged native-event stack
    		_default: function( event ) {
    			return dataPriv.get( event.target, type );
    		},

    		delegateType: delegateType
    	};

    	// Support: Firefox <=44
    	// Firefox doesn't have focus(in | out) events
    	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    	//
    	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    	// focus(in | out) events fire after focus & blur events,
    	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    	//
    	// Support: IE 9 - 11+
    	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
    	// attach a single handler for both events in IE.
    	jQuery.event.special[ delegateType ] = {
    		setup: function() {

    			// Handle: regular nodes (via `this.ownerDocument`), window
    			// (via `this.document`) & document (via `this`).
    			var doc = this.ownerDocument || this.document || this,
    				dataHolder = document.documentMode ? this : doc,
    				attaches = dataPriv.get( dataHolder, delegateType );

    			// Support: IE 9 - 11+
    			// We use the same native handler for focusin & focus (and focusout & blur)
    			// so we need to coordinate setup & teardown parts between those events.
    			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
    			if ( !attaches ) {
    				if ( document.documentMode ) {
    					this.addEventListener( delegateType, focusMappedHandler );
    				} else {
    					doc.addEventListener( type, focusMappedHandler, true );
    				}
    			}
    			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
    		},
    		teardown: function() {
    			var doc = this.ownerDocument || this.document || this,
    				dataHolder = document.documentMode ? this : doc,
    				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

    			if ( !attaches ) {
    				if ( document.documentMode ) {
    					this.removeEventListener( delegateType, focusMappedHandler );
    				} else {
    					doc.removeEventListener( type, focusMappedHandler, true );
    				}
    				dataPriv.remove( dataHolder, delegateType );
    			} else {
    				dataPriv.set( dataHolder, delegateType, attaches );
    			}
    		}
    	};
    } );

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each( {
    	mouseenter: "mouseover",
    	mouseleave: "mouseout",
    	pointerenter: "pointerover",
    	pointerleave: "pointerout"
    }, function( orig, fix ) {
    	jQuery.event.special[ orig ] = {
    		delegateType: fix,
    		bindType: fix,

    		handle: function( event ) {
    			var ret,
    				target = this,
    				related = event.relatedTarget,
    				handleObj = event.handleObj;

    			// For mouseenter/leave call the handler if related is outside the target.
    			// NB: No relatedTarget if the mouse left/entered the browser window
    			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
    				event.type = handleObj.origType;
    				ret = handleObj.handler.apply( this, arguments );
    				event.type = fix;
    			}
    			return ret;
    		}
    	};
    } );

    jQuery.fn.extend( {

    	on: function( types, selector, data, fn ) {
    		return on( this, types, selector, data, fn );
    	},
    	one: function( types, selector, data, fn ) {
    		return on( this, types, selector, data, fn, 1 );
    	},
    	off: function( types, selector, fn ) {
    		var handleObj, type;
    		if ( types && types.preventDefault && types.handleObj ) {

    			// ( event )  dispatched jQuery.Event
    			handleObj = types.handleObj;
    			jQuery( types.delegateTarget ).off(
    				handleObj.namespace ?
    					handleObj.origType + "." + handleObj.namespace :
    					handleObj.origType,
    				handleObj.selector,
    				handleObj.handler
    			);
    			return this;
    		}
    		if ( typeof types === "object" ) {

    			// ( types-object [, selector] )
    			for ( type in types ) {
    				this.off( type, selector, types[ type ] );
    			}
    			return this;
    		}
    		if ( selector === false || typeof selector === "function" ) {

    			// ( types [, fn] )
    			fn = selector;
    			selector = undefined;
    		}
    		if ( fn === false ) {
    			fn = returnFalse;
    		}
    		return this.each( function() {
    			jQuery.event.remove( this, types, fn, selector );
    		} );
    	}
    } );


    var

    	// Support: IE <=10 - 11, Edge 12 - 13 only
    	// In IE/Edge using regex groups here causes severe slowdowns.
    	// See https://connect.microsoft.com/IE/feedback/details/1736512/
    	rnoInnerhtml = /<script|<style|<link/i,

    	// checked="checked" or checked
    	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

    	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget( elem, content ) {
    	if ( nodeName( elem, "table" ) &&
    		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

    		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
    	}

    	return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
    	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
    	return elem;
    }
    function restoreScript( elem ) {
    	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
    		elem.type = elem.type.slice( 5 );
    	} else {
    		elem.removeAttribute( "type" );
    	}

    	return elem;
    }

    function cloneCopyEvent( src, dest ) {
    	var i, l, type, pdataOld, udataOld, udataCur, events;

    	if ( dest.nodeType !== 1 ) {
    		return;
    	}

    	// 1. Copy private data: events, handlers, etc.
    	if ( dataPriv.hasData( src ) ) {
    		pdataOld = dataPriv.get( src );
    		events = pdataOld.events;

    		if ( events ) {
    			dataPriv.remove( dest, "handle events" );

    			for ( type in events ) {
    				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
    					jQuery.event.add( dest, type, events[ type ][ i ] );
    				}
    			}
    		}
    	}

    	// 2. Copy user data
    	if ( dataUser.hasData( src ) ) {
    		udataOld = dataUser.access( src );
    		udataCur = jQuery.extend( {}, udataOld );

    		dataUser.set( dest, udataCur );
    	}
    }

    // Fix IE bugs, see support tests
    function fixInput( src, dest ) {
    	var nodeName = dest.nodeName.toLowerCase();

    	// Fails to persist the checked state of a cloned checkbox or radio button.
    	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    		dest.checked = src.checked;

    	// Fails to return the selected option to the default selected state when cloning options
    	} else if ( nodeName === "input" || nodeName === "textarea" ) {
    		dest.defaultValue = src.defaultValue;
    	}
    }

    function domManip( collection, args, callback, ignored ) {

    	// Flatten any nested arrays
    	args = flat( args );

    	var fragment, first, scripts, hasScripts, node, doc,
    		i = 0,
    		l = collection.length,
    		iNoClone = l - 1,
    		value = args[ 0 ],
    		valueIsFunction = isFunction( value );

    	// We can't cloneNode fragments that contain checked, in WebKit
    	if ( valueIsFunction ||
    			( l > 1 && typeof value === "string" &&
    				!support.checkClone && rchecked.test( value ) ) ) {
    		return collection.each( function( index ) {
    			var self = collection.eq( index );
    			if ( valueIsFunction ) {
    				args[ 0 ] = value.call( this, index, self.html() );
    			}
    			domManip( self, args, callback, ignored );
    		} );
    	}

    	if ( l ) {
    		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
    		first = fragment.firstChild;

    		if ( fragment.childNodes.length === 1 ) {
    			fragment = first;
    		}

    		// Require either new content or an interest in ignored elements to invoke the callback
    		if ( first || ignored ) {
    			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
    			hasScripts = scripts.length;

    			// Use the original fragment for the last item
    			// instead of the first because it can end up
    			// being emptied incorrectly in certain situations (trac-8070).
    			for ( ; i < l; i++ ) {
    				node = fragment;

    				if ( i !== iNoClone ) {
    					node = jQuery.clone( node, true, true );

    					// Keep references to cloned scripts for later restoration
    					if ( hasScripts ) {

    						// Support: Android <=4.0 only, PhantomJS 1 only
    						// push.apply(_, arraylike) throws on ancient WebKit
    						jQuery.merge( scripts, getAll( node, "script" ) );
    					}
    				}

    				callback.call( collection[ i ], node, i );
    			}

    			if ( hasScripts ) {
    				doc = scripts[ scripts.length - 1 ].ownerDocument;

    				// Reenable scripts
    				jQuery.map( scripts, restoreScript );

    				// Evaluate executable scripts on first document insertion
    				for ( i = 0; i < hasScripts; i++ ) {
    					node = scripts[ i ];
    					if ( rscriptType.test( node.type || "" ) &&
    						!dataPriv.access( node, "globalEval" ) &&
    						jQuery.contains( doc, node ) ) {

    						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

    							// Optional AJAX dependency, but won't run scripts if not present
    							if ( jQuery._evalUrl && !node.noModule ) {
    								jQuery._evalUrl( node.src, {
    									nonce: node.nonce || node.getAttribute( "nonce" )
    								}, doc );
    							}
    						} else {

    							// Unwrap a CDATA section containing script contents. This shouldn't be
    							// needed as in XML documents they're already not visible when
    							// inspecting element contents and in HTML documents they have no
    							// meaning but we're preserving that logic for backwards compatibility.
    							// This will be removed completely in 4.0. See gh-4904.
    							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
    						}
    					}
    				}
    			}
    		}
    	}

    	return collection;
    }

    function remove( elem, selector, keepData ) {
    	var node,
    		nodes = selector ? jQuery.filter( selector, elem ) : elem,
    		i = 0;

    	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
    		if ( !keepData && node.nodeType === 1 ) {
    			jQuery.cleanData( getAll( node ) );
    		}

    		if ( node.parentNode ) {
    			if ( keepData && isAttached( node ) ) {
    				setGlobalEval( getAll( node, "script" ) );
    			}
    			node.parentNode.removeChild( node );
    		}
    	}

    	return elem;
    }

    jQuery.extend( {
    	htmlPrefilter: function( html ) {
    		return html;
    	},

    	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    		var i, l, srcElements, destElements,
    			clone = elem.cloneNode( true ),
    			inPage = isAttached( elem );

    		// Fix IE cloning issues
    		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
    				!jQuery.isXMLDoc( elem ) ) {

    			// We eschew jQuery#find here for performance reasons:
    			// https://jsperf.com/getall-vs-sizzle/2
    			destElements = getAll( clone );
    			srcElements = getAll( elem );

    			for ( i = 0, l = srcElements.length; i < l; i++ ) {
    				fixInput( srcElements[ i ], destElements[ i ] );
    			}
    		}

    		// Copy the events from the original to the clone
    		if ( dataAndEvents ) {
    			if ( deepDataAndEvents ) {
    				srcElements = srcElements || getAll( elem );
    				destElements = destElements || getAll( clone );

    				for ( i = 0, l = srcElements.length; i < l; i++ ) {
    					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
    				}
    			} else {
    				cloneCopyEvent( elem, clone );
    			}
    		}

    		// Preserve script evaluation history
    		destElements = getAll( clone, "script" );
    		if ( destElements.length > 0 ) {
    			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    		}

    		// Return the cloned set
    		return clone;
    	},

    	cleanData: function( elems ) {
    		var data, elem, type,
    			special = jQuery.event.special,
    			i = 0;

    		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
    			if ( acceptData( elem ) ) {
    				if ( ( data = elem[ dataPriv.expando ] ) ) {
    					if ( data.events ) {
    						for ( type in data.events ) {
    							if ( special[ type ] ) {
    								jQuery.event.remove( elem, type );

    							// This is a shortcut to avoid jQuery.event.remove's overhead
    							} else {
    								jQuery.removeEvent( elem, type, data.handle );
    							}
    						}
    					}

    					// Support: Chrome <=35 - 45+
    					// Assign undefined instead of using delete, see Data#remove
    					elem[ dataPriv.expando ] = undefined;
    				}
    				if ( elem[ dataUser.expando ] ) {

    					// Support: Chrome <=35 - 45+
    					// Assign undefined instead of using delete, see Data#remove
    					elem[ dataUser.expando ] = undefined;
    				}
    			}
    		}
    	}
    } );

    jQuery.fn.extend( {
    	detach: function( selector ) {
    		return remove( this, selector, true );
    	},

    	remove: function( selector ) {
    		return remove( this, selector );
    	},

    	text: function( value ) {
    		return access( this, function( value ) {
    			return value === undefined ?
    				jQuery.text( this ) :
    				this.empty().each( function() {
    					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    						this.textContent = value;
    					}
    				} );
    		}, null, value, arguments.length );
    	},

    	append: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    				var target = manipulationTarget( this, elem );
    				target.appendChild( elem );
    			}
    		} );
    	},

    	prepend: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    				var target = manipulationTarget( this, elem );
    				target.insertBefore( elem, target.firstChild );
    			}
    		} );
    	},

    	before: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.parentNode ) {
    				this.parentNode.insertBefore( elem, this );
    			}
    		} );
    	},

    	after: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.parentNode ) {
    				this.parentNode.insertBefore( elem, this.nextSibling );
    			}
    		} );
    	},

    	empty: function() {
    		var elem,
    			i = 0;

    		for ( ; ( elem = this[ i ] ) != null; i++ ) {
    			if ( elem.nodeType === 1 ) {

    				// Prevent memory leaks
    				jQuery.cleanData( getAll( elem, false ) );

    				// Remove any remaining nodes
    				elem.textContent = "";
    			}
    		}

    		return this;
    	},

    	clone: function( dataAndEvents, deepDataAndEvents ) {
    		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    		return this.map( function() {
    			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    		} );
    	},

    	html: function( value ) {
    		return access( this, function( value ) {
    			var elem = this[ 0 ] || {},
    				i = 0,
    				l = this.length;

    			if ( value === undefined && elem.nodeType === 1 ) {
    				return elem.innerHTML;
    			}

    			// See if we can take a shortcut and just use innerHTML
    			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
    				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

    				value = jQuery.htmlPrefilter( value );

    				try {
    					for ( ; i < l; i++ ) {
    						elem = this[ i ] || {};

    						// Remove element nodes and prevent memory leaks
    						if ( elem.nodeType === 1 ) {
    							jQuery.cleanData( getAll( elem, false ) );
    							elem.innerHTML = value;
    						}
    					}

    					elem = 0;

    				// If using innerHTML throws an exception, use the fallback method
    				} catch ( e ) {}
    			}

    			if ( elem ) {
    				this.empty().append( value );
    			}
    		}, null, value, arguments.length );
    	},

    	replaceWith: function() {
    		var ignored = [];

    		// Make the changes, replacing each non-ignored context element with the new content
    		return domManip( this, arguments, function( elem ) {
    			var parent = this.parentNode;

    			if ( jQuery.inArray( this, ignored ) < 0 ) {
    				jQuery.cleanData( getAll( this ) );
    				if ( parent ) {
    					parent.replaceChild( elem, this );
    				}
    			}

    		// Force callback invocation
    		}, ignored );
    	}
    } );

    jQuery.each( {
    	appendTo: "append",
    	prependTo: "prepend",
    	insertBefore: "before",
    	insertAfter: "after",
    	replaceAll: "replaceWith"
    }, function( name, original ) {
    	jQuery.fn[ name ] = function( selector ) {
    		var elems,
    			ret = [],
    			insert = jQuery( selector ),
    			last = insert.length - 1,
    			i = 0;

    		for ( ; i <= last; i++ ) {
    			elems = i === last ? this : this.clone( true );
    			jQuery( insert[ i ] )[ original ]( elems );

    			// Support: Android <=4.0 only, PhantomJS 1 only
    			// .get() because push.apply(_, arraylike) throws on ancient WebKit
    			push.apply( ret, elems.get() );
    		}

    		return this.pushStack( ret );
    	};
    } );
    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

    var rcustomProp = /^--/;


    var getStyles = function( elem ) {

    		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
    		// IE throws on elements created in popups
    		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    		var view = elem.ownerDocument.defaultView;

    		if ( !view || !view.opener ) {
    			view = window;
    		}

    		return view.getComputedStyle( elem );
    	};

    var swap = function( elem, options, callback ) {
    	var ret, name,
    		old = {};

    	// Remember the old values, and insert the new ones
    	for ( name in options ) {
    		old[ name ] = elem.style[ name ];
    		elem.style[ name ] = options[ name ];
    	}

    	ret = callback.call( elem );

    	// Revert the old values
    	for ( name in options ) {
    		elem.style[ name ] = old[ name ];
    	}

    	return ret;
    };


    var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



    ( function() {

    	// Executing both pixelPosition & boxSizingReliable tests require only one layout
    	// so they're executed at the same time to save the second computation.
    	function computeStyleTests() {

    		// This is a singleton, we need to execute it only once
    		if ( !div ) {
    			return;
    		}

    		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
    			"margin-top:1px;padding:0;border:0";
    		div.style.cssText =
    			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
    			"margin:auto;border:1px;padding:1px;" +
    			"width:60%;top:1%";
    		documentElement.appendChild( container ).appendChild( div );

    		var divStyle = window.getComputedStyle( div );
    		pixelPositionVal = divStyle.top !== "1%";

    		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
    		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

    		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
    		// Some styles come back with percentage values, even though they shouldn't
    		div.style.right = "60%";
    		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

    		// Support: IE 9 - 11 only
    		// Detect misreporting of content dimensions for box-sizing:border-box elements
    		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

    		// Support: IE 9 only
    		// Detect overflow:scroll screwiness (gh-3699)
    		// Support: Chrome <=64
    		// Don't get tricked when zoom affects offsetWidth (gh-4029)
    		div.style.position = "absolute";
    		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

    		documentElement.removeChild( container );

    		// Nullify the div so it wouldn't be stored in the memory and
    		// it will also be a sign that checks already performed
    		div = null;
    	}

    	function roundPixelMeasures( measure ) {
    		return Math.round( parseFloat( measure ) );
    	}

    	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
    		reliableTrDimensionsVal, reliableMarginLeftVal,
    		container = document.createElement( "div" ),
    		div = document.createElement( "div" );

    	// Finish early in limited (non-browser) environments
    	if ( !div.style ) {
    		return;
    	}

    	// Support: IE <=9 - 11 only
    	// Style of cloned element affects source element cloned (trac-8908)
    	div.style.backgroundClip = "content-box";
    	div.cloneNode( true ).style.backgroundClip = "";
    	support.clearCloneStyle = div.style.backgroundClip === "content-box";

    	jQuery.extend( support, {
    		boxSizingReliable: function() {
    			computeStyleTests();
    			return boxSizingReliableVal;
    		},
    		pixelBoxStyles: function() {
    			computeStyleTests();
    			return pixelBoxStylesVal;
    		},
    		pixelPosition: function() {
    			computeStyleTests();
    			return pixelPositionVal;
    		},
    		reliableMarginLeft: function() {
    			computeStyleTests();
    			return reliableMarginLeftVal;
    		},
    		scrollboxSize: function() {
    			computeStyleTests();
    			return scrollboxSizeVal;
    		},

    		// Support: IE 9 - 11+, Edge 15 - 18+
    		// IE/Edge misreport `getComputedStyle` of table rows with width/height
    		// set in CSS while `offset*` properties report correct values.
    		// Behavior in IE 9 is more subtle than in newer versions & it passes
    		// some versions of this test; make sure not to make it pass there!
    		//
    		// Support: Firefox 70+
    		// Only Firefox includes border widths
    		// in computed dimensions. (gh-4529)
    		reliableTrDimensions: function() {
    			var table, tr, trChild, trStyle;
    			if ( reliableTrDimensionsVal == null ) {
    				table = document.createElement( "table" );
    				tr = document.createElement( "tr" );
    				trChild = document.createElement( "div" );

    				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
    				tr.style.cssText = "border:1px solid";

    				// Support: Chrome 86+
    				// Height set through cssText does not get applied.
    				// Computed height then comes back as 0.
    				tr.style.height = "1px";
    				trChild.style.height = "9px";

    				// Support: Android 8 Chrome 86+
    				// In our bodyBackground.html iframe,
    				// display for all div elements is set to "inline",
    				// which causes a problem only in Android 8 Chrome 86.
    				// Ensuring the div is display: block
    				// gets around this issue.
    				trChild.style.display = "block";

    				documentElement
    					.appendChild( table )
    					.appendChild( tr )
    					.appendChild( trChild );

    				trStyle = window.getComputedStyle( tr );
    				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
    					parseInt( trStyle.borderTopWidth, 10 ) +
    					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

    				documentElement.removeChild( table );
    			}
    			return reliableTrDimensionsVal;
    		}
    	} );
    } )();


    function curCSS( elem, name, computed ) {
    	var width, minWidth, maxWidth, ret,
    		isCustomProp = rcustomProp.test( name ),

    		// Support: Firefox 51+
    		// Retrieving style before computed somehow
    		// fixes an issue with getting wrong values
    		// on detached elements
    		style = elem.style;

    	computed = computed || getStyles( elem );

    	// getPropertyValue is needed for:
    	//   .css('filter') (IE 9 only, trac-12537)
    	//   .css('--customProperty) (gh-3144)
    	if ( computed ) {

    		// Support: IE <=9 - 11+
    		// IE only supports `"float"` in `getPropertyValue`; in computed styles
    		// it's only available as `"cssFloat"`. We no longer modify properties
    		// sent to `.css()` apart from camelCasing, so we need to check both.
    		// Normally, this would create difference in behavior: if
    		// `getPropertyValue` returns an empty string, the value returned
    		// by `.css()` would be `undefined`. This is usually the case for
    		// disconnected elements. However, in IE even disconnected elements
    		// with no styles return `"none"` for `getPropertyValue( "float" )`
    		ret = computed.getPropertyValue( name ) || computed[ name ];

    		if ( isCustomProp && ret ) {

    			// Support: Firefox 105+, Chrome <=105+
    			// Spec requires trimming whitespace for custom properties (gh-4926).
    			// Firefox only trims leading whitespace. Chrome just collapses
    			// both leading & trailing whitespace to a single space.
    			//
    			// Fall back to `undefined` if empty string returned.
    			// This collapses a missing definition with property defined
    			// and set to an empty string but there's no standard API
    			// allowing us to differentiate them without a performance penalty
    			// and returning `undefined` aligns with older jQuery.
    			//
    			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
    			// as whitespace while CSS does not, but this is not a problem
    			// because CSS preprocessing replaces them with U+000A LINE FEED
    			// (which *is* CSS whitespace)
    			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
    			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
    		}

    		if ( ret === "" && !isAttached( elem ) ) {
    			ret = jQuery.style( elem, name );
    		}

    		// A tribute to the "awesome hack by Dean Edwards"
    		// Android Browser returns percentage for some values,
    		// but width seems to be reliably pixels.
    		// This is against the CSSOM draft spec:
    		// https://drafts.csswg.org/cssom/#resolved-values
    		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

    			// Remember the original values
    			width = style.width;
    			minWidth = style.minWidth;
    			maxWidth = style.maxWidth;

    			// Put in the new values to get a computed value out
    			style.minWidth = style.maxWidth = style.width = ret;
    			ret = computed.width;

    			// Revert the changed values
    			style.width = width;
    			style.minWidth = minWidth;
    			style.maxWidth = maxWidth;
    		}
    	}

    	return ret !== undefined ?

    		// Support: IE <=9 - 11 only
    		// IE returns zIndex value as an integer.
    		ret + "" :
    		ret;
    }


    function addGetHookIf( conditionFn, hookFn ) {

    	// Define the hook, we'll check on the first run if it's really needed.
    	return {
    		get: function() {
    			if ( conditionFn() ) {

    				// Hook not needed (or it's not possible to use it due
    				// to missing dependency), remove it.
    				delete this.get;
    				return;
    			}

    			// Hook needed; redefine it so that the support test is not executed again.
    			return ( this.get = hookFn ).apply( this, arguments );
    		}
    	};
    }


    var cssPrefixes = [ "Webkit", "Moz", "ms" ],
    	emptyStyle = document.createElement( "div" ).style,
    	vendorProps = {};

    // Return a vendor-prefixed property or undefined
    function vendorPropName( name ) {

    	// Check for vendor prefixed names
    	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
    		i = cssPrefixes.length;

    	while ( i-- ) {
    		name = cssPrefixes[ i ] + capName;
    		if ( name in emptyStyle ) {
    			return name;
    		}
    	}
    }

    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName( name ) {
    	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

    	if ( final ) {
    		return final;
    	}
    	if ( name in emptyStyle ) {
    		return name;
    	}
    	return vendorProps[ name ] = vendorPropName( name ) || name;
    }


    var

    	// Swappable if display is none or starts with table
    	// except "table", "table-cell", or "table-caption"
    	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    	cssNormalTransform = {
    		letterSpacing: "0",
    		fontWeight: "400"
    	};

    function setPositiveNumber( _elem, value, subtract ) {

    	// Any relative (+/-) values have already been
    	// normalized at this point
    	var matches = rcssNum.exec( value );
    	return matches ?

    		// Guard against undefined "subtract", e.g., when used as in cssHooks
    		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
    		value;
    }

    function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
    	var i = dimension === "width" ? 1 : 0,
    		extra = 0,
    		delta = 0,
    		marginDelta = 0;

    	// Adjustment may not be necessary
    	if ( box === ( isBorderBox ? "border" : "content" ) ) {
    		return 0;
    	}

    	for ( ; i < 4; i += 2 ) {

    		// Both box models exclude margin
    		// Count margin delta separately to only add it after scroll gutter adjustment.
    		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
    		if ( box === "margin" ) {
    			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
    		}

    		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
    		if ( !isBorderBox ) {

    			// Add padding
    			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

    			// For "border" or "margin", add border
    			if ( box !== "padding" ) {
    				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

    			// But still keep track of it otherwise
    			} else {
    				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
    			}

    		// If we get here with a border-box (content + padding + border), we're seeking "content" or
    		// "padding" or "margin"
    		} else {

    			// For "content", subtract padding
    			if ( box === "content" ) {
    				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
    			}

    			// For "content" or "padding", subtract border
    			if ( box !== "margin" ) {
    				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
    			}
    		}
    	}

    	// Account for positive content-box scroll gutter when requested by providing computedVal
    	if ( !isBorderBox && computedVal >= 0 ) {

    		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
    		// Assuming integer scroll gutter, subtract the rest and round down
    		delta += Math.max( 0, Math.ceil(
    			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
    			computedVal -
    			delta -
    			extra -
    			0.5

    		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
    		// Use an explicit zero to avoid NaN (gh-3964)
    		) ) || 0;
    	}

    	return delta + marginDelta;
    }

    function getWidthOrHeight( elem, dimension, extra ) {

    	// Start with computed style
    	var styles = getStyles( elem ),

    		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    		// Fake content-box until we know it's needed to know the true value.
    		boxSizingNeeded = !support.boxSizingReliable() || extra,
    		isBorderBox = boxSizingNeeded &&
    			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
    		valueIsBorderBox = isBorderBox,

    		val = curCSS( elem, dimension, styles ),
    		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

    	// Support: Firefox <=54
    	// Return a confounding non-pixel value or feign ignorance, as appropriate.
    	if ( rnumnonpx.test( val ) ) {
    		if ( !extra ) {
    			return val;
    		}
    		val = "auto";
    	}


    	// Support: IE 9 - 11 only
    	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
    	// In those cases, the computed value can be trusted to be border-box.
    	if ( ( !support.boxSizingReliable() && isBorderBox ||

    		// Support: IE 10 - 11+, Edge 15 - 18+
    		// IE/Edge misreport `getComputedStyle` of table rows with width/height
    		// set in CSS while `offset*` properties report correct values.
    		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
    		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

    		// Fall back to offsetWidth/offsetHeight when value is "auto"
    		// This happens for inline elements with no explicit setting (gh-3571)
    		val === "auto" ||

    		// Support: Android <=4.1 - 4.3 only
    		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

    		// Make sure the element is visible & connected
    		elem.getClientRects().length ) {

    		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
    		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
    		// retrieved value as a content box dimension.
    		valueIsBorderBox = offsetProp in elem;
    		if ( valueIsBorderBox ) {
    			val = elem[ offsetProp ];
    		}
    	}

    	// Normalize "" and auto
    	val = parseFloat( val ) || 0;

    	// Adjust for the element's box model
    	return ( val +
    		boxModelAdjustment(
    			elem,
    			dimension,
    			extra || ( isBorderBox ? "border" : "content" ),
    			valueIsBorderBox,
    			styles,

    			// Provide the current computed size to request scroll gutter calculation (gh-3589)
    			val
    		)
    	) + "px";
    }

    jQuery.extend( {

    	// Add in style property hooks for overriding the default
    	// behavior of getting and setting a style property
    	cssHooks: {
    		opacity: {
    			get: function( elem, computed ) {
    				if ( computed ) {

    					// We should always get a number back from opacity
    					var ret = curCSS( elem, "opacity" );
    					return ret === "" ? "1" : ret;
    				}
    			}
    		}
    	},

    	// Don't automatically add "px" to these possibly-unitless properties
    	cssNumber: {
    		animationIterationCount: true,
    		aspectRatio: true,
    		borderImageSlice: true,
    		columnCount: true,
    		flexGrow: true,
    		flexShrink: true,
    		fontWeight: true,
    		gridArea: true,
    		gridColumn: true,
    		gridColumnEnd: true,
    		gridColumnStart: true,
    		gridRow: true,
    		gridRowEnd: true,
    		gridRowStart: true,
    		lineHeight: true,
    		opacity: true,
    		order: true,
    		orphans: true,
    		scale: true,
    		widows: true,
    		zIndex: true,
    		zoom: true,

    		// SVG-related
    		fillOpacity: true,
    		floodOpacity: true,
    		stopOpacity: true,
    		strokeMiterlimit: true,
    		strokeOpacity: true
    	},

    	// Add in properties whose names you wish to fix before
    	// setting or getting the value
    	cssProps: {},

    	// Get and set the style property on a DOM Node
    	style: function( elem, name, value, extra ) {

    		// Don't set styles on text and comment nodes
    		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
    			return;
    		}

    		// Make sure that we're working with the right name
    		var ret, type, hooks,
    			origName = camelCase( name ),
    			isCustomProp = rcustomProp.test( name ),
    			style = elem.style;

    		// Make sure that we're working with the right name. We don't
    		// want to query the value if it is a CSS custom property
    		// since they are user-defined.
    		if ( !isCustomProp ) {
    			name = finalPropName( origName );
    		}

    		// Gets hook for the prefixed version, then unprefixed version
    		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    		// Check if we're setting a value
    		if ( value !== undefined ) {
    			type = typeof value;

    			// Convert "+=" or "-=" to relative numbers (trac-7345)
    			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
    				value = adjustCSS( elem, name, ret );

    				// Fixes bug trac-9237
    				type = "number";
    			}

    			// Make sure that null and NaN values aren't set (trac-7116)
    			if ( value == null || value !== value ) {
    				return;
    			}

    			// If a number was passed in, add the unit (except for certain CSS properties)
    			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
    			// "px" to a few hardcoded values.
    			if ( type === "number" && !isCustomProp ) {
    				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
    			}

    			// background-* props affect original clone's values
    			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
    				style[ name ] = "inherit";
    			}

    			// If a hook was provided, use that value, otherwise just set the specified value
    			if ( !hooks || !( "set" in hooks ) ||
    				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

    				if ( isCustomProp ) {
    					style.setProperty( name, value );
    				} else {
    					style[ name ] = value;
    				}
    			}

    		} else {

    			// If a hook was provided get the non-computed value from there
    			if ( hooks && "get" in hooks &&
    				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

    				return ret;
    			}

    			// Otherwise just get the value from the style object
    			return style[ name ];
    		}
    	},

    	css: function( elem, name, extra, styles ) {
    		var val, num, hooks,
    			origName = camelCase( name ),
    			isCustomProp = rcustomProp.test( name );

    		// Make sure that we're working with the right name. We don't
    		// want to modify the value if it is a CSS custom property
    		// since they are user-defined.
    		if ( !isCustomProp ) {
    			name = finalPropName( origName );
    		}

    		// Try prefixed name followed by the unprefixed name
    		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    		// If a hook was provided get the computed value from there
    		if ( hooks && "get" in hooks ) {
    			val = hooks.get( elem, true, extra );
    		}

    		// Otherwise, if a way to get the computed value exists, use that
    		if ( val === undefined ) {
    			val = curCSS( elem, name, styles );
    		}

    		// Convert "normal" to computed value
    		if ( val === "normal" && name in cssNormalTransform ) {
    			val = cssNormalTransform[ name ];
    		}

    		// Make numeric if forced or a qualifier was provided and val looks numeric
    		if ( extra === "" || extra ) {
    			num = parseFloat( val );
    			return extra === true || isFinite( num ) ? num || 0 : val;
    		}

    		return val;
    	}
    } );

    jQuery.each( [ "height", "width" ], function( _i, dimension ) {
    	jQuery.cssHooks[ dimension ] = {
    		get: function( elem, computed, extra ) {
    			if ( computed ) {

    				// Certain elements can have dimension info if we invisibly show them
    				// but it must have a current display style that would benefit
    				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

    					// Support: Safari 8+
    					// Table columns in Safari have non-zero offsetWidth & zero
    					// getBoundingClientRect().width unless display is changed.
    					// Support: IE <=11 only
    					// Running getBoundingClientRect on a disconnected node
    					// in IE throws an error.
    					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
    					swap( elem, cssShow, function() {
    						return getWidthOrHeight( elem, dimension, extra );
    					} ) :
    					getWidthOrHeight( elem, dimension, extra );
    			}
    		},

    		set: function( elem, value, extra ) {
    			var matches,
    				styles = getStyles( elem ),

    				// Only read styles.position if the test has a chance to fail
    				// to avoid forcing a reflow.
    				scrollboxSizeBuggy = !support.scrollboxSize() &&
    					styles.position === "absolute",

    				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
    				boxSizingNeeded = scrollboxSizeBuggy || extra,
    				isBorderBox = boxSizingNeeded &&
    					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
    				subtract = extra ?
    					boxModelAdjustment(
    						elem,
    						dimension,
    						extra,
    						isBorderBox,
    						styles
    					) :
    					0;

    			// Account for unreliable border-box dimensions by comparing offset* to computed and
    			// faking a content-box to get border and padding (gh-3699)
    			if ( isBorderBox && scrollboxSizeBuggy ) {
    				subtract -= Math.ceil(
    					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
    					parseFloat( styles[ dimension ] ) -
    					boxModelAdjustment( elem, dimension, "border", false, styles ) -
    					0.5
    				);
    			}

    			// Convert to pixels if value adjustment is needed
    			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
    				( matches[ 3 ] || "px" ) !== "px" ) {

    				elem.style[ dimension ] = value;
    				value = jQuery.css( elem, dimension );
    			}

    			return setPositiveNumber( elem, value, subtract );
    		}
    	};
    } );

    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
    	function( elem, computed ) {
    		if ( computed ) {
    			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
    				elem.getBoundingClientRect().left -
    					swap( elem, { marginLeft: 0 }, function() {
    						return elem.getBoundingClientRect().left;
    					} )
    			) + "px";
    		}
    	}
    );

    // These hooks are used by animate to expand properties
    jQuery.each( {
    	margin: "",
    	padding: "",
    	border: "Width"
    }, function( prefix, suffix ) {
    	jQuery.cssHooks[ prefix + suffix ] = {
    		expand: function( value ) {
    			var i = 0,
    				expanded = {},

    				// Assumes a single number if not a string
    				parts = typeof value === "string" ? value.split( " " ) : [ value ];

    			for ( ; i < 4; i++ ) {
    				expanded[ prefix + cssExpand[ i ] + suffix ] =
    					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
    			}

    			return expanded;
    		}
    	};

    	if ( prefix !== "margin" ) {
    		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    	}
    } );

    jQuery.fn.extend( {
    	css: function( name, value ) {
    		return access( this, function( elem, name, value ) {
    			var styles, len,
    				map = {},
    				i = 0;

    			if ( Array.isArray( name ) ) {
    				styles = getStyles( elem );
    				len = name.length;

    				for ( ; i < len; i++ ) {
    					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
    				}

    				return map;
    			}

    			return value !== undefined ?
    				jQuery.style( elem, name, value ) :
    				jQuery.css( elem, name );
    		}, name, value, arguments.length > 1 );
    	}
    } );


    function Tween( elem, options, prop, end, easing ) {
    	return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
    	constructor: Tween,
    	init: function( elem, options, prop, end, easing, unit ) {
    		this.elem = elem;
    		this.prop = prop;
    		this.easing = easing || jQuery.easing._default;
    		this.options = options;
    		this.start = this.now = this.cur();
    		this.end = end;
    		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    	},
    	cur: function() {
    		var hooks = Tween.propHooks[ this.prop ];

    		return hooks && hooks.get ?
    			hooks.get( this ) :
    			Tween.propHooks._default.get( this );
    	},
    	run: function( percent ) {
    		var eased,
    			hooks = Tween.propHooks[ this.prop ];

    		if ( this.options.duration ) {
    			this.pos = eased = jQuery.easing[ this.easing ](
    				percent, this.options.duration * percent, 0, 1, this.options.duration
    			);
    		} else {
    			this.pos = eased = percent;
    		}
    		this.now = ( this.end - this.start ) * eased + this.start;

    		if ( this.options.step ) {
    			this.options.step.call( this.elem, this.now, this );
    		}

    		if ( hooks && hooks.set ) {
    			hooks.set( this );
    		} else {
    			Tween.propHooks._default.set( this );
    		}
    		return this;
    	}
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
    	_default: {
    		get: function( tween ) {
    			var result;

    			// Use a property on the element directly when it is not a DOM element,
    			// or when there is no matching style property that exists.
    			if ( tween.elem.nodeType !== 1 ||
    				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
    				return tween.elem[ tween.prop ];
    			}

    			// Passing an empty string as a 3rd parameter to .css will automatically
    			// attempt a parseFloat and fallback to a string if the parse fails.
    			// Simple values such as "10px" are parsed to Float;
    			// complex values such as "rotate(1rad)" are returned as-is.
    			result = jQuery.css( tween.elem, tween.prop, "" );

    			// Empty strings, null, undefined and "auto" are converted to 0.
    			return !result || result === "auto" ? 0 : result;
    		},
    		set: function( tween ) {

    			// Use step hook for back compat.
    			// Use cssHook if its there.
    			// Use .style if available and use plain properties where available.
    			if ( jQuery.fx.step[ tween.prop ] ) {
    				jQuery.fx.step[ tween.prop ]( tween );
    			} else if ( tween.elem.nodeType === 1 && (
    				jQuery.cssHooks[ tween.prop ] ||
    					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
    				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
    			} else {
    				tween.elem[ tween.prop ] = tween.now;
    			}
    		}
    	}
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    	set: function( tween ) {
    		if ( tween.elem.nodeType && tween.elem.parentNode ) {
    			tween.elem[ tween.prop ] = tween.now;
    		}
    	}
    };

    jQuery.easing = {
    	linear: function( p ) {
    		return p;
    	},
    	swing: function( p ) {
    		return 0.5 - Math.cos( p * Math.PI ) / 2;
    	},
    	_default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};




    var
    	fxNow, inProgress,
    	rfxtypes = /^(?:toggle|show|hide)$/,
    	rrun = /queueHooks$/;

    function schedule() {
    	if ( inProgress ) {
    		if ( document.hidden === false && window.requestAnimationFrame ) {
    			window.requestAnimationFrame( schedule );
    		} else {
    			window.setTimeout( schedule, jQuery.fx.interval );
    		}

    		jQuery.fx.tick();
    	}
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
    	window.setTimeout( function() {
    		fxNow = undefined;
    	} );
    	return ( fxNow = Date.now() );
    }

    // Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
    	var which,
    		i = 0,
    		attrs = { height: type };

    	// If we include width, step value is 1 to do all cssExpand values,
    	// otherwise step value is 2 to skip over Left and Right
    	includeWidth = includeWidth ? 1 : 0;
    	for ( ; i < 4; i += 2 - includeWidth ) {
    		which = cssExpand[ i ];
    		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    	}

    	if ( includeWidth ) {
    		attrs.opacity = attrs.width = type;
    	}

    	return attrs;
    }

    function createTween( value, prop, animation ) {
    	var tween,
    		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
    		index = 0,
    		length = collection.length;
    	for ( ; index < length; index++ ) {
    		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

    			// We're done with this property
    			return tween;
    		}
    	}
    }

    function defaultPrefilter( elem, props, opts ) {
    	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
    		isBox = "width" in props || "height" in props,
    		anim = this,
    		orig = {},
    		style = elem.style,
    		hidden = elem.nodeType && isHiddenWithinTree( elem ),
    		dataShow = dataPriv.get( elem, "fxshow" );

    	// Queue-skipping animations hijack the fx hooks
    	if ( !opts.queue ) {
    		hooks = jQuery._queueHooks( elem, "fx" );
    		if ( hooks.unqueued == null ) {
    			hooks.unqueued = 0;
    			oldfire = hooks.empty.fire;
    			hooks.empty.fire = function() {
    				if ( !hooks.unqueued ) {
    					oldfire();
    				}
    			};
    		}
    		hooks.unqueued++;

    		anim.always( function() {

    			// Ensure the complete handler is called before this completes
    			anim.always( function() {
    				hooks.unqueued--;
    				if ( !jQuery.queue( elem, "fx" ).length ) {
    					hooks.empty.fire();
    				}
    			} );
    		} );
    	}

    	// Detect show/hide animations
    	for ( prop in props ) {
    		value = props[ prop ];
    		if ( rfxtypes.test( value ) ) {
    			delete props[ prop ];
    			toggle = toggle || value === "toggle";
    			if ( value === ( hidden ? "hide" : "show" ) ) {

    				// Pretend to be hidden if this is a "show" and
    				// there is still data from a stopped show/hide
    				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
    					hidden = true;

    				// Ignore all other no-op show/hide data
    				} else {
    					continue;
    				}
    			}
    			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
    		}
    	}

    	// Bail out if this is a no-op like .hide().hide()
    	propTween = !jQuery.isEmptyObject( props );
    	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
    		return;
    	}

    	// Restrict "overflow" and "display" styles during box animations
    	if ( isBox && elem.nodeType === 1 ) {

    		// Support: IE <=9 - 11, Edge 12 - 15
    		// Record all 3 overflow attributes because IE does not infer the shorthand
    		// from identically-valued overflowX and overflowY and Edge just mirrors
    		// the overflowX value there.
    		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    		// Identify a display type, preferring old show/hide data over the CSS cascade
    		restoreDisplay = dataShow && dataShow.display;
    		if ( restoreDisplay == null ) {
    			restoreDisplay = dataPriv.get( elem, "display" );
    		}
    		display = jQuery.css( elem, "display" );
    		if ( display === "none" ) {
    			if ( restoreDisplay ) {
    				display = restoreDisplay;
    			} else {

    				// Get nonempty value(s) by temporarily forcing visibility
    				showHide( [ elem ], true );
    				restoreDisplay = elem.style.display || restoreDisplay;
    				display = jQuery.css( elem, "display" );
    				showHide( [ elem ] );
    			}
    		}

    		// Animate inline elements as inline-block
    		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
    			if ( jQuery.css( elem, "float" ) === "none" ) {

    				// Restore the original display value at the end of pure show/hide animations
    				if ( !propTween ) {
    					anim.done( function() {
    						style.display = restoreDisplay;
    					} );
    					if ( restoreDisplay == null ) {
    						display = style.display;
    						restoreDisplay = display === "none" ? "" : display;
    					}
    				}
    				style.display = "inline-block";
    			}
    		}
    	}

    	if ( opts.overflow ) {
    		style.overflow = "hidden";
    		anim.always( function() {
    			style.overflow = opts.overflow[ 0 ];
    			style.overflowX = opts.overflow[ 1 ];
    			style.overflowY = opts.overflow[ 2 ];
    		} );
    	}

    	// Implement show/hide animations
    	propTween = false;
    	for ( prop in orig ) {

    		// General show/hide setup for this element animation
    		if ( !propTween ) {
    			if ( dataShow ) {
    				if ( "hidden" in dataShow ) {
    					hidden = dataShow.hidden;
    				}
    			} else {
    				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
    			}

    			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
    			if ( toggle ) {
    				dataShow.hidden = !hidden;
    			}

    			// Show elements before animating them
    			if ( hidden ) {
    				showHide( [ elem ], true );
    			}

    			/* eslint-disable no-loop-func */

    			anim.done( function() {

    				/* eslint-enable no-loop-func */

    				// The final step of a "hide" animation is actually hiding the element
    				if ( !hidden ) {
    					showHide( [ elem ] );
    				}
    				dataPriv.remove( elem, "fxshow" );
    				for ( prop in orig ) {
    					jQuery.style( elem, prop, orig[ prop ] );
    				}
    			} );
    		}

    		// Per-property setup
    		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
    		if ( !( prop in dataShow ) ) {
    			dataShow[ prop ] = propTween.start;
    			if ( hidden ) {
    				propTween.end = propTween.start;
    				propTween.start = 0;
    			}
    		}
    	}
    }

    function propFilter( props, specialEasing ) {
    	var index, name, easing, value, hooks;

    	// camelCase, specialEasing and expand cssHook pass
    	for ( index in props ) {
    		name = camelCase( index );
    		easing = specialEasing[ name ];
    		value = props[ index ];
    		if ( Array.isArray( value ) ) {
    			easing = value[ 1 ];
    			value = props[ index ] = value[ 0 ];
    		}

    		if ( index !== name ) {
    			props[ name ] = value;
    			delete props[ index ];
    		}

    		hooks = jQuery.cssHooks[ name ];
    		if ( hooks && "expand" in hooks ) {
    			value = hooks.expand( value );
    			delete props[ name ];

    			// Not quite $.extend, this won't overwrite existing keys.
    			// Reusing 'index' because we have the correct "name"
    			for ( index in value ) {
    				if ( !( index in props ) ) {
    					props[ index ] = value[ index ];
    					specialEasing[ index ] = easing;
    				}
    			}
    		} else {
    			specialEasing[ name ] = easing;
    		}
    	}
    }

    function Animation( elem, properties, options ) {
    	var result,
    		stopped,
    		index = 0,
    		length = Animation.prefilters.length,
    		deferred = jQuery.Deferred().always( function() {

    			// Don't match elem in the :animated selector
    			delete tick.elem;
    		} ),
    		tick = function() {
    			if ( stopped ) {
    				return false;
    			}
    			var currentTime = fxNow || createFxNow(),
    				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

    				// Support: Android 2.3 only
    				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
    				temp = remaining / animation.duration || 0,
    				percent = 1 - temp,
    				index = 0,
    				length = animation.tweens.length;

    			for ( ; index < length; index++ ) {
    				animation.tweens[ index ].run( percent );
    			}

    			deferred.notifyWith( elem, [ animation, percent, remaining ] );

    			// If there's more to do, yield
    			if ( percent < 1 && length ) {
    				return remaining;
    			}

    			// If this was an empty animation, synthesize a final progress notification
    			if ( !length ) {
    				deferred.notifyWith( elem, [ animation, 1, 0 ] );
    			}

    			// Resolve the animation and report its conclusion
    			deferred.resolveWith( elem, [ animation ] );
    			return false;
    		},
    		animation = deferred.promise( {
    			elem: elem,
    			props: jQuery.extend( {}, properties ),
    			opts: jQuery.extend( true, {
    				specialEasing: {},
    				easing: jQuery.easing._default
    			}, options ),
    			originalProperties: properties,
    			originalOptions: options,
    			startTime: fxNow || createFxNow(),
    			duration: options.duration,
    			tweens: [],
    			createTween: function( prop, end ) {
    				var tween = jQuery.Tween( elem, animation.opts, prop, end,
    					animation.opts.specialEasing[ prop ] || animation.opts.easing );
    				animation.tweens.push( tween );
    				return tween;
    			},
    			stop: function( gotoEnd ) {
    				var index = 0,

    					// If we are going to the end, we want to run all the tweens
    					// otherwise we skip this part
    					length = gotoEnd ? animation.tweens.length : 0;
    				if ( stopped ) {
    					return this;
    				}
    				stopped = true;
    				for ( ; index < length; index++ ) {
    					animation.tweens[ index ].run( 1 );
    				}

    				// Resolve when we played the last frame; otherwise, reject
    				if ( gotoEnd ) {
    					deferred.notifyWith( elem, [ animation, 1, 0 ] );
    					deferred.resolveWith( elem, [ animation, gotoEnd ] );
    				} else {
    					deferred.rejectWith( elem, [ animation, gotoEnd ] );
    				}
    				return this;
    			}
    		} ),
    		props = animation.props;

    	propFilter( props, animation.opts.specialEasing );

    	for ( ; index < length; index++ ) {
    		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
    		if ( result ) {
    			if ( isFunction( result.stop ) ) {
    				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
    					result.stop.bind( result );
    			}
    			return result;
    		}
    	}

    	jQuery.map( props, createTween, animation );

    	if ( isFunction( animation.opts.start ) ) {
    		animation.opts.start.call( elem, animation );
    	}

    	// Attach callbacks from options
    	animation
    		.progress( animation.opts.progress )
    		.done( animation.opts.done, animation.opts.complete )
    		.fail( animation.opts.fail )
    		.always( animation.opts.always );

    	jQuery.fx.timer(
    		jQuery.extend( tick, {
    			elem: elem,
    			anim: animation,
    			queue: animation.opts.queue
    		} )
    	);

    	return animation;
    }

    jQuery.Animation = jQuery.extend( Animation, {

    	tweeners: {
    		"*": [ function( prop, value ) {
    			var tween = this.createTween( prop, value );
    			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
    			return tween;
    		} ]
    	},

    	tweener: function( props, callback ) {
    		if ( isFunction( props ) ) {
    			callback = props;
    			props = [ "*" ];
    		} else {
    			props = props.match( rnothtmlwhite );
    		}

    		var prop,
    			index = 0,
    			length = props.length;

    		for ( ; index < length; index++ ) {
    			prop = props[ index ];
    			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
    			Animation.tweeners[ prop ].unshift( callback );
    		}
    	},

    	prefilters: [ defaultPrefilter ],

    	prefilter: function( callback, prepend ) {
    		if ( prepend ) {
    			Animation.prefilters.unshift( callback );
    		} else {
    			Animation.prefilters.push( callback );
    		}
    	}
    } );

    jQuery.speed = function( speed, easing, fn ) {
    	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    		complete: fn || !fn && easing ||
    			isFunction( speed ) && speed,
    		duration: speed,
    		easing: fn && easing || easing && !isFunction( easing ) && easing
    	};

    	// Go to the end state if fx are off
    	if ( jQuery.fx.off ) {
    		opt.duration = 0;

    	} else {
    		if ( typeof opt.duration !== "number" ) {
    			if ( opt.duration in jQuery.fx.speeds ) {
    				opt.duration = jQuery.fx.speeds[ opt.duration ];

    			} else {
    				opt.duration = jQuery.fx.speeds._default;
    			}
    		}
    	}

    	// Normalize opt.queue - true/undefined/null -> "fx"
    	if ( opt.queue == null || opt.queue === true ) {
    		opt.queue = "fx";
    	}

    	// Queueing
    	opt.old = opt.complete;

    	opt.complete = function() {
    		if ( isFunction( opt.old ) ) {
    			opt.old.call( this );
    		}

    		if ( opt.queue ) {
    			jQuery.dequeue( this, opt.queue );
    		}
    	};

    	return opt;
    };

    jQuery.fn.extend( {
    	fadeTo: function( speed, to, easing, callback ) {

    		// Show any hidden elements after setting opacity to 0
    		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

    			// Animate to the value specified
    			.end().animate( { opacity: to }, speed, easing, callback );
    	},
    	animate: function( prop, speed, easing, callback ) {
    		var empty = jQuery.isEmptyObject( prop ),
    			optall = jQuery.speed( speed, easing, callback ),
    			doAnimation = function() {

    				// Operate on a copy of prop so per-property easing won't be lost
    				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

    				// Empty animations, or finishing resolves immediately
    				if ( empty || dataPriv.get( this, "finish" ) ) {
    					anim.stop( true );
    				}
    			};

    		doAnimation.finish = doAnimation;

    		return empty || optall.queue === false ?
    			this.each( doAnimation ) :
    			this.queue( optall.queue, doAnimation );
    	},
    	stop: function( type, clearQueue, gotoEnd ) {
    		var stopQueue = function( hooks ) {
    			var stop = hooks.stop;
    			delete hooks.stop;
    			stop( gotoEnd );
    		};

    		if ( typeof type !== "string" ) {
    			gotoEnd = clearQueue;
    			clearQueue = type;
    			type = undefined;
    		}
    		if ( clearQueue ) {
    			this.queue( type || "fx", [] );
    		}

    		return this.each( function() {
    			var dequeue = true,
    				index = type != null && type + "queueHooks",
    				timers = jQuery.timers,
    				data = dataPriv.get( this );

    			if ( index ) {
    				if ( data[ index ] && data[ index ].stop ) {
    					stopQueue( data[ index ] );
    				}
    			} else {
    				for ( index in data ) {
    					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
    						stopQueue( data[ index ] );
    					}
    				}
    			}

    			for ( index = timers.length; index--; ) {
    				if ( timers[ index ].elem === this &&
    					( type == null || timers[ index ].queue === type ) ) {

    					timers[ index ].anim.stop( gotoEnd );
    					dequeue = false;
    					timers.splice( index, 1 );
    				}
    			}

    			// Start the next in the queue if the last step wasn't forced.
    			// Timers currently will call their complete callbacks, which
    			// will dequeue but only if they were gotoEnd.
    			if ( dequeue || !gotoEnd ) {
    				jQuery.dequeue( this, type );
    			}
    		} );
    	},
    	finish: function( type ) {
    		if ( type !== false ) {
    			type = type || "fx";
    		}
    		return this.each( function() {
    			var index,
    				data = dataPriv.get( this ),
    				queue = data[ type + "queue" ],
    				hooks = data[ type + "queueHooks" ],
    				timers = jQuery.timers,
    				length = queue ? queue.length : 0;

    			// Enable finishing flag on private data
    			data.finish = true;

    			// Empty the queue first
    			jQuery.queue( this, type, [] );

    			if ( hooks && hooks.stop ) {
    				hooks.stop.call( this, true );
    			}

    			// Look for any active animations, and finish them
    			for ( index = timers.length; index--; ) {
    				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
    					timers[ index ].anim.stop( true );
    					timers.splice( index, 1 );
    				}
    			}

    			// Look for any animations in the old queue and finish them
    			for ( index = 0; index < length; index++ ) {
    				if ( queue[ index ] && queue[ index ].finish ) {
    					queue[ index ].finish.call( this );
    				}
    			}

    			// Turn off finishing flag
    			delete data.finish;
    		} );
    	}
    } );

    jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
    	var cssFn = jQuery.fn[ name ];
    	jQuery.fn[ name ] = function( speed, easing, callback ) {
    		return speed == null || typeof speed === "boolean" ?
    			cssFn.apply( this, arguments ) :
    			this.animate( genFx( name, true ), speed, easing, callback );
    	};
    } );

    // Generate shortcuts for custom animations
    jQuery.each( {
    	slideDown: genFx( "show" ),
    	slideUp: genFx( "hide" ),
    	slideToggle: genFx( "toggle" ),
    	fadeIn: { opacity: "show" },
    	fadeOut: { opacity: "hide" },
    	fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
    	jQuery.fn[ name ] = function( speed, easing, callback ) {
    		return this.animate( props, speed, easing, callback );
    	};
    } );

    jQuery.timers = [];
    jQuery.fx.tick = function() {
    	var timer,
    		i = 0,
    		timers = jQuery.timers;

    	fxNow = Date.now();

    	for ( ; i < timers.length; i++ ) {
    		timer = timers[ i ];

    		// Run the timer and safely remove it when done (allowing for external removal)
    		if ( !timer() && timers[ i ] === timer ) {
    			timers.splice( i--, 1 );
    		}
    	}

    	if ( !timers.length ) {
    		jQuery.fx.stop();
    	}
    	fxNow = undefined;
    };

    jQuery.fx.timer = function( timer ) {
    	jQuery.timers.push( timer );
    	jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
    	if ( inProgress ) {
    		return;
    	}

    	inProgress = true;
    	schedule();
    };

    jQuery.fx.stop = function() {
    	inProgress = null;
    };

    jQuery.fx.speeds = {
    	slow: 600,
    	fast: 200,

    	// Default speed
    	_default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    jQuery.fn.delay = function( time, type ) {
    	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    	type = type || "fx";

    	return this.queue( type, function( next, hooks ) {
    		var timeout = window.setTimeout( next, time );
    		hooks.stop = function() {
    			window.clearTimeout( timeout );
    		};
    	} );
    };


    ( function() {
    	var input = document.createElement( "input" ),
    		select = document.createElement( "select" ),
    		opt = select.appendChild( document.createElement( "option" ) );

    	input.type = "checkbox";

    	// Support: Android <=4.3 only
    	// Default value for a checkbox should be "on"
    	support.checkOn = input.value !== "";

    	// Support: IE <=11 only
    	// Must access selectedIndex to make default options select
    	support.optSelected = opt.selected;

    	// Support: IE <=11 only
    	// An input loses its value after becoming a radio
    	input = document.createElement( "input" );
    	input.value = "t";
    	input.type = "radio";
    	support.radioValue = input.value === "t";
    } )();


    var boolHook,
    	attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend( {
    	attr: function( name, value ) {
    		return access( this, jQuery.attr, name, value, arguments.length > 1 );
    	},

    	removeAttr: function( name ) {
    		return this.each( function() {
    			jQuery.removeAttr( this, name );
    		} );
    	}
    } );

    jQuery.extend( {
    	attr: function( elem, name, value ) {
    		var ret, hooks,
    			nType = elem.nodeType;

    		// Don't get/set attributes on text, comment and attribute nodes
    		if ( nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}

    		// Fallback to prop when attributes are not supported
    		if ( typeof elem.getAttribute === "undefined" ) {
    			return jQuery.prop( elem, name, value );
    		}

    		// Attribute hooks are determined by the lowercase version
    		// Grab necessary hook if one is defined
    		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
    			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
    				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
    		}

    		if ( value !== undefined ) {
    			if ( value === null ) {
    				jQuery.removeAttr( elem, name );
    				return;
    			}

    			if ( hooks && "set" in hooks &&
    				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
    				return ret;
    			}

    			elem.setAttribute( name, value + "" );
    			return value;
    		}

    		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
    			return ret;
    		}

    		ret = jQuery.find.attr( elem, name );

    		// Non-existent attributes return null, we normalize to undefined
    		return ret == null ? undefined : ret;
    	},

    	attrHooks: {
    		type: {
    			set: function( elem, value ) {
    				if ( !support.radioValue && value === "radio" &&
    					nodeName( elem, "input" ) ) {
    					var val = elem.value;
    					elem.setAttribute( "type", value );
    					if ( val ) {
    						elem.value = val;
    					}
    					return value;
    				}
    			}
    		}
    	},

    	removeAttr: function( elem, value ) {
    		var name,
    			i = 0,

    			// Attribute names can contain non-HTML whitespace characters
    			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
    			attrNames = value && value.match( rnothtmlwhite );

    		if ( attrNames && elem.nodeType === 1 ) {
    			while ( ( name = attrNames[ i++ ] ) ) {
    				elem.removeAttribute( name );
    			}
    		}
    	}
    } );

    // Hooks for boolean attributes
    boolHook = {
    	set: function( elem, value, name ) {
    		if ( value === false ) {

    			// Remove boolean attributes when set to false
    			jQuery.removeAttr( elem, name );
    		} else {
    			elem.setAttribute( name, name );
    		}
    		return name;
    	}
    };

    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
    	var getter = attrHandle[ name ] || jQuery.find.attr;

    	attrHandle[ name ] = function( elem, name, isXML ) {
    		var ret, handle,
    			lowercaseName = name.toLowerCase();

    		if ( !isXML ) {

    			// Avoid an infinite loop by temporarily removing this function from the getter
    			handle = attrHandle[ lowercaseName ];
    			attrHandle[ lowercaseName ] = ret;
    			ret = getter( elem, name, isXML ) != null ?
    				lowercaseName :
    				null;
    			attrHandle[ lowercaseName ] = handle;
    		}
    		return ret;
    	};
    } );




    var rfocusable = /^(?:input|select|textarea|button)$/i,
    	rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend( {
    	prop: function( name, value ) {
    		return access( this, jQuery.prop, name, value, arguments.length > 1 );
    	},

    	removeProp: function( name ) {
    		return this.each( function() {
    			delete this[ jQuery.propFix[ name ] || name ];
    		} );
    	}
    } );

    jQuery.extend( {
    	prop: function( elem, name, value ) {
    		var ret, hooks,
    			nType = elem.nodeType;

    		// Don't get/set properties on text, comment and attribute nodes
    		if ( nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}

    		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

    			// Fix name and attach hooks
    			name = jQuery.propFix[ name ] || name;
    			hooks = jQuery.propHooks[ name ];
    		}

    		if ( value !== undefined ) {
    			if ( hooks && "set" in hooks &&
    				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
    				return ret;
    			}

    			return ( elem[ name ] = value );
    		}

    		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
    			return ret;
    		}

    		return elem[ name ];
    	},

    	propHooks: {
    		tabIndex: {
    			get: function( elem ) {

    				// Support: IE <=9 - 11 only
    				// elem.tabIndex doesn't always return the
    				// correct value when it hasn't been explicitly set
    				// Use proper attribute retrieval (trac-12072)
    				var tabindex = jQuery.find.attr( elem, "tabindex" );

    				if ( tabindex ) {
    					return parseInt( tabindex, 10 );
    				}

    				if (
    					rfocusable.test( elem.nodeName ) ||
    					rclickable.test( elem.nodeName ) &&
    					elem.href
    				) {
    					return 0;
    				}

    				return -1;
    			}
    		}
    	},

    	propFix: {
    		"for": "htmlFor",
    		"class": "className"
    	}
    } );

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if ( !support.optSelected ) {
    	jQuery.propHooks.selected = {
    		get: function( elem ) {

    			/* eslint no-unused-expressions: "off" */

    			var parent = elem.parentNode;
    			if ( parent && parent.parentNode ) {
    				parent.parentNode.selectedIndex;
    			}
    			return null;
    		},
    		set: function( elem ) {

    			/* eslint no-unused-expressions: "off" */

    			var parent = elem.parentNode;
    			if ( parent ) {
    				parent.selectedIndex;

    				if ( parent.parentNode ) {
    					parent.parentNode.selectedIndex;
    				}
    			}
    		}
    	};
    }

    jQuery.each( [
    	"tabIndex",
    	"readOnly",
    	"maxLength",
    	"cellSpacing",
    	"cellPadding",
    	"rowSpan",
    	"colSpan",
    	"useMap",
    	"frameBorder",
    	"contentEditable"
    ], function() {
    	jQuery.propFix[ this.toLowerCase() ] = this;
    } );




    	// Strip and collapse whitespace according to HTML spec
    	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    	function stripAndCollapse( value ) {
    		var tokens = value.match( rnothtmlwhite ) || [];
    		return tokens.join( " " );
    	}


    function getClass( elem ) {
    	return elem.getAttribute && elem.getAttribute( "class" ) || "";
    }

    function classesToArray( value ) {
    	if ( Array.isArray( value ) ) {
    		return value;
    	}
    	if ( typeof value === "string" ) {
    		return value.match( rnothtmlwhite ) || [];
    	}
    	return [];
    }

    jQuery.fn.extend( {
    	addClass: function( value ) {
    		var classNames, cur, curValue, className, i, finalValue;

    		if ( isFunction( value ) ) {
    			return this.each( function( j ) {
    				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
    			} );
    		}

    		classNames = classesToArray( value );

    		if ( classNames.length ) {
    			return this.each( function() {
    				curValue = getClass( this );
    				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

    				if ( cur ) {
    					for ( i = 0; i < classNames.length; i++ ) {
    						className = classNames[ i ];
    						if ( cur.indexOf( " " + className + " " ) < 0 ) {
    							cur += className + " ";
    						}
    					}

    					// Only assign if different to avoid unneeded rendering.
    					finalValue = stripAndCollapse( cur );
    					if ( curValue !== finalValue ) {
    						this.setAttribute( "class", finalValue );
    					}
    				}
    			} );
    		}

    		return this;
    	},

    	removeClass: function( value ) {
    		var classNames, cur, curValue, className, i, finalValue;

    		if ( isFunction( value ) ) {
    			return this.each( function( j ) {
    				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
    			} );
    		}

    		if ( !arguments.length ) {
    			return this.attr( "class", "" );
    		}

    		classNames = classesToArray( value );

    		if ( classNames.length ) {
    			return this.each( function() {
    				curValue = getClass( this );

    				// This expression is here for better compressibility (see addClass)
    				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

    				if ( cur ) {
    					for ( i = 0; i < classNames.length; i++ ) {
    						className = classNames[ i ];

    						// Remove *all* instances
    						while ( cur.indexOf( " " + className + " " ) > -1 ) {
    							cur = cur.replace( " " + className + " ", " " );
    						}
    					}

    					// Only assign if different to avoid unneeded rendering.
    					finalValue = stripAndCollapse( cur );
    					if ( curValue !== finalValue ) {
    						this.setAttribute( "class", finalValue );
    					}
    				}
    			} );
    		}

    		return this;
    	},

    	toggleClass: function( value, stateVal ) {
    		var classNames, className, i, self,
    			type = typeof value,
    			isValidValue = type === "string" || Array.isArray( value );

    		if ( isFunction( value ) ) {
    			return this.each( function( i ) {
    				jQuery( this ).toggleClass(
    					value.call( this, i, getClass( this ), stateVal ),
    					stateVal
    				);
    			} );
    		}

    		if ( typeof stateVal === "boolean" && isValidValue ) {
    			return stateVal ? this.addClass( value ) : this.removeClass( value );
    		}

    		classNames = classesToArray( value );

    		return this.each( function() {
    			if ( isValidValue ) {

    				// Toggle individual class names
    				self = jQuery( this );

    				for ( i = 0; i < classNames.length; i++ ) {
    					className = classNames[ i ];

    					// Check each className given, space separated list
    					if ( self.hasClass( className ) ) {
    						self.removeClass( className );
    					} else {
    						self.addClass( className );
    					}
    				}

    			// Toggle whole class name
    			} else if ( value === undefined || type === "boolean" ) {
    				className = getClass( this );
    				if ( className ) {

    					// Store className if set
    					dataPriv.set( this, "__className__", className );
    				}

    				// If the element has a class name or if we're passed `false`,
    				// then remove the whole classname (if there was one, the above saved it).
    				// Otherwise bring back whatever was previously saved (if anything),
    				// falling back to the empty string if nothing was stored.
    				if ( this.setAttribute ) {
    					this.setAttribute( "class",
    						className || value === false ?
    							"" :
    							dataPriv.get( this, "__className__" ) || ""
    					);
    				}
    			}
    		} );
    	},

    	hasClass: function( selector ) {
    		var className, elem,
    			i = 0;

    		className = " " + selector + " ";
    		while ( ( elem = this[ i++ ] ) ) {
    			if ( elem.nodeType === 1 &&
    				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
    				return true;
    			}
    		}

    		return false;
    	}
    } );




    var rreturn = /\r/g;

    jQuery.fn.extend( {
    	val: function( value ) {
    		var hooks, ret, valueIsFunction,
    			elem = this[ 0 ];

    		if ( !arguments.length ) {
    			if ( elem ) {
    				hooks = jQuery.valHooks[ elem.type ] ||
    					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

    				if ( hooks &&
    					"get" in hooks &&
    					( ret = hooks.get( elem, "value" ) ) !== undefined
    				) {
    					return ret;
    				}

    				ret = elem.value;

    				// Handle most common string cases
    				if ( typeof ret === "string" ) {
    					return ret.replace( rreturn, "" );
    				}

    				// Handle cases where value is null/undef or number
    				return ret == null ? "" : ret;
    			}

    			return;
    		}

    		valueIsFunction = isFunction( value );

    		return this.each( function( i ) {
    			var val;

    			if ( this.nodeType !== 1 ) {
    				return;
    			}

    			if ( valueIsFunction ) {
    				val = value.call( this, i, jQuery( this ).val() );
    			} else {
    				val = value;
    			}

    			// Treat null/undefined as ""; convert numbers to string
    			if ( val == null ) {
    				val = "";

    			} else if ( typeof val === "number" ) {
    				val += "";

    			} else if ( Array.isArray( val ) ) {
    				val = jQuery.map( val, function( value ) {
    					return value == null ? "" : value + "";
    				} );
    			}

    			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

    			// If set returns undefined, fall back to normal setting
    			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
    				this.value = val;
    			}
    		} );
    	}
    } );

    jQuery.extend( {
    	valHooks: {
    		option: {
    			get: function( elem ) {

    				var val = jQuery.find.attr( elem, "value" );
    				return val != null ?
    					val :

    					// Support: IE <=10 - 11 only
    					// option.text throws exceptions (trac-14686, trac-14858)
    					// Strip and collapse whitespace
    					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
    					stripAndCollapse( jQuery.text( elem ) );
    			}
    		},
    		select: {
    			get: function( elem ) {
    				var value, option, i,
    					options = elem.options,
    					index = elem.selectedIndex,
    					one = elem.type === "select-one",
    					values = one ? null : [],
    					max = one ? index + 1 : options.length;

    				if ( index < 0 ) {
    					i = max;

    				} else {
    					i = one ? index : 0;
    				}

    				// Loop through all the selected options
    				for ( ; i < max; i++ ) {
    					option = options[ i ];

    					// Support: IE <=9 only
    					// IE8-9 doesn't update selected after form reset (trac-2551)
    					if ( ( option.selected || i === index ) &&

    							// Don't return options that are disabled or in a disabled optgroup
    							!option.disabled &&
    							( !option.parentNode.disabled ||
    								!nodeName( option.parentNode, "optgroup" ) ) ) {

    						// Get the specific value for the option
    						value = jQuery( option ).val();

    						// We don't need an array for one selects
    						if ( one ) {
    							return value;
    						}

    						// Multi-Selects return an array
    						values.push( value );
    					}
    				}

    				return values;
    			},

    			set: function( elem, value ) {
    				var optionSet, option,
    					options = elem.options,
    					values = jQuery.makeArray( value ),
    					i = options.length;

    				while ( i-- ) {
    					option = options[ i ];

    					/* eslint-disable no-cond-assign */

    					if ( option.selected =
    						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
    					) {
    						optionSet = true;
    					}

    					/* eslint-enable no-cond-assign */
    				}

    				// Force browsers to behave consistently when non-matching value is set
    				if ( !optionSet ) {
    					elem.selectedIndex = -1;
    				}
    				return values;
    			}
    		}
    	}
    } );

    // Radios and checkboxes getter/setter
    jQuery.each( [ "radio", "checkbox" ], function() {
    	jQuery.valHooks[ this ] = {
    		set: function( elem, value ) {
    			if ( Array.isArray( value ) ) {
    				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
    			}
    		}
    	};
    	if ( !support.checkOn ) {
    		jQuery.valHooks[ this ].get = function( elem ) {
    			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
    		};
    	}
    } );




    // Return jQuery for attributes-only inclusion
    var location = window.location;

    var nonce = { guid: Date.now() };

    var rquery = ( /\?/ );



    // Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
    	var xml, parserErrorElem;
    	if ( !data || typeof data !== "string" ) {
    		return null;
    	}

    	// Support: IE 9 - 11 only
    	// IE throws on parseFromString with invalid input.
    	try {
    		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
    	} catch ( e ) {}

    	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
    	if ( !xml || parserErrorElem ) {
    		jQuery.error( "Invalid XML: " + (
    			parserErrorElem ?
    				jQuery.map( parserErrorElem.childNodes, function( el ) {
    					return el.textContent;
    				} ).join( "\n" ) :
    				data
    		) );
    	}
    	return xml;
    };


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    	stopPropagationCallback = function( e ) {
    		e.stopPropagation();
    	};

    jQuery.extend( jQuery.event, {

    	trigger: function( event, data, elem, onlyHandlers ) {

    		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
    			eventPath = [ elem || document ],
    			type = hasOwn.call( event, "type" ) ? event.type : event,
    			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

    		cur = lastElement = tmp = elem = elem || document;

    		// Don't do events on text and comment nodes
    		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
    			return;
    		}

    		// focus/blur morphs to focusin/out; ensure we're not firing them right now
    		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    			return;
    		}

    		if ( type.indexOf( "." ) > -1 ) {

    			// Namespaced trigger; create a regexp to match event type in handle()
    			namespaces = type.split( "." );
    			type = namespaces.shift();
    			namespaces.sort();
    		}
    		ontype = type.indexOf( ":" ) < 0 && "on" + type;

    		// Caller can pass in a jQuery.Event object, Object, or just an event type string
    		event = event[ jQuery.expando ] ?
    			event :
    			new jQuery.Event( type, typeof event === "object" && event );

    		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    		event.isTrigger = onlyHandlers ? 2 : 3;
    		event.namespace = namespaces.join( "." );
    		event.rnamespace = event.namespace ?
    			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
    			null;

    		// Clean up the event in case it is being reused
    		event.result = undefined;
    		if ( !event.target ) {
    			event.target = elem;
    		}

    		// Clone any incoming data and prepend the event, creating the handler arg list
    		data = data == null ?
    			[ event ] :
    			jQuery.makeArray( data, [ event ] );

    		// Allow special events to draw outside the lines
    		special = jQuery.event.special[ type ] || {};
    		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
    			return;
    		}

    		// Determine event propagation path in advance, per W3C events spec (trac-9951)
    		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
    		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

    			bubbleType = special.delegateType || type;
    			if ( !rfocusMorph.test( bubbleType + type ) ) {
    				cur = cur.parentNode;
    			}
    			for ( ; cur; cur = cur.parentNode ) {
    				eventPath.push( cur );
    				tmp = cur;
    			}

    			// Only add window if we got to document (e.g., not plain obj or detached DOM)
    			if ( tmp === ( elem.ownerDocument || document ) ) {
    				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
    			}
    		}

    		// Fire handlers on the event path
    		i = 0;
    		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
    			lastElement = cur;
    			event.type = i > 1 ?
    				bubbleType :
    				special.bindType || type;

    			// jQuery handler
    			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
    				dataPriv.get( cur, "handle" );
    			if ( handle ) {
    				handle.apply( cur, data );
    			}

    			// Native handler
    			handle = ontype && cur[ ontype ];
    			if ( handle && handle.apply && acceptData( cur ) ) {
    				event.result = handle.apply( cur, data );
    				if ( event.result === false ) {
    					event.preventDefault();
    				}
    			}
    		}
    		event.type = type;

    		// If nobody prevented the default action, do it now
    		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

    			if ( ( !special._default ||
    				special._default.apply( eventPath.pop(), data ) === false ) &&
    				acceptData( elem ) ) {

    				// Call a native DOM method on the target with the same name as the event.
    				// Don't do default actions on window, that's where global variables be (trac-6170)
    				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

    					// Don't re-trigger an onFOO event when we call its FOO() method
    					tmp = elem[ ontype ];

    					if ( tmp ) {
    						elem[ ontype ] = null;
    					}

    					// Prevent re-triggering of the same event, since we already bubbled it above
    					jQuery.event.triggered = type;

    					if ( event.isPropagationStopped() ) {
    						lastElement.addEventListener( type, stopPropagationCallback );
    					}

    					elem[ type ]();

    					if ( event.isPropagationStopped() ) {
    						lastElement.removeEventListener( type, stopPropagationCallback );
    					}

    					jQuery.event.triggered = undefined;

    					if ( tmp ) {
    						elem[ ontype ] = tmp;
    					}
    				}
    			}
    		}

    		return event.result;
    	},

    	// Piggyback on a donor event to simulate a different one
    	// Used only for `focus(in | out)` events
    	simulate: function( type, elem, event ) {
    		var e = jQuery.extend(
    			new jQuery.Event(),
    			event,
    			{
    				type: type,
    				isSimulated: true
    			}
    		);

    		jQuery.event.trigger( e, null, elem );
    	}

    } );

    jQuery.fn.extend( {

    	trigger: function( type, data ) {
    		return this.each( function() {
    			jQuery.event.trigger( type, data, this );
    		} );
    	},
    	triggerHandler: function( type, data ) {
    		var elem = this[ 0 ];
    		if ( elem ) {
    			return jQuery.event.trigger( type, data, elem, true );
    		}
    	}
    } );


    var
    	rbracket = /\[\]$/,
    	rCRLF = /\r?\n/g,
    	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    	rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams( prefix, obj, traditional, add ) {
    	var name;

    	if ( Array.isArray( obj ) ) {

    		// Serialize array item.
    		jQuery.each( obj, function( i, v ) {
    			if ( traditional || rbracket.test( prefix ) ) {

    				// Treat each array item as a scalar.
    				add( prefix, v );

    			} else {

    				// Item is non-scalar (array or object), encode its numeric index.
    				buildParams(
    					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
    					v,
    					traditional,
    					add
    				);
    			}
    		} );

    	} else if ( !traditional && toType( obj ) === "object" ) {

    		// Serialize object item.
    		for ( name in obj ) {
    			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    		}

    	} else {

    		// Serialize scalar item.
    		add( prefix, obj );
    	}
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function( a, traditional ) {
    	var prefix,
    		s = [],
    		add = function( key, valueOrFunction ) {

    			// If value is a function, invoke it and use its return value
    			var value = isFunction( valueOrFunction ) ?
    				valueOrFunction() :
    				valueOrFunction;

    			s[ s.length ] = encodeURIComponent( key ) + "=" +
    				encodeURIComponent( value == null ? "" : value );
    		};

    	if ( a == null ) {
    		return "";
    	}

    	// If an array was passed in, assume that it is an array of form elements.
    	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

    		// Serialize the form elements
    		jQuery.each( a, function() {
    			add( this.name, this.value );
    		} );

    	} else {

    		// If traditional, encode the "old" way (the way 1.3.2 or older
    		// did it), otherwise encode params recursively.
    		for ( prefix in a ) {
    			buildParams( prefix, a[ prefix ], traditional, add );
    		}
    	}

    	// Return the resulting serialization
    	return s.join( "&" );
    };

    jQuery.fn.extend( {
    	serialize: function() {
    		return jQuery.param( this.serializeArray() );
    	},
    	serializeArray: function() {
    		return this.map( function() {

    			// Can add propHook for "elements" to filter or add form elements
    			var elements = jQuery.prop( this, "elements" );
    			return elements ? jQuery.makeArray( elements ) : this;
    		} ).filter( function() {
    			var type = this.type;

    			// Use .is( ":disabled" ) so that fieldset[disabled] works
    			return this.name && !jQuery( this ).is( ":disabled" ) &&
    				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
    				( this.checked || !rcheckableType.test( type ) );
    		} ).map( function( _i, elem ) {
    			var val = jQuery( this ).val();

    			if ( val == null ) {
    				return null;
    			}

    			if ( Array.isArray( val ) ) {
    				return jQuery.map( val, function( val ) {
    					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    				} );
    			}

    			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    		} ).get();
    	}
    } );


    var
    	r20 = /%20/g,
    	rhash = /#.*$/,
    	rantiCache = /([?&])_=[^&]*/,
    	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

    	// trac-7653, trac-8125, trac-8152: local protocol detection
    	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    	rnoContent = /^(?:GET|HEAD)$/,
    	rprotocol = /^\/\//,

    	/* Prefilters
    	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    	 * 2) These are called:
    	 *    - BEFORE asking for a transport
    	 *    - AFTER param serialization (s.data is a string if s.processData is true)
    	 * 3) key is the dataType
    	 * 4) the catchall symbol "*" can be used
    	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    	 */
    	prefilters = {},

    	/* Transports bindings
    	 * 1) key is the dataType
    	 * 2) the catchall symbol "*" can be used
    	 * 3) selection will start with transport dataType and THEN go to "*" if needed
    	 */
    	transports = {},

    	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
    	allTypes = "*/".concat( "*" ),

    	// Anchor tag for parsing the document origin
    	originAnchor = document.createElement( "a" );

    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

    	// dataTypeExpression is optional and defaults to "*"
    	return function( dataTypeExpression, func ) {

    		if ( typeof dataTypeExpression !== "string" ) {
    			func = dataTypeExpression;
    			dataTypeExpression = "*";
    		}

    		var dataType,
    			i = 0,
    			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

    		if ( isFunction( func ) ) {

    			// For each dataType in the dataTypeExpression
    			while ( ( dataType = dataTypes[ i++ ] ) ) {

    				// Prepend if requested
    				if ( dataType[ 0 ] === "+" ) {
    					dataType = dataType.slice( 1 ) || "*";
    					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

    				// Otherwise append
    				} else {
    					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
    				}
    			}
    		}
    	};
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

    	var inspected = {},
    		seekingTransport = ( structure === transports );

    	function inspect( dataType ) {
    		var selected;
    		inspected[ dataType ] = true;
    		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
    			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
    			if ( typeof dataTypeOrTransport === "string" &&
    				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

    				options.dataTypes.unshift( dataTypeOrTransport );
    				inspect( dataTypeOrTransport );
    				return false;
    			} else if ( seekingTransport ) {
    				return !( selected = dataTypeOrTransport );
    			}
    		} );
    		return selected;
    	}

    	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes trac-9887
    function ajaxExtend( target, src ) {
    	var key, deep,
    		flatOptions = jQuery.ajaxSettings.flatOptions || {};

    	for ( key in src ) {
    		if ( src[ key ] !== undefined ) {
    			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    		}
    	}
    	if ( deep ) {
    		jQuery.extend( true, target, deep );
    	}

    	return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {

    	var ct, type, finalDataType, firstDataType,
    		contents = s.contents,
    		dataTypes = s.dataTypes;

    	// Remove auto dataType and get content-type in the process
    	while ( dataTypes[ 0 ] === "*" ) {
    		dataTypes.shift();
    		if ( ct === undefined ) {
    			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
    		}
    	}

    	// Check if we're dealing with a known content-type
    	if ( ct ) {
    		for ( type in contents ) {
    			if ( contents[ type ] && contents[ type ].test( ct ) ) {
    				dataTypes.unshift( type );
    				break;
    			}
    		}
    	}

    	// Check to see if we have a response for the expected dataType
    	if ( dataTypes[ 0 ] in responses ) {
    		finalDataType = dataTypes[ 0 ];
    	} else {

    		// Try convertible dataTypes
    		for ( type in responses ) {
    			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
    				finalDataType = type;
    				break;
    			}
    			if ( !firstDataType ) {
    				firstDataType = type;
    			}
    		}

    		// Or just use first one
    		finalDataType = finalDataType || firstDataType;
    	}

    	// If we found a dataType
    	// We add the dataType to the list if needed
    	// and return the corresponding response
    	if ( finalDataType ) {
    		if ( finalDataType !== dataTypes[ 0 ] ) {
    			dataTypes.unshift( finalDataType );
    		}
    		return responses[ finalDataType ];
    	}
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
    	var conv2, current, conv, tmp, prev,
    		converters = {},

    		// Work with a copy of dataTypes in case we need to modify it for conversion
    		dataTypes = s.dataTypes.slice();

    	// Create converters map with lowercased keys
    	if ( dataTypes[ 1 ] ) {
    		for ( conv in s.converters ) {
    			converters[ conv.toLowerCase() ] = s.converters[ conv ];
    		}
    	}

    	current = dataTypes.shift();

    	// Convert to each sequential dataType
    	while ( current ) {

    		if ( s.responseFields[ current ] ) {
    			jqXHR[ s.responseFields[ current ] ] = response;
    		}

    		// Apply the dataFilter if provided
    		if ( !prev && isSuccess && s.dataFilter ) {
    			response = s.dataFilter( response, s.dataType );
    		}

    		prev = current;
    		current = dataTypes.shift();

    		if ( current ) {

    			// There's only work to do if current dataType is non-auto
    			if ( current === "*" ) {

    				current = prev;

    			// Convert response if prev dataType is non-auto and differs from current
    			} else if ( prev !== "*" && prev !== current ) {

    				// Seek a direct converter
    				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

    				// If none found, seek a pair
    				if ( !conv ) {
    					for ( conv2 in converters ) {

    						// If conv2 outputs current
    						tmp = conv2.split( " " );
    						if ( tmp[ 1 ] === current ) {

    							// If prev can be converted to accepted input
    							conv = converters[ prev + " " + tmp[ 0 ] ] ||
    								converters[ "* " + tmp[ 0 ] ];
    							if ( conv ) {

    								// Condense equivalence converters
    								if ( conv === true ) {
    									conv = converters[ conv2 ];

    								// Otherwise, insert the intermediate dataType
    								} else if ( converters[ conv2 ] !== true ) {
    									current = tmp[ 0 ];
    									dataTypes.unshift( tmp[ 1 ] );
    								}
    								break;
    							}
    						}
    					}
    				}

    				// Apply converter (if not an equivalence)
    				if ( conv !== true ) {

    					// Unless errors are allowed to bubble, catch and return them
    					if ( conv && s.throws ) {
    						response = conv( response );
    					} else {
    						try {
    							response = conv( response );
    						} catch ( e ) {
    							return {
    								state: "parsererror",
    								error: conv ? e : "No conversion from " + prev + " to " + current
    							};
    						}
    					}
    				}
    			}
    		}
    	}

    	return { state: "success", data: response };
    }

    jQuery.extend( {

    	// Counter for holding the number of active queries
    	active: 0,

    	// Last-Modified header cache for next request
    	lastModified: {},
    	etag: {},

    	ajaxSettings: {
    		url: location.href,
    		type: "GET",
    		isLocal: rlocalProtocol.test( location.protocol ),
    		global: true,
    		processData: true,
    		async: true,
    		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

    		/*
    		timeout: 0,
    		data: null,
    		dataType: null,
    		username: null,
    		password: null,
    		cache: null,
    		throws: false,
    		traditional: false,
    		headers: {},
    		*/

    		accepts: {
    			"*": allTypes,
    			text: "text/plain",
    			html: "text/html",
    			xml: "application/xml, text/xml",
    			json: "application/json, text/javascript"
    		},

    		contents: {
    			xml: /\bxml\b/,
    			html: /\bhtml/,
    			json: /\bjson\b/
    		},

    		responseFields: {
    			xml: "responseXML",
    			text: "responseText",
    			json: "responseJSON"
    		},

    		// Data converters
    		// Keys separate source (or catchall "*") and destination types with a single space
    		converters: {

    			// Convert anything to text
    			"* text": String,

    			// Text to html (true = no transformation)
    			"text html": true,

    			// Evaluate text as a json expression
    			"text json": JSON.parse,

    			// Parse text as xml
    			"text xml": jQuery.parseXML
    		},

    		// For options that shouldn't be deep extended:
    		// you can add your own custom options here if
    		// and when you create one that shouldn't be
    		// deep extended (see ajaxExtend)
    		flatOptions: {
    			url: true,
    			context: true
    		}
    	},

    	// Creates a full fledged settings object into target
    	// with both ajaxSettings and settings fields.
    	// If target is omitted, writes into ajaxSettings.
    	ajaxSetup: function( target, settings ) {
    		return settings ?

    			// Building a settings object
    			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

    			// Extending ajaxSettings
    			ajaxExtend( jQuery.ajaxSettings, target );
    	},

    	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    	ajaxTransport: addToPrefiltersOrTransports( transports ),

    	// Main method
    	ajax: function( url, options ) {

    		// If url is an object, simulate pre-1.5 signature
    		if ( typeof url === "object" ) {
    			options = url;
    			url = undefined;
    		}

    		// Force options to be an object
    		options = options || {};

    		var transport,

    			// URL without anti-cache param
    			cacheURL,

    			// Response headers
    			responseHeadersString,
    			responseHeaders,

    			// timeout handle
    			timeoutTimer,

    			// Url cleanup var
    			urlAnchor,

    			// Request state (becomes false upon send and true upon completion)
    			completed,

    			// To know if global events are to be dispatched
    			fireGlobals,

    			// Loop variable
    			i,

    			// uncached part of the url
    			uncached,

    			// Create the final options object
    			s = jQuery.ajaxSetup( {}, options ),

    			// Callbacks context
    			callbackContext = s.context || s,

    			// Context for global events is callbackContext if it is a DOM node or jQuery collection
    			globalEventContext = s.context &&
    				( callbackContext.nodeType || callbackContext.jquery ) ?
    				jQuery( callbackContext ) :
    				jQuery.event,

    			// Deferreds
    			deferred = jQuery.Deferred(),
    			completeDeferred = jQuery.Callbacks( "once memory" ),

    			// Status-dependent callbacks
    			statusCode = s.statusCode || {},

    			// Headers (they are sent all at once)
    			requestHeaders = {},
    			requestHeadersNames = {},

    			// Default abort message
    			strAbort = "canceled",

    			// Fake xhr
    			jqXHR = {
    				readyState: 0,

    				// Builds headers hashtable if needed
    				getResponseHeader: function( key ) {
    					var match;
    					if ( completed ) {
    						if ( !responseHeaders ) {
    							responseHeaders = {};
    							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
    								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
    									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
    										.concat( match[ 2 ] );
    							}
    						}
    						match = responseHeaders[ key.toLowerCase() + " " ];
    					}
    					return match == null ? null : match.join( ", " );
    				},

    				// Raw string
    				getAllResponseHeaders: function() {
    					return completed ? responseHeadersString : null;
    				},

    				// Caches the header
    				setRequestHeader: function( name, value ) {
    					if ( completed == null ) {
    						name = requestHeadersNames[ name.toLowerCase() ] =
    							requestHeadersNames[ name.toLowerCase() ] || name;
    						requestHeaders[ name ] = value;
    					}
    					return this;
    				},

    				// Overrides response content-type header
    				overrideMimeType: function( type ) {
    					if ( completed == null ) {
    						s.mimeType = type;
    					}
    					return this;
    				},

    				// Status-dependent callbacks
    				statusCode: function( map ) {
    					var code;
    					if ( map ) {
    						if ( completed ) {

    							// Execute the appropriate callbacks
    							jqXHR.always( map[ jqXHR.status ] );
    						} else {

    							// Lazy-add the new callbacks in a way that preserves old ones
    							for ( code in map ) {
    								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
    							}
    						}
    					}
    					return this;
    				},

    				// Cancel the request
    				abort: function( statusText ) {
    					var finalText = statusText || strAbort;
    					if ( transport ) {
    						transport.abort( finalText );
    					}
    					done( 0, finalText );
    					return this;
    				}
    			};

    		// Attach deferreds
    		deferred.promise( jqXHR );

    		// Add protocol if not provided (prefilters might expect it)
    		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
    		// We also use the url parameter if available
    		s.url = ( ( url || s.url || location.href ) + "" )
    			.replace( rprotocol, location.protocol + "//" );

    		// Alias method option to type as per ticket trac-12004
    		s.type = options.method || options.type || s.method || s.type;

    		// Extract dataTypes list
    		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

    		// A cross-domain request is in order when the origin doesn't match the current origin.
    		if ( s.crossDomain == null ) {
    			urlAnchor = document.createElement( "a" );

    			// Support: IE <=8 - 11, Edge 12 - 15
    			// IE throws exception on accessing the href property if url is malformed,
    			// e.g. http://example.com:80x/
    			try {
    				urlAnchor.href = s.url;

    				// Support: IE <=8 - 11 only
    				// Anchor's host property isn't correctly set when s.url is relative
    				urlAnchor.href = urlAnchor.href;
    				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
    					urlAnchor.protocol + "//" + urlAnchor.host;
    			} catch ( e ) {

    				// If there is an error parsing the URL, assume it is crossDomain,
    				// it can be rejected by the transport if it is invalid
    				s.crossDomain = true;
    			}
    		}

    		// Convert data if not already a string
    		if ( s.data && s.processData && typeof s.data !== "string" ) {
    			s.data = jQuery.param( s.data, s.traditional );
    		}

    		// Apply prefilters
    		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    		// If request was aborted inside a prefilter, stop there
    		if ( completed ) {
    			return jqXHR;
    		}

    		// We can fire global events as of now if asked to
    		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
    		fireGlobals = jQuery.event && s.global;

    		// Watch for a new set of requests
    		if ( fireGlobals && jQuery.active++ === 0 ) {
    			jQuery.event.trigger( "ajaxStart" );
    		}

    		// Uppercase the type
    		s.type = s.type.toUpperCase();

    		// Determine if request has content
    		s.hasContent = !rnoContent.test( s.type );

    		// Save the URL in case we're toying with the If-Modified-Since
    		// and/or If-None-Match header later on
    		// Remove hash to simplify url manipulation
    		cacheURL = s.url.replace( rhash, "" );

    		// More options handling for requests with no content
    		if ( !s.hasContent ) {

    			// Remember the hash so we can put it back
    			uncached = s.url.slice( cacheURL.length );

    			// If data is available and should be processed, append data to url
    			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
    				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

    				// trac-9682: remove data so that it's not used in an eventual retry
    				delete s.data;
    			}

    			// Add or update anti-cache param if needed
    			if ( s.cache === false ) {
    				cacheURL = cacheURL.replace( rantiCache, "$1" );
    				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
    					uncached;
    			}

    			// Put hash and anti-cache on the URL that will be requested (gh-1732)
    			s.url = cacheURL + uncached;

    		// Change '%20' to '+' if this is encoded form body content (gh-2658)
    		} else if ( s.data && s.processData &&
    			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
    			s.data = s.data.replace( r20, "+" );
    		}

    		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    		if ( s.ifModified ) {
    			if ( jQuery.lastModified[ cacheURL ] ) {
    				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
    			}
    			if ( jQuery.etag[ cacheURL ] ) {
    				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
    			}
    		}

    		// Set the correct header, if data is being sent
    		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
    			jqXHR.setRequestHeader( "Content-Type", s.contentType );
    		}

    		// Set the Accepts header for the server, depending on the dataType
    		jqXHR.setRequestHeader(
    			"Accept",
    			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
    				s.accepts[ s.dataTypes[ 0 ] ] +
    					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
    				s.accepts[ "*" ]
    		);

    		// Check for headers option
    		for ( i in s.headers ) {
    			jqXHR.setRequestHeader( i, s.headers[ i ] );
    		}

    		// Allow custom headers/mimetypes and early abort
    		if ( s.beforeSend &&
    			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

    			// Abort if not done already and return
    			return jqXHR.abort();
    		}

    		// Aborting is no longer a cancellation
    		strAbort = "abort";

    		// Install callbacks on deferreds
    		completeDeferred.add( s.complete );
    		jqXHR.done( s.success );
    		jqXHR.fail( s.error );

    		// Get transport
    		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    		// If no transport, we auto-abort
    		if ( !transport ) {
    			done( -1, "No Transport" );
    		} else {
    			jqXHR.readyState = 1;

    			// Send global event
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
    			}

    			// If request was aborted inside ajaxSend, stop there
    			if ( completed ) {
    				return jqXHR;
    			}

    			// Timeout
    			if ( s.async && s.timeout > 0 ) {
    				timeoutTimer = window.setTimeout( function() {
    					jqXHR.abort( "timeout" );
    				}, s.timeout );
    			}

    			try {
    				completed = false;
    				transport.send( requestHeaders, done );
    			} catch ( e ) {

    				// Rethrow post-completion exceptions
    				if ( completed ) {
    					throw e;
    				}

    				// Propagate others as results
    				done( -1, e );
    			}
    		}

    		// Callback for when everything is done
    		function done( status, nativeStatusText, responses, headers ) {
    			var isSuccess, success, error, response, modified,
    				statusText = nativeStatusText;

    			// Ignore repeat invocations
    			if ( completed ) {
    				return;
    			}

    			completed = true;

    			// Clear timeout if it exists
    			if ( timeoutTimer ) {
    				window.clearTimeout( timeoutTimer );
    			}

    			// Dereference transport for early garbage collection
    			// (no matter how long the jqXHR object will be used)
    			transport = undefined;

    			// Cache response headers
    			responseHeadersString = headers || "";

    			// Set readyState
    			jqXHR.readyState = status > 0 ? 4 : 0;

    			// Determine if successful
    			isSuccess = status >= 200 && status < 300 || status === 304;

    			// Get response data
    			if ( responses ) {
    				response = ajaxHandleResponses( s, jqXHR, responses );
    			}

    			// Use a noop converter for missing script but not if jsonp
    			if ( !isSuccess &&
    				jQuery.inArray( "script", s.dataTypes ) > -1 &&
    				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
    				s.converters[ "text script" ] = function() {};
    			}

    			// Convert no matter what (that way responseXXX fields are always set)
    			response = ajaxConvert( s, response, jqXHR, isSuccess );

    			// If successful, handle type chaining
    			if ( isSuccess ) {

    				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    				if ( s.ifModified ) {
    					modified = jqXHR.getResponseHeader( "Last-Modified" );
    					if ( modified ) {
    						jQuery.lastModified[ cacheURL ] = modified;
    					}
    					modified = jqXHR.getResponseHeader( "etag" );
    					if ( modified ) {
    						jQuery.etag[ cacheURL ] = modified;
    					}
    				}

    				// if no content
    				if ( status === 204 || s.type === "HEAD" ) {
    					statusText = "nocontent";

    				// if not modified
    				} else if ( status === 304 ) {
    					statusText = "notmodified";

    				// If we have data, let's convert it
    				} else {
    					statusText = response.state;
    					success = response.data;
    					error = response.error;
    					isSuccess = !error;
    				}
    			} else {

    				// Extract error from statusText and normalize for non-aborts
    				error = statusText;
    				if ( status || !statusText ) {
    					statusText = "error";
    					if ( status < 0 ) {
    						status = 0;
    					}
    				}
    			}

    			// Set data for the fake xhr object
    			jqXHR.status = status;
    			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

    			// Success/Error
    			if ( isSuccess ) {
    				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
    			} else {
    				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
    			}

    			// Status-dependent callbacks
    			jqXHR.statusCode( statusCode );
    			statusCode = undefined;

    			if ( fireGlobals ) {
    				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
    					[ jqXHR, s, isSuccess ? success : error ] );
    			}

    			// Complete
    			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

    				// Handle the global AJAX counter
    				if ( !( --jQuery.active ) ) {
    					jQuery.event.trigger( "ajaxStop" );
    				}
    			}
    		}

    		return jqXHR;
    	},

    	getJSON: function( url, data, callback ) {
    		return jQuery.get( url, data, callback, "json" );
    	},

    	getScript: function( url, callback ) {
    		return jQuery.get( url, undefined, callback, "script" );
    	}
    } );

    jQuery.each( [ "get", "post" ], function( _i, method ) {
    	jQuery[ method ] = function( url, data, callback, type ) {

    		// Shift arguments if data argument was omitted
    		if ( isFunction( data ) ) {
    			type = type || callback;
    			callback = data;
    			data = undefined;
    		}

    		// The url can be an options object (which then must have .url)
    		return jQuery.ajax( jQuery.extend( {
    			url: url,
    			type: method,
    			dataType: type,
    			data: data,
    			success: callback
    		}, jQuery.isPlainObject( url ) && url ) );
    	};
    } );

    jQuery.ajaxPrefilter( function( s ) {
    	var i;
    	for ( i in s.headers ) {
    		if ( i.toLowerCase() === "content-type" ) {
    			s.contentType = s.headers[ i ] || "";
    		}
    	}
    } );


    jQuery._evalUrl = function( url, options, doc ) {
    	return jQuery.ajax( {
    		url: url,

    		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
    		type: "GET",
    		dataType: "script",
    		cache: true,
    		async: false,
    		global: false,

    		// Only evaluate the response if it is successful (gh-4126)
    		// dataFilter is not invoked for failure responses, so using it instead
    		// of the default converter is kludgy but it works.
    		converters: {
    			"text script": function() {}
    		},
    		dataFilter: function( response ) {
    			jQuery.globalEval( response, options, doc );
    		}
    	} );
    };


    jQuery.fn.extend( {
    	wrapAll: function( html ) {
    		var wrap;

    		if ( this[ 0 ] ) {
    			if ( isFunction( html ) ) {
    				html = html.call( this[ 0 ] );
    			}

    			// The elements to wrap the target around
    			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

    			if ( this[ 0 ].parentNode ) {
    				wrap.insertBefore( this[ 0 ] );
    			}

    			wrap.map( function() {
    				var elem = this;

    				while ( elem.firstElementChild ) {
    					elem = elem.firstElementChild;
    				}

    				return elem;
    			} ).append( this );
    		}

    		return this;
    	},

    	wrapInner: function( html ) {
    		if ( isFunction( html ) ) {
    			return this.each( function( i ) {
    				jQuery( this ).wrapInner( html.call( this, i ) );
    			} );
    		}

    		return this.each( function() {
    			var self = jQuery( this ),
    				contents = self.contents();

    			if ( contents.length ) {
    				contents.wrapAll( html );

    			} else {
    				self.append( html );
    			}
    		} );
    	},

    	wrap: function( html ) {
    		var htmlIsFunction = isFunction( html );

    		return this.each( function( i ) {
    			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
    		} );
    	},

    	unwrap: function( selector ) {
    		this.parent( selector ).not( "body" ).each( function() {
    			jQuery( this ).replaceWith( this.childNodes );
    		} );
    		return this;
    	}
    } );


    jQuery.expr.pseudos.hidden = function( elem ) {
    	return !jQuery.expr.pseudos.visible( elem );
    };
    jQuery.expr.pseudos.visible = function( elem ) {
    	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
    };




    jQuery.ajaxSettings.xhr = function() {
    	try {
    		return new window.XMLHttpRequest();
    	} catch ( e ) {}
    };

    var xhrSuccessStatus = {

    		// File protocol always yields status code 0, assume 200
    		0: 200,

    		// Support: IE <=9 only
    		// trac-1450: sometimes IE returns 1223 when it should be 204
    		1223: 204
    	},
    	xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport( function( options ) {
    	var callback, errorCallback;

    	// Cross domain only allowed if supported through XMLHttpRequest
    	if ( support.cors || xhrSupported && !options.crossDomain ) {
    		return {
    			send: function( headers, complete ) {
    				var i,
    					xhr = options.xhr();

    				xhr.open(
    					options.type,
    					options.url,
    					options.async,
    					options.username,
    					options.password
    				);

    				// Apply custom fields if provided
    				if ( options.xhrFields ) {
    					for ( i in options.xhrFields ) {
    						xhr[ i ] = options.xhrFields[ i ];
    					}
    				}

    				// Override mime type if needed
    				if ( options.mimeType && xhr.overrideMimeType ) {
    					xhr.overrideMimeType( options.mimeType );
    				}

    				// X-Requested-With header
    				// For cross-domain requests, seeing as conditions for a preflight are
    				// akin to a jigsaw puzzle, we simply never set it to be sure.
    				// (it can always be set on a per-request basis or even using ajaxSetup)
    				// For same-domain requests, won't change header if already provided.
    				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
    					headers[ "X-Requested-With" ] = "XMLHttpRequest";
    				}

    				// Set headers
    				for ( i in headers ) {
    					xhr.setRequestHeader( i, headers[ i ] );
    				}

    				// Callback
    				callback = function( type ) {
    					return function() {
    						if ( callback ) {
    							callback = errorCallback = xhr.onload =
    								xhr.onerror = xhr.onabort = xhr.ontimeout =
    									xhr.onreadystatechange = null;

    							if ( type === "abort" ) {
    								xhr.abort();
    							} else if ( type === "error" ) {

    								// Support: IE <=9 only
    								// On a manual native abort, IE9 throws
    								// errors on any property access that is not readyState
    								if ( typeof xhr.status !== "number" ) {
    									complete( 0, "error" );
    								} else {
    									complete(

    										// File: protocol always yields status 0; see trac-8605, trac-14207
    										xhr.status,
    										xhr.statusText
    									);
    								}
    							} else {
    								complete(
    									xhrSuccessStatus[ xhr.status ] || xhr.status,
    									xhr.statusText,

    									// Support: IE <=9 only
    									// IE9 has no XHR2 but throws on binary (trac-11426)
    									// For XHR2 non-text, let the caller handle it (gh-2498)
    									( xhr.responseType || "text" ) !== "text"  ||
    									typeof xhr.responseText !== "string" ?
    										{ binary: xhr.response } :
    										{ text: xhr.responseText },
    									xhr.getAllResponseHeaders()
    								);
    							}
    						}
    					};
    				};

    				// Listen to events
    				xhr.onload = callback();
    				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

    				// Support: IE 9 only
    				// Use onreadystatechange to replace onabort
    				// to handle uncaught aborts
    				if ( xhr.onabort !== undefined ) {
    					xhr.onabort = errorCallback;
    				} else {
    					xhr.onreadystatechange = function() {

    						// Check readyState before timeout as it changes
    						if ( xhr.readyState === 4 ) {

    							// Allow onerror to be called first,
    							// but that will not handle a native abort
    							// Also, save errorCallback to a variable
    							// as xhr.onerror cannot be accessed
    							window.setTimeout( function() {
    								if ( callback ) {
    									errorCallback();
    								}
    							} );
    						}
    					};
    				}

    				// Create the abort callback
    				callback = callback( "abort" );

    				try {

    					// Do send the request (this may raise an exception)
    					xhr.send( options.hasContent && options.data || null );
    				} catch ( e ) {

    					// trac-14683: Only rethrow if this hasn't been notified as an error yet
    					if ( callback ) {
    						throw e;
    					}
    				}
    			},

    			abort: function() {
    				if ( callback ) {
    					callback();
    				}
    			}
    		};
    	}
    } );




    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter( function( s ) {
    	if ( s.crossDomain ) {
    		s.contents.script = false;
    	}
    } );

    // Install script dataType
    jQuery.ajaxSetup( {
    	accepts: {
    		script: "text/javascript, application/javascript, " +
    			"application/ecmascript, application/x-ecmascript"
    	},
    	contents: {
    		script: /\b(?:java|ecma)script\b/
    	},
    	converters: {
    		"text script": function( text ) {
    			jQuery.globalEval( text );
    			return text;
    		}
    	}
    } );

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
    	if ( s.cache === undefined ) {
    		s.cache = false;
    	}
    	if ( s.crossDomain ) {
    		s.type = "GET";
    	}
    } );

    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {

    	// This transport only deals with cross domain or forced-by-attrs requests
    	if ( s.crossDomain || s.scriptAttrs ) {
    		var script, callback;
    		return {
    			send: function( _, complete ) {
    				script = jQuery( "<script>" )
    					.attr( s.scriptAttrs || {} )
    					.prop( { charset: s.scriptCharset, src: s.url } )
    					.on( "load error", callback = function( evt ) {
    						script.remove();
    						callback = null;
    						if ( evt ) {
    							complete( evt.type === "error" ? 404 : 200, evt.type );
    						}
    					} );

    				// Use native DOM manipulation to avoid our domManip AJAX trickery
    				document.head.appendChild( script[ 0 ] );
    			},
    			abort: function() {
    				if ( callback ) {
    					callback();
    				}
    			}
    		};
    	}
    } );




    var oldCallbacks = [],
    	rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup( {
    	jsonp: "callback",
    	jsonpCallback: function() {
    		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
    		this[ callback ] = true;
    		return callback;
    	}
    } );

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

    	var callbackName, overwritten, responseContainer,
    		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
    			"url" :
    			typeof s.data === "string" &&
    				( s.contentType || "" )
    					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
    				rjsonp.test( s.data ) && "data"
    		);

    	// Handle iff the expected data type is "jsonp" or we have a parameter to set
    	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

    		// Get callback name, remembering preexisting value associated with it
    		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
    			s.jsonpCallback() :
    			s.jsonpCallback;

    		// Insert callback into url or form data
    		if ( jsonProp ) {
    			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    		} else if ( s.jsonp !== false ) {
    			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    		}

    		// Use data converter to retrieve json after script execution
    		s.converters[ "script json" ] = function() {
    			if ( !responseContainer ) {
    				jQuery.error( callbackName + " was not called" );
    			}
    			return responseContainer[ 0 ];
    		};

    		// Force json dataType
    		s.dataTypes[ 0 ] = "json";

    		// Install callback
    		overwritten = window[ callbackName ];
    		window[ callbackName ] = function() {
    			responseContainer = arguments;
    		};

    		// Clean-up function (fires after converters)
    		jqXHR.always( function() {

    			// If previous value didn't exist - remove it
    			if ( overwritten === undefined ) {
    				jQuery( window ).removeProp( callbackName );

    			// Otherwise restore preexisting value
    			} else {
    				window[ callbackName ] = overwritten;
    			}

    			// Save back as free
    			if ( s[ callbackName ] ) {

    				// Make sure that re-using the options doesn't screw things around
    				s.jsonpCallback = originalSettings.jsonpCallback;

    				// Save the callback name for future use
    				oldCallbacks.push( callbackName );
    			}

    			// Call if it was a function and we have a response
    			if ( responseContainer && isFunction( overwritten ) ) {
    				overwritten( responseContainer[ 0 ] );
    			}

    			responseContainer = overwritten = undefined;
    		} );

    		// Delegate to script
    		return "script";
    	}
    } );




    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = ( function() {
    	var body = document.implementation.createHTMLDocument( "" ).body;
    	body.innerHTML = "<form></form><form></form>";
    	return body.childNodes.length === 2;
    } )();


    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
    	if ( typeof data !== "string" ) {
    		return [];
    	}
    	if ( typeof context === "boolean" ) {
    		keepScripts = context;
    		context = false;
    	}

    	var base, parsed, scripts;

    	if ( !context ) {

    		// Stop scripts or inline event handlers from being executed immediately
    		// by using document.implementation
    		if ( support.createHTMLDocument ) {
    			context = document.implementation.createHTMLDocument( "" );

    			// Set the base href for the created document
    			// so any parsed elements with URLs
    			// are based on the document's URL (gh-2965)
    			base = context.createElement( "base" );
    			base.href = document.location.href;
    			context.head.appendChild( base );
    		} else {
    			context = document;
    		}
    	}

    	parsed = rsingleTag.exec( data );
    	scripts = !keepScripts && [];

    	// Single tag
    	if ( parsed ) {
    		return [ context.createElement( parsed[ 1 ] ) ];
    	}

    	parsed = buildFragment( [ data ], context, scripts );

    	if ( scripts && scripts.length ) {
    		jQuery( scripts ).remove();
    	}

    	return jQuery.merge( [], parsed.childNodes );
    };


    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
    	var selector, type, response,
    		self = this,
    		off = url.indexOf( " " );

    	if ( off > -1 ) {
    		selector = stripAndCollapse( url.slice( off ) );
    		url = url.slice( 0, off );
    	}

    	// If it's a function
    	if ( isFunction( params ) ) {

    		// We assume that it's the callback
    		callback = params;
    		params = undefined;

    	// Otherwise, build a param string
    	} else if ( params && typeof params === "object" ) {
    		type = "POST";
    	}

    	// If we have elements to modify, make the request
    	if ( self.length > 0 ) {
    		jQuery.ajax( {
    			url: url,

    			// If "type" variable is undefined, then "GET" method will be used.
    			// Make value of this field explicit since
    			// user can override it through ajaxSetup method
    			type: type || "GET",
    			dataType: "html",
    			data: params
    		} ).done( function( responseText ) {

    			// Save response for use in complete callback
    			response = arguments;

    			self.html( selector ?

    				// If a selector was specified, locate the right elements in a dummy div
    				// Exclude scripts to avoid IE 'Permission Denied' errors
    				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

    				// Otherwise use the full result
    				responseText );

    		// If the request succeeds, this function gets "data", "status", "jqXHR"
    		// but they are ignored because response was set above.
    		// If it fails, this function gets "jqXHR", "status", "error"
    		} ).always( callback && function( jqXHR, status ) {
    			self.each( function() {
    				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
    			} );
    		} );
    	}

    	return this;
    };




    jQuery.expr.pseudos.animated = function( elem ) {
    	return jQuery.grep( jQuery.timers, function( fn ) {
    		return elem === fn.elem;
    	} ).length;
    };




    jQuery.offset = {
    	setOffset: function( elem, options, i ) {
    		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
    			position = jQuery.css( elem, "position" ),
    			curElem = jQuery( elem ),
    			props = {};

    		// Set position first, in-case top/left are set even on static elem
    		if ( position === "static" ) {
    			elem.style.position = "relative";
    		}

    		curOffset = curElem.offset();
    		curCSSTop = jQuery.css( elem, "top" );
    		curCSSLeft = jQuery.css( elem, "left" );
    		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
    			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

    		// Need to be able to calculate position if either
    		// top or left is auto and position is either absolute or fixed
    		if ( calculatePosition ) {
    			curPosition = curElem.position();
    			curTop = curPosition.top;
    			curLeft = curPosition.left;

    		} else {
    			curTop = parseFloat( curCSSTop ) || 0;
    			curLeft = parseFloat( curCSSLeft ) || 0;
    		}

    		if ( isFunction( options ) ) {

    			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
    			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
    		}

    		if ( options.top != null ) {
    			props.top = ( options.top - curOffset.top ) + curTop;
    		}
    		if ( options.left != null ) {
    			props.left = ( options.left - curOffset.left ) + curLeft;
    		}

    		if ( "using" in options ) {
    			options.using.call( elem, props );

    		} else {
    			curElem.css( props );
    		}
    	}
    };

    jQuery.fn.extend( {

    	// offset() relates an element's border box to the document origin
    	offset: function( options ) {

    		// Preserve chaining for setter
    		if ( arguments.length ) {
    			return options === undefined ?
    				this :
    				this.each( function( i ) {
    					jQuery.offset.setOffset( this, options, i );
    				} );
    		}

    		var rect, win,
    			elem = this[ 0 ];

    		if ( !elem ) {
    			return;
    		}

    		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
    		// Support: IE <=11 only
    		// Running getBoundingClientRect on a
    		// disconnected node in IE throws an error
    		if ( !elem.getClientRects().length ) {
    			return { top: 0, left: 0 };
    		}

    		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
    		rect = elem.getBoundingClientRect();
    		win = elem.ownerDocument.defaultView;
    		return {
    			top: rect.top + win.pageYOffset,
    			left: rect.left + win.pageXOffset
    		};
    	},

    	// position() relates an element's margin box to its offset parent's padding box
    	// This corresponds to the behavior of CSS absolute positioning
    	position: function() {
    		if ( !this[ 0 ] ) {
    			return;
    		}

    		var offsetParent, offset, doc,
    			elem = this[ 0 ],
    			parentOffset = { top: 0, left: 0 };

    		// position:fixed elements are offset from the viewport, which itself always has zero offset
    		if ( jQuery.css( elem, "position" ) === "fixed" ) {

    			// Assume position:fixed implies availability of getBoundingClientRect
    			offset = elem.getBoundingClientRect();

    		} else {
    			offset = this.offset();

    			// Account for the *real* offset parent, which can be the document or its root element
    			// when a statically positioned element is identified
    			doc = elem.ownerDocument;
    			offsetParent = elem.offsetParent || doc.documentElement;
    			while ( offsetParent &&
    				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
    				jQuery.css( offsetParent, "position" ) === "static" ) {

    				offsetParent = offsetParent.parentNode;
    			}
    			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

    				// Incorporate borders into its offset, since they are outside its content origin
    				parentOffset = jQuery( offsetParent ).offset();
    				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
    				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
    			}
    		}

    		// Subtract parent offsets and element margins
    		return {
    			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
    			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    		};
    	},

    	// This method will return documentElement in the following cases:
    	// 1) For the element inside the iframe without offsetParent, this method will return
    	//    documentElement of the parent window
    	// 2) For the hidden or detached element
    	// 3) For body or html element, i.e. in case of the html node - it will return itself
    	//
    	// but those exceptions were never presented as a real life use-cases
    	// and might be considered as more preferable results.
    	//
    	// This logic, however, is not guaranteed and can change at any point in the future
    	offsetParent: function() {
    		return this.map( function() {
    			var offsetParent = this.offsetParent;

    			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
    				offsetParent = offsetParent.offsetParent;
    			}

    			return offsetParent || documentElement;
    		} );
    	}
    } );

    // Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    	var top = "pageYOffset" === prop;

    	jQuery.fn[ method ] = function( val ) {
    		return access( this, function( elem, method, val ) {

    			// Coalesce documents and windows
    			var win;
    			if ( isWindow( elem ) ) {
    				win = elem;
    			} else if ( elem.nodeType === 9 ) {
    				win = elem.defaultView;
    			}

    			if ( val === undefined ) {
    				return win ? win[ prop ] : elem[ method ];
    			}

    			if ( win ) {
    				win.scrollTo(
    					!top ? val : win.pageXOffset,
    					top ? val : win.pageYOffset
    				);

    			} else {
    				elem[ method ] = val;
    			}
    		}, method, val, arguments.length );
    	};
    } );

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each( [ "top", "left" ], function( _i, prop ) {
    	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    		function( elem, computed ) {
    			if ( computed ) {
    				computed = curCSS( elem, prop );

    				// If curCSS returns percentage, fallback to offset
    				return rnumnonpx.test( computed ) ?
    					jQuery( elem ).position()[ prop ] + "px" :
    					computed;
    			}
    		}
    	);
    } );


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    	jQuery.each( {
    		padding: "inner" + name,
    		content: type,
    		"": "outer" + name
    	}, function( defaultExtra, funcName ) {

    		// Margin is only for outerHeight, outerWidth
    		jQuery.fn[ funcName ] = function( margin, value ) {
    			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
    				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

    			return access( this, function( elem, type, value ) {
    				var doc;

    				if ( isWindow( elem ) ) {

    					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
    					return funcName.indexOf( "outer" ) === 0 ?
    						elem[ "inner" + name ] :
    						elem.document.documentElement[ "client" + name ];
    				}

    				// Get document width or height
    				if ( elem.nodeType === 9 ) {
    					doc = elem.documentElement;

    					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
    					// whichever is greatest
    					return Math.max(
    						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
    						elem.body[ "offset" + name ], doc[ "offset" + name ],
    						doc[ "client" + name ]
    					);
    				}

    				return value === undefined ?

    					// Get width or height on the element, requesting but not forcing parseFloat
    					jQuery.css( elem, type, extra ) :

    					// Set width or height on the element
    					jQuery.style( elem, type, value, extra );
    			}, type, chainable ? margin : undefined, chainable );
    		};
    	} );
    } );


    jQuery.each( [
    	"ajaxStart",
    	"ajaxStop",
    	"ajaxComplete",
    	"ajaxError",
    	"ajaxSuccess",
    	"ajaxSend"
    ], function( _i, type ) {
    	jQuery.fn[ type ] = function( fn ) {
    		return this.on( type, fn );
    	};
    } );




    jQuery.fn.extend( {

    	bind: function( types, data, fn ) {
    		return this.on( types, null, data, fn );
    	},
    	unbind: function( types, fn ) {
    		return this.off( types, null, fn );
    	},

    	delegate: function( selector, types, data, fn ) {
    		return this.on( types, selector, data, fn );
    	},
    	undelegate: function( selector, types, fn ) {

    		// ( namespace ) or ( selector, types [, fn] )
    		return arguments.length === 1 ?
    			this.off( selector, "**" ) :
    			this.off( types, selector || "**", fn );
    	},

    	hover: function( fnOver, fnOut ) {
    		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    	}
    } );

    jQuery.each(
    	( "blur focus focusin focusout resize scroll click dblclick " +
    	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
    	function( _i, name ) {

    		// Handle event binding
    		jQuery.fn[ name ] = function( data, fn ) {
    			return arguments.length > 0 ?
    				this.on( name, null, data, fn ) :
    				this.trigger( name );
    		};
    	}
    );




    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    // Require that the "whitespace run" starts from a non-whitespace
    // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function( fn, context ) {
    	var tmp, args, proxy;

    	if ( typeof context === "string" ) {
    		tmp = fn[ context ];
    		context = fn;
    		fn = tmp;
    	}

    	// Quick check to determine if target is callable, in the spec
    	// this throws a TypeError, but we will just return undefined.
    	if ( !isFunction( fn ) ) {
    		return undefined;
    	}

    	// Simulated bind
    	args = slice.call( arguments, 2 );
    	proxy = function() {
    		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
    	};

    	// Set the guid of unique handler to the same of original handler, so it can be removed
    	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

    	return proxy;
    };

    jQuery.holdReady = function( hold ) {
    	if ( hold ) {
    		jQuery.readyWait++;
    	} else {
    		jQuery.ready( true );
    	}
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function( obj ) {

    	// As of jQuery 3.0, isNumeric is limited to
    	// strings and numbers (primitives or objects)
    	// that can be coerced to finite numbers (gh-2662)
    	var type = jQuery.type( obj );
    	return ( type === "number" || type === "string" ) &&

    		// parseFloat NaNs numeric-cast false positives ("")
    		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    		// subtraction forces infinities to NaN
    		!isNaN( obj - parseFloat( obj ) );
    };

    jQuery.trim = function( text ) {
    	return text == null ?
    		"" :
    		( text + "" ).replace( rtrim, "$1" );
    };




    var

    	// Map over jQuery in case of overwrite
    	_jQuery = window.jQuery,

    	// Map over the $ in case of overwrite
    	_$ = window.$;

    jQuery.noConflict = function( deep ) {
    	if ( window.$ === jQuery ) {
    		window.$ = _$;
    	}

    	if ( deep && window.jQuery === jQuery ) {
    		window.jQuery = _jQuery;
    	}

    	return jQuery;
    };

    // Expose jQuery and $ identifiers, even in AMD
    // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (trac-13566)
    if ( typeof noGlobal === "undefined" ) {
    	window.jQuery = window.$ = jQuery;
    }




    return jQuery;
    } );
    });

    /* src\components\TextField\TextField.svelte generated by Svelte v3.59.2 */
    const file$E = "src\\components\\TextField\\TextField.svelte";

    // (36:4) {#if Icon}
    function create_if_block_1$i(ctx) {
    	let i_1;
    	let i_1_class_value;

    	const block = {
    		c: function create() {
    			i_1 = element("i");
    			attr_dev(i_1, "class", i_1_class_value = "fas fa-" + /*Icon*/ ctx[6]);
    			add_location(i_1, file$E, 36, 8, 1173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i_1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Icon*/ 64 && i_1_class_value !== (i_1_class_value = "fas fa-" + /*Icon*/ ctx[6])) {
    				attr_dev(i_1, "class", i_1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(36:4) {#if Icon}",
    		ctx
    	});

    	return block;
    }

    // (91:4) {#if Select && !Icon}
    function create_if_block$u(ctx) {
    	let i_1;

    	const block = {
    		c: function create() {
    			i_1 = element("i");
    			attr_dev(i_1, "class", "fas fa-caret-down");
    			add_location(i_1, file$E, 91, 8, 3235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i_1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(91:4) {#if Select && !Icon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div2;
    	let p0;
    	let t0;
    	let t1;
    	let t2;
    	let input;
    	let input_style_value;
    	let input_readonly_value;
    	let t3;
    	let t4;
    	let div1;
    	let div0;
    	let t5;
    	let p1;
    	let t6;
    	let div2_class_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*Icon*/ ctx[6] && create_if_block_1$i(ctx);
    	let if_block1 = /*Select*/ ctx[2] && !/*Icon*/ ctx[6] && create_if_block$u(ctx);

    	let div2_levels = [
    		/*$$restProps*/ ctx[15],
    		{
    			class: div2_class_value = "textfield-component-container " + /*$$restProps*/ ctx[15]?.class
    		}
    	];

    	let div_data_2 = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div_data_2 = assign(div_data_2, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			p0 = element("p");
    			t0 = text(/*Title*/ ctx[4]);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t5 = space();
    			p1 = element("p");
    			t6 = text(/*Sub*/ ctx[0]);
    			attr_dev(p0, "class", "textfield-title");
    			add_location(p0, file$E, 33, 4, 1107);
    			attr_dev(input, "style", input_style_value = /*Select*/ ctx[2] && /*Select*/ ctx[2].length > 0 && 'user-select: none;' || '');
    			input.value = /*RealValue*/ ctx[3];
    			attr_dev(input, "placeholder", /*Placeholder*/ ctx[5]);
    			attr_dev(input, "maxlength", /*MaxLength*/ ctx[9]);
    			attr_dev(input, "type", /*Type*/ ctx[7]);
    			input.readOnly = input_readonly_value = /*ReadOnly*/ ctx[10] || /*Select*/ ctx[2] && /*Select*/ ctx[2].length > 0 && !/*SearchSelect*/ ctx[11];
    			add_location(input, file$E, 39, 4, 1221);
    			attr_dev(div0, "class", "textfield-underline-fill");
    			set_style(div0, "width", (/*Focused*/ ctx[12] ? 100 : 0) + "%");
    			add_location(div0, file$E, 96, 8, 3358);
    			attr_dev(div1, "class", "textfield-underline");
    			set_style(div1, "height", "0.1vh");
    			add_location(div1, file$E, 95, 4, 3293);
    			attr_dev(p1, "class", "textfield-sub");
    			add_location(p1, file$E, 98, 4, 3456);
    			set_attributes(div2, div_data_2);
    			add_location(div2, file$E, 32, 0, 1020);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, p0);
    			append_dev(p0, t0);
    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, input);
    			append_dev(div2, t3);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div2, t5);
    			append_dev(div2, p1);
    			append_dev(p1, t6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "focusin", /*focusin_handler*/ ctx[16], false, false, false, false),
    					listen_dev(input, "focusout", /*focusout_handler*/ ctx[17], false, false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[18], false, false, false, false),
    					listen_dev(input, "click", /*click_handler*/ ctx[19], false, false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[20], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Title*/ 16) set_data_dev(t0, /*Title*/ ctx[4]);

    			if (/*Icon*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$i(ctx);
    					if_block0.c();
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*Select*/ 4 && input_style_value !== (input_style_value = /*Select*/ ctx[2] && /*Select*/ ctx[2].length > 0 && 'user-select: none;' || '')) {
    				attr_dev(input, "style", input_style_value);
    			}

    			if (dirty & /*RealValue*/ 8 && input.value !== /*RealValue*/ ctx[3]) {
    				prop_dev(input, "value", /*RealValue*/ ctx[3]);
    			}

    			if (dirty & /*Placeholder*/ 32) {
    				attr_dev(input, "placeholder", /*Placeholder*/ ctx[5]);
    			}

    			if (dirty & /*MaxLength*/ 512) {
    				attr_dev(input, "maxlength", /*MaxLength*/ ctx[9]);
    			}

    			if (dirty & /*Type*/ 128) {
    				attr_dev(input, "type", /*Type*/ ctx[7]);
    			}

    			if (dirty & /*ReadOnly, Select, SearchSelect*/ 3076 && input_readonly_value !== (input_readonly_value = /*ReadOnly*/ ctx[10] || /*Select*/ ctx[2] && /*Select*/ ctx[2].length > 0 && !/*SearchSelect*/ ctx[11])) {
    				prop_dev(input, "readOnly", input_readonly_value);
    			}

    			if (/*Select*/ ctx[2] && !/*Icon*/ ctx[6]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$u(ctx);
    					if_block1.c();
    					if_block1.m(div2, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*Focused*/ 4096) {
    				set_style(div0, "width", (/*Focused*/ ctx[12] ? 100 : 0) + "%");
    			}

    			if (dirty & /*Sub*/ 1) set_data_dev(t6, /*Sub*/ ctx[0]);

    			set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
    				dirty & /*$$restProps*/ 32768 && /*$$restProps*/ ctx[15],
    				dirty & /*$$restProps*/ 32768 && div2_class_value !== (div2_class_value = "textfield-component-container " + /*$$restProps*/ ctx[15]?.class) && { class: div2_class_value }
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"Title","Placeholder","Icon","Sub","Type","SubSet","MaxLength","Value","Select","ReadOnly","RealValue","SearchSelect"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $DropdownData;
    	validate_store(DropdownData, 'DropdownData');
    	component_subscribe($$self, DropdownData, $$value => $$invalidate(13, $DropdownData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextField', slots, []);
    	let { Title = 'No Title' } = $$props;
    	let { Placeholder = '' } = $$props;
    	let { Icon } = $$props;
    	let { Sub = '' } = $$props;
    	let { Type = 'text' } = $$props;

    	let { SubSet = () => {
    		
    	} } = $$props;

    	let { MaxLength = 999 } = $$props;
    	let { Value = '' } = $$props;
    	let { Select = undefined } = $$props;
    	let { ReadOnly = false } = $$props;
    	let { RealValue = Value } = $$props;
    	let { SearchSelect = false } = $$props;
    	let OrgSelect = Select && Select.length > 0 ? [...Select] : [];
    	let Focused = false;

    	onMount(() => {
    		if (RealValue) {
    			const SubsetValue = SubSet(RealValue);
    			if (SubsetValue && SubsetValue != Sub) $$invalidate(0, Sub = SubsetValue);
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (Icon === undefined && !('Icon' in $$props || $$self.$$.bound[$$self.$$.props['Icon']])) {
    			console.warn("<TextField> was created without expected prop 'Icon'");
    		}
    	});

    	const focusin_handler = () => {
    		$$invalidate(12, Focused = true);
    	};

    	const focusout_handler = () => {
    		$$invalidate(12, Focused = false);
    	};

    	const input_handler = e => {
    		($$invalidate(1, Value = e.target.value), $$invalidate(3, RealValue = e.target.value));

    		if (Select && SearchSelect) {
    			let Query = Value.toLowerCase();
    			set_store_value(DropdownData, $DropdownData.Options = OrgSelect.filter(Val => Val.Value.toLowerCase().includes(Query) || Val.Text.toLowerCase().includes(Query)), $DropdownData);
    			return;
    		}

    		const SubsetValue = SubSet(Value);
    		if (SubsetValue && SubsetValue != Sub) $$invalidate(0, Sub = SubsetValue);
    	};

    	const click_handler = e => {
    		if (!Select || Select.length == 0) return;
    		const Container = jquery(e.target).closest(".textfield-component-container");
    		const ContainerWidth = jquery(Container).width();

    		for (let i = 0; i < Select.length; i++) {
    			$$invalidate(
    				2,
    				Select[i].Cb = (_Value, Text) => {
    					$$invalidate(1, Value = _Value);
    					$$invalidate(3, RealValue = Text);
    					const SubsetValue = SubSet(RealValue);
    					if (SubsetValue && SubsetValue != Sub) $$invalidate(0, Sub = SubsetValue);
    				},
    				Select
    			);
    		}

    		SetDropdown(true, Select, {
    			Top: jquery(Container).offset().top + jquery(Container).height() / 2,
    			Left: jquery(Container).offset().left,
    			Width: ContainerWidth + "px"
    		});
    	};

    	const blur_handler = e => {
    		// Must wait because otherwise the blur event is triggered before the dropdown click event.
    		setTimeout(
    			() => {
    				SetDropdown(false, [], {});
    			},
    			200
    		);
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('Title' in $$new_props) $$invalidate(4, Title = $$new_props.Title);
    		if ('Placeholder' in $$new_props) $$invalidate(5, Placeholder = $$new_props.Placeholder);
    		if ('Icon' in $$new_props) $$invalidate(6, Icon = $$new_props.Icon);
    		if ('Sub' in $$new_props) $$invalidate(0, Sub = $$new_props.Sub);
    		if ('Type' in $$new_props) $$invalidate(7, Type = $$new_props.Type);
    		if ('SubSet' in $$new_props) $$invalidate(8, SubSet = $$new_props.SubSet);
    		if ('MaxLength' in $$new_props) $$invalidate(9, MaxLength = $$new_props.MaxLength);
    		if ('Value' in $$new_props) $$invalidate(1, Value = $$new_props.Value);
    		if ('Select' in $$new_props) $$invalidate(2, Select = $$new_props.Select);
    		if ('ReadOnly' in $$new_props) $$invalidate(10, ReadOnly = $$new_props.ReadOnly);
    		if ('RealValue' in $$new_props) $$invalidate(3, RealValue = $$new_props.RealValue);
    		if ('SearchSelect' in $$new_props) $$invalidate(11, SearchSelect = $$new_props.SearchSelect);
    	};

    	$$self.$capture_state = () => ({
    		_$: jquery,
    		onMount,
    		DropdownData,
    		SetDropdown,
    		Title,
    		Placeholder,
    		Icon,
    		Sub,
    		Type,
    		SubSet,
    		MaxLength,
    		Value,
    		Select,
    		ReadOnly,
    		RealValue,
    		SearchSelect,
    		OrgSelect,
    		Focused,
    		$DropdownData
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('Title' in $$props) $$invalidate(4, Title = $$new_props.Title);
    		if ('Placeholder' in $$props) $$invalidate(5, Placeholder = $$new_props.Placeholder);
    		if ('Icon' in $$props) $$invalidate(6, Icon = $$new_props.Icon);
    		if ('Sub' in $$props) $$invalidate(0, Sub = $$new_props.Sub);
    		if ('Type' in $$props) $$invalidate(7, Type = $$new_props.Type);
    		if ('SubSet' in $$props) $$invalidate(8, SubSet = $$new_props.SubSet);
    		if ('MaxLength' in $$props) $$invalidate(9, MaxLength = $$new_props.MaxLength);
    		if ('Value' in $$props) $$invalidate(1, Value = $$new_props.Value);
    		if ('Select' in $$props) $$invalidate(2, Select = $$new_props.Select);
    		if ('ReadOnly' in $$props) $$invalidate(10, ReadOnly = $$new_props.ReadOnly);
    		if ('RealValue' in $$props) $$invalidate(3, RealValue = $$new_props.RealValue);
    		if ('SearchSelect' in $$props) $$invalidate(11, SearchSelect = $$new_props.SearchSelect);
    		if ('OrgSelect' in $$props) $$invalidate(14, OrgSelect = $$new_props.OrgSelect);
    		if ('Focused' in $$props) $$invalidate(12, Focused = $$new_props.Focused);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Sub,
    		Value,
    		Select,
    		RealValue,
    		Title,
    		Placeholder,
    		Icon,
    		Type,
    		SubSet,
    		MaxLength,
    		ReadOnly,
    		SearchSelect,
    		Focused,
    		$DropdownData,
    		OrgSelect,
    		$$restProps,
    		focusin_handler,
    		focusout_handler,
    		input_handler,
    		click_handler,
    		blur_handler
    	];
    }

    class TextField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			Title: 4,
    			Placeholder: 5,
    			Icon: 6,
    			Sub: 0,
    			Type: 7,
    			SubSet: 8,
    			MaxLength: 9,
    			Value: 1,
    			Select: 2,
    			ReadOnly: 10,
    			RealValue: 3,
    			SearchSelect: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextField",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get Title() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Title(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Placeholder() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Placeholder(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Icon() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Icon(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Sub() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Sub(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Type() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Type(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get SubSet() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set SubSet(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MaxLength() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MaxLength(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Value() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Value(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Select() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Select(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ReadOnly() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ReadOnly(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get RealValue() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set RealValue(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get SearchSelect() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set SearchSelect(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\apps\Dashboard.svelte generated by Svelte v3.59.2 */
    const file$D = "src\\apps\\Mdw\\apps\\Dashboard.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    function get_each_context_1$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (118:0) {#if HasCidPermission("Dashboard.ShowWarrents")}
    function create_if_block_1$h(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: " + (HasCidPermission("Dashboard.ShowBulletin") ? 50 : 100) + "%",
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredWarrents*/ 65537) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(118:0) {#if HasCidPermission(\\\"Dashboard.ShowWarrents\\\")}",
    		ctx
    	});

    	return block;
    }

    // (120:8) <MdwPanelHeader>
    function create_default_slot_5$c(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterWarrents*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Warrents";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$D, 120, 12, 4686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$c.name,
    		type: "slot",
    		source: "(120:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (126:12) {#each FilteredWarrents as Data, Key}
    function create_each_block_1$c(ctx) {
    	let div3;
    	let img;
    	let img_src_value;
    	let t0;
    	let div2;
    	let div0;
    	let p0;
    	let t1_value = /*Data*/ ctx[12].name + "";
    	let t1;
    	let t2;
    	let p1;
    	let t3_value = /*Data*/ ctx[12].title + "";
    	let t3;
    	let t4;
    	let div1;
    	let p2;
    	let t5;
    	let t6_value = /*Data*/ ctx[12].id + "";
    	let t6;
    	let t7;
    	let p3;
    	let t8_value = GetTimeLabel(/*Data*/ ctx[12].timestamp) + "";
    	let t8;
    	let t9;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*Data*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			img = element("img");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			t1 = text(t1_value);
    			t2 = space();
    			p1 = element("p");
    			t3 = text(t3_value);
    			t4 = space();
    			div1 = element("div");
    			p2 = element("p");
    			t5 = text("ID: ");
    			t6 = text(t6_value);
    			t7 = space();
    			p3 = element("p");
    			t8 = text(t8_value);
    			t9 = space();
    			if (!src_url_equal(img.src, img_src_value = /*Data*/ ctx[12].image || "./images/mugshot.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			set_style(img, "width", "15vh");
    			set_style(img, "height", "15vh");
    			set_style(img, "margin-right", "0.8vh");
    			add_location(img, file$D, 127, 20, 5012);
    			attr_dev(p0, "class", "warrent-name");
    			add_location(p0, file$D, 130, 28, 5306);
    			attr_dev(p1, "class", "warrent-title");
    			add_location(p1, file$D, 131, 28, 5375);
    			add_location(div0, file$D, 129, 24, 5271);
    			attr_dev(p2, "class", "warrent-name");
    			add_location(p2, file$D, 134, 28, 5595);
    			attr_dev(p3, "class", "warrent-title");
    			add_location(p3, file$D, 135, 28, 5666);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-between");
    			set_style(div1, "margin-top", "auto");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$D, 133, 24, 5474);
    			attr_dev(div2, "class", "mdw-warrent-card-details");
    			set_style(div2, "width", "100%");
    			set_style(div2, "display", "flex");
    			set_style(div2, "flex-direction", "column");
    			add_location(div2, file$D, 128, 20, 5147);
    			attr_dev(div3, "class", "mdw-warrent-card svelte-1oq7knp");
    			add_location(div3, file$D, 126, 16, 4905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, img);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(p0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, p1);
    			append_dev(p1, t3);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, p2);
    			append_dev(p2, t5);
    			append_dev(p2, t6);
    			append_dev(div1, t7);
    			append_dev(div1, p3);
    			append_dev(p3, t8);
    			append_dev(div3, t9);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "keyup", /*keyup_handler*/ ctx[6], false, false, false, false),
    					listen_dev(div3, "click", click_handler, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*FilteredWarrents*/ 1 && !src_url_equal(img.src, img_src_value = /*Data*/ ctx[12].image || "./images/mugshot.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*FilteredWarrents*/ 1 && t1_value !== (t1_value = /*Data*/ ctx[12].name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*FilteredWarrents*/ 1 && t3_value !== (t3_value = /*Data*/ ctx[12].title + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*FilteredWarrents*/ 1 && t6_value !== (t6_value = /*Data*/ ctx[12].id + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*FilteredWarrents*/ 1 && t8_value !== (t8_value = GetTimeLabel(/*Data*/ ctx[12].timestamp) + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$c.name,
    		type: "each",
    		source: "(126:12) {#each FilteredWarrents as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (125:8) <MdwPanelList>
    function create_default_slot_4$d(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*FilteredWarrents*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FetchReportById, FilteredWarrents, GetTimeLabel*/ 17) {
    				each_value_1 = /*FilteredWarrents*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$c(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$d.name,
    		type: "slot",
    		source: "(125:8) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (119:4) <MdwPanel class="filled" style="width: {HasCidPermission("Dashboard.ShowBulletin") ? 50 : 100}%">
    function create_default_slot_3$d(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_5$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_4$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredWarrents*/ 65537) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(119:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: {HasCidPermission(\\\"Dashboard.ShowBulletin\\\") ? 50 : 100}%\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:0) {#if HasCidPermission("Dashboard.ShowBulletin")}
    function create_if_block$t(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: " + (HasCidPermission("Dashboard.ShowWarrents") ? 50 : 100) + "%",
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredBulletins*/ 65538) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(145:0) {#if HasCidPermission(\\\"Dashboard.ShowBulletin\\\")}",
    		ctx
    	});

    	return block;
    }

    // (147:8) <MdwPanelHeader>
    function create_default_slot_2$e(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterBulletin*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Clipboard";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$D, 147, 12, 6074);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(147:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (153:12) {#each FilteredBulletins as Data, Key}
    function create_each_block$m(ctx) {
    	let div3;
    	let p0;
    	let t0_value = /*Data*/ ctx[12].title + "";
    	let t0;
    	let t1;
    	let div0;
    	let raw_value = /*Data*/ ctx[12].report + "";
    	let t2;
    	let div2;
    	let div1;
    	let p1;
    	let t3;
    	let t4_value = /*Data*/ ctx[12].id + "";
    	let t4;
    	let t5;
    	let p2;
    	let t6_value = GetTimeLabel(/*Data*/ ctx[12].timestamp) + "";
    	let t6;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[8](/*Data*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			div2 = element("div");
    			div1 = element("div");
    			p1 = element("p");
    			t3 = text("ID: ");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			set_style(p0, "font-weight", "500");
    			set_style(p0, "margin", "0px");
    			add_location(p0, file$D, 154, 20, 6407);
    			attr_dev(div0, "class", "mdw-bulletin-content svelte-1oq7knp");
    			add_location(div0, file$D, 155, 20, 6487);
    			attr_dev(p1, "class", "warrent-name");
    			add_location(p1, file$D, 160, 28, 6828);
    			attr_dev(p2, "class", "warrent-title");
    			add_location(p2, file$D, 161, 28, 6899);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-between");
    			set_style(div1, "margin-top", "auto");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$D, 159, 24, 6707);
    			set_style(div2, "width", "100%");
    			set_style(div2, "display", "flex");
    			set_style(div2, "flex-direction", "column");
    			add_location(div2, file$D, 158, 20, 6616);
    			attr_dev(div3, "class", "mdw-bulletin-card svelte-1oq7knp");
    			add_location(div3, file$D, 153, 16, 6299);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, p0);
    			append_dev(p0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, p1);
    			append_dev(p1, t3);
    			append_dev(p1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p2);
    			append_dev(p2, t6);
    			append_dev(div3, t7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "keyup", /*keyup_handler_1*/ ctx[5], false, false, false, false),
    					listen_dev(div3, "click", click_handler_1, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*FilteredBulletins*/ 2 && t0_value !== (t0_value = /*Data*/ ctx[12].title + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*FilteredBulletins*/ 2 && raw_value !== (raw_value = /*Data*/ ctx[12].report + "")) div0.innerHTML = raw_value;			if (dirty & /*FilteredBulletins*/ 2 && t4_value !== (t4_value = /*Data*/ ctx[12].id + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*FilteredBulletins*/ 2 && t6_value !== (t6_value = GetTimeLabel(/*Data*/ ctx[12].timestamp) + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$m.name,
    		type: "each",
    		source: "(153:12) {#each FilteredBulletins as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (152:8) <MdwPanelList>
    function create_default_slot_1$h(ctx) {
    	let each_1_anchor;
    	let each_value = /*FilteredBulletins*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FetchReportById, FilteredBulletins, GetTimeLabel*/ 18) {
    				each_value = /*FilteredBulletins*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(152:8) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (146:4) <MdwPanel class="filled" style="width: {HasCidPermission("Dashboard.ShowWarrents") ? 50 : 100}%">
    function create_default_slot$q(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredBulletins*/ 65538) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(146:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: {HasCidPermission(\\\"Dashboard.ShowWarrents\\\") ? 50 : 100}%\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let show_if_1 = HasCidPermission("Dashboard.ShowWarrents");
    	let t;
    	let show_if = HasCidPermission("Dashboard.ShowBulletin");
    	let if_block1_anchor;
    	let current;
    	let if_block0 = show_if_1 && create_if_block_1$h(ctx);
    	let if_block1 = show_if && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (show_if_1) if_block0.p(ctx, dirty);
    			if (show_if) if_block1.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $CurrentReport;
    	validate_store(CurrentReport, 'CurrentReport');
    	component_subscribe($$self, CurrentReport, $$value => $$invalidate(11, $CurrentReport = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dashboard', slots, []);
    	let Warrents = [];
    	let FilteredWarrents = [];
    	let Bulletins = [];
    	let FilteredBulletins = [];

    	onMount(() => {
    		SendEvent("Dashboard/GetWarrents", {}, (Success, Data) => {
    			if (!Success) return;
    			Warrents = Data;
    			$$invalidate(0, FilteredWarrents = Data);
    		});

    		SendEvent("Dashboard/GetBulletin", {}, (Success, Data) => {
    			if (!Success) return;
    			Bulletins = Data;
    			$$invalidate(1, FilteredBulletins = Data);
    		});
    	});

    	const FilterWarrents = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredWarrents = Warrents.filter(Val => {
    			return Val.title.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search);
    		}));
    	};

    	const FilterBulletin = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(1, FilteredBulletins = Bulletins.filter(Val => {
    			return Val.title.toLowerCase().includes(Search) || Val.report.toLowerCase().includes(Search);
    		}));
    	};

    	const FetchReportById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Reports/FetchById", { Id }, async (Success, Data) => {
    			if (!Success) return;
    			CurrentReport.set(Data);
    			let formattedScums = Data.scums;

    			for (let i = 0; i < formattedScums.length; i++) {
    				if (!formattedScums[i].ReductionString) {
    					formattedScums[i].ReductionString = "0% / 0 maanden / $ 0,00";
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.scums = formattedScums, $CurrentReport);
    			let formattedEvidence = [];

    			for (let i = 0; i < Data.evidence.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Evidence/FetchById", { Id: Data.evidence[i] });

    				if (Success) {
    					const EvidenceData = GetEvidenceById(Result.type);
    					let EvidenceText = Result.description;

    					if (Result.type == "Foto") {
    						EvidenceText = `Foto (${EvidenceText})`;
    					} else {
    						EvidenceText = `${Result.identifier} - (${EvidenceText})`;
    					}

    					formattedEvidence.push({
    						Color: EvidenceData.Color,
    						Text: EvidenceText,
    						Image: Result.type == "Foto" ? Result.identifier : false,
    						Id: formattedEvidence.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedEvidence = formattedEvidence, $CurrentReport);
    			let formattedOfficers = [];

    			for (let i = 0; i < Data.officers.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Staff/FetchById", { Id: Data.officers[i] });

    				if (Success) {
    					formattedOfficers.push({
    						Color: "#ffffff",
    						Text: `(${Result.callsign}) ${Result.name}`,
    						Id: formattedOfficers.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedOfficers = formattedOfficers, $CurrentReport);
    			let formattedPersons = [];

    			for (let i = 0; i < Data.persons.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Profiles/FetchById", { Id: Data.persons[i] });

    				if (Success) {
    					formattedPersons.push({
    						Color: "#ffffff",
    						Text: `${Result.name} (#${Result.citizenid})`,
    						Id: formattedPersons.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedPersons = formattedPersons, $CurrentReport);
    			ShowLoader.set(false);
    			CurrentTab.set("Reports");
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Data => {
    		FetchReportById(Data.id);
    	};

    	const click_handler_1 = Data => {
    		FetchReportById(Data.id);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		onMount,
    		AsyncSendEvent,
    		GetEvidenceById,
    		GetTimeLabel,
    		HasCidPermission,
    		SendEvent,
    		CurrentReport,
    		CurrentTab,
    		ShowLoader,
    		Warrents,
    		FilteredWarrents,
    		Bulletins,
    		FilteredBulletins,
    		FilterWarrents,
    		FilterBulletin,
    		FetchReportById,
    		$CurrentReport
    	});

    	$$self.$inject_state = $$props => {
    		if ('Warrents' in $$props) Warrents = $$props.Warrents;
    		if ('FilteredWarrents' in $$props) $$invalidate(0, FilteredWarrents = $$props.FilteredWarrents);
    		if ('Bulletins' in $$props) Bulletins = $$props.Bulletins;
    		if ('FilteredBulletins' in $$props) $$invalidate(1, FilteredBulletins = $$props.FilteredBulletins);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredWarrents,
    		FilteredBulletins,
    		FilterWarrents,
    		FilterBulletin,
    		FetchReportById,
    		keyup_handler_1,
    		keyup_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    var ckeditor = createCommonjsModule(function (module, exports) {
    !function(t){const e=t.en=t.en||{};e.dictionary=Object.assign(e.dictionary||{},{"%0 of %1":"%0 of %1",Aquamarine:"Aquamarine",Black:"Black","Block quote":"Block quote",Blue:"Blue",Bold:"Bold","Break text":"Break text","Bulleted List":"Bulleted List",Cancel:"Cancel","Cannot determine a category for the uploaded file.":"Cannot determine a category for the uploaded file.","Cannot upload file:":"Cannot upload file:","Caption for image: %0":"Caption for image: %0","Caption for the image":"Caption for the image","Centered image":"Centered image","Change image text alternative":"Change image text alternative","Choose heading":"Choose heading",Column:"Column","Could not insert image at the current position.":"Could not insert image at the current position.","Could not obtain resized image URL.":"Could not obtain resized image URL.","Decrease indent":"Decrease indent","Delete column":"Delete column","Delete row":"Delete row","Dim grey":"Dim grey",Downloadable:"Downloadable","Dropdown toolbar":"Dropdown toolbar","Edit block":"Edit block","Edit link":"Edit link","Editor block content toolbar":"Editor block content toolbar","Editor contextual toolbar":"Editor contextual toolbar","Editor editing area: %0":"Editor editing area: %0","Editor toolbar":"Editor toolbar","Enter image caption":"Enter image caption","Full size image":"Full size image",Green:"Green",Grey:"Grey","Header column":"Header column","Header row":"Header row",Heading:"Heading","Heading 1":"Heading 1","Heading 2":"Heading 2","Heading 3":"Heading 3","Heading 4":"Heading 4","Heading 5":"Heading 5","Heading 6":"Heading 6","Image toolbar":"Image toolbar","image widget":"image widget","In line":"In line","Increase indent":"Increase indent","Insert column left":"Insert column left","Insert column right":"Insert column right","Insert image":"Insert image","Insert image or file":"Insert image or file","Insert media":"Insert media","Insert paragraph after block":"Insert paragraph after block","Insert paragraph before block":"Insert paragraph before block","Insert row above":"Insert row above","Insert row below":"Insert row below","Insert table":"Insert table","Inserting image failed":"Inserting image failed",Italic:"Italic","Left aligned image":"Left aligned image","Light blue":"Light blue","Light green":"Light green","Light grey":"Light grey",Link:"Link","Link URL":"Link URL","Media URL":"Media URL","media widget":"media widget","Merge cell down":"Merge cell down","Merge cell left":"Merge cell left","Merge cell right":"Merge cell right","Merge cell up":"Merge cell up","Merge cells":"Merge cells",Next:"Next","Numbered List":"Numbered List","Open file manager":"Open file manager","Open in a new tab":"Open in a new tab","Open link in new tab":"Open link in new tab","Open media in new tab":"Open media in new tab",Orange:"Orange",Paragraph:"Paragraph","Paste the media URL in the input.":"Paste the media URL in the input.","Press Enter to type after or press Shift + Enter to type before the widget":"Press Enter to type after or press Shift + Enter to type before the widget",Previous:"Previous",Purple:"Purple",Red:"Red",Redo:"Redo","Rich Text Editor":"Rich Text Editor","Rich Text Editor. Editing area: %0":"Rich Text Editor. Editing area: %0","Right aligned image":"Right aligned image",Row:"Row",Save:"Save","Select all":"Select all","Select column":"Select column","Select row":"Select row","Selecting resized image failed":"Selecting resized image failed","Show more items":"Show more items","Side image":"Side image","Split cell horizontally":"Split cell horizontally","Split cell vertically":"Split cell vertically","Table toolbar":"Table toolbar","Text alternative":"Text alternative","The URL must not be empty.":"The URL must not be empty.","This link has no URL":"This link has no URL","This media URL is not supported.":"This media URL is not supported.","Tip: Paste the URL into the content to embed faster.":"Tip: Paste the URL into the content to embed faster.","Toggle caption off":"Toggle caption off","Toggle caption on":"Toggle caption on",Turquoise:"Turquoise",Undo:"Undo",Unlink:"Unlink","Upload failed":"Upload failed","Upload in progress":"Upload in progress",White:"White","Widget toolbar":"Widget toolbar","Wrap text":"Wrap text",Yellow:"Yellow"});}(window.CKEDITOR_TRANSLATIONS||(window.CKEDITOR_TRANSLATIONS={})),
    /*!
     * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    function(t,e){module.exports=e();}(self,(()=>(()=>{var t={3062:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}","",{version:3,sources:["webpack://./../ckeditor5-block-quote/theme/blockquote.css"],names:[],mappings:"AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'],sourceRoot:""}]);const a=s;},903:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',"",{version:3,sources:["webpack://./../ckeditor5-clipboard/theme/clipboard.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],names:[],mappings:"AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n'],sourceRoot:""}]);const a=s;},4717:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}","",{version:3,sources:["webpack://./../ckeditor5-engine/theme/placeholder.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],names:[],mappings:"AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],sourceRoot:""}]);const a=s;},9315:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}","",{version:3,sources:["webpack://./../ckeditor5-engine/theme/renderer.css"],names:[],mappings:"AAMA,qDACC,YACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"],sourceRoot:""}]);const a=s;},8733:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}","",{version:3,sources:["webpack://./../ckeditor5-heading/theme/heading.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],names:[],mappings:"AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},3508:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}","",{version:3,sources:["webpack://./../ckeditor5-image/theme/image.css"],names:[],mappings:"AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},2640:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}","",{version:3,sources:["webpack://./../ckeditor5-image/theme/imagecaption.css"],names:[],mappings:"AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n"],sourceRoot:""}]);const a=s;},5083:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}","",{version:3,sources:["webpack://./../ckeditor5-image/theme/imagestyle.css"],names:[],mappings:"AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"],sourceRoot:""}]);const a=s;},4036:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}',"",{version:3,sources:["webpack://./../ckeditor5-image/theme/imageuploadicon.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],names:[],mappings:"AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n','/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],sourceRoot:""}]);const a=s;},3773:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',"",{version:3,sources:["webpack://./../ckeditor5-image/theme/imageuploadloader.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],names:[],mappings:"AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],sourceRoot:""}]);const a=s;},3689:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}","",{version:3,sources:["webpack://./../ckeditor5-image/theme/imageuploadprogress.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],names:[],mappings:"AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],sourceRoot:""}]);const a=s;},1905:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}","",{version:3,sources:["webpack://./../ckeditor5-image/theme/textalternativeform.css","webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],names:[],mappings:"AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},9773:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}","",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],names:[],mappings:"AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],sourceRoot:""}]);const a=s;},2347:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}","",{version:3,sources:["webpack://./../ckeditor5-link/theme/linkactions.css","webpack://./../ckeditor5-ui/theme/mixins/_rwd.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],names:[],mappings:"AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},7754:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}","",{version:3,sources:["webpack://./../ckeditor5-link/theme/linkform.css","webpack://./../ckeditor5-ui/theme/mixins/_rwd.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],names:[],mappings:"AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},4652:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}","",{version:3,sources:["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"],names:[],mappings:"AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'],sourceRoot:""}]);const a=s;},7442:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}',"",{version:3,sources:["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],names:[],mappings:"AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n','/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},9292:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}","",{version:3,sources:["webpack://./../ckeditor5-media-embed/theme/mediaform.css","webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],names:[],mappings:"AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},1613:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}","",{version:3,sources:["webpack://./../ckeditor5-table/theme/inserttable.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],names:[],mappings:"AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"],sourceRoot:""}]);const a=s;},6306:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}","",{version:3,sources:["webpack://./../ckeditor5-table/theme/table.css"],names:[],mappings:"AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n'],sourceRoot:""}]);const a=s;},3881:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}","",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],names:[],mappings:"AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"],sourceRoot:""}]);const a=s;},6945:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}',"",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],names:[],mappings:"AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"],sourceRoot:""}]);const a=s;},4906:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/button/button.css","webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],names:[],mappings:"AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],sourceRoot:""}]);const a=s;},5332:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],names:[],mappings:"AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],sourceRoot:""}]);const a=s;},6781:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],names:[],mappings:"AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],sourceRoot:""}]);const a=s;},5485:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},3949:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}","",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},7686:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',"",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},7339:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],names:[],mappings:"AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],sourceRoot:""}]);const a=s;},9688:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}","",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},8847:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],names:[],mappings:"AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},6574:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/icon/icon.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],names:[],mappings:"AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},4879:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}","",{version:3,sources:["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},3662:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/label/label.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],names:[],mappings:"AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],sourceRoot:""}]);const a=s;},2577:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},1046:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/list/list.css","webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},8793:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',"",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n','/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},4650:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],names:[],mappings:"AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},7676:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},5868:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},6764:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',"",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css","webpack://./../ckeditor5-ui/theme/mixins/_rwd.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],names:[],mappings:"AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'],sourceRoot:""}]);const a=s;},9695:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],names:[],mappings:"AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"],sourceRoot:""}]);const a=s;},5542:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css","webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],names:[],mappings:"AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],sourceRoot:""}]);const a=s;},3332:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],names:[],mappings:"AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'],sourceRoot:""}]);const a=s;},4793:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}","",{version:3,sources:["webpack://./../ckeditor5-ui/theme/globals/_hidden.css","webpack://./../ckeditor5-ui/theme/globals/_reset.css","webpack://./../ckeditor5-ui/theme/globals/_zindex.css","webpack://./../ckeditor5-ui/theme/globals/_transition.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],names:[],mappings:"AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],sourceRoot:""}]);const a=s;},3488:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}","",{version:3,sources:["webpack://./../ckeditor5-widget/theme/widget.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css","webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],names:[],mappings:"AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n",'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],sourceRoot:""}]);const a=s;},8506:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}","",{version:3,sources:["webpack://./../ckeditor5-widget/theme/widgetresize.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],names:[],mappings:"AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",sourcesContent:["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n","/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"],sourceRoot:""}]);const a=s;},4921:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(1799),i=n.n(o),r=n(2609),s=n.n(r)()(i());s.push([t.id,'.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',"",{version:3,sources:["webpack://./../ckeditor5-widget/theme/widgettypearound.css","webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],names:[],mappings:"AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",sourcesContent:['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n','/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],sourceRoot:""}]);const a=s;},2609:t=>{t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var n=t(e);return e[2]?"@media ".concat(e[2]," {").concat(n,"}"):n})).join("")},e.i=function(t,n,o){"string"==typeof t&&(t=[[null,t,""]]);var i={};if(o)for(var r=0;r<this.length;r++){var s=this[r][0];null!=s&&(i[s]=!0);}for(var a=0;a<t.length;a++){var c=[].concat(t[a]);o&&i[c[0]]||(n&&(c[2]?c[2]="".concat(n," and ").concat(c[2]):c[2]=n),e.push(c));}},e};},1799:t=>{function e(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=t&&("undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"]);if(null==n)return;var o,i,r=[],s=!0,a=!1;try{for(n=n.call(t);!(s=(o=n.next()).done)&&(r.push(o.value),!e||r.length!==e);s=!0);}catch(t){a=!0,i=t;}finally{try{s||null==n.return||n.return();}finally{if(a)throw i}}return r}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return n(t,e);var o=Object.prototype.toString.call(t).slice(8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return Array.from(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return n(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,o=new Array(e);n<e;n++)o[n]=t[n];return o}t.exports=function(t){var n=e(t,4),o=n[1],i=n[3];if(!i)return o;if("function"==typeof btoa){var r=btoa(unescape(encodeURIComponent(JSON.stringify(i)))),s="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),a="/*# ".concat(s," */"),c=i.sources.map((function(t){return "/*# sourceURL=".concat(i.sourceRoot||"").concat(t," */")}));return [o].concat(c).concat([a]).join("\n")}return [o].join("\n")};},6062:(t,e,n)=>{var o,i=function(){return void 0===o&&(o=Boolean(window&&document&&document.all&&!window.atob)),o},r=function(){var t={};return function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head;}catch(t){n=null;}t[e]=n;}return t[e]}}(),s=[];function a(t){for(var e=-1,n=0;n<s.length;n++)if(s[n].identifier===t){e=n;break}return e}function c(t,e){for(var n={},o=[],i=0;i<t.length;i++){var r=t[i],c=e.base?r[0]+e.base:r[0],l=n[c]||0,d="".concat(c," ").concat(l);n[c]=l+1;var h=a(d),u={css:r[1],media:r[2],sourceMap:r[3]};-1!==h?(s[h].references++,s[h].updater(u)):s.push({identifier:d,updater:f(u,e),references:1}),o.push(d);}return o}function l(t){var e=document.createElement("style"),o=t.attributes||{};if(void 0===o.nonce){var i=n.nc;i&&(o.nonce=i);}if(Object.keys(o).forEach((function(t){e.setAttribute(t,o[t]);})),"function"==typeof t.insert)t.insert(e);else {var s=r(t.insert||"head");if(!s)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");s.appendChild(e);}return e}var d,h=(d=[],function(t,e){return d[t]=e,d.filter(Boolean).join("\n")});function u(t,e,n,o){var i=n?"":o.media?"@media ".concat(o.media," {").concat(o.css,"}"):o.css;if(t.styleSheet)t.styleSheet.cssText=h(e,i);else {var r=document.createTextNode(i),s=t.childNodes;s[e]&&t.removeChild(s[e]),s.length?t.insertBefore(r,s[e]):t.appendChild(r);}}function g(t,e,n){var o=n.css,i=n.media,r=n.sourceMap;if(i?t.setAttribute("media",i):t.removeAttribute("media"),r&&"undefined"!=typeof btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r))))," */")),t.styleSheet)t.styleSheet.cssText=o;else {for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(o));}}var m=null,p=0;function f(t,e){var n,o,i;if(e.singleton){var r=p++;n=m||(m=l(e)),o=u.bind(null,n,r,!1),i=u.bind(null,n,r,!0);}else n=l(e),o=g.bind(null,n,e),i=function(){!function(t){if(null===t.parentNode)return !1;t.parentNode.removeChild(t);}(n);};return o(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;o(t=e);}else i();}}t.exports=function(t,e){(e=e||{}).singleton||"boolean"==typeof e.singleton||(e.singleton=i());var n=c(t=t||[],e);return function(t){if(t=t||[],"[object Array]"===Object.prototype.toString.call(t)){for(var o=0;o<n.length;o++){var i=a(n[o]);s[i].references--;}for(var r=c(t,e),l=0;l<n.length;l++){var d=a(n[l]);0===s[d].references&&(s[d].updater(),s.splice(d,1));}n=r;}}};}},e={};function n(o){var i=e[o];if(void 0!==i)return i.exports;var r=e[o]={id:o,exports:{}};return t[o](r,r.exports,n),r.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var o in e)n.o(e,o)&&!n.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]});},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.nc=void 0;var o={};return (()=>{n.d(o,{default:()=>rC});const t=function(){try{return navigator.userAgent.toLowerCase()}catch(t){return ""}}(),e={isMac:r(t),isWindows:function(t){return t.indexOf("windows")>-1}(t),isGecko:function(t){return !!t.match(/gecko\/\d+/)}(t),isSafari:function(t){return t.indexOf(" applewebkit/")>-1&&-1===t.indexOf("chrome")}(t),isiOS:function(t){return !!t.match(/iphone|ipad/i)||r(t)&&navigator.maxTouchPoints>0}(t),isAndroid:function(t){return t.indexOf("android")>-1}(t),isBlink:function(t){return t.indexOf("chrome/")>-1&&t.indexOf("edge/")<0}(t),features:{isRegExpUnicodePropertySupported:function(){let t=!1;try{t=0==="ć".search(new RegExp("[\\p{L}]","u"));}catch(t){}return t}()}},i=e;function r(t){return t.indexOf("macintosh")>-1}function s(t,e,n,o){n=n||function(t,e){return t===e};const i=Array.isArray(t)?t:Array.prototype.slice.call(t),r=Array.isArray(e)?e:Array.prototype.slice.call(e),s=function(t,e,n){const o=a(t,e,n);if(-1===o)return {firstIndex:-1,lastIndexOld:-1,lastIndexNew:-1};const i=c(t,o),r=c(e,o),s=a(i,r,n),l=t.length-s,d=e.length-s;return {firstIndex:o,lastIndexOld:l,lastIndexNew:d}}(i,r,n),l=o?function(t,e){const{firstIndex:n,lastIndexOld:o,lastIndexNew:i}=t;if(-1===n)return Array(e).fill("equal");let r=[];n>0&&(r=r.concat(Array(n).fill("equal")));i-n>0&&(r=r.concat(Array(i-n).fill("insert")));o-n>0&&(r=r.concat(Array(o-n).fill("delete")));i<e&&(r=r.concat(Array(e-i).fill("equal")));return r}(s,r.length):function(t,e){const n=[],{firstIndex:o,lastIndexOld:i,lastIndexNew:r}=e;r-o>0&&n.push({index:o,type:"insert",values:t.slice(o,r)});i-o>0&&n.push({index:o+(r-o),type:"delete",howMany:i-o});return n}(r,s);return l}function a(t,e,n){for(let o=0;o<Math.max(t.length,e.length);o++)if(void 0===t[o]||void 0===e[o]||!n(t[o],e[o]))return o;return -1}function c(t,e){return t.slice(e).reverse()}function l(t,e,n){n=n||function(t,e){return t===e};const o=t.length,i=e.length;if(o>200||i>200||o+i>300)return l.fastDiff(t,e,n,!0);let r,s;if(i<o){const n=t;t=e,e=n,r="delete",s="insert";}else r="insert",s="delete";const a=t.length,c=e.length,d=c-a,h={},u={};function g(o){const i=(void 0!==u[o-1]?u[o-1]:-1)+1,l=void 0!==u[o+1]?u[o+1]:-1,d=i>l?-1:1;h[o+d]&&(h[o]=h[o+d].slice(0)),h[o]||(h[o]=[]),h[o].push(i>l?r:s);let g=Math.max(i,l),m=g-o;for(;m<a&&g<c&&n(t[m],e[g]);)m++,g++,h[o].push("equal");return g}let m,p=0;do{for(m=-p;m<d;m++)u[m]=g(m);for(m=d+p;m>d;m--)u[m]=g(m);u[d]=g(d),p++;}while(u[d]!==c);return h[d].slice(1)}function d(t,...e){e.forEach((e=>{const n=Object.getOwnPropertyNames(e),o=Object.getOwnPropertySymbols(e);n.concat(o).forEach((n=>{if(n in t.prototype)return;if("function"==typeof e&&("length"==n||"name"==n||"prototype"==n))return;const o=Object.getOwnPropertyDescriptor(e,n);o.enumerable=!1,Object.defineProperty(t.prototype,n,o);}));}));}l.fastDiff=s;const h=function(){return function t(){t.called=!0;}};class u{constructor(t,e){this.source=t,this.name=e,this.path=[],this.stop=h(),this.off=h();}}const g=new Array(256).fill("").map(((t,e)=>("0"+e.toString(16)).slice(-2)));function m(){const t=4294967296*Math.random()>>>0,e=4294967296*Math.random()>>>0,n=4294967296*Math.random()>>>0,o=4294967296*Math.random()>>>0;return "e"+g[t>>0&255]+g[t>>8&255]+g[t>>16&255]+g[t>>24&255]+g[e>>0&255]+g[e>>8&255]+g[e>>16&255]+g[e>>24&255]+g[n>>0&255]+g[n>>8&255]+g[n>>16&255]+g[n>>24&255]+g[o>>0&255]+g[o>>8&255]+g[o>>16&255]+g[o>>24&255]}const p={get(t="normal"){return "number"!=typeof t?this[t]||this.normal:t},highest:1e5,high:1e3,normal:0,low:-1e3,lowest:-1e5};function f(t,e){const n=p.get(e.priority);for(let o=0;o<t.length;o++)if(p.get(t[o].priority)<n)return void t.splice(o,0,e);t.push(e);}class k extends Error{constructor(t,e,n){super(function(t,e){const n=new WeakSet,o=(t,e)=>{if("object"==typeof e&&null!==e){if(n.has(e))return `[object ${e.constructor.name}]`;n.add(e);}return e},i=e?` ${JSON.stringify(e,o)}`:"",r=_(t);return t+i+r}(t,n)),this.name="CKEditorError",this.context=e,this.data=n;}is(t){return "CKEditorError"===t}static rethrowUnexpectedError(t,e){if(t.is&&t.is("CKEditorError"))throw t;const n=new k(t.message,e);throw n.stack=t.stack,n}}function b(t,e){console.warn(...A(t,e));}function w(t,e){console.error(...A(t,e));}function _(t){return `\nRead more: https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html#error-${t}`}function A(t,e){const n=_(t);return e?[t,e,n]:[t,n]}const C="35.4.0",v="object"==typeof window?window:n.g;if(v.CKEDITOR_VERSION)throw new k("ckeditor-duplicated-modules",null);v.CKEDITOR_VERSION=C;const y=Symbol("listeningTo"),x=Symbol("emitterId"),E=Symbol("delegations"),D=I(Object);function I(t){if(!t)return D;return class extends t{on(t,e,n){this.listenTo(this,t,e,n);}once(t,e,n){let o=!1;this.listenTo(this,t,((t,...n)=>{o||(o=!0,t.off(),e.call(this,t,...n));}),n);}off(t,e){this.stopListening(this,t,e);}listenTo(t,e,n,o={}){let i,r;this[y]||(this[y]={});const s=this[y];T(t)||M(t);const a=T(t);(i=s[a])||(i=s[a]={emitter:t,callbacks:{}}),(r=i.callbacks[e])||(r=i.callbacks[e]=[]),r.push(n),function(t,e,n,o,i){e._addEventListener?e._addEventListener(n,o,i):t._addEventListener.call(e,n,o,i);}(this,t,e,n,o);}stopListening(t,e,n){const o=this[y];let i=t&&T(t);const r=o&&i?o[i]:void 0,s=r&&e?r.callbacks[e]:void 0;if(!(!o||t&&!r||e&&!s))if(n){z(this,t,e,n);-1!==s.indexOf(n)&&(1===s.length?delete r.callbacks[e]:z(this,t,e,n));}else if(s){for(;n=s.pop();)z(this,t,e,n);delete r.callbacks[e];}else if(r){for(e in r.callbacks)this.stopListening(t,e);delete o[i];}else {for(i in o)this.stopListening(o[i].emitter);delete this[y];}}fire(t,...e){try{const n=t instanceof u?t:new u(this,t),o=n.name;let i=B(this,o);if(n.path.push(this),i){const t=[n,...e];i=Array.from(i);for(let e=0;e<i.length&&(i[e].callback.apply(this,t),n.off.called&&(delete n.off.called,this._removeEventListener(o,i[e].callback)),!n.stop.called);e++);}const r=this[E];if(r){const t=r.get(o),i=r.get("*");t&&P(t,n,e),i&&P(i,n,e);}return n.return}catch(t){k.rethrowUnexpectedError(t,this);}}delegate(...t){return {to:(e,n)=>{this[E]||(this[E]=new Map),t.forEach((t=>{const o=this[E].get(t);o?o.set(e,n):this[E].set(t,new Map([[e,n]]));}));}}}stopDelegating(t,e){if(this[E])if(t)if(e){const n=this[E].get(t);n&&n.delete(e);}else this[E].delete(t);else this[E].clear();}_addEventListener(t,e,n){!function(t,e){const n=S(t);if(n[e])return;let o=e,i=null;const r=[];for(;""!==o&&!n[o];)n[o]={callbacks:[],childEvents:[]},r.push(n[o]),i&&n[o].childEvents.push(i),i=o,o=o.substr(0,o.lastIndexOf(":"));if(""!==o){for(const t of r)t.callbacks=n[o].callbacks.slice();n[o].childEvents.push(i);}}(this,t);const o=N(this,t),i={callback:e,priority:p.get(n.priority)};for(const t of o)f(t,i);}_removeEventListener(t,e){const n=N(this,t);for(const t of n)for(let n=0;n<t.length;n++)t[n].callback==e&&(t.splice(n,1),n--);}}}function M(t,e){t[x]||(t[x]=e||m());}function T(t){return t[x]}function S(t){return t._events||Object.defineProperty(t,"_events",{value:{}}),t._events}function N(t,e){const n=S(t)[e];if(!n)return [];let o=[n.callbacks];for(let e=0;e<n.childEvents.length;e++){const i=N(t,n.childEvents[e]);o=o.concat(i);}return o}function B(t,e){let n;return t._events&&(n=t._events[e])&&n.callbacks.length?n.callbacks:e.indexOf(":")>-1?B(t,e.substr(0,e.lastIndexOf(":"))):null}function P(t,e,n){for(let[o,i]of t){i?"function"==typeof i&&(i=i(e.name)):i=e.name;const t=new u(e.source,i);t.path=[...e.path],o.fire(t,...n);}}function z(t,e,n,o){e._removeEventListener?e._removeEventListener(n,o):t._removeEventListener.call(e,n,o);}["on","once","off","listenTo","stopListening","fire","delegate","stopDelegating","_addEventListener","_removeEventListener"].forEach((t=>{I[t]=D.prototype[t];}));const L=function(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)},O=Symbol("observableProperties"),R=Symbol("boundObservables"),j=Symbol("boundProperties"),F=Symbol("decoratedMethods"),V=Symbol("decoratedOriginal"),U=H(I());function H(t){if(!t)return U;return class extends t{set(t,e){if(L(t))return void Object.keys(t).forEach((e=>{this.set(e,t[e]);}),this);W(this);const n=this[O];if(t in this&&!n.has(t))throw new k("observable-set-cannot-override",this);Object.defineProperty(this,t,{enumerable:!0,configurable:!0,get:()=>n.get(t),set(e){const o=n.get(t);let i=this.fire(`set:${t}`,t,e,o);void 0===i&&(i=e),o===i&&n.has(t)||(n.set(t,i),this.fire(`change:${t}`,t,i,o));}}),this[t]=e;}bind(...t){if(!t.length||!Y(t))throw new k("observable-bind-wrong-properties",this);if(new Set(t).size!==t.length)throw new k("observable-bind-duplicate-properties",this);W(this);const e=this[j];t.forEach((t=>{if(e.has(t))throw new k("observable-bind-rebind",this)}));const n=new Map;return t.forEach((t=>{const o={property:t,to:[]};e.set(t,o),n.set(t,o);})),{to:G,toMany:q,_observable:this,_bindProperties:t,_to:[],_bindings:n}}unbind(...t){if(!this[O])return;const e=this[j],n=this[R];if(t.length){if(!Y(t))throw new k("observable-unbind-wrong-properties",this);t.forEach((t=>{const o=e.get(t);o&&(o.to.forEach((([t,e])=>{const i=n.get(t),r=i[e];r.delete(o),r.size||delete i[e],Object.keys(i).length||(n.delete(t),this.stopListening(t,"change"));})),e.delete(t));}));}else n.forEach(((t,e)=>{this.stopListening(e,"change");})),n.clear(),e.clear();}decorate(t){W(this);const e=this[t];if(!e)throw new k("observablemixin-cannot-decorate-undefined",this,{object:this,methodName:t});this.on(t,((t,n)=>{t.return=e.apply(this,n);})),this[t]=function(...e){return this.fire(t,e)},this[t][V]=e,this[F]||(this[F]=[]),this[F].push(t);}stopListening(t,e,n){if(!t&&this[F]){for(const t of this[F])this[t]=this[t][V];delete this[F];}super.stopListening(t,e,n);}}}function W(t){t[O]||(Object.defineProperty(t,O,{value:new Map}),Object.defineProperty(t,R,{value:new Map}),Object.defineProperty(t,j,{value:new Map}));}function G(...t){const e=function(...t){if(!t.length)throw new k("observable-bind-to-parse-error",null);const e={to:[]};let n;"function"==typeof t[t.length-1]&&(e.callback=t.pop());return t.forEach((t=>{if("string"==typeof t)n.properties.push(t);else {if("object"!=typeof t)throw new k("observable-bind-to-parse-error",null);n={observable:t,properties:[]},e.to.push(n);}})),e}(...t),n=Array.from(this._bindings.keys()),o=n.length;if(!e.callback&&e.to.length>1)throw new k("observable-bind-to-no-callback",this);if(o>1&&e.callback)throw new k("observable-bind-to-extra-callback",this);var i;e.to.forEach((t=>{if(t.properties.length&&t.properties.length!==o)throw new k("observable-bind-to-properties-length",this);t.properties.length||(t.properties=this._bindProperties);})),this._to=e.to,e.callback&&(this._bindings.get(n[0]).callback=e.callback),i=this._observable,this._to.forEach((t=>{const e=i[R];let n;e.get(t.observable)||i.listenTo(t.observable,"change",((o,r)=>{n=e.get(t.observable)[r],n&&n.forEach((t=>{$(i,t.property);}));}));})),function(t){let e;t._bindings.forEach(((n,o)=>{t._to.forEach((i=>{e=i.properties[n.callback?0:t._bindProperties.indexOf(o)],n.to.push([i.observable,e]),function(t,e,n,o){const i=t[R],r=i.get(n),s=r||{};s[o]||(s[o]=new Set);s[o].add(e),r||i.set(n,s);}(t._observable,n,i.observable,e);}));}));}(this),this._bindProperties.forEach((t=>{$(this._observable,t);}));}function q(t,e,n){if(this._bindings.size>1)throw new k("observable-bind-to-many-not-one-binding",this);this.to(...function(t,e){const n=t.map((t=>[t,e]));return Array.prototype.concat.apply([],n)}(t,e),n);}function Y(t){return t.every((t=>"string"==typeof t))}function $(t,e){const n=t[j].get(e);let o;n.callback?o=n.callback.apply(t,n.to.map((t=>t[0][t[1]]))):(o=n.to[0],o=o[0][o[1]]),Object.prototype.hasOwnProperty.call(t,e)?t[e]=o:t.set(e,o);}function K(t){let e=0;for(const n of t)e++;return e}function Q(t,e){const n=Math.min(t.length,e.length);for(let o=0;o<n;o++)if(t[o]!=e[o])return o;return t.length==e.length?"same":t.length<e.length?"prefix":"extension"}function Z(t){return !(!t||!t[Symbol.iterator])}["set","bind","unbind","decorate","on","once","off","listenTo","stopListening","fire","delegate","stopDelegating","_addEventListener","_removeEventListener"].forEach((t=>{H[t]=U.prototype[t];}));const J="object"==typeof commonjsGlobal&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;var X="object"==typeof self&&self&&self.Object===Object&&self;const tt=J||X||Function("return this")();const et=tt.Symbol;var nt=Object.prototype,ot=nt.hasOwnProperty,it=nt.toString,rt=et?et.toStringTag:void 0;const st=function(t){var e=ot.call(t,rt),n=t[rt];try{t[rt]=void 0;var o=!0;}catch(t){}var i=it.call(t);return o&&(e?t[rt]=n:delete t[rt]),i};var at=Object.prototype.toString;const ct=function(t){return at.call(t)};var lt=et?et.toStringTag:void 0;const dt=function(t){return null==t?void 0===t?"[object Undefined]":"[object Null]":lt&&lt in Object(t)?st(t):ct(t)};const ht=Array.isArray;const ut=function(t){return null!=t&&"object"==typeof t};const gt=function(t){return "string"==typeof t||!ht(t)&&ut(t)&&"[object String]"==dt(t)};function mt(t,e,n={},o=[]){const i=n&&n.xmlns,r=i?t.createElementNS(i,e):t.createElement(e);for(const t in n)r.setAttribute(t,n[t]);!gt(o)&&Z(o)||(o=[o]);for(let e of o)gt(e)&&(e=t.createTextNode(e)),r.appendChild(e);return r}const pt=function(t,e){return function(n){return t(e(n))}};const ft=pt(Object.getPrototypeOf,Object);var kt=Function.prototype,bt=Object.prototype,wt=kt.toString,_t=bt.hasOwnProperty,At=wt.call(Object);const Ct=function(t){if(!ut(t)||"[object Object]"!=dt(t))return !1;var e=ft(t);if(null===e)return !0;var n=_t.call(e,"constructor")&&e.constructor;return "function"==typeof n&&n instanceof n&&wt.call(n)==At};const vt=function(){this.__data__=[],this.size=0;};const yt=function(t,e){return t===e||t!=t&&e!=e};const xt=function(t,e){for(var n=t.length;n--;)if(yt(t[n][0],e))return n;return -1};var Et=Array.prototype.splice;const Dt=function(t){var e=this.__data__,n=xt(e,t);return !(n<0)&&(n==e.length-1?e.pop():Et.call(e,n,1),--this.size,!0)};const It=function(t){var e=this.__data__,n=xt(e,t);return n<0?void 0:e[n][1]};const Mt=function(t){return xt(this.__data__,t)>-1};const Tt=function(t,e){var n=this.__data__,o=xt(n,t);return o<0?(++this.size,n.push([t,e])):n[o][1]=e,this};function St(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var o=t[e];this.set(o[0],o[1]);}}St.prototype.clear=vt,St.prototype.delete=Dt,St.prototype.get=It,St.prototype.has=Mt,St.prototype.set=Tt;const Nt=St;const Bt=function(){this.__data__=new Nt,this.size=0;};const Pt=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n};const zt=function(t){return this.__data__.get(t)};const Lt=function(t){return this.__data__.has(t)};const Ot=function(t){if(!L(t))return !1;var e=dt(t);return "[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e};const Rt=tt["__core-js_shared__"];var jt=function(){var t=/[^.]+$/.exec(Rt&&Rt.keys&&Rt.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}();const Ft=function(t){return !!jt&&jt in t};var Vt=Function.prototype.toString;const Ut=function(t){if(null!=t){try{return Vt.call(t)}catch(t){}try{return t+""}catch(t){}}return ""};var Ht=/^\[object .+?Constructor\]$/,Wt=Function.prototype,Gt=Object.prototype,qt=Wt.toString,Yt=Gt.hasOwnProperty,$t=RegExp("^"+qt.call(Yt).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");const Kt=function(t){return !(!L(t)||Ft(t))&&(Ot(t)?$t:Ht).test(Ut(t))};const Qt=function(t,e){return null==t?void 0:t[e]};const Zt=function(t,e){var n=Qt(t,e);return Kt(n)?n:void 0};const Jt=Zt(tt,"Map");const Xt=Zt(Object,"create");const te=function(){this.__data__=Xt?Xt(null):{},this.size=0;};const ee=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e};var ne=Object.prototype.hasOwnProperty;const oe=function(t){var e=this.__data__;if(Xt){var n=e[t];return "__lodash_hash_undefined__"===n?void 0:n}return ne.call(e,t)?e[t]:void 0};var ie=Object.prototype.hasOwnProperty;const re=function(t){var e=this.__data__;return Xt?void 0!==e[t]:ie.call(e,t)};const se=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=Xt&&void 0===e?"__lodash_hash_undefined__":e,this};function ae(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var o=t[e];this.set(o[0],o[1]);}}ae.prototype.clear=te,ae.prototype.delete=ee,ae.prototype.get=oe,ae.prototype.has=re,ae.prototype.set=se;const ce=ae;const le=function(){this.size=0,this.__data__={hash:new ce,map:new(Jt||Nt),string:new ce};};const de=function(t){var e=typeof t;return "string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t};const he=function(t,e){var n=t.__data__;return de(e)?n["string"==typeof e?"string":"hash"]:n.map};const ue=function(t){var e=he(this,t).delete(t);return this.size-=e?1:0,e};const ge=function(t){return he(this,t).get(t)};const me=function(t){return he(this,t).has(t)};const pe=function(t,e){var n=he(this,t),o=n.size;return n.set(t,e),this.size+=n.size==o?0:1,this};function fe(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var o=t[e];this.set(o[0],o[1]);}}fe.prototype.clear=le,fe.prototype.delete=ue,fe.prototype.get=ge,fe.prototype.has=me,fe.prototype.set=pe;const ke=fe;const be=function(t,e){var n=this.__data__;if(n instanceof Nt){var o=n.__data__;if(!Jt||o.length<199)return o.push([t,e]),this.size=++n.size,this;n=this.__data__=new ke(o);}return n.set(t,e),this.size=n.size,this};function we(t){var e=this.__data__=new Nt(t);this.size=e.size;}we.prototype.clear=Bt,we.prototype.delete=Pt,we.prototype.get=zt,we.prototype.has=Lt,we.prototype.set=be;const _e=we;const Ae=function(t,e){for(var n=-1,o=null==t?0:t.length;++n<o&&!1!==e(t[n],n,t););return t};const Ce=function(){try{var t=Zt(Object,"defineProperty");return t({},"",{}),t}catch(t){}}();const ve=function(t,e,n){"__proto__"==e&&Ce?Ce(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n;};var ye=Object.prototype.hasOwnProperty;const xe=function(t,e,n){var o=t[e];ye.call(t,e)&&yt(o,n)&&(void 0!==n||e in t)||ve(t,e,n);};const Ee=function(t,e,n,o){var i=!n;n||(n={});for(var r=-1,s=e.length;++r<s;){var a=e[r],c=o?o(n[a],t[a],a,n,t):void 0;void 0===c&&(c=t[a]),i?ve(n,a,c):xe(n,a,c);}return n};const De=function(t,e){for(var n=-1,o=Array(t);++n<t;)o[n]=e(n);return o};const Ie=function(t){return ut(t)&&"[object Arguments]"==dt(t)};var Me=Object.prototype,Te=Me.hasOwnProperty,Se=Me.propertyIsEnumerable;const Ne=Ie(function(){return arguments}())?Ie:function(t){return ut(t)&&Te.call(t,"callee")&&!Se.call(t,"callee")};const Be=function(){return !1};var Pe=exports&&!exports.nodeType&&exports,ze=Pe&&"object"=='object'&&module&&!module.nodeType&&module,Le=ze&&ze.exports===Pe?tt.Buffer:void 0;const Oe=(Le?Le.isBuffer:void 0)||Be;var Re=/^(?:0|[1-9]\d*)$/;const je=function(t,e){var n=typeof t;return !!(e=null==e?9007199254740991:e)&&("number"==n||"symbol"!=n&&Re.test(t))&&t>-1&&t%1==0&&t<e};const Fe=function(t){return "number"==typeof t&&t>-1&&t%1==0&&t<=9007199254740991};var Ve={};Ve["[object Float32Array]"]=Ve["[object Float64Array]"]=Ve["[object Int8Array]"]=Ve["[object Int16Array]"]=Ve["[object Int32Array]"]=Ve["[object Uint8Array]"]=Ve["[object Uint8ClampedArray]"]=Ve["[object Uint16Array]"]=Ve["[object Uint32Array]"]=!0,Ve["[object Arguments]"]=Ve["[object Array]"]=Ve["[object ArrayBuffer]"]=Ve["[object Boolean]"]=Ve["[object DataView]"]=Ve["[object Date]"]=Ve["[object Error]"]=Ve["[object Function]"]=Ve["[object Map]"]=Ve["[object Number]"]=Ve["[object Object]"]=Ve["[object RegExp]"]=Ve["[object Set]"]=Ve["[object String]"]=Ve["[object WeakMap]"]=!1;const Ue=function(t){return ut(t)&&Fe(t.length)&&!!Ve[dt(t)]};const He=function(t){return function(e){return t(e)}};var We=exports&&!exports.nodeType&&exports,Ge=We&&"object"=='object'&&module&&!module.nodeType&&module,qe=Ge&&Ge.exports===We&&J.process;const Ye=function(){try{var t=Ge&&Ge.require&&Ge.require("util").types;return t||qe&&qe.binding&&qe.binding("util")}catch(t){}}();var $e=Ye&&Ye.isTypedArray;const Ke=$e?He($e):Ue;var Qe=Object.prototype.hasOwnProperty;const Ze=function(t,e){var n=ht(t),o=!n&&Ne(t),i=!n&&!o&&Oe(t),r=!n&&!o&&!i&&Ke(t),s=n||o||i||r,a=s?De(t.length,String):[],c=a.length;for(var l in t)!e&&!Qe.call(t,l)||s&&("length"==l||i&&("offset"==l||"parent"==l)||r&&("buffer"==l||"byteLength"==l||"byteOffset"==l)||je(l,c))||a.push(l);return a};var Je=Object.prototype;const Xe=function(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||Je)};const tn=pt(Object.keys,Object);var en=Object.prototype.hasOwnProperty;const nn=function(t){if(!Xe(t))return tn(t);var e=[];for(var n in Object(t))en.call(t,n)&&"constructor"!=n&&e.push(n);return e};const on=function(t){return null!=t&&Fe(t.length)&&!Ot(t)};const rn=function(t){return on(t)?Ze(t):nn(t)};const sn=function(t,e){return t&&Ee(e,rn(e),t)};const an=function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e};var cn=Object.prototype.hasOwnProperty;const ln=function(t){if(!L(t))return an(t);var e=Xe(t),n=[];for(var o in t)("constructor"!=o||!e&&cn.call(t,o))&&n.push(o);return n};const dn=function(t){return on(t)?Ze(t,!0):ln(t)};const hn=function(t,e){return t&&Ee(e,dn(e),t)};var un=exports&&!exports.nodeType&&exports,gn=un&&"object"=='object'&&module&&!module.nodeType&&module,mn=gn&&gn.exports===un?tt.Buffer:void 0,pn=mn?mn.allocUnsafe:void 0;const fn=function(t,e){if(e)return t.slice();var n=t.length,o=pn?pn(n):new t.constructor(n);return t.copy(o),o};const kn=function(t,e){var n=-1,o=t.length;for(e||(e=Array(o));++n<o;)e[n]=t[n];return e};const bn=function(t,e){for(var n=-1,o=null==t?0:t.length,i=0,r=[];++n<o;){var s=t[n];e(s,n,t)&&(r[i++]=s);}return r};const wn=function(){return []};var _n=Object.prototype.propertyIsEnumerable,An=Object.getOwnPropertySymbols;const Cn=An?function(t){return null==t?[]:(t=Object(t),bn(An(t),(function(e){return _n.call(t,e)})))}:wn;const vn=function(t,e){return Ee(t,Cn(t),e)};const yn=function(t,e){for(var n=-1,o=e.length,i=t.length;++n<o;)t[i+n]=e[n];return t};const xn=Object.getOwnPropertySymbols?function(t){for(var e=[];t;)yn(e,Cn(t)),t=ft(t);return e}:wn;const En=function(t,e){return Ee(t,xn(t),e)};const Dn=function(t,e,n){var o=e(t);return ht(t)?o:yn(o,n(t))};const In=function(t){return Dn(t,rn,Cn)};const Mn=function(t){return Dn(t,dn,xn)};const Tn=Zt(tt,"DataView");const Sn=Zt(tt,"Promise");const Nn=Zt(tt,"Set");const Bn=Zt(tt,"WeakMap");var Pn="[object Map]",zn="[object Promise]",Ln="[object Set]",On="[object WeakMap]",Rn="[object DataView]",jn=Ut(Tn),Fn=Ut(Jt),Vn=Ut(Sn),Un=Ut(Nn),Hn=Ut(Bn),Wn=dt;(Tn&&Wn(new Tn(new ArrayBuffer(1)))!=Rn||Jt&&Wn(new Jt)!=Pn||Sn&&Wn(Sn.resolve())!=zn||Nn&&Wn(new Nn)!=Ln||Bn&&Wn(new Bn)!=On)&&(Wn=function(t){var e=dt(t),n="[object Object]"==e?t.constructor:void 0,o=n?Ut(n):"";if(o)switch(o){case jn:return Rn;case Fn:return Pn;case Vn:return zn;case Un:return Ln;case Hn:return On}return e});const Gn=Wn;var qn=Object.prototype.hasOwnProperty;const Yn=function(t){var e=t.length,n=new t.constructor(e);return e&&"string"==typeof t[0]&&qn.call(t,"index")&&(n.index=t.index,n.input=t.input),n};const $n=tt.Uint8Array;const Kn=function(t){var e=new t.constructor(t.byteLength);return new $n(e).set(new $n(t)),e};const Qn=function(t,e){var n=e?Kn(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)};var Zn=/\w*$/;const Jn=function(t){var e=new t.constructor(t.source,Zn.exec(t));return e.lastIndex=t.lastIndex,e};var Xn=et?et.prototype:void 0,to=Xn?Xn.valueOf:void 0;const eo=function(t){return to?Object(to.call(t)):{}};const no=function(t,e){var n=e?Kn(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)};const oo=function(t,e,n){var o=t.constructor;switch(e){case"[object ArrayBuffer]":return Kn(t);case"[object Boolean]":case"[object Date]":return new o(+t);case"[object DataView]":return Qn(t,n);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Uint16Array]":case"[object Uint32Array]":return no(t,n);case"[object Map]":case"[object Set]":return new o;case"[object Number]":case"[object String]":return new o(t);case"[object RegExp]":return Jn(t);case"[object Symbol]":return eo(t)}};var io=Object.create;const ro=function(){function t(){}return function(e){if(!L(e))return {};if(io)return io(e);t.prototype=e;var n=new t;return t.prototype=void 0,n}}();const so=function(t){return "function"!=typeof t.constructor||Xe(t)?{}:ro(ft(t))};const ao=function(t){return ut(t)&&"[object Map]"==Gn(t)};var co=Ye&&Ye.isMap;const lo=co?He(co):ao;const ho=function(t){return ut(t)&&"[object Set]"==Gn(t)};var uo=Ye&&Ye.isSet;const go=uo?He(uo):ho;var mo="[object Arguments]",po="[object Function]",fo="[object Object]",ko={};ko[mo]=ko["[object Array]"]=ko["[object ArrayBuffer]"]=ko["[object DataView]"]=ko["[object Boolean]"]=ko["[object Date]"]=ko["[object Float32Array]"]=ko["[object Float64Array]"]=ko["[object Int8Array]"]=ko["[object Int16Array]"]=ko["[object Int32Array]"]=ko["[object Map]"]=ko["[object Number]"]=ko[fo]=ko["[object RegExp]"]=ko["[object Set]"]=ko["[object String]"]=ko["[object Symbol]"]=ko["[object Uint8Array]"]=ko["[object Uint8ClampedArray]"]=ko["[object Uint16Array]"]=ko["[object Uint32Array]"]=!0,ko["[object Error]"]=ko[po]=ko["[object WeakMap]"]=!1;const bo=function t(e,n,o,i,r,s){var a,c=1&n,l=2&n,d=4&n;if(o&&(a=r?o(e,i,r,s):o(e)),void 0!==a)return a;if(!L(e))return e;var h=ht(e);if(h){if(a=Yn(e),!c)return kn(e,a)}else {var u=Gn(e),g=u==po||"[object GeneratorFunction]"==u;if(Oe(e))return fn(e,c);if(u==fo||u==mo||g&&!r){if(a=l||g?{}:so(e),!c)return l?En(e,hn(a,e)):vn(e,sn(a,e))}else {if(!ko[u])return r?e:{};a=oo(e,u,c);}}s||(s=new _e);var m=s.get(e);if(m)return m;s.set(e,a),go(e)?e.forEach((function(i){a.add(t(i,n,o,i,e,s));})):lo(e)&&e.forEach((function(i,r){a.set(r,t(i,n,o,r,e,s));}));var p=h?void 0:(d?l?Mn:In:l?dn:rn)(e);return Ae(p||e,(function(i,r){p&&(i=e[r=i]),xe(a,r,t(i,n,o,r,e,s));})),a};const wo=function(t,e){return bo(t,5,e="function"==typeof e?e:void 0)};const _o=function(t){return ut(t)&&1===t.nodeType&&!Ct(t)};class Ao{constructor(t,e){this._config={},e&&this.define(Co(e)),t&&this._setObjectToTarget(this._config,t);}set(t,e){this._setToTarget(this._config,t,e);}define(t,e){this._setToTarget(this._config,t,e,!0);}get(t){return this._getFromSource(this._config,t)}*names(){for(const t of Object.keys(this._config))yield t;}_setToTarget(t,e,n,o=!1){if(Ct(e))return void this._setObjectToTarget(t,e,o);const i=e.split(".");e=i.pop();for(const e of i)Ct(t[e])||(t[e]={}),t=t[e];if(Ct(n))return Ct(t[e])||(t[e]={}),t=t[e],void this._setObjectToTarget(t,n,o);o&&void 0!==t[e]||(t[e]=n);}_getFromSource(t,e){const n=e.split(".");e=n.pop();for(const e of n){if(!Ct(t[e])){t=null;break}t=t[e];}return t?Co(t[e]):void 0}_setObjectToTarget(t,e,n){Object.keys(e).forEach((o=>{this._setToTarget(t,o,e[o],n);}));}}function Co(t){return wo(t,vo)}function vo(t){return _o(t)?t:void 0}function yo(t){if(t){if(t.defaultView)return t instanceof t.defaultView.Document;if(t.ownerDocument&&t.ownerDocument.defaultView)return t instanceof t.ownerDocument.defaultView.Node}return !1}function xo(t){const e=Object.prototype.toString.apply(t);return "[object Window]"==e||"[object global]"==e}const Eo=Do(I());function Do(t){if(!t)return Eo;return class extends t{listenTo(t,e,n,o={}){if(yo(t)||xo(t)){const i={capture:!!o.useCapture,passive:!!o.usePassive},r=this._getProxyEmitter(t,i)||new Io(t,i);this.listenTo(r,e,n,o);}else super.listenTo(t,e,n,o);}stopListening(t,e,n){if(yo(t)||xo(t)){const o=this._getAllProxyEmitters(t);for(const t of o)this.stopListening(t,e,n);}else super.stopListening(t,e,n);}_getProxyEmitter(t,e){return function(t,e){const n=t[y];return n&&n[e]?n[e].emitter:null}(this,Mo(t,e))}_getAllProxyEmitters(t){return [{capture:!1,passive:!1},{capture:!1,passive:!0},{capture:!0,passive:!1},{capture:!0,passive:!0}].map((e=>this._getProxyEmitter(t,e))).filter((t=>!!t))}}}["_getProxyEmitter","_getAllProxyEmitters","on","once","off","listenTo","stopListening","fire","delegate","stopDelegating","_addEventListener","_removeEventListener"].forEach((t=>{Do[t]=Eo.prototype[t];}));class Io extends(I()){constructor(t,e){super(),M(this,Mo(t,e)),this._domNode=t,this._options=e;}attach(t){if(this._domListeners&&this._domListeners[t])return;const e=this._createDomListener(t);this._domNode.addEventListener(t,e,this._options),this._domListeners||(this._domListeners={}),this._domListeners[t]=e;}detach(t){let e;!this._domListeners[t]||(e=this._events[t])&&e.callbacks.length||this._domListeners[t].removeListener();}_addEventListener(t,e,n){this.attach(t),I().prototype._addEventListener.call(this,t,e,n);}_removeEventListener(t,e){I().prototype._removeEventListener.call(this,t,e),this.detach(t);}_createDomListener(t){const e=e=>{this.fire(t,e);};return e.removeListener=()=>{this._domNode.removeEventListener(t,e,this._options),delete this._domListeners[t];},e}}function Mo(t,e){let n=function(t){return t["data-ck-expando"]||(t["data-ck-expando"]=m())}(t);for(const t of Object.keys(e).sort())e[t]&&(n+="-"+t);return n}let To;try{To={window,document};}catch(t){To={window:{},document:{}};}const So=To;function No(t){const e=[];let n=t;for(;n&&n.nodeType!=Node.DOCUMENT_NODE;)e.unshift(n),n=n.parentNode;return e}function Bo(t){return "[object Text]"==Object.prototype.toString.call(t)}function Po(t){return "[object Range]"==Object.prototype.toString.apply(t)}function zo(t){const e=t.ownerDocument.defaultView.getComputedStyle(t);return {top:parseInt(e.borderTopWidth,10),right:parseInt(e.borderRightWidth,10),bottom:parseInt(e.borderBottomWidth,10),left:parseInt(e.borderLeftWidth,10)}}const Lo=["top","right","bottom","left","width","height"];class Oo{constructor(t){const e=Po(t);if(Object.defineProperty(this,"_source",{value:t._source||t,writable:!0,enumerable:!1}),Fo(t)||e)if(e){const e=Oo.getDomRangeRects(t);Ro(this,Oo.getBoundingRect(e));}else Ro(this,t.getBoundingClientRect());else if(xo(t)){const{innerWidth:e,innerHeight:n}=t;Ro(this,{top:0,right:e,bottom:n,left:0,width:e,height:n});}else Ro(this,t);}clone(){return new Oo(this)}moveTo(t,e){return this.top=e,this.right=t+this.width,this.bottom=e+this.height,this.left=t,this}moveBy(t,e){return this.top+=e,this.right+=t,this.left+=t,this.bottom+=e,this}getIntersection(t){const e={top:Math.max(this.top,t.top),right:Math.min(this.right,t.right),bottom:Math.min(this.bottom,t.bottom),left:Math.max(this.left,t.left),width:0,height:0};return e.width=e.right-e.left,e.height=e.bottom-e.top,e.width<0||e.height<0?null:new Oo(e)}getIntersectionArea(t){const e=this.getIntersection(t);return e?e.getArea():0}getArea(){return this.width*this.height}getVisible(){const t=this._source;let e=this.clone();if(!jo(t)){let n=t.parentNode||t.commonAncestorContainer;for(;n&&!jo(n);){const t=new Oo(n),o=e.getIntersection(t);if(!o)return null;o.getArea()<e.getArea()&&(e=o),n=n.parentNode;}}return e}isEqual(t){for(const e of Lo)if(this[e]!==t[e])return !1;return !0}contains(t){const e=this.getIntersection(t);return !(!e||!e.isEqual(t))}excludeScrollbarsAndBorders(){const t=this._source;let e,n,o;if(xo(t))e=t.innerWidth-t.document.documentElement.clientWidth,n=t.innerHeight-t.document.documentElement.clientHeight,o=t.getComputedStyle(t.document.documentElement).direction;else {const i=zo(t);e=t.offsetWidth-t.clientWidth-i.left-i.right,n=t.offsetHeight-t.clientHeight-i.top-i.bottom,o=t.ownerDocument.defaultView.getComputedStyle(t).direction,this.left+=i.left,this.top+=i.top,this.right-=i.right,this.bottom-=i.bottom,this.width=this.right-this.left,this.height=this.bottom-this.top;}return this.width-=e,"ltr"===o?this.right-=e:this.left+=e,this.height-=n,this.bottom-=n,this}static getDomRangeRects(t){const e=[],n=Array.from(t.getClientRects());if(n.length)for(const t of n)e.push(new Oo(t));else {let n=t.startContainer;Bo(n)&&(n=n.parentNode);const o=new Oo(n.getBoundingClientRect());o.right=o.left,o.width=0,e.push(o);}return e}static getBoundingRect(t){const e={left:Number.POSITIVE_INFINITY,top:Number.POSITIVE_INFINITY,right:Number.NEGATIVE_INFINITY,bottom:Number.NEGATIVE_INFINITY,width:0,height:0};let n=0;for(const o of t)n++,e.left=Math.min(e.left,o.left),e.top=Math.min(e.top,o.top),e.right=Math.max(e.right,o.right),e.bottom=Math.max(e.bottom,o.bottom);return 0==n?null:(e.width=e.right-e.left,e.height=e.bottom-e.top,new Oo(e))}}function Ro(t,e){for(const n of Lo)t[n]=e[n];}function jo(t){return !!Fo(t)&&t===t.ownerDocument.body}function Fo(t){return null!==t&&"object"==typeof t&&1===t.nodeType&&"function"==typeof t.getBoundingClientRect}class Vo{constructor(t,e){Vo._observerInstance||Vo._createObserver(),this._element=t,this._callback=e,Vo._addElementCallback(t,e),Vo._observerInstance.observe(t);}destroy(){Vo._deleteElementCallback(this._element,this._callback);}static _addElementCallback(t,e){Vo._elementCallbacks||(Vo._elementCallbacks=new Map);let n=Vo._elementCallbacks.get(t);n||(n=new Set,Vo._elementCallbacks.set(t,n)),n.add(e);}static _deleteElementCallback(t,e){const n=Vo._getElementCallbacks(t);n&&(n.delete(e),n.size||(Vo._elementCallbacks.delete(t),Vo._observerInstance.unobserve(t))),Vo._elementCallbacks&&!Vo._elementCallbacks.size&&(Vo._observerInstance=null,Vo._elementCallbacks=null);}static _getElementCallbacks(t){return Vo._elementCallbacks?Vo._elementCallbacks.get(t):null}static _createObserver(){Vo._observerInstance=new So.window.ResizeObserver((t=>{for(const e of t){const t=Vo._getElementCallbacks(e.target);if(t)for(const n of t)n(e);}}));}}function Uo(t,e){t instanceof HTMLTextAreaElement&&(t.value=e),t.innerHTML=e;}function Ho(t){return e=>e+t}function Wo(t){let e=0;for(;t.previousSibling;)t=t.previousSibling,e++;return e}function Go(t,e,n){t.insertBefore(n,t.childNodes[e]||null);}function qo(t){return t&&t.nodeType===Node.COMMENT_NODE}function Yo(t){return !!(t&&t.getClientRects&&t.getClientRects().length)}function $o({element:t,target:e,positions:n,limiter:o,fitInViewport:i,viewportOffsetConfig:r}){Ot(e)&&(e=e()),Ot(o)&&(o=o());const s=function(t){return t&&t.parentNode?t.offsetParent===So.document.body?null:t.offsetParent:null}(t),a=new Oo(t),c=new Oo(e);let l;const d=i&&function(t){t=Object.assign({top:0,bottom:0,left:0,right:0},t);const e=new Oo(So.window);return e.top+=t.top,e.height-=t.top,e.bottom-=t.bottom,e.height-=t.bottom,e}(r)||null,h={targetRect:c,elementRect:a,positionedElementAncestor:s,viewportRect:d};if(o||i){const t=o&&new Oo(o).getVisible();Object.assign(h,{limiterRect:t,viewportRect:d}),l=function(t,e){const{elementRect:n}=e,o=n.getArea(),i=t.map((t=>new Qo(t,e))).filter((t=>!!t.name));let r=0,s=null;for(const t of i){const{limiterIntersectionArea:e,viewportIntersectionArea:n}=t;if(e===o)return t;const i=n**2+e**2;i>r&&(r=i,s=t);}return s}(n,h)||new Qo(n[0],h);}else l=new Qo(n[0],h);return l}function Ko(t){const{scrollX:e,scrollY:n}=So.window;return t.clone().moveBy(e,n)}Vo._observerInstance=null,Vo._elementCallbacks=null;class Qo{constructor(t,e){const n=t(e.targetRect,e.elementRect,e.viewportRect);if(!n)return;const{left:o,top:i,name:r,config:s}=n;this.name=r,this.config=s,this._positioningFunctionCorrdinates={left:o,top:i},this._options=e;}get left(){return this._absoluteRect.left}get top(){return this._absoluteRect.top}get limiterIntersectionArea(){const t=this._options.limiterRect;if(t){const e=this._options.viewportRect;if(!e)return t.getIntersectionArea(this._rect);{const n=t.getIntersection(e);if(n)return n.getIntersectionArea(this._rect)}}return 0}get viewportIntersectionArea(){const t=this._options.viewportRect;return t?t.getIntersectionArea(this._rect):0}get _rect(){return this._cachedRect||(this._cachedRect=this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left,this._positioningFunctionCorrdinates.top)),this._cachedRect}get _absoluteRect(){return this._cachedAbsoluteRect||(this._cachedAbsoluteRect=Ko(this._rect),this._options.positionedElementAncestor&&function(t,e){const n=Ko(new Oo(e)),o=zo(e);let i=0,r=0;i-=n.left,r-=n.top,i+=e.scrollLeft,r+=e.scrollTop,i-=o.left,r-=o.top,t.moveBy(i,r);}(this._cachedAbsoluteRect,this._options.positionedElementAncestor)),this._cachedAbsoluteRect}}function Zo(t){const e=t.parentNode;e&&e.removeChild(t);}function Jo(t,e,n){const o=e.clone().moveBy(0,n),i=e.clone().moveBy(0,-n),r=new Oo(t).excludeScrollbarsAndBorders();if(![i,o].every((t=>r.contains(t)))){let{scrollX:s,scrollY:a}=t;ei(i,r)?a-=r.top-e.top+n:ti(o,r)&&(a+=e.bottom-r.bottom+n),ni(e,r)?s-=r.left-e.left+n:oi(e,r)&&(s+=e.right-r.right+n),t.scrollTo(s,a);}}function Xo(t,e){const n=ii(t);let o,i;for(;t!=n.document.body;)i=e(),o=new Oo(t).excludeScrollbarsAndBorders(),o.contains(i)||(ei(i,o)?t.scrollTop-=o.top-i.top:ti(i,o)&&(t.scrollTop+=i.bottom-o.bottom),ni(i,o)?t.scrollLeft-=o.left-i.left:oi(i,o)&&(t.scrollLeft+=i.right-o.right)),t=t.parentNode;}function ti(t,e){return t.bottom>e.bottom}function ei(t,e){return t.top<e.top}function ni(t,e){return t.left<e.left}function oi(t,e){return t.right>e.right}function ii(t){return Po(t)?t.startContainer.ownerDocument.defaultView:t.ownerDocument.defaultView}function ri(t){if(Po(t)){let e=t.commonAncestorContainer;return Bo(e)&&(e=e.parentNode),e}return t.parentNode}function si(t,e){const n=ii(t),o=new Oo(t);if(n===e)return o;{let t=n;for(;t!=e;){const e=t.frameElement,n=new Oo(e).excludeScrollbarsAndBorders();o.moveBy(n.left,n.top),t=t.parent;}}return o}const ai={ctrl:"⌃",cmd:"⌘",alt:"⌥",shift:"⇧"},ci={ctrl:"Ctrl+",alt:"Alt+",shift:"Shift+"},li=function(){const t={arrowleft:37,arrowup:38,arrowright:39,arrowdown:40,backspace:8,delete:46,enter:13,space:32,esc:27,tab:9,ctrl:1114112,shift:2228224,alt:4456448,cmd:8912896};for(let e=65;e<=90;e++){t[String.fromCharCode(e).toLowerCase()]=e;}for(let e=48;e<=57;e++)t[e-48]=e;for(let e=112;e<=123;e++)t["f"+(e-111)]=e;for(const e of "`-=[];',./\\")t[e]=e.charCodeAt(0);return t}(),di=Object.fromEntries(Object.entries(li).map((([t,e])=>[e,t.charAt(0).toUpperCase()+t.slice(1)])));function hi(t){let e;if("string"==typeof t){if(e=li[t.toLowerCase()],!e)throw new k("keyboard-unknown-key",null,{key:t})}else e=t.keyCode+(t.altKey?li.alt:0)+(t.ctrlKey?li.ctrl:0)+(t.shiftKey?li.shift:0)+(t.metaKey?li.cmd:0);return e}function ui(t){return "string"==typeof t&&(t=function(t){return t.split("+").map((t=>t.trim()))}(t)),t.map((t=>"string"==typeof t?function(t){if(t.endsWith("!"))return hi(t.slice(0,-1));const e=hi(t);return i.isMac&&e==li.ctrl?li.cmd:e}(t):t)).reduce(((t,e)=>e+t),0)}function gi(t){let e=ui(t);return Object.entries(i.isMac?ai:ci).reduce(((t,[n,o])=>(0!=(e&li[n])&&(e&=~li[n],t+=o),t)),"")+(e?di[e]:"")}function mi(t,e){const n="ltr"===e;switch(t){case li.arrowleft:return n?"left":"right";case li.arrowright:return n?"right":"left";case li.arrowup:return "up";case li.arrowdown:return "down"}}function pi(t){return Array.isArray(t)?t:[t]}function fi(t,e,n=1){if("number"!=typeof n)throw new k("translation-service-quantity-not-a-number",null,{quantity:n});const o=Object.keys(So.window.CKEDITOR_TRANSLATIONS).length;1===o&&(t=Object.keys(So.window.CKEDITOR_TRANSLATIONS)[0]);const i=e.id||e.string;if(0===o||!function(t,e){return !!So.window.CKEDITOR_TRANSLATIONS[t]&&!!So.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]}(t,i))return 1!==n?e.plural:e.string;const r=So.window.CKEDITOR_TRANSLATIONS[t].dictionary,s=So.window.CKEDITOR_TRANSLATIONS[t].getPluralForm||(t=>1===t?0:1),a=r[i];if("string"==typeof a)return a;return a[Number(s(n))]}So.window.CKEDITOR_TRANSLATIONS||(So.window.CKEDITOR_TRANSLATIONS={});const ki=["ar","ara","fa","per","fas","he","heb","ku","kur","ug","uig"];function bi(t){return ki.includes(t)?"rtl":"ltr"}class wi{constructor({uiLanguage:t="en",contentLanguage:e}={}){this.uiLanguage=t,this.contentLanguage=e||this.uiLanguage,this.uiLanguageDirection=bi(this.uiLanguage),this.contentLanguageDirection=bi(this.contentLanguage),this.t=(t,e)=>this._t(t,e);}get language(){return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."),this.uiLanguage}_t(t,e=[]){e=pi(e),"string"==typeof t&&(t={string:t});const n=!!t.plural?e[0]:1;return function(t,e){return t.replace(/%(\d+)/g,((t,n)=>n<e.length?e[n]:t))}(fi(this.uiLanguage,t,n),e)}}class _i extends(I()){constructor(t={},e={}){super();const n=Z(t);if(n||(e=t),this._items=[],this._itemMap=new Map,this._idProperty=e.idProperty||"id",this._bindToExternalToInternalMap=new WeakMap,this._bindToInternalToExternalMap=new WeakMap,this._skippedIndexesFromExternal=[],n)for(const e of t)this._items.push(e),this._itemMap.set(this._getItemIdBeforeAdding(e),e);}get length(){return this._items.length}get first(){return this._items[0]||null}get last(){return this._items[this.length-1]||null}add(t,e){return this.addMany([t],e)}addMany(t,e){if(void 0===e)e=this._items.length;else if(e>this._items.length||e<0)throw new k("collection-add-item-invalid-index",this);let n=0;for(const o of t){const t=this._getItemIdBeforeAdding(o),i=e+n;this._items.splice(i,0,o),this._itemMap.set(t,o),this.fire("add",o,i),n++;}return this.fire("change",{added:t,removed:[],index:e}),this}get(t){let e;if("string"==typeof t)e=this._itemMap.get(t);else {if("number"!=typeof t)throw new k("collection-get-invalid-arg",this);e=this._items[t];}return e||null}has(t){if("string"==typeof t)return this._itemMap.has(t);{const e=t[this._idProperty];return e&&this._itemMap.has(e)}}getIndex(t){let e;return e="string"==typeof t?this._itemMap.get(t):t,e?this._items.indexOf(e):-1}remove(t){const[e,n]=this._remove(t);return this.fire("change",{added:[],removed:[e],index:n}),e}map(t,e){return this._items.map(t,e)}find(t,e){return this._items.find(t,e)}filter(t,e){return this._items.filter(t,e)}clear(){this._bindToCollection&&(this.stopListening(this._bindToCollection),this._bindToCollection=null);const t=Array.from(this._items);for(;this.length;)this._remove(0);this.fire("change",{added:[],removed:t,index:0});}bindTo(t){if(this._bindToCollection)throw new k("collection-bind-to-rebind",this);return this._bindToCollection=t,{as:t=>{this._setUpBindToBinding((e=>new t(e)));},using:t=>{"function"==typeof t?this._setUpBindToBinding(t):this._setUpBindToBinding((e=>e[t]));}}}_setUpBindToBinding(t){const e=this._bindToCollection,n=(n,o,i)=>{const r=e._bindToCollection==this,s=e._bindToInternalToExternalMap.get(o);if(r&&s)this._bindToExternalToInternalMap.set(o,s),this._bindToInternalToExternalMap.set(s,o);else {const n=t(o);if(!n)return void this._skippedIndexesFromExternal.push(i);let r=i;for(const t of this._skippedIndexesFromExternal)i>t&&r--;for(const t of e._skippedIndexesFromExternal)r>=t&&r++;this._bindToExternalToInternalMap.set(o,n),this._bindToInternalToExternalMap.set(n,o),this.add(n,r);for(let t=0;t<e._skippedIndexesFromExternal.length;t++)r<=e._skippedIndexesFromExternal[t]&&e._skippedIndexesFromExternal[t]++;}};for(const t of e)n(0,t,e.getIndex(t));this.listenTo(e,"add",n),this.listenTo(e,"remove",((t,e,n)=>{const o=this._bindToExternalToInternalMap.get(e);o&&this.remove(o),this._skippedIndexesFromExternal=this._skippedIndexesFromExternal.reduce(((t,e)=>(n<e&&t.push(e-1),n>e&&t.push(e),t)),[]);}));}_getItemIdBeforeAdding(t){const e=this._idProperty;let n;if(e in t){if(n=t[e],"string"!=typeof n)throw new k("collection-add-invalid-id",this);if(this.get(n))throw new k("collection-add-item-already-exists",this)}else t[e]=n=m();return n}_remove(t){let e,n,o,i=!1;const r=this._idProperty;if("string"==typeof t?(n=t,o=this._itemMap.get(n),i=!o,o&&(e=this._items.indexOf(o))):"number"==typeof t?(e=t,o=this._items[e],i=!o,o&&(n=o[r])):(o=t,n=o[r],e=this._items.indexOf(o),i=-1==e||!this._itemMap.get(n)),i)throw new k("collection-remove-404",this);this._items.splice(e,1),this._itemMap.delete(n);const s=this._bindToInternalToExternalMap.get(o);return this._bindToInternalToExternalMap.delete(o),this._bindToExternalToInternalMap.delete(s),this.fire("remove",o,e),[o,e]}[Symbol.iterator](){return this._items[Symbol.iterator]()}}function Ai(t){const e=t.next();return e.done?null:e.value}class Ci extends(Do(H())){constructor(){super(),this._elements=new Set,this._nextEventLoopTimeout=null,this.set("isFocused",!1),this.set("focusedElement",null);}add(t){if(this._elements.has(t))throw new k("focustracker-add-element-already-exist",this);this.listenTo(t,"focus",(()=>this._focus(t)),{useCapture:!0}),this.listenTo(t,"blur",(()=>this._blur()),{useCapture:!0}),this._elements.add(t);}remove(t){t===this.focusedElement&&this._blur(),this._elements.has(t)&&(this.stopListening(t),this._elements.delete(t));}destroy(){this.stopListening();}_focus(t){clearTimeout(this._nextEventLoopTimeout),this.focusedElement=t,this.isFocused=!0;}_blur(){clearTimeout(this._nextEventLoopTimeout),this._nextEventLoopTimeout=setTimeout((()=>{this.focusedElement=null,this.isFocused=!1;}),0);}}class vi{constructor(){this._listener=new(Do());}listenTo(t){this._listener.listenTo(t,"keydown",((t,e)=>{this._listener.fire("_keydown:"+hi(e),e);}));}set(t,e,n={}){const o=ui(t),i=n.priority;this._listener.listenTo(this._listener,"_keydown:"+o,((t,n)=>{e(n,(()=>{n.preventDefault(),n.stopPropagation(),t.stop();})),t.return=!0;}),{priority:i});}press(t){return !!this._listener.fire("_keydown:"+hi(t),t)}destroy(){this._listener.stopListening();}}function yi(t){return Z(t)?new Map(t):function(t){const e=new Map;for(const n in t)e.set(n,t[n]);return e}(t)}function xi(t,e){return !!(n=t.charAt(e-1))&&1==n.length&&/[\ud800-\udbff]/.test(n)&&function(t){return !!t&&1==t.length&&/[\udc00-\udfff]/.test(t)}(t.charAt(e));var n;}function Ei(t,e){return !!(n=t.charAt(e))&&1==n.length&&/[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n);var n;}const Di=function(){const t=/\p{Regional_Indicator}{2}/u.source,e="(?:"+[/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,/\p{Emoji}\u{FE0F}?\u{20E3}/u,/\p{Emoji}\u{FE0F}/u,/(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u].map((t=>t.source)).join("|")+")";return new RegExp(`${t}|${e}(?:‍${e})*`,"ug")}();function Ii(t,e){const n=String(t).matchAll(Di);return Array.from(n).some((t=>t.index<e&&e<t.index+t[0].length))}class Mi extends(H()){constructor(t){super(),this.editor=t,this.set("isEnabled",!0),this._disableStack=new Set;}forceDisabled(t){this._disableStack.add(t),1==this._disableStack.size&&(this.on("set:isEnabled",Ti,{priority:"highest"}),this.isEnabled=!1);}clearForceDisabled(t){this._disableStack.delete(t),0==this._disableStack.size&&(this.off("set:isEnabled",Ti),this.isEnabled=!0);}destroy(){this.stopListening();}static get isContextPlugin(){return !1}}function Ti(t){t.return=!1,t.stop();}class Si extends(H()){constructor(t){super(),this.editor=t,this.set("value",void 0),this.set("isEnabled",!1),this._affectsData=!0,this._disableStack=new Set,this.decorate("execute"),this.listenTo(this.editor.model.document,"change",(()=>{this.refresh();})),this.on("execute",(t=>{this.isEnabled||t.stop();}),{priority:"high"}),this.listenTo(t,"change:isReadOnly",((t,e,n)=>{n&&this.affectsData?this.forceDisabled("readOnlyMode"):this.clearForceDisabled("readOnlyMode");}));}get affectsData(){return this._affectsData}set affectsData(t){this._affectsData=t;}refresh(){this.isEnabled=!0;}forceDisabled(t){this._disableStack.add(t),1==this._disableStack.size&&(this.on("set:isEnabled",Ni,{priority:"highest"}),this.isEnabled=!1);}clearForceDisabled(t){this._disableStack.delete(t),0==this._disableStack.size&&(this.off("set:isEnabled",Ni),this.refresh());}execute(...t){}destroy(){this.stopListening();}}function Ni(t){t.return=!1,t.stop();}class Bi extends Si{constructor(t){super(t),this._childCommandsDefinitions=[];}refresh(){}execute(...t){const e=this._getFirstEnabledCommand();return !!e&&e.execute(t)}registerChildCommand(t,e={}){f(this._childCommandsDefinitions,{command:t,priority:e.priority||"normal"}),t.on("change:isEnabled",(()=>this._checkEnabled())),this._checkEnabled();}_checkEnabled(){this.isEnabled=!!this._getFirstEnabledCommand();}_getFirstEnabledCommand(){const t=this._childCommandsDefinitions.find((({command:t})=>t.isEnabled));return t&&t.command}}class Pi extends(I()){constructor(t,e=[],n=[]){super(),this._context=t,this._plugins=new Map,this._availablePlugins=new Map;for(const t of e)t.pluginName&&this._availablePlugins.set(t.pluginName,t);this._contextPlugins=new Map;for(const[t,e]of n)this._contextPlugins.set(t,e),this._contextPlugins.set(e,t),t.pluginName&&this._availablePlugins.set(t.pluginName,t);}*[Symbol.iterator](){for(const t of this._plugins)"function"==typeof t[0]&&(yield t);}get(t){const e=this._plugins.get(t);if(!e){let e=t;throw "function"==typeof t&&(e=t.pluginName||t.name),new k("plugincollection-plugin-not-loaded",this._context,{plugin:e})}return e}has(t){return this._plugins.has(t)}init(t,e=[],n=[]){const o=this,i=this._context;!function t(e,n=new Set){e.forEach((e=>{a(e)&&(n.has(e)||(n.add(e),e.pluginName&&!o._availablePlugins.has(e.pluginName)&&o._availablePlugins.set(e.pluginName,e),e.requires&&t(e.requires,n)));}));}(t),h(t);const r=[...function t(e,n=new Set){return e.map((t=>a(t)?t:o._availablePlugins.get(t))).reduce(((e,o)=>n.has(o)?e:(n.add(o),o.requires&&(h(o.requires,o),t(o.requires,n).forEach((t=>e.add(t)))),e.add(o))),new Set)}(t.filter((t=>!l(t,e))))];!function(t,e){for(const n of e){if("function"!=typeof n)throw new k("plugincollection-replace-plugin-invalid-type",null,{pluginItem:n});const e=n.pluginName;if(!e)throw new k("plugincollection-replace-plugin-missing-name",null,{pluginItem:n});if(n.requires&&n.requires.length)throw new k("plugincollection-plugin-for-replacing-cannot-have-dependencies",null,{pluginName:e});const i=o._availablePlugins.get(e);if(!i)throw new k("plugincollection-plugin-for-replacing-not-exist",null,{pluginName:e});const r=t.indexOf(i);if(-1===r){if(o._contextPlugins.has(i))return;throw new k("plugincollection-plugin-for-replacing-not-loaded",null,{pluginName:e})}if(i.requires&&i.requires.length)throw new k("plugincollection-replaced-plugin-cannot-have-dependencies",null,{pluginName:e});t.splice(r,1,n),o._availablePlugins.set(e,n);}}(r,n);const s=function(t){return t.map((t=>{let e=o._contextPlugins.get(t);return e=e||new t(i),o._add(t,e),e}))}(r);return u(s,"init").then((()=>u(s,"afterInit"))).then((()=>s));function a(t){return "function"==typeof t}function c(t){return a(t)&&t.isContextPlugin}function l(t,e){return e.some((e=>e===t||(d(t)===e||d(e)===t)))}function d(t){return a(t)?t.pluginName||t.name:t}function h(t,n=null){t.map((t=>a(t)?t:o._availablePlugins.get(t)||t)).forEach((t=>{!function(t,e){if(a(t))return;if(e)throw new k("plugincollection-soft-required",i,{missingPlugin:t,requiredBy:d(e)});throw new k("plugincollection-plugin-not-found",i,{plugin:t})}(t,n),function(t,e){if(!c(e))return;if(c(t))return;throw new k("plugincollection-context-required",i,{plugin:d(t),requiredBy:d(e)})}(t,n),function(t,n){if(!n)return;if(!l(t,e))return;throw new k("plugincollection-required",i,{plugin:d(t),requiredBy:d(n)})}(t,n);}));}function u(t,e){return t.reduce(((t,n)=>n[e]?o._contextPlugins.has(n)?t:t.then(n[e].bind(n)):t),Promise.resolve())}}destroy(){const t=[];for(const[,e]of this)"function"!=typeof e.destroy||this._contextPlugins.has(e)||t.push(e.destroy());return Promise.all(t)}_add(t,e){this._plugins.set(t,e);const n=t.pluginName;if(n){if(this._plugins.has(n))throw new k("plugincollection-plugin-name-conflict",null,{pluginName:n,plugin1:this._plugins.get(n).constructor,plugin2:t});this._plugins.set(n,e);}}}class zi{constructor(t){this.config=new Ao(t,this.constructor.defaultConfig);const e=this.constructor.builtinPlugins;this.config.define("plugins",e),this.plugins=new Pi(this,e);const n=this.config.get("language")||{};this.locale=new wi({uiLanguage:"string"==typeof n?n:n.ui,contentLanguage:this.config.get("language.content")}),this.t=this.locale.t,this.editors=new _i,this._contextOwner=null;}initPlugins(){const t=this.config.get("plugins")||[],e=this.config.get("substitutePlugins")||[];for(const n of t.concat(e)){if("function"!=typeof n)throw new k("context-initplugins-constructor-only",null,{Plugin:n});if(!0!==n.isContextPlugin)throw new k("context-initplugins-invalid-plugin",null,{Plugin:n})}return this.plugins.init(t,[],e)}destroy(){return Promise.all(Array.from(this.editors,(t=>t.destroy()))).then((()=>this.plugins.destroy()))}_addEditor(t,e){if(this._contextOwner)throw new k("context-addeditor-private-context");this.editors.add(t),e&&(this._contextOwner=t);}_removeEditor(t){return this.editors.has(t)&&this.editors.remove(t),this._contextOwner===t?this.destroy():Promise.resolve()}_getEditorConfig(){const t={};for(const e of this.config.names())["plugins","removePlugins","extraPlugins"].includes(e)||(t[e]=this.config.get(e));return t}static create(t){return new Promise((e=>{const n=new this(t);e(n.initPlugins().then((()=>n)));}))}}class Li extends(H()){constructor(t){super(),this.context=t;}destroy(){this.stopListening();}static get isContextPlugin(){return !0}}var Oi=n(6062),Ri=n.n(Oi),ji=n(4717),Fi={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(ji.Z,Fi);ji.Z.locals;const Vi=new WeakMap;function Ui(t){const{view:e,element:n,text:o,isDirectHost:i=!0,keepOnFocus:r=!1}=t,s=e.document;Vi.has(s)||(Vi.set(s,new Map),s.registerPostFixer((t=>Wi(s,t))),s.on("change:isComposing",(()=>{e.change((t=>Wi(s,t)));}),{priority:"high"})),Vi.get(s).set(n,{text:o,isDirectHost:i,keepOnFocus:r,hostElement:i?n:null}),e.change((t=>Wi(s,t)));}function Hi(t,e){return !!e.hasClass("ck-placeholder")&&(t.removeClass("ck-placeholder",e),!0)}function Wi(t,e){const n=Vi.get(t),o=[];let i=!1;for(const[t,r]of n)r.isDirectHost&&(o.push(t),Gi(e,t,r)&&(i=!0));for(const[t,r]of n){if(r.isDirectHost)continue;const n=qi(t);n&&(o.includes(n)||(r.hostElement=n,Gi(e,t,r)&&(i=!0)));}return i}function Gi(t,e,n){const{text:o,isDirectHost:i,hostElement:r}=n;let s=!1;r.getAttribute("data-placeholder")!==o&&(t.setAttribute("data-placeholder",o,r),s=!0);return (i||1==e.childCount)&&function(t,e){if(!t.isAttached())return !1;const n=Array.from(t.getChildren()).some((t=>!t.is("uiElement")));if(n)return !1;const o=t.document,i=o.selection.anchor;return !(o.isComposing&&i&&i.parent===t||!e&&o.isFocused&&(!i||i.parent===t))}(r,n.keepOnFocus)?function(t,e){return !e.hasClass("ck-placeholder")&&(t.addClass("ck-placeholder",e),!0)}(t,r)&&(s=!0):Hi(t,r)&&(s=!0),s}function qi(t){if(t.childCount){const e=t.getChild(0);if(e.is("element")&&!e.is("uiElement")&&!e.is("attributeElement"))return e}return null}class Yi{is(){throw new Error("is() method is abstract")}}const $i=function(t){return bo(t,4)};class Ki extends(I(Yi)){constructor(t){super(),this.document=t,this.parent=null;}get index(){let t;if(!this.parent)return null;if(-1==(t=this.parent.getChildIndex(this)))throw new k("view-node-not-found-in-parent",this);return t}get nextSibling(){const t=this.index;return null!==t&&this.parent.getChild(t+1)||null}get previousSibling(){const t=this.index;return null!==t&&this.parent.getChild(t-1)||null}get root(){let t=this;for(;t.parent;)t=t.parent;return t}isAttached(){return this.root.is("rootElement")}getPath(){const t=[];let e=this;for(;e.parent;)t.unshift(e.index),e=e.parent;return t}getAncestors(t={}){const e=[];let n=t.includeSelf?this:this.parent;for(;n;)e[t.parentFirst?"push":"unshift"](n),n=n.parent;return e}getCommonAncestor(t,e={}){const n=this.getAncestors(e),o=t.getAncestors(e);let i=0;for(;n[i]==o[i]&&n[i];)i++;return 0===i?null:n[i-1]}isBefore(t){if(this==t)return !1;if(this.root!==t.root)return !1;const e=this.getPath(),n=t.getPath(),o=Q(e,n);switch(o){case"prefix":return !0;case"extension":return !1;default:return e[o]<n[o]}}isAfter(t){return this!=t&&(this.root===t.root&&!this.isBefore(t))}_remove(){this.parent._removeChildren(this.index);}_fireChange(t,e){this.fire(`change:${t}`,e),this.parent&&this.parent._fireChange(t,e);}toJSON(){const t=$i(this);return delete t.parent,t}}Ki.prototype.is=function(t){return "node"===t||"view:node"===t};class Qi extends Ki{constructor(t,e){super(t),this._textData=e;}get data(){return this._textData}get _data(){return this.data}set _data(t){this._fireChange("text",this),this._textData=t;}isSimilar(t){return t instanceof Qi&&(this===t||this.data===t.data)}_clone(){return new Qi(this.document,this.data)}}Qi.prototype.is=function(t){return "$text"===t||"view:$text"===t||"text"===t||"view:text"===t||"node"===t||"view:node"===t};class Zi extends Yi{constructor(t,e,n){if(super(),this.textNode=t,e<0||e>t.data.length)throw new k("view-textproxy-wrong-offsetintext",this);if(n<0||e+n>t.data.length)throw new k("view-textproxy-wrong-length",this);this.data=t.data.substring(e,e+n),this.offsetInText=e;}get offsetSize(){return this.data.length}get isPartial(){return this.data.length!==this.textNode.data.length}get parent(){return this.textNode.parent}get root(){return this.textNode.root}get document(){return this.textNode.document}getAncestors(t={}){const e=[];let n=t.includeSelf?this.textNode:this.parent;for(;null!==n;)e[t.parentFirst?"push":"unshift"](n),n=n.parent;return e}}Zi.prototype.is=function(t){return "$textProxy"===t||"view:$textProxy"===t||"textProxy"===t||"view:textProxy"===t};class Ji{constructor(...t){this._patterns=[],this.add(...t);}add(...t){for(let e of t)("string"==typeof e||e instanceof RegExp)&&(e={name:e}),this._patterns.push(e);}match(...t){for(const e of t)for(const t of this._patterns){const n=Xi(e,t);if(n)return {element:e,pattern:t,match:n}}return null}matchAll(...t){const e=[];for(const n of t)for(const t of this._patterns){const o=Xi(n,t);o&&e.push({element:n,pattern:t,match:o});}return e.length>0?e:null}getElementName(){if(1!==this._patterns.length)return null;const t=this._patterns[0],e=t.name;return "function"==typeof t||!e||e instanceof RegExp?null:e}}function Xi(t,e){if("function"==typeof e)return e(t);const n={};return e.name&&(n.name=function(t,e){if(t instanceof RegExp)return !!e.match(t);return t===e}(e.name,t.name),!n.name)||e.attributes&&(n.attributes=function(t,e){const n=new Set(e.getAttributeKeys());Ct(t)?(void 0!==t.style&&b("matcher-pattern-deprecated-attributes-style-key",t),void 0!==t.class&&b("matcher-pattern-deprecated-attributes-class-key",t)):(n.delete("style"),n.delete("class"));return tr(t,n,(t=>e.getAttribute(t)))}(e.attributes,t),!n.attributes)||e.classes&&(n.classes=function(t,e){return tr(t,e.getClassNames(),(()=>{}))}(e.classes,t),!n.classes)||e.styles&&(n.styles=function(t,e){return tr(t,e.getStyleNames(!0),(t=>e.getStyle(t)))}(e.styles,t),!n.styles)?null:n}function tr(t,e,n){const o=function(t){if(Array.isArray(t))return t.map((t=>Ct(t)?(void 0!==t.key&&void 0!==t.value||b("matcher-pattern-missing-key-or-value",t),[t.key,t.value]):[t,!0]));if(Ct(t))return Object.entries(t);return [[t,!0]]}(t),i=Array.from(e),r=[];if(o.forEach((([t,e])=>{i.forEach((o=>{(function(t,e){return !0===t||t===e||t instanceof RegExp&&e.match(t)})(t,o)&&function(t,e,n){if(!0===t)return !0;const o=n(e);return t===o||t instanceof RegExp&&!!String(o).match(t)}(e,o,n)&&r.push(o);}));})),o.length&&!(r.length<o.length))return r}const er=function(t){return "symbol"==typeof t||ut(t)&&"[object Symbol]"==dt(t)};var nr=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,or=/^\w*$/;const ir=function(t,e){if(ht(t))return !1;var n=typeof t;return !("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!er(t))||(or.test(t)||!nr.test(t)||null!=e&&t in Object(e))};function rr(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var n=function(){var o=arguments,i=e?e.apply(this,o):o[0],r=n.cache;if(r.has(i))return r.get(i);var s=t.apply(this,o);return n.cache=r.set(i,s)||r,s};return n.cache=new(rr.Cache||ke),n}rr.Cache=ke;const sr=rr;var ar=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,cr=/\\(\\)?/g,lr=function(t){var e=sr(t,(function(t){return 500===n.size&&n.clear(),t})),n=e.cache;return e}((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(ar,(function(t,n,o,i){e.push(o?i.replace(cr,"$1"):n||t);})),e}));const dr=lr;const hr=function(t,e){for(var n=-1,o=null==t?0:t.length,i=Array(o);++n<o;)i[n]=e(t[n],n,t);return i};var ur=et?et.prototype:void 0,gr=ur?ur.toString:void 0;const mr=function t(e){if("string"==typeof e)return e;if(ht(e))return hr(e,t)+"";if(er(e))return gr?gr.call(e):"";var n=e+"";return "0"==n&&1/e==-Infinity?"-0":n};const pr=function(t){return null==t?"":mr(t)};const fr=function(t,e){return ht(t)?t:ir(t,e)?[t]:dr(pr(t))};const kr=function(t){var e=null==t?0:t.length;return e?t[e-1]:void 0};const br=function(t){if("string"==typeof t||er(t))return t;var e=t+"";return "0"==e&&1/t==-Infinity?"-0":e};const wr=function(t,e){for(var n=0,o=(e=fr(e,t)).length;null!=t&&n<o;)t=t[br(e[n++])];return n&&n==o?t:void 0};const _r=function(t,e,n){var o=-1,i=t.length;e<0&&(e=-e>i?0:i+e),(n=n>i?i:n)<0&&(n+=i),i=e>n?0:n-e>>>0,e>>>=0;for(var r=Array(i);++o<i;)r[o]=t[o+e];return r};const Ar=function(t,e){return e.length<2?t:wr(t,_r(e,0,-1))};const Cr=function(t,e){return e=fr(e,t),null==(t=Ar(t,e))||delete t[br(kr(e))]};const vr=function(t,e){return null==t||Cr(t,e)};const yr=function(t,e,n){var o=null==t?void 0:wr(t,e);return void 0===o?n:o};const xr=function(t,e,n){(void 0!==n&&!yt(t[e],n)||void 0===n&&!(e in t))&&ve(t,e,n);};const Er=function(t){return function(e,n,o){for(var i=-1,r=Object(e),s=o(e),a=s.length;a--;){var c=s[t?a:++i];if(!1===n(r[c],c,r))break}return e}}();const Dr=function(t){return ut(t)&&on(t)};const Ir=function(t,e){if(("constructor"!==e||"function"!=typeof t[e])&&"__proto__"!=e)return t[e]};const Mr=function(t){return Ee(t,dn(t))};const Tr=function(t,e,n,o,i,r,s){var a=Ir(t,n),c=Ir(e,n),l=s.get(c);if(l)xr(t,n,l);else {var d=r?r(a,c,n+"",t,e,s):void 0,h=void 0===d;if(h){var u=ht(c),g=!u&&Oe(c),m=!u&&!g&&Ke(c);d=c,u||g||m?ht(a)?d=a:Dr(a)?d=kn(a):g?(h=!1,d=fn(c,!0)):m?(h=!1,d=no(c,!0)):d=[]:Ct(c)||Ne(c)?(d=a,Ne(a)?d=Mr(a):L(a)&&!Ot(a)||(d=so(c))):h=!1;}h&&(s.set(c,d),i(d,c,o,r,s),s.delete(c)),xr(t,n,d);}};const Sr=function t(e,n,o,i,r){e!==n&&Er(n,(function(s,a){if(r||(r=new _e),L(s))Tr(e,n,a,o,t,i,r);else {var c=i?i(Ir(e,a),s,a+"",e,n,r):void 0;void 0===c&&(c=s),xr(e,a,c);}}),dn);};const Nr=function(t){return t};const Br=function(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)};var Pr=Math.max;const zr=function(t,e,n){return e=Pr(void 0===e?t.length-1:e,0),function(){for(var o=arguments,i=-1,r=Pr(o.length-e,0),s=Array(r);++i<r;)s[i]=o[e+i];i=-1;for(var a=Array(e+1);++i<e;)a[i]=o[i];return a[e]=n(s),Br(t,this,a)}};const Lr=function(t){return function(){return t}};const Or=Ce?function(t,e){return Ce(t,"toString",{configurable:!0,enumerable:!1,value:Lr(e),writable:!0})}:Nr;var Rr=Date.now;const jr=function(t){var e=0,n=0;return function(){var o=Rr(),i=16-(o-n);if(n=o,i>0){if(++e>=800)return arguments[0]}else e=0;return t.apply(void 0,arguments)}};const Fr=jr(Or);const Vr=function(t,e){return Fr(zr(t,e,Nr),t+"")};const Ur=function(t,e,n){if(!L(n))return !1;var o=typeof e;return !!("number"==o?on(n)&&je(e,n.length):"string"==o&&e in n)&&yt(n[e],t)};const Hr=function(t){return Vr((function(e,n){var o=-1,i=n.length,r=i>1?n[i-1]:void 0,s=i>2?n[2]:void 0;for(r=t.length>3&&"function"==typeof r?(i--,r):void 0,s&&Ur(n[0],n[1],s)&&(r=i<3?void 0:r,i=1),e=Object(e);++o<i;){var a=n[o];a&&t(e,a,o,r);}return e}))};const Wr=Hr((function(t,e,n){Sr(t,e,n);}));const Gr=function(t,e,n,o){if(!L(t))return t;for(var i=-1,r=(e=fr(e,t)).length,s=r-1,a=t;null!=a&&++i<r;){var c=br(e[i]),l=n;if("__proto__"===c||"constructor"===c||"prototype"===c)return t;if(i!=s){var d=a[c];void 0===(l=o?o(d,c,a):void 0)&&(l=L(d)?d:je(e[i+1])?[]:{});}xe(a,c,l),a=a[c];}return t};const qr=function(t,e,n){return null==t?t:Gr(t,e,n)};class Yr{constructor(t){this._styles={},this._styleProcessor=t;}get isEmpty(){const t=Object.entries(this._styles);return !Array.from(t).length}get size(){return this.isEmpty?0:this.getStyleNames().length}setTo(t){this.clear();const e=Array.from(function(t){let e=null,n=0,o=0,i=null;const r=new Map;if(""===t)return r;";"!=t.charAt(t.length-1)&&(t+=";");for(let s=0;s<t.length;s++){const a=t.charAt(s);if(null===e)switch(a){case":":i||(i=t.substr(n,s-n),o=s+1);break;case'"':case"'":e=a;break;case";":{const e=t.substr(o,s-o);i&&r.set(i.trim(),e.trim()),i=null,n=s+1;break}}else a===e&&(e=null);}return r}(t).entries());for(const[t,n]of e)this._styleProcessor.toNormalizedForm(t,n,this._styles);}has(t){if(this.isEmpty)return !1;const e=this._styleProcessor.getReducedForm(t,this._styles).find((([e])=>e===t));return Array.isArray(e)}set(t,e){if(L(t))for(const[e,n]of Object.entries(t))this._styleProcessor.toNormalizedForm(e,n,this._styles);else this._styleProcessor.toNormalizedForm(t,e,this._styles);}remove(t){const e=Kr(t);vr(this._styles,e),delete this._styles[t],this._cleanEmptyObjectsOnPath(e);}getNormalized(t){return this._styleProcessor.getNormalized(t,this._styles)}toString(){return this.isEmpty?"":this._getStylesEntries().map((t=>t.join(":"))).sort().join(";")+";"}getAsString(t){if(this.isEmpty)return;if(this._styles[t]&&!L(this._styles[t]))return this._styles[t];const e=this._styleProcessor.getReducedForm(t,this._styles).find((([e])=>e===t));return Array.isArray(e)?e[1]:void 0}getStyleNames(t=!1){if(this.isEmpty)return [];if(t)return this._styleProcessor.getStyleNames(this._styles);return this._getStylesEntries().map((([t])=>t))}clear(){this._styles={};}_getStylesEntries(){const t=[],e=Object.keys(this._styles);for(const n of e)t.push(...this._styleProcessor.getReducedForm(n,this._styles));return t}_cleanEmptyObjectsOnPath(t){const e=t.split(".");if(!(e.length>1))return;const n=e.splice(0,e.length-1).join("."),o=yr(this._styles,n);if(!o)return;!Array.from(Object.keys(o)).length&&this.remove(n);}}class $r{constructor(){this._normalizers=new Map,this._extractors=new Map,this._reducers=new Map,this._consumables=new Map;}toNormalizedForm(t,e,n){if(L(e))Qr(n,Kr(t),e);else if(this._normalizers.has(t)){const o=this._normalizers.get(t),{path:i,value:r}=o(e);Qr(n,i,r);}else Qr(n,t,e);}getNormalized(t,e){if(!t)return Wr({},e);if(void 0!==e[t])return e[t];if(this._extractors.has(t)){const n=this._extractors.get(t);if("string"==typeof n)return yr(e,n);const o=n(t,e);if(o)return o}return yr(e,Kr(t))}getReducedForm(t,e){const n=this.getNormalized(t,e);if(void 0===n)return [];if(this._reducers.has(t)){return this._reducers.get(t)(n)}return [[t,n]]}getStyleNames(t){const e=Array.from(this._consumables.keys()).filter((e=>{const n=this.getNormalized(e,t);return n&&"object"==typeof n?Object.keys(n).length:n})),n=new Set([...e,...Object.keys(t)]);return Array.from(n.values())}getRelatedStyles(t){return this._consumables.get(t)||[]}setNormalizer(t,e){this._normalizers.set(t,e);}setExtractor(t,e){this._extractors.set(t,e);}setReducer(t,e){this._reducers.set(t,e);}setStyleRelation(t,e){this._mapStyleNames(t,e);for(const n of e)this._mapStyleNames(n,[t]);}_mapStyleNames(t,e){this._consumables.has(t)||this._consumables.set(t,[]),this._consumables.get(t).push(...e);}}function Kr(t){return t.replace("-",".")}function Qr(t,e,n){let o=n;L(n)&&(o=Wr({},yr(t,e),n)),qr(t,e,o);}class Zr extends Ki{constructor(t,e,n,o){if(super(t),this.name=e,this._attrs=function(t){const e=yi(t);for(const[t,n]of e)null===n?e.delete(t):"string"!=typeof n&&e.set(t,String(n));return e}(n),this._children=[],o&&this._insertChild(0,o),this._classes=new Set,this._attrs.has("class")){const t=this._attrs.get("class");Jr(this._classes,t),this._attrs.delete("class");}this._styles=new Yr(this.document.stylesProcessor),this._attrs.has("style")&&(this._styles.setTo(this._attrs.get("style")),this._attrs.delete("style")),this._customProperties=new Map,this._unsafeAttributesToRender=[];}get childCount(){return this._children.length}get isEmpty(){return 0===this._children.length}getChild(t){return this._children[t]}getChildIndex(t){return this._children.indexOf(t)}getChildren(){return this._children[Symbol.iterator]()}*getAttributeKeys(){this._classes.size>0&&(yield "class"),this._styles.isEmpty||(yield "style"),yield*this._attrs.keys();}*getAttributes(){yield*this._attrs.entries(),this._classes.size>0&&(yield ["class",this.getAttribute("class")]),this._styles.isEmpty||(yield ["style",this.getAttribute("style")]);}getAttribute(t){if("class"==t)return this._classes.size>0?[...this._classes].join(" "):void 0;if("style"==t){const t=this._styles.toString();return ""==t?void 0:t}return this._attrs.get(t)}hasAttribute(t){return "class"==t?this._classes.size>0:"style"==t?!this._styles.isEmpty:this._attrs.has(t)}isSimilar(t){if(!(t instanceof Zr))return !1;if(this===t)return !0;if(this.name!=t.name)return !1;if(this._attrs.size!==t._attrs.size||this._classes.size!==t._classes.size||this._styles.size!==t._styles.size)return !1;for(const[e,n]of this._attrs)if(!t._attrs.has(e)||t._attrs.get(e)!==n)return !1;for(const e of this._classes)if(!t._classes.has(e))return !1;for(const e of this._styles.getStyleNames())if(!t._styles.has(e)||t._styles.getAsString(e)!==this._styles.getAsString(e))return !1;return !0}hasClass(...t){for(const e of t)if(!this._classes.has(e))return !1;return !0}getClassNames(){return this._classes.keys()}getStyle(t){return this._styles.getAsString(t)}getNormalizedStyle(t){return this._styles.getNormalized(t)}getStyleNames(t){return this._styles.getStyleNames(t)}hasStyle(...t){for(const e of t)if(!this._styles.has(e))return !1;return !0}findAncestor(...t){const e=new Ji(...t);let n=this.parent;for(;n&&!n.is("documentFragment");){if(e.match(n))return n;n=n.parent;}return null}getCustomProperty(t){return this._customProperties.get(t)}*getCustomProperties(){yield*this._customProperties.entries();}getIdentity(){const t=Array.from(this._classes).sort().join(","),e=this._styles.toString(),n=Array.from(this._attrs).map((t=>`${t[0]}="${t[1]}"`)).sort().join(" ");return this.name+(""==t?"":` class="${t}"`)+(e?` style="${e}"`:"")+(""==n?"":` ${n}`)}shouldRenderUnsafeAttribute(t){return this._unsafeAttributesToRender.includes(t)}_clone(t=!1){const e=[];if(t)for(const n of this.getChildren())e.push(n._clone(t));const n=new this.constructor(this.document,this.name,this._attrs,e);return n._classes=new Set(this._classes),n._styles.set(this._styles.getNormalized()),n._customProperties=new Map(this._customProperties),n.getFillerOffset=this.getFillerOffset,n._unsafeAttributesToRender=this._unsafeAttributesToRender,n}_appendChild(t){return this._insertChild(this.childCount,t)}_insertChild(t,e){this._fireChange("children",this);let n=0;const o=function(t,e){if("string"==typeof e)return [new Qi(t,e)];Z(e)||(e=[e]);return Array.from(e).map((e=>"string"==typeof e?new Qi(t,e):e instanceof Zi?new Qi(t,e.data):e))}(this.document,e);for(const e of o)null!==e.parent&&e._remove(),e.parent=this,e.document=this.document,this._children.splice(t,0,e),t++,n++;return n}_removeChildren(t,e=1){this._fireChange("children",this);for(let n=t;n<t+e;n++)this._children[n].parent=null;return this._children.splice(t,e)}_setAttribute(t,e){e=String(e),this._fireChange("attributes",this),"class"==t?Jr(this._classes,e):"style"==t?this._styles.setTo(e):this._attrs.set(t,e);}_removeAttribute(t){return this._fireChange("attributes",this),"class"==t?this._classes.size>0&&(this._classes.clear(),!0):"style"==t?!this._styles.isEmpty&&(this._styles.clear(),!0):this._attrs.delete(t)}_addClass(t){this._fireChange("attributes",this);for(const e of pi(t))this._classes.add(e);}_removeClass(t){this._fireChange("attributes",this);for(const e of pi(t))this._classes.delete(e);}_setStyle(t,e){this._fireChange("attributes",this),Ct(t)?this._styles.set(t):this._styles.set(t,e);}_removeStyle(t){this._fireChange("attributes",this);for(const e of pi(t))this._styles.remove(e);}_setCustomProperty(t,e){this._customProperties.set(t,e);}_removeCustomProperty(t){return this._customProperties.delete(t)}}function Jr(t,e){const n=e.split(/\s+/);t.clear(),n.forEach((e=>t.add(e)));}Zr.prototype.is=function(t,e){return e?e===this.name&&("element"===t||"view:element"===t):"element"===t||"view:element"===t||"node"===t||"view:node"===t};class Xr extends Zr{constructor(...t){super(...t),this.getFillerOffset=ts;}}function ts(){const t=[...this.getChildren()],e=t[this.childCount-1];if(e&&e.is("element","br"))return this.childCount;for(const e of t)if(!e.is("uiElement"))return null;return this.childCount}Xr.prototype.is=function(t,e){return e?e===this.name&&("containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t):"containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class es extends(H(Xr)){constructor(...t){super(...t);const e=t[0];this.set("isReadOnly",!1),this.set("isFocused",!1),this.bind("isReadOnly").to(e),this.bind("isFocused").to(e,"isFocused",(t=>t&&e.selection.editableElement==this)),this.listenTo(e.selection,"change",(()=>{this.isFocused=e.isFocused&&e.selection.editableElement==this;}));}destroy(){this.stopListening();}}es.prototype.is=function(t,e){return e?e===this.name&&("editableElement"===t||"view:editableElement"===t||"containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t):"editableElement"===t||"view:editableElement"===t||"containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};const ns=Symbol("rootName");class os extends es{constructor(t,e){super(t,e),this.rootName="main";}get rootName(){return this.getCustomProperty(ns)}set rootName(t){this._setCustomProperty(ns,t);}set _name(t){this.name=t;}}os.prototype.is=function(t,e){return e?e===this.name&&("rootElement"===t||"view:rootElement"===t||"editableElement"===t||"view:editableElement"===t||"containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t):"rootElement"===t||"view:rootElement"===t||"editableElement"===t||"view:editableElement"===t||"containerElement"===t||"view:containerElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class is{constructor(t={}){if(!t.boundaries&&!t.startPosition)throw new k("view-tree-walker-no-start-position",null);if(t.direction&&"forward"!=t.direction&&"backward"!=t.direction)throw new k("view-tree-walker-unknown-direction",t.startPosition,{direction:t.direction});this.boundaries=t.boundaries||null,t.startPosition?this.position=rs._createAt(t.startPosition):this.position=rs._createAt(t.boundaries["backward"==t.direction?"end":"start"]),this.direction=t.direction||"forward",this.singleCharacters=!!t.singleCharacters,this.shallow=!!t.shallow,this.ignoreElementEnd=!!t.ignoreElementEnd,this._boundaryStartParent=this.boundaries?this.boundaries.start.parent:null,this._boundaryEndParent=this.boundaries?this.boundaries.end.parent:null;}[Symbol.iterator](){return this}skip(t){let e,n,o;do{o=this.position,({done:e,value:n}=this.next());}while(!e&&t(n));e||(this.position=o);}next(){return "forward"==this.direction?this._next():this._previous()}_next(){let t=this.position.clone();const e=this.position,n=t.parent;if(null===n.parent&&t.offset===n.childCount)return {done:!0,value:void 0};if(n===this._boundaryEndParent&&t.offset==this.boundaries.end.offset)return {done:!0,value:void 0};let o;if(n instanceof Qi){if(t.isAtEnd)return this.position=rs._createAfter(n),this._next();o=n.data[t.offset];}else o=n.getChild(t.offset);if(o instanceof Zr)return this.shallow?t.offset++:t=new rs(o,0),this.position=t,this._formatReturnValue("elementStart",o,e,t,1);if(o instanceof Qi){if(this.singleCharacters)return t=new rs(o,0),this.position=t,this._next();{let n,i=o.data.length;return o==this._boundaryEndParent?(i=this.boundaries.end.offset,n=new Zi(o,0,i),t=rs._createAfter(n)):(n=new Zi(o,0,o.data.length),t.offset++),this.position=t,this._formatReturnValue("text",n,e,t,i)}}if("string"==typeof o){let o;if(this.singleCharacters)o=1;else {o=(n===this._boundaryEndParent?this.boundaries.end.offset:n.data.length)-t.offset;}const i=new Zi(n,t.offset,o);return t.offset+=o,this.position=t,this._formatReturnValue("text",i,e,t,o)}return t=rs._createAfter(n),this.position=t,this.ignoreElementEnd?this._next():this._formatReturnValue("elementEnd",n,e,t)}_previous(){let t=this.position.clone();const e=this.position,n=t.parent;if(null===n.parent&&0===t.offset)return {done:!0,value:void 0};if(n==this._boundaryStartParent&&t.offset==this.boundaries.start.offset)return {done:!0,value:void 0};let o;if(n instanceof Qi){if(t.isAtStart)return this.position=rs._createBefore(n),this._previous();o=n.data[t.offset-1];}else o=n.getChild(t.offset-1);if(o instanceof Zr)return this.shallow?(t.offset--,this.position=t,this._formatReturnValue("elementStart",o,e,t,1)):(t=new rs(o,o.childCount),this.position=t,this.ignoreElementEnd?this._previous():this._formatReturnValue("elementEnd",o,e,t));if(o instanceof Qi){if(this.singleCharacters)return t=new rs(o,o.data.length),this.position=t,this._previous();{let n,i=o.data.length;if(o==this._boundaryStartParent){const e=this.boundaries.start.offset;n=new Zi(o,e,o.data.length-e),i=n.data.length,t=rs._createBefore(n);}else n=new Zi(o,0,o.data.length),t.offset--;return this.position=t,this._formatReturnValue("text",n,e,t,i)}}if("string"==typeof o){let o;if(this.singleCharacters)o=1;else {const e=n===this._boundaryStartParent?this.boundaries.start.offset:0;o=t.offset-e;}t.offset-=o;const i=new Zi(n,t.offset,o);return this.position=t,this._formatReturnValue("text",i,e,t,o)}return t=rs._createBefore(n),this.position=t,this._formatReturnValue("elementStart",n,e,t,1)}_formatReturnValue(t,e,n,o,i){return e instanceof Zi&&(e.offsetInText+e.data.length==e.textNode.data.length&&("forward"!=this.direction||this.boundaries&&this.boundaries.end.isEqual(this.position)?n=rs._createAfter(e.textNode):(o=rs._createAfter(e.textNode),this.position=o)),0===e.offsetInText&&("backward"!=this.direction||this.boundaries&&this.boundaries.start.isEqual(this.position)?n=rs._createBefore(e.textNode):(o=rs._createBefore(e.textNode),this.position=o))),{done:!1,value:{type:t,item:e,previousPosition:n,nextPosition:o,length:i}}}}class rs extends Yi{constructor(t,e){super(),this.parent=t,this.offset=e;}get nodeAfter(){return this.parent.is("$text")?null:this.parent.getChild(this.offset)||null}get nodeBefore(){return this.parent.is("$text")?null:this.parent.getChild(this.offset-1)||null}get isAtStart(){return 0===this.offset}get isAtEnd(){const t=this.parent.is("$text")?this.parent.data.length:this.parent.childCount;return this.offset===t}get root(){return this.parent.root}get editableElement(){let t=this.parent;for(;!(t instanceof es);){if(!t.parent)return null;t=t.parent;}return t}getShiftedBy(t){const e=rs._createAt(this),n=e.offset+t;return e.offset=n<0?0:n,e}getLastMatchingPosition(t,e={}){e.startPosition=this;const n=new is(e);return n.skip(t),n.position}getAncestors(){return this.parent.is("documentFragment")?[this.parent]:this.parent.getAncestors({includeSelf:!0})}getCommonAncestor(t){const e=this.getAncestors(),n=t.getAncestors();let o=0;for(;e[o]==n[o]&&e[o];)o++;return 0===o?null:e[o-1]}isEqual(t){return this.parent==t.parent&&this.offset==t.offset}isBefore(t){return "before"==this.compareWith(t)}isAfter(t){return "after"==this.compareWith(t)}compareWith(t){if(this.root!==t.root)return "different";if(this.isEqual(t))return "same";const e=this.parent.is("node")?this.parent.getPath():[],n=t.parent.is("node")?t.parent.getPath():[];e.push(this.offset),n.push(t.offset);const o=Q(e,n);switch(o){case"prefix":return "before";case"extension":return "after";default:return e[o]<n[o]?"before":"after"}}getWalker(t={}){return t.startPosition=this,new is(t)}clone(){return new rs(this.parent,this.offset)}static _createAt(t,e){if(t instanceof rs)return new this(t.parent,t.offset);{const n=t;if("end"==e)e=n.is("$text")?n.data.length:n.childCount;else {if("before"==e)return this._createBefore(n);if("after"==e)return this._createAfter(n);if(0!==e&&!e)throw new k("view-createpositionat-offset-required",n)}return new rs(n,e)}}static _createAfter(t){if(t.is("$textProxy"))return new rs(t.textNode,t.offsetInText+t.data.length);if(!t.parent)throw new k("view-position-after-root",t,{root:t});return new rs(t.parent,t.index+1)}static _createBefore(t){if(t.is("$textProxy"))return new rs(t.textNode,t.offsetInText);if(!t.parent)throw new k("view-position-before-root",t,{root:t});return new rs(t.parent,t.index)}}rs.prototype.is=function(t){return "position"===t||"view:position"===t};class ss extends Yi{constructor(t,e=null){super(),this.start=t.clone(),this.end=e?e.clone():t.clone();}*[Symbol.iterator](){yield*new is({boundaries:this,ignoreElementEnd:!0});}get isCollapsed(){return this.start.isEqual(this.end)}get isFlat(){return this.start.parent===this.end.parent}get root(){return this.start.root}getEnlarged(){let t=this.start.getLastMatchingPosition(as,{direction:"backward"}),e=this.end.getLastMatchingPosition(as);return t.parent.is("$text")&&t.isAtStart&&(t=rs._createBefore(t.parent)),e.parent.is("$text")&&e.isAtEnd&&(e=rs._createAfter(e.parent)),new ss(t,e)}getTrimmed(){let t=this.start.getLastMatchingPosition(as);if(t.isAfter(this.end)||t.isEqual(this.end))return new ss(t,t);let e=this.end.getLastMatchingPosition(as,{direction:"backward"});const n=t.nodeAfter,o=e.nodeBefore;return n&&n.is("$text")&&(t=new rs(n,0)),o&&o.is("$text")&&(e=new rs(o,o.data.length)),new ss(t,e)}isEqual(t){return this==t||this.start.isEqual(t.start)&&this.end.isEqual(t.end)}containsPosition(t){return t.isAfter(this.start)&&t.isBefore(this.end)}containsRange(t,e=!1){t.isCollapsed&&(e=!1);const n=this.containsPosition(t.start)||e&&this.start.isEqual(t.start),o=this.containsPosition(t.end)||e&&this.end.isEqual(t.end);return n&&o}getDifference(t){const e=[];return this.isIntersecting(t)?(this.containsPosition(t.start)&&e.push(new ss(this.start,t.start)),this.containsPosition(t.end)&&e.push(new ss(t.end,this.end))):e.push(this.clone()),e}getIntersection(t){if(this.isIntersecting(t)){let e=this.start,n=this.end;return this.containsPosition(t.start)&&(e=t.start),this.containsPosition(t.end)&&(n=t.end),new ss(e,n)}return null}getWalker(t={}){return t.boundaries=this,new is(t)}getCommonAncestor(){return this.start.getCommonAncestor(this.end)}getContainedElement(){if(this.isCollapsed)return null;let t=this.start.nodeAfter,e=this.end.nodeBefore;return this.start.parent.is("$text")&&this.start.isAtEnd&&this.start.parent.nextSibling&&(t=this.start.parent.nextSibling),this.end.parent.is("$text")&&this.end.isAtStart&&this.end.parent.previousSibling&&(e=this.end.parent.previousSibling),t&&t.is("element")&&t===e?t:null}clone(){return new ss(this.start,this.end)}*getItems(t={}){t.boundaries=this,t.ignoreElementEnd=!0;const e=new is(t);for(const t of e)yield t.item;}*getPositions(t={}){t.boundaries=this;const e=new is(t);yield e.position;for(const t of e)yield t.nextPosition;}isIntersecting(t){return this.start.isBefore(t.end)&&this.end.isAfter(t.start)}static _createFromParentsAndOffsets(t,e,n,o){return new this(new rs(t,e),new rs(n,o))}static _createFromPositionAndShift(t,e){const n=t,o=t.getShiftedBy(e);return e>0?new this(n,o):new this(o,n)}static _createIn(t){return this._createFromParentsAndOffsets(t,0,t,t.childCount)}static _createOn(t){const e=t.is("$textProxy")?t.offsetSize:1;return this._createFromPositionAndShift(rs._createBefore(t),e)}}function as(t){return !(!t.item.is("attributeElement")&&!t.item.is("uiElement"))}ss.prototype.is=function(t){return "range"===t||"view:range"===t};class cs extends(I(Yi)){constructor(...t){super(),this._ranges=[],this._lastRangeBackward=!1,this._isFake=!1,this._fakeSelectionLabel="",t.length&&this.setTo(...t);}get isFake(){return this._isFake}get fakeSelectionLabel(){return this._fakeSelectionLabel}get anchor(){if(!this._ranges.length)return null;const t=this._ranges[this._ranges.length-1];return (this._lastRangeBackward?t.end:t.start).clone()}get focus(){if(!this._ranges.length)return null;const t=this._ranges[this._ranges.length-1];return (this._lastRangeBackward?t.start:t.end).clone()}get isCollapsed(){return 1===this.rangeCount&&this._ranges[0].isCollapsed}get rangeCount(){return this._ranges.length}get isBackward(){return !this.isCollapsed&&this._lastRangeBackward}get editableElement(){return this.anchor?this.anchor.editableElement:null}*getRanges(){for(const t of this._ranges)yield t.clone();}getFirstRange(){let t=null;for(const e of this._ranges)t&&!e.start.isBefore(t.start)||(t=e);return t?t.clone():null}getLastRange(){let t=null;for(const e of this._ranges)t&&!e.end.isAfter(t.end)||(t=e);return t?t.clone():null}getFirstPosition(){const t=this.getFirstRange();return t?t.start.clone():null}getLastPosition(){const t=this.getLastRange();return t?t.end.clone():null}isEqual(t){if(this.isFake!=t.isFake)return !1;if(this.isFake&&this.fakeSelectionLabel!=t.fakeSelectionLabel)return !1;if(this.rangeCount!=t.rangeCount)return !1;if(0===this.rangeCount)return !0;if(!this.anchor.isEqual(t.anchor)||!this.focus.isEqual(t.focus))return !1;for(const e of this._ranges){let n=!1;for(const o of t._ranges)if(e.isEqual(o)){n=!0;break}if(!n)return !1}return !0}isSimilar(t){if(this.isBackward!=t.isBackward)return !1;const e=K(this.getRanges());if(e!=K(t.getRanges()))return !1;if(0==e)return !0;for(let e of this.getRanges()){e=e.getTrimmed();let n=!1;for(let o of t.getRanges())if(o=o.getTrimmed(),e.start.isEqual(o.start)&&e.end.isEqual(o.end)){n=!0;break}if(!n)return !1}return !0}getSelectedElement(){return 1!==this.rangeCount?null:this.getFirstRange().getContainedElement()}setTo(...t){let[e,n,o]=t;if("object"==typeof n&&(o=n,n=void 0),null===e)this._setRanges([]),this._setFakeOptions(o);else if(e instanceof cs||e instanceof ls)this._setRanges(e.getRanges(),e.isBackward),this._setFakeOptions({fake:e.isFake,label:e.fakeSelectionLabel});else if(e instanceof ss)this._setRanges([e],o&&o.backward),this._setFakeOptions(o);else if(e instanceof rs)this._setRanges([new ss(e)]),this._setFakeOptions(o);else if(e instanceof Ki){const t=!!o&&!!o.backward;let i;if(void 0===n)throw new k("view-selection-setto-required-second-parameter",this);i="in"==n?ss._createIn(e):"on"==n?ss._createOn(e):new ss(rs._createAt(e,n)),this._setRanges([i],t),this._setFakeOptions(o);}else {if(!Z(e))throw new k("view-selection-setto-not-selectable",this);this._setRanges(e,o&&o.backward),this._setFakeOptions(o);}this.fire("change");}setFocus(t,e){if(null===this.anchor)throw new k("view-selection-setfocus-no-ranges",this);const n=rs._createAt(t,e);if("same"==n.compareWith(this.focus))return;const o=this.anchor;this._ranges.pop(),"before"==n.compareWith(o)?this._addRange(new ss(n,o),!0):this._addRange(new ss(o,n)),this.fire("change");}_setRanges(t,e=!1){t=Array.from(t),this._ranges=[];for(const e of t)this._addRange(e);this._lastRangeBackward=!!e;}_setFakeOptions(t={}){this._isFake=!!t.fake,this._fakeSelectionLabel=t.fake&&t.label||"";}_addRange(t,e=!1){if(!(t instanceof ss))throw new k("view-selection-add-range-not-range",this);this._pushRange(t),this._lastRangeBackward=!!e;}_pushRange(t){for(const e of this._ranges)if(t.isIntersecting(e))throw new k("view-selection-range-intersects",this,{addedRange:t,intersectingRange:e});this._ranges.push(new ss(t.start,t.end));}}cs.prototype.is=function(t){return "selection"===t||"view:selection"===t};class ls extends(I(Yi)){constructor(...t){super(),this._selection=new cs,this._selection.delegate("change").to(this),t.length&&this._selection.setTo(...t);}get isFake(){return this._selection.isFake}get fakeSelectionLabel(){return this._selection.fakeSelectionLabel}get anchor(){return this._selection.anchor}get focus(){return this._selection.focus}get isCollapsed(){return this._selection.isCollapsed}get rangeCount(){return this._selection.rangeCount}get isBackward(){return this._selection.isBackward}get editableElement(){return this._selection.editableElement}get _ranges(){return this._selection._ranges}*getRanges(){yield*this._selection.getRanges();}getFirstRange(){return this._selection.getFirstRange()}getLastRange(){return this._selection.getLastRange()}getFirstPosition(){return this._selection.getFirstPosition()}getLastPosition(){return this._selection.getLastPosition()}getSelectedElement(){return this._selection.getSelectedElement()}isEqual(t){return this._selection.isEqual(t)}isSimilar(t){return this._selection.isSimilar(t)}_setTo(...t){this._selection.setTo(...t);}_setFocus(t,e){this._selection.setFocus(t,e);}}ls.prototype.is=function(t){return "selection"===t||"documentSelection"==t||"view:selection"==t||"view:documentSelection"==t};class ds extends u{constructor(t,e,n){super(t,e),this.startRange=n,this._eventPhase="none",this._currentTarget=null;}get eventPhase(){return this._eventPhase}get currentTarget(){return this._currentTarget}}const hs=Symbol("bubbling contexts");function us(t){return class extends t{fire(t,...e){try{const n=t instanceof u?t:new u(this,t),o=fs(this);if(!o.size)return;if(gs(n,"capturing",this),ms(o,"$capture",n,...e))return n.return;const i=n.startRange||this.selection.getFirstRange(),r=i?i.getContainedElement():null,s=!!r&&Boolean(ps(o,r));let a=r||function(t){if(!t)return null;const e=t.start.parent,n=t.end.parent,o=e.getPath(),i=n.getPath();return o.length>i.length?e:n}(i);if(gs(n,"atTarget",a),!s){if(ms(o,"$text",n,...e))return n.return;gs(n,"bubbling",a);}for(;a;){if(a.is("rootElement")){if(ms(o,"$root",n,...e))return n.return}else if(a.is("element")&&ms(o,a.name,n,...e))return n.return;if(ms(o,a,n,...e))return n.return;a=a.parent,gs(n,"bubbling",a);}return gs(n,"bubbling",this),ms(o,"$document",n,...e),n.return}catch(t){k.rethrowUnexpectedError(t,this);}}_addEventListener(t,e,n){const o=pi(n.context||"$document"),i=fs(this);for(const r of o){let o=i.get(r);o||(o=new(I()),i.set(r,o)),this.listenTo(o,t,e,n);}}_removeEventListener(t,e){const n=fs(this);for(const o of n.values())this.stopListening(o,t,e);}}}{const t=us(Object);["fire","_addEventListener","_removeEventListener"].forEach((e=>{us[e]=t.prototype[e];}));}function gs(t,e,n){t instanceof ds&&(t._eventPhase=e,t._currentTarget=n);}function ms(t,e,n,...o){const i="string"==typeof e?t.get(e):ps(t,e);return !!i&&(i.fire(n,...o),n.stop.called)}function ps(t,e){for(const[n,o]of t)if("function"==typeof n&&n(e))return o;return null}function fs(t){return t[hs]||(t[hs]=new Map),t[hs]}class ks extends(us(H())){constructor(t){super(),this.selection=new ls,this.roots=new _i({idProperty:"rootName"}),this.stylesProcessor=t,this.set("isReadOnly",!1),this.set("isFocused",!1),this.set("_isFocusChanging",!1),this.set("isSelecting",!1),this.set("isComposing",!1),this._postFixers=new Set;}getRoot(t="main"){return this.roots.get(t)}registerPostFixer(t){this._postFixers.add(t);}destroy(){this.roots.map((t=>t.destroy())),this.stopListening();}_callPostFixers(t){let e=!1;do{for(const n of this._postFixers)if(e=n(t),e)break}while(e)}}class bs extends Zr{constructor(...t){super(...t),this.getFillerOffset=ws,this._priority=10,this._id=null,this._clonesGroup=null;}get priority(){return this._priority}get id(){return this._id}getElementsWithSameId(){if(null===this.id)throw new k("attribute-element-get-elements-with-same-id-no-id",this);return new Set(this._clonesGroup)}isSimilar(t){return null!==this.id||null!==t.id?this.id===t.id:super.isSimilar(t)&&this.priority==t.priority}_clone(t=!1){const e=super._clone(t);return e._priority=this._priority,e._id=this._id,e}}function ws(){if(_s(this))return null;let t=this.parent;for(;t&&t.is("attributeElement");){if(_s(t)>1)return null;t=t.parent;}return !t||_s(t)>1?null:this.childCount}function _s(t){return Array.from(t.getChildren()).filter((t=>!t.is("uiElement"))).length}bs.DEFAULT_PRIORITY=10,bs.prototype.is=function(t,e){return e?e===this.name&&("attributeElement"===t||"view:attributeElement"===t||"element"===t||"view:element"===t):"attributeElement"===t||"view:attributeElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class As extends Zr{constructor(t,e,n,o){super(t,e,n,o),this.getFillerOffset=Cs;}_insertChild(t,e){if(e&&(e instanceof Ki||Array.from(e).length>0))throw new k("view-emptyelement-cannot-add",[this,e]);return 0}}function Cs(){return null}As.prototype.is=function(t,e){return e?e===this.name&&("emptyElement"===t||"view:emptyElement"===t||"element"===t||"view:element"===t):"emptyElement"===t||"view:emptyElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class vs extends Zr{constructor(...t){super(...t),this.getFillerOffset=xs;}_insertChild(t,e){if(e&&(e instanceof Ki||Array.from(e).length>0))throw new k("view-uielement-cannot-add",[this,e]);return 0}render(t,e){return this.toDomElement(t)}toDomElement(t){const e=t.createElement(this.name);for(const t of this.getAttributeKeys())e.setAttribute(t,this.getAttribute(t));return e}}function ys(t){t.document.on("arrowKey",((e,n)=>function(t,e,n){if(e.keyCode==li.arrowright){const t=e.domTarget.ownerDocument.defaultView.getSelection(),o=1==t.rangeCount&&t.getRangeAt(0).collapsed;if(o||e.shiftKey){const e=t.focusNode,i=t.focusOffset,r=n.domPositionToView(e,i);if(null===r)return;let s=!1;const a=r.getLastMatchingPosition((t=>(t.item.is("uiElement")&&(s=!0),!(!t.item.is("uiElement")&&!t.item.is("attributeElement")))));if(s){const e=n.viewPositionToDom(a);o?t.collapse(e.parent,e.offset):t.extend(e.parent,e.offset);}}}}(0,n,t.domConverter)),{priority:"low"});}function xs(){return null}vs.prototype.is=function(t,e){return e?e===this.name&&("uiElement"===t||"view:uiElement"===t||"element"===t||"view:element"===t):"uiElement"===t||"view:uiElement"===t||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class Es extends Zr{constructor(...t){super(...t),this.getFillerOffset=Ds;}_insertChild(t,e){if(e&&(e instanceof Ki||Array.from(e).length>0))throw new k("view-rawelement-cannot-add",[this,e]);return 0}render(){}}function Ds(){return null}Es.prototype.is=function(t,e){return e?e===this.name&&("rawElement"===t||"view:rawElement"===t||"element"===t||"view:element"===t):"rawElement"===t||"view:rawElement"===t||t===this.name||t==="view:"+this.name||"element"===t||"view:element"===t||"node"===t||"view:node"===t};class Is extends(I(Yi)){constructor(t,e){super(),this.document=t,this._children=[],e&&this._insertChild(0,e);}[Symbol.iterator](){return this._children[Symbol.iterator]()}get childCount(){return this._children.length}get isEmpty(){return 0===this.childCount}get root(){return this}get parent(){return null}_appendChild(t){return this._insertChild(this.childCount,t)}getChild(t){return this._children[t]}getChildIndex(t){return this._children.indexOf(t)}getChildren(){return this._children[Symbol.iterator]()}_insertChild(t,e){this._fireChange("children",this);let n=0;const o=function(t,e){if("string"==typeof e)return [new Qi(t,e)];Z(e)||(e=[e]);return Array.from(e).map((e=>"string"==typeof e?new Qi(t,e):e instanceof Zi?new Qi(t,e.data):e))}(this.document,e);for(const e of o)null!==e.parent&&e._remove(),e.parent=this,this._children.splice(t,0,e),t++,n++;return n}_removeChildren(t,e=1){this._fireChange("children",this);for(let n=t;n<t+e;n++)this._children[n].parent=null;return this._children.splice(t,e)}_fireChange(t,e){this.fire("change:"+t,e);}}Is.prototype.is=function(t){return "documentFragment"===t||"view:documentFragment"===t};class Ms{constructor(t){this.document=t,this._cloneGroups=new Map,this._slotFactory=null;}setSelection(...t){this.document.selection._setTo(...t);}setSelectionFocus(...t){this.document.selection._setFocus(...t);}createDocumentFragment(t){return new Is(this.document,t)}createText(t){return new Qi(this.document,t)}createAttributeElement(t,e,n={}){const o=new bs(this.document,t,e);return "number"==typeof n.priority&&(o._priority=n.priority),n.id&&(o._id=n.id),n.renderUnsafeAttributes&&o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),o}createContainerElement(t,e,n={},o={}){let i=null;Ct(n)?o=n:i=n;const r=new Xr(this.document,t,e,i);return o.renderUnsafeAttributes&&r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes),r}createEditableElement(t,e,n={}){const o=new es(this.document,t,e);return n.renderUnsafeAttributes&&o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),o}createEmptyElement(t,e,n={}){const o=new As(this.document,t,e);return n.renderUnsafeAttributes&&o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),o}createUIElement(t,e,n){const o=new vs(this.document,t,e);return n&&(o.render=n),o}createRawElement(t,e,n,o={}){const i=new Es(this.document,t,e);return n&&(i.render=n),o.renderUnsafeAttributes&&i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes),i}setAttribute(t,e,n){n._setAttribute(t,e);}removeAttribute(t,e){e._removeAttribute(t);}addClass(t,e){e._addClass(t);}removeClass(t,e){e._removeClass(t);}setStyle(t,e,n){Ct(t)&&void 0===n?e._setStyle(t):n._setStyle(t,e);}removeStyle(t,e){e._removeStyle(t);}setCustomProperty(t,e,n){n._setCustomProperty(t,e);}removeCustomProperty(t,e){return e._removeCustomProperty(t)}breakAttributes(t){return t instanceof rs?this._breakAttributes(t):this._breakAttributesRange(t)}breakContainer(t){const e=t.parent;if(!e.is("containerElement"))throw new k("view-writer-break-non-container-element",this.document);if(!e.parent)throw new k("view-writer-break-root",this.document);if(t.isAtStart)return rs._createBefore(e);if(!t.isAtEnd){const n=e._clone(!1);this.insert(rs._createAfter(e),n);const o=new ss(t,rs._createAt(e,"end")),i=new rs(n,0);this.move(o,i);}return rs._createAfter(e)}mergeAttributes(t){const e=t.offset,n=t.parent;if(n.is("$text"))return t;if(n.is("attributeElement")&&0===n.childCount){const t=n.parent,e=n.index;return n._remove(),this._removeFromClonedElementsGroup(n),this.mergeAttributes(new rs(t,e))}const o=n.getChild(e-1),i=n.getChild(e);if(!o||!i)return t;if(o.is("$text")&&i.is("$text"))return Ps(o,i);if(o.is("attributeElement")&&i.is("attributeElement")&&o.isSimilar(i)){const t=o.childCount;return o._appendChild(i.getChildren()),i._remove(),this._removeFromClonedElementsGroup(i),this.mergeAttributes(new rs(o,t))}return t}mergeContainers(t){const e=t.nodeBefore,n=t.nodeAfter;if(!(e&&n&&e.is("containerElement")&&n.is("containerElement")))throw new k("view-writer-merge-containers-invalid-position",this.document);const o=e.getChild(e.childCount-1),i=o instanceof Qi?rs._createAt(o,"end"):rs._createAt(e,"end");return this.move(ss._createIn(n),rs._createAt(e,"end")),this.remove(ss._createOn(n)),i}insert(t,e){Ls(e=Z(e)?[...e]:[e],this.document);const n=e.reduce(((t,e)=>{const n=t[t.length-1],o=!e.is("uiElement");return n&&n.breakAttributes==o?n.nodes.push(e):t.push({breakAttributes:o,nodes:[e]}),t}),[]);let o=null,i=t;for(const{nodes:t,breakAttributes:e}of n){const n=this._insertNodes(i,t,e);o||(o=n.start),i=n.end;}return o?new ss(o,i):new ss(t)}remove(t){const e=t instanceof ss?t:ss._createOn(t);if(Rs(e,this.document),e.isCollapsed)return new Is(this.document);const{start:n,end:o}=this._breakAttributesRange(e,!0),i=n.parent,r=o.offset-n.offset,s=i._removeChildren(n.offset,r);for(const t of s)this._removeFromClonedElementsGroup(t);const a=this.mergeAttributes(n);return e.start=a,e.end=a.clone(),new Is(this.document,s)}clear(t,e){Rs(t,this.document);const n=t.getWalker({direction:"backward",ignoreElementEnd:!0});for(const o of n){const n=o.item;let i;if(n.is("element")&&e.isSimilar(n))i=ss._createOn(n);else if(!o.nextPosition.isAfter(t.start)&&n.is("$textProxy")){const t=n.getAncestors().find((t=>t.is("element")&&e.isSimilar(t)));t&&(i=ss._createIn(t));}i&&(i.end.isAfter(t.end)&&(i.end=t.end),i.start.isBefore(t.start)&&(i.start=t.start),this.remove(i));}}move(t,e){let n;if(e.isAfter(t.end)){const o=(e=this._breakAttributes(e,!0)).parent,i=o.childCount;t=this._breakAttributesRange(t,!0),n=this.remove(t),e.offset+=o.childCount-i;}else n=this.remove(t);return this.insert(e,n)}wrap(t,e){if(!(e instanceof bs))throw new k("view-writer-wrap-invalid-attribute",this.document);if(Rs(t,this.document),t.isCollapsed){let o=t.start;o.parent.is("element")&&(n=o.parent,!Array.from(n.getChildren()).some((t=>!t.is("uiElement"))))&&(o=o.getLastMatchingPosition((t=>t.item.is("uiElement")))),o=this._wrapPosition(o,e);const i=this.document.selection;return i.isCollapsed&&i.getFirstPosition().isEqual(t.start)&&this.setSelection(o),new ss(o)}return this._wrapRange(t,e);var n;}unwrap(t,e){if(!(e instanceof bs))throw new k("view-writer-unwrap-invalid-attribute",this.document);if(Rs(t,this.document),t.isCollapsed)return t;const{start:n,end:o}=this._breakAttributesRange(t,!0),i=n.parent,r=this._unwrapChildren(i,n.offset,o.offset,e),s=this.mergeAttributes(r.start);s.isEqual(r.start)||r.end.offset--;const a=this.mergeAttributes(r.end);return new ss(s,a)}rename(t,e){const n=new Xr(this.document,t,e.getAttributes());return this.insert(rs._createAfter(e),n),this.move(ss._createIn(e),rs._createAt(n,0)),this.remove(ss._createOn(e)),n}clearClonedElementsGroup(t){this._cloneGroups.delete(t);}createPositionAt(t,e){return rs._createAt(t,e)}createPositionAfter(t){return rs._createAfter(t)}createPositionBefore(t){return rs._createBefore(t)}createRange(...t){return new ss(...t)}createRangeOn(t){return ss._createOn(t)}createRangeIn(t){return ss._createIn(t)}createSelection(...t){return new cs(...t)}createSlot(t){if(!this._slotFactory)throw new k("view-writer-invalid-create-slot-context",this.document);return this._slotFactory(this,t)}_registerSlotFactory(t){this._slotFactory=t;}_clearSlotFactory(){this._slotFactory=null;}_insertNodes(t,e,n){let o,i;if(o=n?Ts(t):t.parent.is("$text")?t.parent.parent:t.parent,!o)throw new k("view-writer-invalid-position-container",this.document);i=n?this._breakAttributes(t,!0):t.parent.is("$text")?Bs(t):t;const r=o._insertChild(i.offset,e);for(const t of e)this._addToClonedElementsGroup(t);const s=i.getShiftedBy(r),a=this.mergeAttributes(i);a.isEqual(i)||s.offset--;const c=this.mergeAttributes(s);return new ss(a,c)}_wrapChildren(t,e,n,o){let i=e;const r=[];for(;i<n;){const e=t.getChild(i),n=e.is("$text"),s=e.is("attributeElement");if(s&&this._wrapAttributeElement(o,e))r.push(new rs(t,i));else if(n||!s||Ss(o,e)){const n=o._clone();e._remove(),n._appendChild(e),t._insertChild(i,n),this._addToClonedElementsGroup(n),r.push(new rs(t,i));}else this._wrapChildren(e,0,e.childCount,o);i++;}let s=0;for(const t of r){if(t.offset-=s,t.offset==e)continue;this.mergeAttributes(t).isEqual(t)||(s++,n--);}return ss._createFromParentsAndOffsets(t,e,t,n)}_unwrapChildren(t,e,n,o){let i=e;const r=[];for(;i<n;){const e=t.getChild(i);if(e.is("attributeElement"))if(e.isSimilar(o)){const o=e.getChildren(),s=e.childCount;e._remove(),t._insertChild(i,o),this._removeFromClonedElementsGroup(e),r.push(new rs(t,i),new rs(t,i+s)),i+=s,n+=s-1;}else this._unwrapAttributeElement(o,e)?(r.push(new rs(t,i),new rs(t,i+1)),i++):(this._unwrapChildren(e,0,e.childCount,o),i++);else i++;}let s=0;for(const t of r){if(t.offset-=s,t.offset==e||t.offset==n)continue;this.mergeAttributes(t).isEqual(t)||(s++,n--);}return ss._createFromParentsAndOffsets(t,e,t,n)}_wrapRange(t,e){const{start:n,end:o}=this._breakAttributesRange(t,!0),i=n.parent,r=this._wrapChildren(i,n.offset,o.offset,e),s=this.mergeAttributes(r.start);s.isEqual(r.start)||r.end.offset--;const a=this.mergeAttributes(r.end);return new ss(s,a)}_wrapPosition(t,e){if(e.isSimilar(t.parent))return Ns(t.clone());t.parent.is("$text")&&(t=Bs(t));const n=this.createAttributeElement("_wrapPosition-fake-element");n._priority=Number.POSITIVE_INFINITY,n.isSimilar=()=>!1,t.parent._insertChild(t.offset,n);const o=new ss(t,t.getShiftedBy(1));this.wrap(o,e);const i=new rs(n.parent,n.index);n._remove();const r=i.nodeBefore,s=i.nodeAfter;return r instanceof Qi&&s instanceof Qi?Ps(r,s):Ns(i)}_wrapAttributeElement(t,e){if(!js(t,e))return !1;if(t.name!==e.name||t.priority!==e.priority)return !1;for(const n of t.getAttributeKeys())if("class"!==n&&"style"!==n&&e.hasAttribute(n)&&e.getAttribute(n)!==t.getAttribute(n))return !1;for(const n of t.getStyleNames())if(e.hasStyle(n)&&e.getStyle(n)!==t.getStyle(n))return !1;for(const n of t.getAttributeKeys())"class"!==n&&"style"!==n&&(e.hasAttribute(n)||this.setAttribute(n,t.getAttribute(n),e));for(const n of t.getStyleNames())e.hasStyle(n)||this.setStyle(n,t.getStyle(n),e);for(const n of t.getClassNames())e.hasClass(n)||this.addClass(n,e);return !0}_unwrapAttributeElement(t,e){if(!js(t,e))return !1;if(t.name!==e.name||t.priority!==e.priority)return !1;for(const n of t.getAttributeKeys())if("class"!==n&&"style"!==n&&(!e.hasAttribute(n)||e.getAttribute(n)!==t.getAttribute(n)))return !1;if(!e.hasClass(...t.getClassNames()))return !1;for(const n of t.getStyleNames())if(!e.hasStyle(n)||e.getStyle(n)!==t.getStyle(n))return !1;for(const n of t.getAttributeKeys())"class"!==n&&"style"!==n&&this.removeAttribute(n,e);return this.removeClass(Array.from(t.getClassNames()),e),this.removeStyle(Array.from(t.getStyleNames()),e),!0}_breakAttributesRange(t,e=!1){const n=t.start,o=t.end;if(Rs(t,this.document),t.isCollapsed){const n=this._breakAttributes(t.start,e);return new ss(n,n)}const i=this._breakAttributes(o,e),r=i.parent.childCount,s=this._breakAttributes(n,e);return i.offset+=i.parent.childCount-r,new ss(s,i)}_breakAttributes(t,e=!1){const n=t.offset,o=t.parent;if(t.parent.is("emptyElement"))throw new k("view-writer-cannot-break-empty-element",this.document);if(t.parent.is("uiElement"))throw new k("view-writer-cannot-break-ui-element",this.document);if(t.parent.is("rawElement"))throw new k("view-writer-cannot-break-raw-element",this.document);if(!e&&o.is("$text")&&Os(o.parent))return t.clone();if(Os(o))return t.clone();if(o.is("$text"))return this._breakAttributes(Bs(t),e);if(n==o.childCount){const t=new rs(o.parent,o.index+1);return this._breakAttributes(t,e)}if(0===n){const t=new rs(o.parent,o.index);return this._breakAttributes(t,e)}{const t=o.index+1,i=o._clone();o.parent._insertChild(t,i),this._addToClonedElementsGroup(i);const r=o.childCount-n,s=o._removeChildren(n,r);i._appendChild(s);const a=new rs(o.parent,t);return this._breakAttributes(a,e)}}_addToClonedElementsGroup(t){if(!t.root.is("rootElement"))return;if(t.is("element"))for(const e of t.getChildren())this._addToClonedElementsGroup(e);const e=t.id;if(!e)return;let n=this._cloneGroups.get(e);n||(n=new Set,this._cloneGroups.set(e,n)),n.add(t),t._clonesGroup=n;}_removeFromClonedElementsGroup(t){if(t.is("element"))for(const e of t.getChildren())this._removeFromClonedElementsGroup(e);const e=t.id;if(!e)return;const n=this._cloneGroups.get(e);n&&n.delete(t);}}function Ts(t){let e=t.parent;for(;!Os(e);){if(!e)return;e=e.parent;}return e}function Ss(t,e){return t.priority<e.priority||!(t.priority>e.priority)&&t.getIdentity()<e.getIdentity()}function Ns(t){const e=t.nodeBefore;if(e&&e.is("$text"))return new rs(e,e.data.length);const n=t.nodeAfter;return n&&n.is("$text")?new rs(n,0):t}function Bs(t){if(t.offset==t.parent.data.length)return new rs(t.parent.parent,t.parent.index+1);if(0===t.offset)return new rs(t.parent.parent,t.parent.index);const e=t.parent.data.slice(t.offset);return t.parent._data=t.parent.data.slice(0,t.offset),t.parent.parent._insertChild(t.parent.index+1,new Qi(t.root.document,e)),new rs(t.parent.parent,t.parent.index+1)}function Ps(t,e){const n=t.data.length;return t._data+=e.data,e._remove(),new rs(t,n)}const zs=[Qi,bs,Xr,As,Es,vs];function Ls(t,e){for(const n of t){if(!zs.some((t=>n instanceof t)))throw new k("view-writer-insert-invalid-node-type",e);n.is("$text")||Ls(n.getChildren(),e);}}function Os(t){return t&&(t.is("containerElement")||t.is("documentFragment"))}function Rs(t,e){const n=Ts(t.start),o=Ts(t.end);if(!n||!o||n!==o)throw new k("view-writer-invalid-range-container",e)}function js(t,e){return null===t.id&&null===e.id}const Fs=t=>t.createTextNode(" "),Vs=t=>{const e=t.createElement("span");return e.dataset.ckeFiller="true",e.innerText=" ",e},Us=t=>{const e=t.createElement("br");return e.dataset.ckeFiller="true",e},Hs="⁠".repeat(7);function Ws(t){return Bo(t)&&t.data.substr(0,7)===Hs}function Gs(t){return 7==t.data.length&&Ws(t)}function qs(t){return Ws(t)?t.data.slice(7):t.data}function Ys(t,e){if(e.keyCode==li.arrowleft){const t=e.domTarget.ownerDocument.defaultView.getSelection();if(1==t.rangeCount&&t.getRangeAt(0).collapsed){const e=t.getRangeAt(0).startContainer,n=t.getRangeAt(0).startOffset;Ws(e)&&n<=7&&t.collapse(e,0);}}}var $s=n(9315),Ks={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()($s.Z,Ks);$s.Z.locals;class Qs extends(H()){constructor(t,e){super(),this.domDocuments=new Set,this.domConverter=t,this.markedAttributes=new Set,this.markedChildren=new Set,this.markedTexts=new Set,this.selection=e,this.set("isFocused",!1),this.set("_isFocusChanging",!1),this.set("isSelecting",!1),i.isBlink&&!i.isAndroid&&this.on("change:isSelecting",(()=>{this.isSelecting||this.render();})),this.set("isComposing",!1),this.on("change:isComposing",(()=>{this.isComposing||this.render();})),this._inlineFiller=null,this._fakeSelectionContainer=null;}markToSync(t,e){if("text"===t)this.domConverter.mapViewToDom(e.parent)&&this.markedTexts.add(e);else {if(!this.domConverter.mapViewToDom(e))return;if("attributes"===t)this.markedAttributes.add(e);else {if("children"!==t)throw new k("view-renderer-unknown-type",this);this.markedChildren.add(e);}}}render(){if(this.isComposing&&!i.isAndroid)return;let t=null;const e=!(i.isBlink&&!i.isAndroid)||!this.isSelecting;for(const t of this.markedChildren)this._updateChildrenMappings(t);e?(this._inlineFiller&&!this._isSelectionInInlineFiller()&&this._removeInlineFiller(),this._inlineFiller?t=this._getInlineFillerPosition():this._needsInlineFillerAtSelection()&&(t=this.selection.getFirstPosition(),this.markedChildren.add(t.parent))):this._inlineFiller&&this._inlineFiller.parentNode&&(t=this.domConverter.domPositionToView(this._inlineFiller),t&&t.parent.is("$text")&&(t=rs._createBefore(t.parent)));for(const t of this.markedAttributes)this._updateAttrs(t);for(const e of this.markedChildren)this._updateChildren(e,{inlineFillerPosition:t});for(const e of this.markedTexts)!this.markedChildren.has(e.parent)&&this.domConverter.mapViewToDom(e.parent)&&this._updateText(e,{inlineFillerPosition:t});if(e)if(t){const e=this.domConverter.viewPositionToDom(t),n=e.parent.ownerDocument;Ws(e.parent)?this._inlineFiller=e.parent:this._inlineFiller=Zs(n,e.parent,e.offset);}else this._inlineFiller=null;this._updateFocus(),this._updateSelection(),this.markedTexts.clear(),this.markedAttributes.clear(),this.markedChildren.clear();}_updateChildrenMappings(t){if(!this.domConverter.mapViewToDom(t))return;const e=Array.from(this.domConverter.mapViewToDom(t).childNodes),n=Array.from(this.domConverter.viewChildrenToDom(t,{withChildren:!1})),o=this._diffNodeLists(e,n),i=this._findReplaceActions(o,e,n);if(-1!==i.indexOf("replace")){const o={equal:0,insert:0,delete:0};for(const r of i)if("replace"===r){const i=o.equal+o.insert,r=o.equal+o.delete,s=t.getChild(i);!s||s.is("uiElement")||s.is("rawElement")||this._updateElementMappings(s,e[r]),Zo(n[i]),o.equal++;}else o[r]++;}}_updateElementMappings(t,e){this.domConverter.unbindDomElement(e),this.domConverter.bindElements(e,t),this.markedChildren.add(t),this.markedAttributes.add(t);}_getInlineFillerPosition(){const t=this.selection.getFirstPosition();return t.parent.is("$text")?rs._createBefore(t.parent):t}_isSelectionInInlineFiller(){if(1!=this.selection.rangeCount||!this.selection.isCollapsed)return !1;const t=this.selection.getFirstPosition(),e=this.domConverter.viewPositionToDom(t);return !!(e&&Bo(e.parent)&&Ws(e.parent))}_removeInlineFiller(){const t=this._inlineFiller;if(!Ws(t))throw new k("view-renderer-filler-was-lost",this);Gs(t)?t.remove():t.data=t.data.substr(7),this._inlineFiller=null;}_needsInlineFillerAtSelection(){if(1!=this.selection.rangeCount||!this.selection.isCollapsed)return !1;const t=this.selection.getFirstPosition(),e=t.parent,n=t.offset;if(!this.domConverter.mapViewToDom(e.root))return !1;if(!e.is("element"))return !1;if(!function(t){if("false"==t.getAttribute("contenteditable"))return !1;const e=t.findAncestor((t=>t.hasAttribute("contenteditable")));return !e||"true"==e.getAttribute("contenteditable")}(e))return !1;if(n===e.getFillerOffset())return !1;const o=t.nodeBefore,r=t.nodeAfter;return !(o instanceof Qi||r instanceof Qi)&&(!i.isAndroid||!o&&!r)}_updateText(t,e){const n=this.domConverter.findCorrespondingDomText(t);let o=this.domConverter.viewToDom(t).data;const i=e.inlineFillerPosition;i&&i.parent==t.parent&&i.offset==t.index&&(o=Hs+o),ea(n,o);}_updateAttrs(t){const e=this.domConverter.mapViewToDom(t);if(!e)return;const n=Array.from(e.attributes).map((t=>t.name)),o=t.getAttributeKeys();for(const n of o)this.domConverter.setDomElementAttribute(e,n,t.getAttribute(n),t);for(const o of n)t.hasAttribute(o)||this.domConverter.removeDomElementAttribute(e,o);}_updateChildren(t,e){const n=this.domConverter.mapViewToDom(t);if(!n)return;if(i.isAndroid){let t=null;for(const e of Array.from(n.childNodes)){if(t&&Bo(t)&&Bo(e)){n.normalize();break}t=e;}}const o=e.inlineFillerPosition,r=n.childNodes,s=Array.from(this.domConverter.viewChildrenToDom(t,{bind:!0}));o&&o.parent===t&&Zs(n.ownerDocument,s,o.offset);const a=this._diffNodeLists(r,s),c=i.isAndroid?this._findReplaceActions(a,r,s,{replaceText:!0}):a;let l=0;const d=new Set;for(const t of c)"delete"===t?(d.add(r[l]),Zo(r[l])):"equal"!==t&&"replace"!==t||l++;l=0;for(const t of c)"insert"===t?(Go(n,l,s[l]),l++):"replace"===t?(ea(r[l],s[l].data),l++):"equal"===t&&(this._markDescendantTextToSync(this.domConverter.domToView(s[l])),l++);for(const t of d)t.parentNode||this.domConverter.unbindDomElement(t);}_diffNodeLists(t,e){return t=function(t,e){const n=Array.from(t);if(0==n.length||!e)return n;const o=n[n.length-1];o==e&&n.pop();return n}(t,this._fakeSelectionContainer),l(t,e,ta.bind(null,this.domConverter))}_findReplaceActions(t,e,n,o={}){if(-1===t.indexOf("insert")||-1===t.indexOf("delete"))return t;let i=[],r=[],s=[];const a={equal:0,insert:0,delete:0};for(const c of t)"insert"===c?s.push(n[a.equal+a.insert]):"delete"===c?r.push(e[a.equal+a.delete]):(i=i.concat(l(r,s,o.replaceText?Xs:Js).map((t=>"equal"===t?"replace":t))),i.push("equal"),r=[],s=[]),a[c]++;return i.concat(l(r,s,o.replaceText?Xs:Js).map((t=>"equal"===t?"replace":t)))}_markDescendantTextToSync(t){if(t)if(t.is("$text"))this.markedTexts.add(t);else if(t.is("element"))for(const e of t.getChildren())this._markDescendantTextToSync(e);}_updateSelection(){if(i.isBlink&&!i.isAndroid&&this.isSelecting&&!this.markedChildren.size)return;if(this._isFocusChanging)return;if(0===this.selection.rangeCount)return this._removeDomSelection(),void this._removeFakeSelection();const t=this.domConverter.mapViewToDom(this.selection.editableElement);this.isFocused&&t&&(this.selection.isFake?this._updateFakeSelection(t):this._fakeSelectionContainer&&this._fakeSelectionContainer.isConnected?(this._removeFakeSelection(),this._updateDomSelection(t)):this.isComposing&&i.isAndroid||this._updateDomSelection(t));}_updateFakeSelection(t){const e=t.ownerDocument;this._fakeSelectionContainer||(this._fakeSelectionContainer=function(t){const e=t.createElement("div");return e.className="ck-fake-selection-container",Object.assign(e.style,{position:"fixed",top:0,left:"-9999px",width:"42px"}),e.textContent=" ",e}(e));const n=this._fakeSelectionContainer;if(this.domConverter.bindFakeSelection(n,this.selection),!this._fakeSelectionNeedsUpdate(t))return;n.parentElement&&n.parentElement==t||t.appendChild(n),n.textContent=this.selection.fakeSelectionLabel||" ";const o=e.getSelection(),i=e.createRange();o.removeAllRanges(),i.selectNodeContents(n),o.addRange(i);}_updateDomSelection(t){const e=t.ownerDocument.defaultView.getSelection();if(!this._domSelectionNeedsUpdate(e))return;const n=this.domConverter.viewPositionToDom(this.selection.anchor),o=this.domConverter.viewPositionToDom(this.selection.focus);e.collapse(n.parent,n.offset),e.extend(o.parent,o.offset),i.isGecko&&function(t,e){const n=t.parent;if(n.nodeType!=Node.ELEMENT_NODE||t.offset!=n.childNodes.length-1)return;const o=n.childNodes[t.offset];o&&"BR"==o.tagName&&e.addRange(e.getRangeAt(0));}(o,e);}_domSelectionNeedsUpdate(t){if(!this.domConverter.isDomSelectionCorrect(t))return !0;const e=t&&this.domConverter.domSelectionToView(t);return (!e||!this.selection.isEqual(e))&&!(!this.selection.isCollapsed&&this.selection.isSimilar(e))}_fakeSelectionNeedsUpdate(t){const e=this._fakeSelectionContainer,n=t.ownerDocument.getSelection();return !e||e.parentElement!==t||(n.anchorNode!==e&&!e.contains(n.anchorNode)||e.textContent!==this.selection.fakeSelectionLabel)}_removeDomSelection(){for(const t of this.domDocuments){const e=t.getSelection();if(e.rangeCount){const n=t.activeElement,o=this.domConverter.mapDomToView(n);n&&o&&e.removeAllRanges();}}}_removeFakeSelection(){const t=this._fakeSelectionContainer;t&&t.remove();}_updateFocus(){if(this.isFocused){const t=this.selection.editableElement;t&&this.domConverter.focus(t);}}}function Zs(t,e,n){const o=e instanceof Array?e:e.childNodes,i=o[n];if(Bo(i))return i.data=Hs+i.data,i;{const i=t.createTextNode(Hs);return Array.isArray(e)?o.splice(n,0,i):Go(e,n,i),i}}function Js(t,e){return yo(t)&&yo(e)&&!Bo(t)&&!Bo(e)&&!qo(t)&&!qo(e)&&t.tagName.toLowerCase()===e.tagName.toLowerCase()}function Xs(t,e){return yo(t)&&yo(e)&&Bo(t)&&Bo(e)}function ta(t,e,n){return e===n||(Bo(e)&&Bo(n)?e.data===n.data:!(!t.isBlockFiller(e)||!t.isBlockFiller(n)))}function ea(t,e){const n=t.data;if(n==e)return;const o=s(n,e);for(const e of o)"insert"===e.type?t.insertData(e.index,e.values.join("")):t.deleteData(e.index,e.howMany);}const na=Us(So.document),oa=Fs(So.document),ia=Vs(So.document),ra="data-ck-unsafe-attribute-",sa="data-ck-unsafe-element";class aa{constructor(t,e={}){this.document=t,this.renderingMode=e.renderingMode||"editing",this.blockFillerMode=e.blockFillerMode||("editing"===this.renderingMode?"br":"nbsp"),this.preElements=["pre"],this.blockElements=["address","article","aside","blockquote","caption","center","dd","details","dir","div","dl","dt","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","legend","li","main","menu","nav","ol","p","pre","section","summary","table","tbody","td","tfoot","th","thead","tr","ul"],this.inlineObjectElements=["object","iframe","input","button","textarea","select","option","video","embed","audio","img","canvas"],this.unsafeElements=["script","style"],this._domDocument="editing"===this.renderingMode?So.document:So.document.implementation.createHTMLDocument(""),this._domToViewMapping=new WeakMap,this._viewToDomMapping=new WeakMap,this._fakeSelectionMapping=new WeakMap,this._rawContentElementMatcher=new Ji,this._encounteredRawContentDomNodes=new WeakSet;}bindFakeSelection(t,e){this._fakeSelectionMapping.set(t,new cs(e));}fakeSelectionToView(t){return this._fakeSelectionMapping.get(t)}bindElements(t,e){this._domToViewMapping.set(t,e),this._viewToDomMapping.set(e,t);}unbindDomElement(t){const e=this._domToViewMapping.get(t);if(e){this._domToViewMapping.delete(t),this._viewToDomMapping.delete(e);for(const e of Array.from(t.children))this.unbindDomElement(e);}}bindDocumentFragments(t,e){this._domToViewMapping.set(t,e),this._viewToDomMapping.set(e,t);}shouldRenderAttribute(t,e,n){return "data"===this.renderingMode||!(t=t.toLowerCase()).startsWith("on")&&(("srcdoc"!==t||!e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i))&&("img"===n&&("src"===t||"srcset"===t)||("source"===n&&"srcset"===t||!e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))))}setContentOf(t,e){if("data"===this.renderingMode)return void(t.innerHTML=e);const n=(new DOMParser).parseFromString(e,"text/html"),o=n.createDocumentFragment(),i=n.body.childNodes;for(;i.length>0;)o.appendChild(i[0]);const r=n.createTreeWalker(o,NodeFilter.SHOW_ELEMENT),s=[];let a;for(;a=r.nextNode();)s.push(a);for(const t of s){for(const e of t.getAttributeNames())this.setDomElementAttribute(t,e,t.getAttribute(e));const e=t.tagName.toLowerCase();this._shouldRenameElement(e)&&(da(e),t.replaceWith(this._createReplacementDomElement(e,t)));}for(;t.firstChild;)t.firstChild.remove();t.append(o);}viewToDom(t,e={}){if(t.is("$text")){const e=this._processDataFromViewText(t);return this._domDocument.createTextNode(e)}{if(this.mapViewToDom(t))return this.mapViewToDom(t);let n;if(t.is("documentFragment"))n=this._domDocument.createDocumentFragment(),e.bind&&this.bindDocumentFragments(n,t);else {if(t.is("uiElement"))return n="$comment"===t.name?this._domDocument.createComment(t.getCustomProperty("$rawContent")):t.render(this._domDocument,this),e.bind&&this.bindElements(n,t),n;this._shouldRenameElement(t.name)?(da(t.name),n=this._createReplacementDomElement(t.name)):n=t.hasAttribute("xmlns")?this._domDocument.createElementNS(t.getAttribute("xmlns"),t.name):this._domDocument.createElement(t.name),t.is("rawElement")&&t.render(n,this),e.bind&&this.bindElements(n,t);for(const e of t.getAttributeKeys())this.setDomElementAttribute(n,e,t.getAttribute(e),t);}if(!1!==e.withChildren)for(const o of this.viewChildrenToDom(t,e))n.appendChild(o);return n}}setDomElementAttribute(t,e,n,o){const i=this.shouldRenderAttribute(e,n,t.tagName.toLowerCase())||o&&o.shouldRenderUnsafeAttribute(e);i||b("domconverter-unsafe-attribute-detected",{domElement:t,key:e,value:n}),t.hasAttribute(e)&&!i?t.removeAttribute(e):t.hasAttribute(ra+e)&&i&&t.removeAttribute(ra+e),t.setAttribute(i?e:ra+e,n);}removeDomElementAttribute(t,e){e!=sa&&(t.removeAttribute(e),t.removeAttribute(ra+e));}*viewChildrenToDom(t,e={}){const n=t.getFillerOffset&&t.getFillerOffset();let o=0;for(const i of t.getChildren()){n===o&&(yield this._getBlockFiller());const t=i.is("element")&&i.getCustomProperty("dataPipeline:transparentRendering");t&&"data"==this.renderingMode?yield*this.viewChildrenToDom(i,e):(t&&b("domconverter-transparent-rendering-unsupported-in-editing-pipeline",{viewElement:i}),yield this.viewToDom(i,e)),o++;}n===o&&(yield this._getBlockFiller());}viewRangeToDom(t){const e=this.viewPositionToDom(t.start),n=this.viewPositionToDom(t.end),o=this._domDocument.createRange();return o.setStart(e.parent,e.offset),o.setEnd(n.parent,n.offset),o}viewPositionToDom(t){const e=t.parent;if(e.is("$text")){const n=this.findCorrespondingDomText(e);if(!n)return null;let o=t.offset;return Ws(n)&&(o+=7),{parent:n,offset:o}}{let n,o,i;if(0===t.offset){if(n=this.mapViewToDom(e),!n)return null;i=n.childNodes[0];}else {const e=t.nodeBefore;if(o=e.is("$text")?this.findCorrespondingDomText(e):this.mapViewToDom(e),!o)return null;n=o.parentNode,i=o.nextSibling;}if(Bo(i)&&Ws(i))return {parent:i,offset:7};return {parent:n,offset:o?Wo(o)+1:0}}}domToView(t,e={}){if(this.isBlockFiller(t))return null;const n=this.getHostViewElement(t);if(n)return n;if(qo(t)&&e.skipComments)return null;if(Bo(t)){if(Gs(t))return null;{const e=this._processDataFromDomText(t);return ""===e?null:new Qi(this.document,e)}}{if(this.mapDomToView(t))return this.mapDomToView(t);let n;if(this.isDocumentFragment(t))n=new Is(this.document),e.bind&&this.bindDocumentFragments(t,n);else {n=this._createViewElement(t,e),e.bind&&this.bindElements(t,n);const o=t.attributes;if(o)for(let t=o.length,e=0;e<t;e++)n._setAttribute(o[e].name,o[e].value);if(this._isViewElementWithRawContent(n,e)||qo(t)){const e=qo(t)?t.data:t.innerHTML;return n._setCustomProperty("$rawContent",e),this._encounteredRawContentDomNodes.add(t),n}}if(!1!==e.withChildren)for(const o of this.domChildrenToView(t,e))n._appendChild(o);return n}}*domChildrenToView(t,e){for(let n=0;n<t.childNodes.length;n++){const o=t.childNodes[n],i=this.domToView(o,e);null!==i&&(yield i);}}domSelectionToView(t){if(1===t.rangeCount){let e=t.getRangeAt(0).startContainer;Bo(e)&&(e=e.parentNode);const n=this.fakeSelectionToView(e);if(n)return n}const e=this.isDomSelectionBackward(t),n=[];for(let e=0;e<t.rangeCount;e++){const o=t.getRangeAt(e),i=this.domRangeToView(o);i&&n.push(i);}return new cs(n,{backward:e})}domRangeToView(t){const e=this.domPositionToView(t.startContainer,t.startOffset),n=this.domPositionToView(t.endContainer,t.endOffset);return e&&n?new ss(e,n):null}domPositionToView(t,e=0){if(this.isBlockFiller(t))return this.domPositionToView(t.parentNode,Wo(t));const n=this.mapDomToView(t);if(n&&(n.is("uiElement")||n.is("rawElement")))return rs._createBefore(n);if(Bo(t)){if(Gs(t))return this.domPositionToView(t.parentNode,Wo(t));const n=this.findCorrespondingViewText(t);let o=e;return n?(Ws(t)&&(o-=7,o=o<0?0:o),new rs(n,o)):null}if(0===e){const e=this.mapDomToView(t);if(e)return new rs(e,0)}else {const n=t.childNodes[e-1];if(Bo(n)&&Gs(n))return this.domPositionToView(n.parentNode,Wo(n));const o=Bo(n)?this.findCorrespondingViewText(n):this.mapDomToView(n);if(o&&o.parent)return new rs(o.parent,o.index+1)}return null}mapDomToView(t){return this.getHostViewElement(t)||this._domToViewMapping.get(t)}findCorrespondingViewText(t){if(Gs(t))return null;const e=this.getHostViewElement(t);if(e)return e;const n=t.previousSibling;if(n){if(!this.isElement(n))return null;const t=this.mapDomToView(n);if(t){const e=t.nextSibling;return e instanceof Qi?e:null}}else {const e=this.mapDomToView(t.parentNode);if(e){const t=e.getChild(0);return t instanceof Qi?t:null}}return null}mapViewToDom(t){return this._viewToDomMapping.get(t)}findCorrespondingDomText(t){const e=t.previousSibling;return e&&this.mapViewToDom(e)?this.mapViewToDom(e).nextSibling:!e&&t.parent&&this.mapViewToDom(t.parent)?this.mapViewToDom(t.parent).childNodes[0]:null}focus(t){const e=this.mapViewToDom(t);if(e&&e.ownerDocument.activeElement!==e){const{scrollX:t,scrollY:n}=So.window,o=[];ca(e,(t=>{const{scrollLeft:e,scrollTop:n}=t;o.push([e,n]);})),e.focus(),ca(e,(t=>{const[e,n]=o.shift();t.scrollLeft=e,t.scrollTop=n;})),So.window.scrollTo(t,n);}}isElement(t){return t&&t.nodeType==Node.ELEMENT_NODE}isDocumentFragment(t){return t&&t.nodeType==Node.DOCUMENT_FRAGMENT_NODE}isBlockFiller(t){return "br"==this.blockFillerMode?t.isEqualNode(na):!("BR"!==t.tagName||!la(t,this.blockElements)||1!==t.parentNode.childNodes.length)||(t.isEqualNode(ia)||function(t,e){const n=t.isEqualNode(oa);return n&&la(t,e)&&1===t.parentNode.childNodes.length}(t,this.blockElements))}isDomSelectionBackward(t){if(t.isCollapsed)return !1;const e=this._domDocument.createRange();try{e.setStart(t.anchorNode,t.anchorOffset),e.setEnd(t.focusNode,t.focusOffset);}catch(t){return !1}const n=e.collapsed;return e.detach(),n}getHostViewElement(t){const e=No(t);for(e.pop();e.length;){const t=e.pop(),n=this._domToViewMapping.get(t);if(n&&(n.is("uiElement")||n.is("rawElement")))return n}return null}isDomSelectionCorrect(t){return this._isDomSelectionPositionCorrect(t.anchorNode,t.anchorOffset)&&this._isDomSelectionPositionCorrect(t.focusNode,t.focusOffset)}registerRawContentMatcher(t){this._rawContentElementMatcher.add(t);}_getBlockFiller(){switch(this.blockFillerMode){case"nbsp":return Fs(this._domDocument);case"markedNbsp":return Vs(this._domDocument);case"br":return Us(this._domDocument)}}_isDomSelectionPositionCorrect(t,e){if(Bo(t)&&Ws(t)&&e<7)return !1;if(this.isElement(t)&&Ws(t.childNodes[e]))return !1;const n=this.mapDomToView(t);return !n||!n.is("uiElement")&&!n.is("rawElement")}_processDataFromViewText(t){let e=t.data;if(t.getAncestors().some((t=>this.preElements.includes(t.name))))return e;if(" "==e.charAt(0)){const n=this._getTouchingInlineViewNode(t,!1);!(n&&n.is("$textProxy")&&this._nodeEndsWithSpace(n))&&n||(e=" "+e.substr(1));}if(" "==e.charAt(e.length-1)){const n=this._getTouchingInlineViewNode(t,!0),o=n&&n.is("$textProxy")&&" "==n.data.charAt(0);" "!=e.charAt(e.length-2)&&n&&!o||(e=e.substr(0,e.length-1)+" ");}return e.replace(/ {2}/g,"  ")}_nodeEndsWithSpace(t){if(t.getAncestors().some((t=>this.preElements.includes(t.name))))return !1;const e=this._processDataFromViewText(t);return " "==e.charAt(e.length-1)}_processDataFromDomText(t){let e=t.data;if(function(t,e){const n=No(t);return n.some((t=>t.tagName&&e.includes(t.tagName.toLowerCase())))}(t,this.preElements))return qs(t);e=e.replace(/[ \n\t\r]{1,}/g," ");const n=this._getTouchingInlineDomNode(t,!1),o=this._getTouchingInlineDomNode(t,!0),i=this._checkShouldLeftTrimDomText(t,n),r=this._checkShouldRightTrimDomText(t,o);i&&(e=e.replace(/^ /,"")),r&&(e=e.replace(/ $/,"")),e=qs(new Text(e)),e=e.replace(/ \u00A0/g,"  ");const s=o&&this.isElement(o)&&"BR"!=o.tagName,a=o&&Bo(o)&&" "==o.data.charAt(0);return (/( |\u00A0)\u00A0$/.test(e)||!o||s||a)&&(e=e.replace(/\u00A0$/," ")),(i||n&&this.isElement(n)&&"BR"!=n.tagName)&&(e=e.replace(/^\u00A0/," ")),e}_checkShouldLeftTrimDomText(t,e){return !e||(this.isElement(e)?"BR"===e.tagName:!this._encounteredRawContentDomNodes.has(t.previousSibling)&&/[^\S\u00A0]/.test(e.data.charAt(e.data.length-1)))}_checkShouldRightTrimDomText(t,e){return !e&&!Ws(t)}_getTouchingInlineViewNode(t,e){const n=new is({startPosition:e?rs._createAfter(t):rs._createBefore(t),direction:e?"forward":"backward"});for(const t of n){if(t.item.is("element")&&this.inlineObjectElements.includes(t.item.name))return t.item;if(t.item.is("containerElement"))return null;if(t.item.is("element","br"))return null;if(t.item.is("$textProxy"))return t.item}return null}_getTouchingInlineDomNode(t,e){if(!t.parentNode)return null;const n=e?"firstChild":"lastChild",o=e?"nextSibling":"previousSibling";let i=!0,r=t;do{if(!i&&r[n]?r=r[n]:r[o]?(r=r[o],i=!1):(r=r.parentNode,i=!0),!r||this._isBlockElement(r))return null}while(!Bo(r)&&"BR"!=r.tagName&&!this._isInlineObjectElement(r));return r}_isBlockElement(t){return this.isElement(t)&&this.blockElements.includes(t.tagName.toLowerCase())}_isInlineObjectElement(t){return this.isElement(t)&&this.inlineObjectElements.includes(t.tagName.toLowerCase())}_createViewElement(t,e){if(qo(t))return new vs(this.document,"$comment");const n=e.keepOriginalCase?t.tagName:t.tagName.toLowerCase();return new Zr(this.document,n)}_isViewElementWithRawContent(t,e){return !1!==e.withChildren&&!!this._rawContentElementMatcher.match(t)}_shouldRenameElement(t){const e=t.toLowerCase();return "editing"===this.renderingMode&&this.unsafeElements.includes(e)}_createReplacementDomElement(t,e){const n=this._domDocument.createElement("span");if(n.setAttribute(sa,t),e){for(;e.firstChild;)n.appendChild(e.firstChild);for(const t of e.getAttributeNames())n.setAttribute(t,e.getAttribute(t));}return n}}function ca(t,e){let n=t;for(;n;)e(n),n=n.parentElement;}function la(t,e){const n=t.parentNode;return !!n&&!!n.tagName&&e.includes(n.tagName.toLowerCase())}function da(t){"script"===t&&b("domconverter-unsafe-script-element-detected"),"style"===t&&b("domconverter-unsafe-style-element-detected");}class ha extends(Do()){constructor(t){super(),this.view=t,this.document=t.document,this.isEnabled=!1;}enable(){this.isEnabled=!0;}disable(){this.isEnabled=!1;}destroy(){this.disable(),this.stopListening();}checkShouldIgnoreEventFromTarget(t){return t&&3===t.nodeType&&(t=t.parentNode),!(!t||1!==t.nodeType)&&t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")}}const ua=Hr((function(t,e){Ee(e,dn(e),t);}));class ga{constructor(t,e,n){this.view=t,this.document=t.document,this.domEvent=e,this.domTarget=e.target,ua(this,n);}get target(){return this.view.domConverter.mapDomToView(this.domTarget)}preventDefault(){this.domEvent.preventDefault();}stopPropagation(){this.domEvent.stopPropagation();}}class ma extends ha{constructor(t){super(t),this.useCapture=!1;}observe(t){("string"==typeof this.domEventType?[this.domEventType]:this.domEventType).forEach((e=>{this.listenTo(t,e,((t,e)=>{this.isEnabled&&!this.checkShouldIgnoreEventFromTarget(e.target)&&this.onDomEvent(e);}),{useCapture:this.useCapture});}));}fire(t,e,n){this.isEnabled&&this.document.fire(t,new ga(this.view,e,n));}}class pa extends ma{constructor(t){super(t),this.domEventType=["keydown","keyup"];}onDomEvent(t){const e={keyCode:t.keyCode,altKey:t.altKey,ctrlKey:t.ctrlKey,shiftKey:t.shiftKey,metaKey:t.metaKey,get keystroke(){return hi(this)}};this.fire(t.type,t,e);}}const fa=function(){return tt.Date.now()};var ka=/\s/;const ba=function(t){for(var e=t.length;e--&&ka.test(t.charAt(e)););return e};var wa=/^\s+/;const _a=function(t){return t?t.slice(0,ba(t)+1).replace(wa,""):t};var Aa=/^[-+]0x[0-9a-f]+$/i,Ca=/^0b[01]+$/i,va=/^0o[0-7]+$/i,ya=parseInt;const xa=function(t){if("number"==typeof t)return t;if(er(t))return NaN;if(L(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=L(e)?e+"":e;}if("string"!=typeof t)return 0===t?t:+t;t=_a(t);var n=Ca.test(t);return n||va.test(t)?ya(t.slice(2),n?2:8):Aa.test(t)?NaN:+t};var Ea=Math.max,Da=Math.min;const Ia=function(t,e,n){var o,i,r,s,a,c,l=0,d=!1,h=!1,u=!0;if("function"!=typeof t)throw new TypeError("Expected a function");function g(e){var n=o,r=i;return o=i=void 0,l=e,s=t.apply(r,n)}function m(t){return l=t,a=setTimeout(f,e),d?g(t):s}function p(t){var n=t-c;return void 0===c||n>=e||n<0||h&&t-l>=r}function f(){var t=fa();if(p(t))return k(t);a=setTimeout(f,function(t){var n=e-(t-c);return h?Da(n,r-(t-l)):n}(t));}function k(t){return a=void 0,u&&o?g(t):(o=i=void 0,s)}function b(){var t=fa(),n=p(t);if(o=arguments,i=this,c=t,n){if(void 0===a)return m(c);if(h)return clearTimeout(a),a=setTimeout(f,e),g(c)}return void 0===a&&(a=setTimeout(f,e)),s}return e=xa(e)||0,L(n)&&(d=!!n.leading,r=(h="maxWait"in n)?Ea(xa(n.maxWait)||0,e):r,u="trailing"in n?!!n.trailing:u),b.cancel=function(){void 0!==a&&clearTimeout(a),l=0,o=c=i=a=void 0;},b.flush=function(){return void 0===a?s:k(fa())},b};class Ma extends ha{constructor(t){super(t),this._fireSelectionChangeDoneDebounced=Ia((t=>{this.document.fire("selectionChangeDone",t);}),200);}observe(){const t=this.document;t.on("arrowKey",((e,n)=>{t.selection.isFake&&this.isEnabled&&n.preventDefault();}),{context:"$capture"}),t.on("arrowKey",((e,n)=>{t.selection.isFake&&this.isEnabled&&this._handleSelectionMove(n.keyCode);}),{priority:"lowest"});}destroy(){super.destroy(),this._fireSelectionChangeDoneDebounced.cancel();}_handleSelectionMove(t){const e=this.document.selection,n=new cs(e.getRanges(),{backward:e.isBackward,fake:!1});t!=li.arrowleft&&t!=li.arrowup||n.setTo(n.getFirstPosition()),t!=li.arrowright&&t!=li.arrowdown||n.setTo(n.getLastPosition());const o={oldSelection:e,newSelection:n,domSelection:null};this.document.fire("selectionChange",o),this._fireSelectionChangeDoneDebounced(o);}}const Ta=function(t){return this.__data__.set(t,"__lodash_hash_undefined__"),this};const Sa=function(t){return this.__data__.has(t)};function Na(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new ke;++e<n;)this.add(t[e]);}Na.prototype.add=Na.prototype.push=Ta,Na.prototype.has=Sa;const Ba=Na;const Pa=function(t,e){for(var n=-1,o=null==t?0:t.length;++n<o;)if(e(t[n],n,t))return !0;return !1};const za=function(t,e){return t.has(e)};const La=function(t,e,n,o,i,r){var s=1&n,a=t.length,c=e.length;if(a!=c&&!(s&&c>a))return !1;var l=r.get(t),d=r.get(e);if(l&&d)return l==e&&d==t;var h=-1,u=!0,g=2&n?new Ba:void 0;for(r.set(t,e),r.set(e,t);++h<a;){var m=t[h],p=e[h];if(o)var f=s?o(p,m,h,e,t,r):o(m,p,h,t,e,r);if(void 0!==f){if(f)continue;u=!1;break}if(g){if(!Pa(e,(function(t,e){if(!za(g,e)&&(m===t||i(m,t,n,o,r)))return g.push(e)}))){u=!1;break}}else if(m!==p&&!i(m,p,n,o,r)){u=!1;break}}return r.delete(t),r.delete(e),u};const Oa=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t,o){n[++e]=[o,t];})),n};const Ra=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t){n[++e]=t;})),n};var ja=et?et.prototype:void 0,Fa=ja?ja.valueOf:void 0;const Va=function(t,e,n,o,i,r,s){switch(n){case"[object DataView]":if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return !1;t=t.buffer,e=e.buffer;case"[object ArrayBuffer]":return !(t.byteLength!=e.byteLength||!r(new $n(t),new $n(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return yt(+t,+e);case"[object Error]":return t.name==e.name&&t.message==e.message;case"[object RegExp]":case"[object String]":return t==e+"";case"[object Map]":var a=Oa;case"[object Set]":var c=1&o;if(a||(a=Ra),t.size!=e.size&&!c)return !1;var l=s.get(t);if(l)return l==e;o|=2,s.set(t,e);var d=La(a(t),a(e),o,i,r,s);return s.delete(t),d;case"[object Symbol]":if(Fa)return Fa.call(t)==Fa.call(e)}return !1};var Ua=Object.prototype.hasOwnProperty;const Ha=function(t,e,n,o,i,r){var s=1&n,a=In(t),c=a.length;if(c!=In(e).length&&!s)return !1;for(var l=c;l--;){var d=a[l];if(!(s?d in e:Ua.call(e,d)))return !1}var h=r.get(t),u=r.get(e);if(h&&u)return h==e&&u==t;var g=!0;r.set(t,e),r.set(e,t);for(var m=s;++l<c;){var p=t[d=a[l]],f=e[d];if(o)var k=s?o(f,p,d,e,t,r):o(p,f,d,t,e,r);if(!(void 0===k?p===f||i(p,f,n,o,r):k)){g=!1;break}m||(m="constructor"==d);}if(g&&!m){var b=t.constructor,w=e.constructor;b==w||!("constructor"in t)||!("constructor"in e)||"function"==typeof b&&b instanceof b&&"function"==typeof w&&w instanceof w||(g=!1);}return r.delete(t),r.delete(e),g};var Wa="[object Arguments]",Ga="[object Array]",qa="[object Object]",Ya=Object.prototype.hasOwnProperty;const $a=function(t,e,n,o,i,r){var s=ht(t),a=ht(e),c=s?Ga:Gn(t),l=a?Ga:Gn(e),d=(c=c==Wa?qa:c)==qa,h=(l=l==Wa?qa:l)==qa,u=c==l;if(u&&Oe(t)){if(!Oe(e))return !1;s=!0,d=!1;}if(u&&!d)return r||(r=new _e),s||Ke(t)?La(t,e,n,o,i,r):Va(t,e,c,n,o,i,r);if(!(1&n)){var g=d&&Ya.call(t,"__wrapped__"),m=h&&Ya.call(e,"__wrapped__");if(g||m){var p=g?t.value():t,f=m?e.value():e;return r||(r=new _e),i(p,f,n,o,r)}}return !!u&&(r||(r=new _e),Ha(t,e,n,o,i,r))};const Ka=function t(e,n,o,i,r){return e===n||(null==e||null==n||!ut(e)&&!ut(n)?e!=e&&n!=n:$a(e,n,o,i,t,r))};const Qa=function(t,e,n){var o=(n="function"==typeof n?n:void 0)?n(t,e):void 0;return void 0===o?Ka(t,e,void 0,n):!!o};class Za extends ha{constructor(t){super(t),this._config={childList:!0,characterData:!0,subtree:!0},this.domConverter=t.domConverter,this.renderer=t._renderer,this._domElements=[],this._mutationObserver=new window.MutationObserver(this._onMutations.bind(this));}flush(){this._onMutations(this._mutationObserver.takeRecords());}observe(t){this._domElements.push(t),this.isEnabled&&this._mutationObserver.observe(t,this._config);}enable(){super.enable();for(const t of this._domElements)this._mutationObserver.observe(t,this._config);}disable(){super.disable(),this._mutationObserver.disconnect();}destroy(){super.destroy(),this._mutationObserver.disconnect();}_onMutations(t){if(0===t.length)return;const e=this.domConverter,n=new Set,o=new Set;for(const n of t){const t=e.mapDomToView(n.target);t&&(t.is("uiElement")||t.is("rawElement")||"childList"!==n.type||this._isBogusBrMutation(n)||o.add(t));}for(const i of t){const t=e.mapDomToView(i.target);if((!t||!t.is("uiElement")&&!t.is("rawElement"))&&"characterData"===i.type){const t=e.findCorrespondingViewText(i.target);t&&!o.has(t.parent)?n.add(t):!t&&Ws(i.target)&&o.add(e.mapDomToView(i.target.parentNode));}}let i=!1;for(const t of n)i=!0,this.renderer.markToSync("text",t);for(const t of o){const n=e.mapViewToDom(t),o=Array.from(t.getChildren()),r=Array.from(e.domChildrenToView(n,{withChildren:!1}));Qa(o,r,Ja)||(i=!0,this.renderer.markToSync("children",t));}i&&this.view.forceRender();}_isBogusBrMutation(t){let e=null;return null===t.nextSibling&&0===t.removedNodes.length&&1==t.addedNodes.length&&(e=this.domConverter.domToView(t.addedNodes[0],{withChildren:!1})),e&&e.is("element","br")}}function Ja(t,e){if(!Array.isArray(t))return t===e||!(!t.is("$text")||!e.is("$text"))&&t.data===e.data}class Xa extends ha{constructor(t){super(t),this.mutationObserver=t.getObserver(Za),this.selection=this.document.selection,this.domConverter=t.domConverter,this._documents=new WeakSet,this._fireSelectionChangeDoneDebounced=Ia((t=>{this.document.fire("selectionChangeDone",t);}),200),this._clearInfiniteLoopInterval=setInterval((()=>this._clearInfiniteLoop()),1e3),this._documentIsSelectingInactivityTimeoutDebounced=Ia((()=>this.document.isSelecting=!1),5e3),this._loopbackCounter=0;}observe(t){const e=t.ownerDocument,n=()=>{this.document.isSelecting&&(this._handleSelectionChange(null,e),this.document.isSelecting=!1,this._documentIsSelectingInactivityTimeoutDebounced.cancel());};this.listenTo(t,"selectstart",(()=>{this.document.isSelecting=!0,this._documentIsSelectingInactivityTimeoutDebounced();}),{priority:"highest"}),this.listenTo(t,"keydown",n,{priority:"highest",useCapture:!0}),this.listenTo(t,"keyup",n,{priority:"highest",useCapture:!0}),this._documents.has(e)||(this.listenTo(e,"mouseup",n,{priority:"highest",useCapture:!0}),this.listenTo(e,"selectionchange",((t,n)=>{this.document.isComposing&&!i.isAndroid||(this._handleSelectionChange(n,e),this._documentIsSelectingInactivityTimeoutDebounced());})),this._documents.add(e));}destroy(){super.destroy(),clearInterval(this._clearInfiniteLoopInterval),this._fireSelectionChangeDoneDebounced.cancel(),this._documentIsSelectingInactivityTimeoutDebounced.cancel();}_handleSelectionChange(t,e){if(!this.isEnabled)return;const n=e.defaultView.getSelection();if(this.checkShouldIgnoreEventFromTarget(n.anchorNode))return;this.mutationObserver.flush();const o=this.domConverter.domSelectionToView(n);if(0!=o.rangeCount){if(this.view.hasDomSelection=!0,!(this.selection.isEqual(o)&&this.domConverter.isDomSelectionCorrect(n)||++this._loopbackCounter>60))if(this.selection.isSimilar(o))this.view.forceRender();else {const t={oldSelection:this.selection,newSelection:o,domSelection:n};this.document._isFocusChanging=!1,this.document.fire("selectionChange",t),this._fireSelectionChangeDoneDebounced(t);}}else this.view.hasDomSelection=!1;}_clearInfiniteLoop(){this._loopbackCounter=0;}}class tc extends ma{constructor(t){super(t),this.domEventType=["focus","blur"],this.useCapture=!0;const e=this.document;e.on("focus",(()=>{e.isFocused=!0,e._isFocusChanging=!0,this._renderTimeoutId=setTimeout((()=>{e._isFocusChanging=!1,t.change((()=>{}));}),50);})),e.on("blur",((n,o)=>{const i=e.selection.editableElement;null!==i&&i!==o.target||(e.isFocused=!1,t.change((()=>{})));}));}onDomEvent(t){this.fire(t.type,t);}destroy(){this._renderTimeoutId&&clearTimeout(this._renderTimeoutId),super.destroy();}}class ec extends ma{constructor(t){super(t),this.domEventType=["compositionstart","compositionupdate","compositionend"];const e=this.document;e.on("compositionstart",(()=>{e.isComposing=!0;}),{priority:"low"}),e.on("compositionend",(()=>{e.isComposing=!1;}),{priority:"low"});}onDomEvent(t){this.fire(t.type,t,{data:t.data});}}class nc{constructor(t){this.files=function(t){const e=Array.from(t.files||[]),n=Array.from(t.items||[]);if(e.length)return e;return n.filter((t=>"file"===t.kind)).map((t=>t.getAsFile()))}(t),this._native=t;}get types(){return this._native.types}getData(t){return this._native.getData(t)}setData(t,e){this._native.setData(t,e);}set effectAllowed(t){this._native.effectAllowed=t;}get effectAllowed(){return this._native.effectAllowed}set dropEffect(t){this._native.dropEffect=t;}get dropEffect(){return this._native.dropEffect}get isCanceled(){return "none"==this._native.dropEffect||!!this._native.mozUserCancelled}}class oc extends ma{constructor(t){super(t),this.domEventType=["beforeinput"];}onDomEvent(t){const e=t.getTargetRanges(),n=this.view,o=n.document;let r=null,s=null,a=[];if(t.dataTransfer&&(r=new nc(t.dataTransfer)),null!==t.data?s=t.data:r&&(s=r.getData("text/plain")),o.selection.isFake)a=Array.from(o.selection.getRanges());else if(e.length)a=e.map((t=>n.domConverter.domRangeToView(t)));else if(i.isAndroid){const e=t.target.ownerDocument.defaultView.getSelection();a=Array.from(n.domConverter.domSelectionToView(e).getRanges());}if(i.isAndroid&&"insertCompositionText"==t.inputType&&s&&s.endsWith("\n"))this.fire(t.type,t,{inputType:"insertParagraph",targetRanges:[n.createRange(a[0].end)]});else if("insertText"==t.inputType&&s&&s.includes("\n")){const e=s.split(/\n{1,2}/g);let n=a;for(let i=0;i<e.length;i++){const s=e[i];""!=s&&(this.fire(t.type,t,{data:s,dataTransfer:r,targetRanges:n,inputType:t.inputType,isComposing:t.isComposing}),n=[o.selection.getFirstRange()]),i+1<e.length&&(this.fire(t.type,t,{inputType:"insertParagraph",targetRanges:n}),n=[o.selection.getFirstRange()]);}}else this.fire(t.type,t,{data:s,dataTransfer:r,targetRanges:a,inputType:t.inputType,isComposing:t.isComposing});}}class ic extends ha{constructor(t){super(t),this.document.on("keydown",((t,e)=>{if(this.isEnabled&&((n=e.keyCode)==li.arrowright||n==li.arrowleft||n==li.arrowup||n==li.arrowdown)){const n=new ds(this.document,"arrowKey",this.document.selection.getFirstRange());this.document.fire(n,e),n.stop.called&&t.stop();}var n;}));}observe(){}}class rc extends ha{constructor(t){super(t);const e=this.document;e.on("keydown",((t,n)=>{if(!this.isEnabled||n.keyCode!=li.tab||n.ctrlKey)return;const o=new ds(e,"tab",e.selection.getFirstRange());e.fire(o,n),o.stop.called&&t.stop();}));}observe(){}}class sc extends(H()){constructor(t){super(),this.document=new ks(t),this.domConverter=new aa(this.document),this.domRoots=new Map,this.set("isRenderingInProgress",!1),this.set("hasDomSelection",!1),this._renderer=new Qs(this.domConverter,this.document.selection),this._renderer.bind("isFocused","isSelecting","isComposing","_isFocusChanging").to(this.document,"isFocused","isSelecting","isComposing","_isFocusChanging"),this._initialDomRootAttributes=new WeakMap,this._observers=new Map,this._ongoingChange=!1,this._postFixersInProgress=!1,this._renderingDisabled=!1,this._hasChangedSinceTheLastRendering=!1,this._writer=new Ms(this.document),this.addObserver(Za),this.addObserver(Xa),this.addObserver(tc),this.addObserver(pa),this.addObserver(Ma),this.addObserver(ec),this.addObserver(ic),this.addObserver(oc),this.addObserver(rc),this.document.on("arrowKey",Ys,{priority:"low"}),ys(this),this.on("render",(()=>{this._render(),this.document.fire("layoutChanged"),this._hasChangedSinceTheLastRendering=!1;})),this.listenTo(this.document.selection,"change",(()=>{this._hasChangedSinceTheLastRendering=!0;})),this.listenTo(this.document,"change:isFocused",(()=>{this._hasChangedSinceTheLastRendering=!0;}));}attachDomRoot(t,e="main"){const n=this.document.getRoot(e);n._name=t.tagName.toLowerCase();const o={};for(const{name:e,value:i}of Array.from(t.attributes))o[e]=i,"class"===e?this._writer.addClass(i.split(" "),n):this._writer.setAttribute(e,i,n);this._initialDomRootAttributes.set(t,o);const i=()=>{this._writer.setAttribute("contenteditable",(!n.isReadOnly).toString(),n),n.isReadOnly?this._writer.addClass("ck-read-only",n):this._writer.removeClass("ck-read-only",n);};i(),this.domRoots.set(e,t),this.domConverter.bindElements(t,n),this._renderer.markToSync("children",n),this._renderer.markToSync("attributes",n),this._renderer.domDocuments.add(t.ownerDocument),n.on("change:children",((t,e)=>this._renderer.markToSync("children",e))),n.on("change:attributes",((t,e)=>this._renderer.markToSync("attributes",e))),n.on("change:text",((t,e)=>this._renderer.markToSync("text",e))),n.on("change:isReadOnly",(()=>this.change(i))),n.on("change",(()=>{this._hasChangedSinceTheLastRendering=!0;}));for(const n of this._observers.values())n.observe(t,e);}detachDomRoot(t){const e=this.domRoots.get(t);Array.from(e.attributes).forEach((({name:t})=>e.removeAttribute(t)));const n=this._initialDomRootAttributes.get(e);for(const t in n)e.setAttribute(t,n[t]);this.domRoots.delete(t),this.domConverter.unbindDomElement(e);}getDomRoot(t="main"){return this.domRoots.get(t)}addObserver(t){let e=this._observers.get(t);if(e)return e;e=new t(this),this._observers.set(t,e);for(const[t,n]of this.domRoots)e.observe(n,t);return e.enable(),e}getObserver(t){return this._observers.get(t)}disableObservers(){for(const t of this._observers.values())t.disable();}enableObservers(){for(const t of this._observers.values())t.enable();}scrollToTheSelection(){const t=this.document.selection.getFirstRange();t&&function({target:t,viewportOffset:e=0}){const n=ii(t);let o=n,i=null;for(;o;){let r;r=ri(o==n?t:i),Xo(r,(()=>si(t,o)));const s=si(t,o);if(Jo(o,s,e),o.parent!=o){if(i=o.frameElement,o=o.parent,!i)return}else o=null;}}({target:this.domConverter.viewRangeToDom(t),viewportOffset:20});}focus(){if(!this.document.isFocused){const t=this.document.selection.editableElement;t&&(this.domConverter.focus(t),this.forceRender());}}change(t){if(this.isRenderingInProgress||this._postFixersInProgress)throw new k("cannot-change-view-tree",this);try{if(this._ongoingChange)return t(this._writer);this._ongoingChange=!0;const e=t(this._writer);return this._ongoingChange=!1,!this._renderingDisabled&&this._hasChangedSinceTheLastRendering&&(this._postFixersInProgress=!0,this.document._callPostFixers(this._writer),this._postFixersInProgress=!1,this.fire("render")),e}catch(t){k.rethrowUnexpectedError(t,this);}}forceRender(){this._hasChangedSinceTheLastRendering=!0,this.document._isFocusChanging=!1,this.change((()=>{}));}destroy(){for(const t of this._observers.values())t.destroy();this.document.destroy(),this.stopListening();}createPositionAt(t,e){return rs._createAt(t,e)}createPositionAfter(t){return rs._createAfter(t)}createPositionBefore(t){return rs._createBefore(t)}createRange(...t){return new ss(...t)}createRangeOn(t){return ss._createOn(t)}createRangeIn(t){return ss._createIn(t)}createSelection(...t){return new cs(...t)}_disableRendering(t){this._renderingDisabled=t,0==t&&this.change((()=>{}));}_render(){this.isRenderingInProgress=!0,this.disableObservers(),this._renderer.render(),this.enableObservers(),this.isRenderingInProgress=!1;}}class ac{is(){throw new Error("is() method is abstract")}}class cc extends ac{constructor(t){super(),this.parent=null,this._attrs=yi(t);}get document(){return null}get index(){let t;if(!this.parent)return null;if(null===(t=this.parent.getChildIndex(this)))throw new k("model-node-not-found-in-parent",this);return t}get startOffset(){let t;if(!this.parent)return null;if(null===(t=this.parent.getChildStartOffset(this)))throw new k("model-node-not-found-in-parent",this);return t}get offsetSize(){return 1}get endOffset(){return this.parent?this.startOffset+this.offsetSize:null}get nextSibling(){const t=this.index;return null!==t&&this.parent.getChild(t+1)||null}get previousSibling(){const t=this.index;return null!==t&&this.parent.getChild(t-1)||null}get root(){let t=this;for(;t.parent;)t=t.parent;return t}isAttached(){return this.root.is("rootElement")}getPath(){const t=[];let e=this;for(;e.parent;)t.unshift(e.startOffset),e=e.parent;return t}getAncestors(t={}){const e=[];let n=t.includeSelf?this:this.parent;for(;n;)e[t.parentFirst?"push":"unshift"](n),n=n.parent;return e}getCommonAncestor(t,e={}){const n=this.getAncestors(e),o=t.getAncestors(e);let i=0;for(;n[i]==o[i]&&n[i];)i++;return 0===i?null:n[i-1]}isBefore(t){if(this==t)return !1;if(this.root!==t.root)return !1;const e=this.getPath(),n=t.getPath(),o=Q(e,n);switch(o){case"prefix":return !0;case"extension":return !1;default:return e[o]<n[o]}}isAfter(t){return this!=t&&(this.root===t.root&&!this.isBefore(t))}hasAttribute(t){return this._attrs.has(t)}getAttribute(t){return this._attrs.get(t)}getAttributes(){return this._attrs.entries()}getAttributeKeys(){return this._attrs.keys()}toJSON(){const t={};return this._attrs.size&&(t.attributes=Array.from(this._attrs).reduce(((t,e)=>(t[e[0]]=e[1],t)),{})),t}_clone(t){return new cc(this._attrs)}_remove(){this.parent._removeChildren(this.index);}_setAttribute(t,e){this._attrs.set(t,e);}_setAttributesTo(t){this._attrs=yi(t);}_removeAttribute(t){return this._attrs.delete(t)}_clearAttributes(){this._attrs.clear();}}cc.prototype.is=function(t){return "node"===t||"model:node"===t};class lc{constructor(t){this._nodes=[],t&&this._insertNodes(0,t);}[Symbol.iterator](){return this._nodes[Symbol.iterator]()}get length(){return this._nodes.length}get maxOffset(){return this._nodes.reduce(((t,e)=>t+e.offsetSize),0)}getNode(t){return this._nodes[t]||null}getNodeIndex(t){const e=this._nodes.indexOf(t);return -1==e?null:e}getNodeStartOffset(t){const e=this.getNodeIndex(t);return null===e?null:this._nodes.slice(0,e).reduce(((t,e)=>t+e.offsetSize),0)}indexToOffset(t){if(t==this._nodes.length)return this.maxOffset;const e=this._nodes[t];if(!e)throw new k("model-nodelist-index-out-of-bounds",this);return this.getNodeStartOffset(e)}offsetToIndex(t){let e=0;for(const n of this._nodes){if(t>=e&&t<e+n.offsetSize)return this.getNodeIndex(n);e+=n.offsetSize;}if(e!=t)throw new k("model-nodelist-offset-out-of-bounds",this,{offset:t,nodeList:this});return this.length}_insertNodes(t,e){for(const t of e)if(!(t instanceof cc))throw new k("model-nodelist-insertnodes-not-node",this);this._nodes=function(t,e,n,o){if(Math.max(e.length,t.length)>1e4)return t.slice(0,n).concat(e).concat(t.slice(n+o,t.length));{const i=Array.from(t);return i.splice(n,o,...e),i}}(this._nodes,Array.from(e),t,0);}_removeNodes(t,e=1){return this._nodes.splice(t,e)}toJSON(){return this._nodes.map((t=>t.toJSON()))}}class dc extends cc{constructor(t,e){super(e),this._data=t||"";}get offsetSize(){return this.data.length}get data(){return this._data}toJSON(){const t=super.toJSON();return t.data=this.data,t}_clone(){return new dc(this.data,this.getAttributes())}static fromJSON(t){return new dc(t.data,t.attributes)}}dc.prototype.is=function(t){return "$text"===t||"model:$text"===t||"text"===t||"model:text"===t||"node"===t||"model:node"===t};class hc extends ac{constructor(t,e,n){if(super(),this.textNode=t,e<0||e>t.offsetSize)throw new k("model-textproxy-wrong-offsetintext",this);if(n<0||e+n>t.offsetSize)throw new k("model-textproxy-wrong-length",this);this.data=t.data.substring(e,e+n),this.offsetInText=e;}get startOffset(){return null!==this.textNode.startOffset?this.textNode.startOffset+this.offsetInText:null}get offsetSize(){return this.data.length}get endOffset(){return null!==this.startOffset?this.startOffset+this.offsetSize:null}get isPartial(){return this.offsetSize!==this.textNode.offsetSize}get parent(){return this.textNode.parent}get root(){return this.textNode.root}getPath(){const t=this.textNode.getPath();return t.length>0&&(t[t.length-1]+=this.offsetInText),t}getAncestors(t={}){const e=[];let n=t.includeSelf?this:this.parent;for(;n;)e[t.parentFirst?"push":"unshift"](n),n=n.parent;return e}hasAttribute(t){return this.textNode.hasAttribute(t)}getAttribute(t){return this.textNode.getAttribute(t)}getAttributes(){return this.textNode.getAttributes()}getAttributeKeys(){return this.textNode.getAttributeKeys()}}hc.prototype.is=function(t){return "$textProxy"===t||"model:$textProxy"===t||"textProxy"===t||"model:textProxy"===t};class uc extends cc{constructor(t,e,n){super(e),this.name=t,this._children=new lc,n&&this._insertChild(0,n);}get childCount(){return this._children.length}get maxOffset(){return this._children.maxOffset}get isEmpty(){return 0===this.childCount}getChild(t){return this._children.getNode(t)}getChildren(){return this._children[Symbol.iterator]()}getChildIndex(t){return this._children.getNodeIndex(t)}getChildStartOffset(t){return this._children.getNodeStartOffset(t)}offsetToIndex(t){return this._children.offsetToIndex(t)}getNodeByPath(t){let e=this;for(const n of t)e=e.getChild(e.offsetToIndex(n));return e}findAncestor(t,e={}){let n=e.includeSelf?this:this.parent;for(;n;){if(n.name===t)return n;n=n.parent;}return null}toJSON(){const t=super.toJSON();if(t.name=this.name,this._children.length>0){t.children=[];for(const e of this._children)t.children.push(e.toJSON());}return t}_clone(t=!1){const e=t?Array.from(this._children).map((t=>t._clone(!0))):void 0;return new uc(this.name,this.getAttributes(),e)}_appendChild(t){this._insertChild(this.childCount,t);}_insertChild(t,e){const n=function(t){if("string"==typeof t)return [new dc(t)];Z(t)||(t=[t]);return Array.from(t).map((t=>"string"==typeof t?new dc(t):t instanceof hc?new dc(t.data,t.getAttributes()):t))}(e);for(const t of n)null!==t.parent&&t._remove(),t.parent=this;this._children._insertNodes(t,n);}_removeChildren(t,e=1){const n=this._children._removeNodes(t,e);for(const t of n)t.parent=null;return n}static fromJSON(t){let e;if(t.children){e=[];for(const n of t.children)n.name?e.push(uc.fromJSON(n)):e.push(dc.fromJSON(n));}return new uc(t.name,t.attributes,e)}}uc.prototype.is=function(t,e){return e?e===this.name&&("element"===t||"model:element"===t):"element"===t||"model:element"===t||"node"===t||"model:node"===t};class gc{constructor(t={}){if(!t.boundaries&&!t.startPosition)throw new k("model-tree-walker-no-start-position",null);const e=t.direction||"forward";if("forward"!=e&&"backward"!=e)throw new k("model-tree-walker-unknown-direction",t,{direction:e});this.direction=e,this.boundaries=t.boundaries||null,t.startPosition?this.position=t.startPosition.clone():this.position=pc._createAt(this.boundaries["backward"==this.direction?"end":"start"]),this.position.stickiness="toNone",this.singleCharacters=!!t.singleCharacters,this.shallow=!!t.shallow,this.ignoreElementEnd=!!t.ignoreElementEnd,this._boundaryStartParent=this.boundaries?this.boundaries.start.parent:null,this._boundaryEndParent=this.boundaries?this.boundaries.end.parent:null,this._visitedParent=this.position.parent;}[Symbol.iterator](){return this}skip(t){let e,n,o,i;do{o=this.position,i=this._visitedParent,({done:e,value:n}=this.next());}while(!e&&t(n));e||(this.position=o,this._visitedParent=i);}next(){return "forward"==this.direction?this._next():this._previous()}_next(){const t=this.position,e=this.position.clone(),n=this._visitedParent;if(null===n.parent&&e.offset===n.maxOffset)return {done:!0,value:void 0};if(n===this._boundaryEndParent&&e.offset==this.boundaries.end.offset)return {done:!0,value:void 0};const o=fc(e,n),i=o||kc(e,n,o);if(i instanceof uc)return this.shallow?e.offset++:(e.path.push(0),this._visitedParent=i),this.position=e,mc("elementStart",i,t,e,1);if(i instanceof dc){let o;if(this.singleCharacters)o=1;else {let t=i.endOffset;this._boundaryEndParent==n&&this.boundaries.end.offset<t&&(t=this.boundaries.end.offset),o=t-e.offset;}const r=e.offset-i.startOffset,s=new hc(i,r,o);return e.offset+=o,this.position=e,mc("text",s,t,e,o)}return e.path.pop(),e.offset++,this.position=e,this._visitedParent=n.parent,this.ignoreElementEnd?this._next():mc("elementEnd",n,t,e)}_previous(){const t=this.position,e=this.position.clone(),n=this._visitedParent;if(null===n.parent&&0===e.offset)return {done:!0,value:void 0};if(n==this._boundaryStartParent&&e.offset==this.boundaries.start.offset)return {done:!0,value:void 0};const o=e.parent,i=fc(e,o),r=i||bc(e,o,i);if(r instanceof uc)return e.offset--,this.shallow?(this.position=e,mc("elementStart",r,t,e,1)):(e.path.push(r.maxOffset),this.position=e,this._visitedParent=r,this.ignoreElementEnd?this._previous():mc("elementEnd",r,t,e));if(r instanceof dc){let o;if(this.singleCharacters)o=1;else {let t=r.startOffset;this._boundaryStartParent==n&&this.boundaries.start.offset>t&&(t=this.boundaries.start.offset),o=e.offset-t;}const i=e.offset-r.startOffset,s=new hc(r,i-o,o);return e.offset-=o,this.position=e,mc("text",s,t,e,o)}return e.path.pop(),this.position=e,this._visitedParent=n.parent,mc("elementStart",n,t,e,1)}}function mc(t,e,n,o,i){return {done:!1,value:{type:t,item:e,previousPosition:n,nextPosition:o,length:i}}}class pc extends ac{constructor(t,e,n="toNone"){if(super(),!t.is("element")&&!t.is("documentFragment"))throw new k("model-position-root-invalid",t);if(!(e instanceof Array)||0===e.length)throw new k("model-position-path-incorrect-format",t,{path:e});t.is("rootElement")?e=e.slice():(e=[...t.getPath(),...e],t=t.root),this.root=t,this.path=e,this.stickiness=n;}get offset(){return this.path[this.path.length-1]}set offset(t){this.path[this.path.length-1]=t;}get parent(){let t=this.root;for(let e=0;e<this.path.length-1;e++)if(t=t.getChild(t.offsetToIndex(this.path[e])),!t)throw new k("model-position-path-incorrect",this,{position:this});if(t.is("$text"))throw new k("model-position-path-incorrect",this,{position:this});return t}get index(){return this.parent.offsetToIndex(this.offset)}get textNode(){return fc(this,this.parent)}get nodeAfter(){const t=this.parent;return kc(this,t,fc(this,t))}get nodeBefore(){const t=this.parent;return bc(this,t,fc(this,t))}get isAtStart(){return 0===this.offset}get isAtEnd(){return this.offset==this.parent.maxOffset}compareWith(t){if(this.root!=t.root)return "different";const e=Q(this.path,t.path);switch(e){case"same":return "same";case"prefix":return "before";case"extension":return "after";default:return this.path[e]<t.path[e]?"before":"after"}}getLastMatchingPosition(t,e={}){e.startPosition=this;const n=new gc(e);return n.skip(t),n.position}getParentPath(){return this.path.slice(0,-1)}getAncestors(){const t=this.parent;return t.is("documentFragment")?[t]:t.getAncestors({includeSelf:!0})}findAncestor(t){const e=this.parent;return e.is("element")?e.findAncestor(t,{includeSelf:!0}):null}getCommonPath(t){if(this.root!=t.root)return [];const e=Q(this.path,t.path),n="string"==typeof e?Math.min(this.path.length,t.path.length):e;return this.path.slice(0,n)}getCommonAncestor(t){const e=this.getAncestors(),n=t.getAncestors();let o=0;for(;e[o]==n[o]&&e[o];)o++;return 0===o?null:e[o-1]}getShiftedBy(t){const e=this.clone(),n=e.offset+t;return e.offset=n<0?0:n,e}isAfter(t){return "after"==this.compareWith(t)}isBefore(t){return "before"==this.compareWith(t)}isEqual(t){return "same"==this.compareWith(t)}isTouching(t){if(this.root!==t.root)return !1;const e=Math.min(this.path.length,t.path.length);for(let n=0;n<e;n++){const e=this.path[n]-t.path[n];if(e<-1||e>1)return !1;if(1===e)return wc(t,this,n);if(-1===e)return wc(this,t,n)}return this.path.length===t.path.length||(this.path.length>t.path.length?_c(this.path,e):_c(t.path,e))}hasSameParentAs(t){if(this.root!==t.root)return !1;return "same"==Q(this.getParentPath(),t.getParentPath())}getTransformedByOperation(t){let e;switch(t.type){case"insert":e=this._getTransformedByInsertOperation(t);break;case"move":case"remove":case"reinsert":e=this._getTransformedByMoveOperation(t);break;case"split":e=this._getTransformedBySplitOperation(t);break;case"merge":e=this._getTransformedByMergeOperation(t);break;default:e=pc._createAt(this);}return e}_getTransformedByInsertOperation(t){return this._getTransformedByInsertion(t.position,t.howMany)}_getTransformedByMoveOperation(t){return this._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany)}_getTransformedBySplitOperation(t){const e=t.movedRange;return e.containsPosition(this)||e.start.isEqual(this)&&"toNext"==this.stickiness?this._getCombined(t.splitPosition,t.moveTargetPosition):t.graveyardPosition?this._getTransformedByMove(t.graveyardPosition,t.insertionPosition,1):this._getTransformedByInsertion(t.insertionPosition,1)}_getTransformedByMergeOperation(t){const e=t.movedRange;let n;return e.containsPosition(this)||e.start.isEqual(this)?(n=this._getCombined(t.sourcePosition,t.targetPosition),t.sourcePosition.isBefore(t.targetPosition)&&(n=n._getTransformedByDeletion(t.deletionPosition,1))):n=this.isEqual(t.deletionPosition)?pc._createAt(t.deletionPosition):this._getTransformedByMove(t.deletionPosition,t.graveyardPosition,1),n}_getTransformedByDeletion(t,e){const n=pc._createAt(this);if(this.root!=t.root)return n;if("same"==Q(t.getParentPath(),this.getParentPath())){if(t.offset<this.offset){if(t.offset+e>this.offset)return null;n.offset-=e;}}else if("prefix"==Q(t.getParentPath(),this.getParentPath())){const o=t.path.length-1;if(t.offset<=this.path[o]){if(t.offset+e>this.path[o])return null;n.path[o]-=e;}}return n}_getTransformedByInsertion(t,e){const n=pc._createAt(this);if(this.root!=t.root)return n;if("same"==Q(t.getParentPath(),this.getParentPath()))(t.offset<this.offset||t.offset==this.offset&&"toPrevious"!=this.stickiness)&&(n.offset+=e);else if("prefix"==Q(t.getParentPath(),this.getParentPath())){const o=t.path.length-1;t.offset<=this.path[o]&&(n.path[o]+=e);}return n}_getTransformedByMove(t,e,n){if(e=e._getTransformedByDeletion(t,n),t.isEqual(e))return pc._createAt(this);const o=this._getTransformedByDeletion(t,n);return null===o||t.isEqual(this)&&"toNext"==this.stickiness||t.getShiftedBy(n).isEqual(this)&&"toPrevious"==this.stickiness?this._getCombined(t,e):o._getTransformedByInsertion(e,n)}_getCombined(t,e){const n=t.path.length-1,o=pc._createAt(e);return o.stickiness=this.stickiness,o.offset=o.offset+this.path[n]-t.offset,o.path=[...o.path,...this.path.slice(n+1)],o}toJSON(){return {root:this.root.toJSON(),path:Array.from(this.path),stickiness:this.stickiness}}clone(){return new this.constructor(this.root,this.path,this.stickiness)}static _createAt(t,e,n="toNone"){if(t instanceof pc)return new pc(t.root,t.path,t.stickiness);{const o=t;if("end"==e)e=o.maxOffset;else {if("before"==e)return this._createBefore(o,n);if("after"==e)return this._createAfter(o,n);if(0!==e&&!e)throw new k("model-createpositionat-offset-required",[this,t])}if(!o.is("element")&&!o.is("documentFragment"))throw new k("model-position-parent-incorrect",[this,t]);const i=o.getPath();return i.push(e),new this(o.root,i,n)}}static _createAfter(t,e){if(!t.parent)throw new k("model-position-after-root",[this,t],{root:t});return this._createAt(t.parent,t.endOffset,e)}static _createBefore(t,e){if(!t.parent)throw new k("model-position-before-root",t,{root:t});return this._createAt(t.parent,t.startOffset,e)}static fromJSON(t,e){if("$graveyard"===t.root){const n=new pc(e.graveyard,t.path);return n.stickiness=t.stickiness,n}if(!e.getRoot(t.root))throw new k("model-position-fromjson-no-root",e,{rootName:t.root});return new pc(e.getRoot(t.root),t.path,t.stickiness)}}function fc(t,e){const n=e.getChild(e.offsetToIndex(t.offset));return n&&n.is("$text")&&n.startOffset<t.offset?n:null}function kc(t,e,n){return null!==n?null:e.getChild(e.offsetToIndex(t.offset))}function bc(t,e,n){return null!==n?null:e.getChild(e.offsetToIndex(t.offset)-1)}function wc(t,e,n){return n+1!==t.path.length&&(!!_c(e.path,n+1)&&!!function(t,e){let n=t.parent,o=t.path.length-1,i=0;for(;o>=e;){if(t.path[o]+i!==n.maxOffset)return !1;i=1,o--,n=n.parent;}return !0}(t,n+1))}function _c(t,e){for(;e<t.length;){if(0!==t[e])return !1;e++;}return !0}pc.prototype.is=function(t){return "position"===t||"model:position"===t};class Ac extends ac{constructor(t,e){super(),this.start=pc._createAt(t),this.end=e?pc._createAt(e):pc._createAt(t),this.start.stickiness=this.isCollapsed?"toNone":"toNext",this.end.stickiness=this.isCollapsed?"toNone":"toPrevious";}*[Symbol.iterator](){yield*new gc({boundaries:this,ignoreElementEnd:!0});}get isCollapsed(){return this.start.isEqual(this.end)}get isFlat(){return "same"==Q(this.start.getParentPath(),this.end.getParentPath())}get root(){return this.start.root}containsPosition(t){return t.isAfter(this.start)&&t.isBefore(this.end)}containsRange(t,e=!1){t.isCollapsed&&(e=!1);const n=this.containsPosition(t.start)||e&&this.start.isEqual(t.start),o=this.containsPosition(t.end)||e&&this.end.isEqual(t.end);return n&&o}containsItem(t){const e=pc._createBefore(t);return this.containsPosition(e)||this.start.isEqual(e)}isEqual(t){return this.start.isEqual(t.start)&&this.end.isEqual(t.end)}isIntersecting(t){return this.start.isBefore(t.end)&&this.end.isAfter(t.start)}getDifference(t){const e=[];return this.isIntersecting(t)?(this.containsPosition(t.start)&&e.push(new Ac(this.start,t.start)),this.containsPosition(t.end)&&e.push(new Ac(t.end,this.end))):e.push(new Ac(this.start,this.end)),e}getIntersection(t){if(this.isIntersecting(t)){let e=this.start,n=this.end;return this.containsPosition(t.start)&&(e=t.start),this.containsPosition(t.end)&&(n=t.end),new Ac(e,n)}return null}getJoined(t,e=!1){let n=this.isIntersecting(t);if(n||(n=this.start.isBefore(t.start)?e?this.end.isTouching(t.start):this.end.isEqual(t.start):e?t.end.isTouching(this.start):t.end.isEqual(this.start)),!n)return null;let o=this.start,i=this.end;return t.start.isBefore(o)&&(o=t.start),t.end.isAfter(i)&&(i=t.end),new Ac(o,i)}getMinimalFlatRanges(){const t=[],e=this.start.getCommonPath(this.end).length,n=pc._createAt(this.start);let o=n.parent;for(;n.path.length>e+1;){const e=o.maxOffset-n.offset;0!==e&&t.push(new Ac(n,n.getShiftedBy(e))),n.path=n.path.slice(0,-1),n.offset++,o=o.parent;}for(;n.path.length<=this.end.path.length;){const e=this.end.path[n.path.length-1],o=e-n.offset;0!==o&&t.push(new Ac(n,n.getShiftedBy(o))),n.offset=e,n.path.push(0);}return t}getWalker(t={}){return t.boundaries=this,new gc(t)}*getItems(t={}){t.boundaries=this,t.ignoreElementEnd=!0;const e=new gc(t);for(const t of e)yield t.item;}*getPositions(t={}){t.boundaries=this;const e=new gc(t);yield e.position;for(const t of e)yield t.nextPosition;}getTransformedByOperation(t){switch(t.type){case"insert":return this._getTransformedByInsertOperation(t);case"move":case"remove":case"reinsert":return this._getTransformedByMoveOperation(t);case"split":return [this._getTransformedBySplitOperation(t)];case"merge":return [this._getTransformedByMergeOperation(t)]}return [new Ac(this.start,this.end)]}getTransformedByOperations(t){const e=[new Ac(this.start,this.end)];for(const n of t)for(let t=0;t<e.length;t++){const o=e[t].getTransformedByOperation(n);e.splice(t,1,...o),t+=o.length-1;}for(let t=0;t<e.length;t++){const n=e[t];for(let o=t+1;o<e.length;o++){const t=e[o];(n.containsRange(t)||t.containsRange(n)||n.isEqual(t))&&e.splice(o,1);}}return e}getCommonAncestor(){return this.start.getCommonAncestor(this.end)}getContainedElement(){if(this.isCollapsed)return null;const t=this.start.nodeAfter,e=this.end.nodeBefore;return t&&t.is("element")&&t===e?t:null}toJSON(){return {start:this.start.toJSON(),end:this.end.toJSON()}}clone(){return new this.constructor(this.start,this.end)}_getTransformedByInsertOperation(t,e=!1){return this._getTransformedByInsertion(t.position,t.howMany,e)}_getTransformedByMoveOperation(t,e=!1){const n=t.sourcePosition,o=t.howMany,i=t.targetPosition;return this._getTransformedByMove(n,i,o,e)}_getTransformedBySplitOperation(t){const e=this.start._getTransformedBySplitOperation(t);let n=this.end._getTransformedBySplitOperation(t);return this.end.isEqual(t.insertionPosition)&&(n=this.end.getShiftedBy(1)),e.root!=n.root&&(n=this.end.getShiftedBy(-1)),new Ac(e,n)}_getTransformedByMergeOperation(t){if(this.start.isEqual(t.targetPosition)&&this.end.isEqual(t.deletionPosition))return new Ac(this.start);let e=this.start._getTransformedByMergeOperation(t),n=this.end._getTransformedByMergeOperation(t);return e.root!=n.root&&(n=this.end.getShiftedBy(-1)),e.isAfter(n)?(t.sourcePosition.isBefore(t.targetPosition)?(e=pc._createAt(n),e.offset=0):(t.deletionPosition.isEqual(e)||(n=t.deletionPosition),e=t.targetPosition),new Ac(e,n)):new Ac(e,n)}_getTransformedByInsertion(t,e,n=!1){if(n&&this.containsPosition(t))return [new Ac(this.start,t),new Ac(t.getShiftedBy(e),this.end._getTransformedByInsertion(t,e))];{const n=new Ac(this.start,this.end);return n.start=n.start._getTransformedByInsertion(t,e),n.end=n.end._getTransformedByInsertion(t,e),[n]}}_getTransformedByMove(t,e,n,o=!1){if(this.isCollapsed){const o=this.start._getTransformedByMove(t,e,n);return [new Ac(o)]}const i=Ac._createFromPositionAndShift(t,n),r=e._getTransformedByDeletion(t,n);if(this.containsPosition(e)&&!o&&(i.containsPosition(this.start)||i.containsPosition(this.end))){const o=this.start._getTransformedByMove(t,e,n),i=this.end._getTransformedByMove(t,e,n);return [new Ac(o,i)]}let s;const a=this.getDifference(i);let c=null;const l=this.getIntersection(i);if(1==a.length?c=new Ac(a[0].start._getTransformedByDeletion(t,n),a[0].end._getTransformedByDeletion(t,n)):2==a.length&&(c=new Ac(this.start,this.end._getTransformedByDeletion(t,n))),s=c?c._getTransformedByInsertion(r,n,null!==l||o):[],l){const t=new Ac(l.start._getCombined(i.start,r),l.end._getCombined(i.start,r));2==s.length?s.splice(1,0,t):s.push(t);}return s}_getTransformedByDeletion(t,e){let n=this.start._getTransformedByDeletion(t,e),o=this.end._getTransformedByDeletion(t,e);return null==n&&null==o?null:(null==n&&(n=t),null==o&&(o=t),new Ac(n,o))}static _createFromPositionAndShift(t,e){const n=t,o=t.getShiftedBy(e);return e>0?new this(n,o):new this(o,n)}static _createIn(t){return new this(pc._createAt(t,0),pc._createAt(t,t.maxOffset))}static _createOn(t){return this._createFromPositionAndShift(pc._createBefore(t),t.offsetSize)}static _createFromRanges(t){if(0===t.length)throw new k("range-create-from-ranges-empty-array",null);if(1==t.length)return t[0].clone();const e=t[0];t.sort(((t,e)=>t.start.isAfter(e.start)?1:-1));const n=t.indexOf(e),o=new this(e.start,e.end);if(n>0)for(let e=n-1;t[e].end.isEqual(o.start);e++)o.start=pc._createAt(t[e].start);for(let e=n+1;e<t.length&&t[e].start.isEqual(o.end);e++)o.end=pc._createAt(t[e].end);return o}static fromJSON(t,e){return new this(pc.fromJSON(t.start,e),pc.fromJSON(t.end,e))}}Ac.prototype.is=function(t){return "range"===t||"model:range"===t};class Cc extends(I()){constructor(){super(),this._modelToViewMapping=new WeakMap,this._viewToModelMapping=new WeakMap,this._viewToModelLengthCallbacks=new Map,this._markerNameToElements=new Map,this._elementToMarkerNames=new Map,this._deferredBindingRemovals=new Map,this._unboundMarkerNames=new Set,this.on("modelToViewPosition",((t,e)=>{if(e.viewPosition)return;const n=this._modelToViewMapping.get(e.modelPosition.parent);if(!n)throw new k("mapping-model-position-view-parent-not-found",this,{modelPosition:e.modelPosition});e.viewPosition=this.findPositionIn(n,e.modelPosition.offset);}),{priority:"low"}),this.on("viewToModelPosition",((t,e)=>{if(e.modelPosition)return;const n=this.findMappedViewAncestor(e.viewPosition),o=this._viewToModelMapping.get(n),i=this._toModelOffset(e.viewPosition.parent,e.viewPosition.offset,n);e.modelPosition=pc._createAt(o,i);}),{priority:"low"});}bindElements(t,e){this._modelToViewMapping.set(t,e),this._viewToModelMapping.set(e,t);}unbindViewElement(t,e={}){const n=this.toModelElement(t);if(this._elementToMarkerNames.has(t))for(const e of this._elementToMarkerNames.get(t))this._unboundMarkerNames.add(e);e.defer?this._deferredBindingRemovals.set(t,t.root):(this._viewToModelMapping.delete(t),this._modelToViewMapping.get(n)==t&&this._modelToViewMapping.delete(n));}unbindModelElement(t){const e=this.toViewElement(t);this._modelToViewMapping.delete(t),this._viewToModelMapping.get(e)==t&&this._viewToModelMapping.delete(e);}bindElementToMarker(t,e){const n=this._markerNameToElements.get(e)||new Set;n.add(t);const o=this._elementToMarkerNames.get(t)||new Set;o.add(e),this._markerNameToElements.set(e,n),this._elementToMarkerNames.set(t,o);}unbindElementFromMarkerName(t,e){const n=this._markerNameToElements.get(e);n&&(n.delete(t),0==n.size&&this._markerNameToElements.delete(e));const o=this._elementToMarkerNames.get(t);o&&(o.delete(e),0==o.size&&this._elementToMarkerNames.delete(t));}flushUnboundMarkerNames(){const t=Array.from(this._unboundMarkerNames);return this._unboundMarkerNames.clear(),t}flushDeferredBindings(){for(const[t,e]of this._deferredBindingRemovals)t.root==e&&this.unbindViewElement(t);this._deferredBindingRemovals=new Map;}clearBindings(){this._modelToViewMapping=new WeakMap,this._viewToModelMapping=new WeakMap,this._markerNameToElements=new Map,this._elementToMarkerNames=new Map,this._unboundMarkerNames=new Set,this._deferredBindingRemovals=new Map;}toModelElement(t){return this._viewToModelMapping.get(t)}toViewElement(t){return this._modelToViewMapping.get(t)}toModelRange(t){return new Ac(this.toModelPosition(t.start),this.toModelPosition(t.end))}toViewRange(t){return new ss(this.toViewPosition(t.start),this.toViewPosition(t.end))}toModelPosition(t){const e={viewPosition:t,mapper:this};return this.fire("viewToModelPosition",e),e.modelPosition}toViewPosition(t,e={}){const n={modelPosition:t,mapper:this,isPhantom:e.isPhantom};return this.fire("modelToViewPosition",n),n.viewPosition}markerNameToElements(t){const e=this._markerNameToElements.get(t);if(!e)return null;const n=new Set;for(const t of e)if(t.is("attributeElement"))for(const e of t.getElementsWithSameId())n.add(e);else n.add(t);return n}registerViewToModelLength(t,e){this._viewToModelLengthCallbacks.set(t,e);}findMappedViewAncestor(t){let e=t.parent;for(;!this._viewToModelMapping.has(e);)e=e.parent;return e}_toModelOffset(t,e,n){if(n!=t){return this._toModelOffset(t.parent,t.index,n)+this._toModelOffset(t,e,t)}if(t.is("$text"))return e;let o=0;for(let n=0;n<e;n++)o+=this.getModelLength(t.getChild(n));return o}getModelLength(t){if(this._viewToModelLengthCallbacks.get(t.name)){return this._viewToModelLengthCallbacks.get(t.name)(t)}if(this._viewToModelMapping.has(t))return 1;if(t.is("$text"))return t.data.length;if(t.is("uiElement"))return 0;{let e=0;for(const n of t.getChildren())e+=this.getModelLength(n);return e}}findPositionIn(t,e){let n,o=0,i=0,r=0;if(t.is("$text"))return new rs(t,e);for(;i<e;)n=t.getChild(r),o=this.getModelLength(n),i+=o,r++;return i==e?this._moveViewPositionToTextNode(new rs(t,r)):this.findPositionIn(n,e-(i-o))}_moveViewPositionToTextNode(t){const e=t.nodeBefore,n=t.nodeAfter;return e instanceof Qi?new rs(e,e.data.length):n instanceof Qi?new rs(n,0):t}}class vc{constructor(){this._consumable=new Map,this._textProxyRegistry=new Map;}add(t,e){e=yc(e),t instanceof hc&&(t=this._getSymbolForTextProxy(t)),this._consumable.has(t)||this._consumable.set(t,new Map),this._consumable.get(t).set(e,!0);}consume(t,e){return e=yc(e),t instanceof hc&&(t=this._getSymbolForTextProxy(t)),!!this.test(t,e)&&(this._consumable.get(t).set(e,!1),!0)}test(t,e){e=yc(e),t instanceof hc&&(t=this._getSymbolForTextProxy(t));const n=this._consumable.get(t);if(void 0===n)return null;const o=n.get(e);return void 0===o?null:o}revert(t,e){e=yc(e),t instanceof hc&&(t=this._getSymbolForTextProxy(t));const n=this.test(t,e);return !1===n?(this._consumable.get(t).set(e,!0),!0):!0!==n&&null}verifyAllConsumed(t){const e=[];for(const[n,o]of this._consumable)for(const[i,r]of o){const o=i.split(":")[0];r&&t==o&&e.push({event:i,item:n.name||n.description});}if(e.length)throw new k("conversion-model-consumable-not-consumed",null,{items:e})}_getSymbolForTextProxy(t){let e=null;const n=this._textProxyRegistry.get(t.startOffset);if(n){const o=n.get(t.endOffset);o&&(e=o.get(t.parent));}return e||(e=this._addSymbolForTextProxy(t)),e}_addSymbolForTextProxy(t){const e=t.startOffset,n=t.endOffset,o=t.parent,i=Symbol("$textProxy:"+t.data);let r,s;return r=this._textProxyRegistry.get(e),r||(r=new Map,this._textProxyRegistry.set(e,r)),s=r.get(n),s||(s=new Map,r.set(n,s)),s.set(o,i),i}}function yc(t){const e=t.split(":");return "insert"==e[0]?e[0]:"addMarker"==e[0]||"removeMarker"==e[0]?t:e.length>1?e[0]+":"+e[1]:e[0]}class xc extends(I()){constructor(t){super(),this._conversionApi={dispatcher:this,...t},this._firedEventsMap=new WeakMap;}convertChanges(t,e,n){const o=this._createConversionApi(n,t.getRefreshedItems());for(const e of t.getMarkersToRemove())this._convertMarkerRemove(e.name,e.range,o);const i=this._reduceChanges(t.getChanges());for(const t of i)"insert"===t.type?this._convertInsert(Ac._createFromPositionAndShift(t.position,t.length),o):"reinsert"===t.type?this._convertReinsert(Ac._createFromPositionAndShift(t.position,t.length),o):"remove"===t.type?this._convertRemove(t.position,t.length,t.name,o):this._convertAttribute(t.range,t.attributeKey,t.attributeOldValue,t.attributeNewValue,o);for(const t of o.mapper.flushUnboundMarkerNames()){const n=e.get(t).getRange();this._convertMarkerRemove(t,n,o),this._convertMarkerAdd(t,n,o);}for(const e of t.getMarkersToAdd())this._convertMarkerAdd(e.name,e.range,o);o.mapper.flushDeferredBindings(),o.consumable.verifyAllConsumed("insert");}convert(t,e,n,o={}){const i=this._createConversionApi(n,void 0,o);this._convertInsert(t,i);for(const[t,n]of e)this._convertMarkerAdd(t,n,i);i.consumable.verifyAllConsumed("insert");}convertSelection(t,e,n){const o=Array.from(e.getMarkersAtPosition(t.getFirstPosition())),i=this._createConversionApi(n);if(this._addConsumablesForSelection(i.consumable,t,o),this.fire("selection",{selection:t},i),t.isCollapsed){for(const e of o){const n=e.getRange();if(!Ec(t.getFirstPosition(),e,i.mapper))continue;const o={item:t,markerName:e.name,markerRange:n};i.consumable.test(t,"addMarker:"+e.name)&&this.fire(`addMarker:${e.name}`,o,i);}for(const e of t.getAttributeKeys()){const n={item:t,range:t.getFirstRange(),attributeKey:e,attributeOldValue:null,attributeNewValue:t.getAttribute(e)};i.consumable.test(t,"attribute:"+n.attributeKey)&&this.fire(`attribute:${n.attributeKey}:$text`,n,i);}}}_convertInsert(t,e,n={}){n.doNotAddConsumables||this._addConsumablesForInsert(e.consumable,Array.from(t));for(const n of Array.from(t.getWalker({shallow:!0})).map(Dc))this._testAndFire("insert",n,e);}_convertRemove(t,e,n,o){this.fire(`remove:${n}`,{position:t,length:e},o);}_convertAttribute(t,e,n,o,i){this._addConsumablesForRange(i.consumable,t,`attribute:${e}`);for(const r of t){const t={item:r.item,range:Ac._createFromPositionAndShift(r.previousPosition,r.length),attributeKey:e,attributeOldValue:n,attributeNewValue:o};this._testAndFire(`attribute:${e}`,t,i);}}_convertReinsert(t,e){const n=Array.from(t.getWalker({shallow:!0}));this._addConsumablesForInsert(e.consumable,n);for(const t of n.map(Dc))this._testAndFire("insert",{...t,reconversion:!0},e);}_convertMarkerAdd(t,e,n){if("$graveyard"==e.root.rootName)return;const o=`addMarker:${t}`;if(n.consumable.add(e,o),this.fire(o,{markerName:t,markerRange:e},n),n.consumable.consume(e,o)){this._addConsumablesForRange(n.consumable,e,o);for(const i of e.getItems()){if(!n.consumable.test(i,o))continue;const r={item:i,range:Ac._createOn(i),markerName:t,markerRange:e};this.fire(o,r,n);}}}_convertMarkerRemove(t,e,n){"$graveyard"!=e.root.rootName&&this.fire(`removeMarker:${t}`,{markerName:t,markerRange:e},n);}_reduceChanges(t){const e={changes:t};return this.fire("reduceChanges",e),e.changes}_addConsumablesForInsert(t,e){for(const n of e){const e=n.item;if(null===t.test(e,"insert")){t.add(e,"insert");for(const n of e.getAttributeKeys())t.add(e,"attribute:"+n);}}return t}_addConsumablesForRange(t,e,n){for(const o of e.getItems())t.add(o,n);return t}_addConsumablesForSelection(t,e,n){t.add(e,"selection");for(const o of n)t.add(e,"addMarker:"+o.name);for(const n of e.getAttributeKeys())t.add(e,"attribute:"+n);return t}_testAndFire(t,e,n){const o=function(t,e){const n=e.item.is("element")?e.item.name:"$text";return `${t}:${n}`}(t,e),i=e.item.is("$textProxy")?n.consumable._getSymbolForTextProxy(e.item):e.item,r=this._firedEventsMap.get(n),s=r.get(i);if(s){if(s.has(o))return;s.add(o);}else r.set(i,new Set([o]));this.fire(o,e,n);}_testAndFireAddAttributes(t,e){const n={item:t,range:Ac._createOn(t)};for(const t of n.item.getAttributeKeys())n.attributeKey=t,n.attributeOldValue=null,n.attributeNewValue=n.item.getAttribute(t),this._testAndFire(`attribute:${t}`,n,e);}_createConversionApi(t,e=new Set,n={}){const o={...this._conversionApi,consumable:new vc,writer:t,options:n,convertItem:t=>this._convertInsert(Ac._createOn(t),o),convertChildren:t=>this._convertInsert(Ac._createIn(t),o,{doNotAddConsumables:!0}),convertAttributes:t=>this._testAndFireAddAttributes(t,o),canReuseView:t=>!e.has(o.mapper.toModelElement(t))};return this._firedEventsMap.set(o,new Map),o}}function Ec(t,e,n){const o=e.getRange(),i=Array.from(t.getAncestors());i.shift(),i.reverse();return !i.some((t=>{if(o.containsItem(t)){return !!n.toViewElement(t).getCustomProperty("addHighlight")}}))}function Dc(t){return {item:t.item,range:Ac._createFromPositionAndShift(t.previousPosition,t.length)}}class Ic extends(I(ac)){constructor(...t){super(),this._lastRangeBackward=!1,this._ranges=[],this._attrs=new Map,t.length&&this.setTo(...t);}get anchor(){if(this._ranges.length>0){const t=this._ranges[this._ranges.length-1];return this._lastRangeBackward?t.end:t.start}return null}get focus(){if(this._ranges.length>0){const t=this._ranges[this._ranges.length-1];return this._lastRangeBackward?t.start:t.end}return null}get isCollapsed(){return 1===this._ranges.length&&this._ranges[0].isCollapsed}get rangeCount(){return this._ranges.length}get isBackward(){return !this.isCollapsed&&this._lastRangeBackward}isEqual(t){if(this.rangeCount!=t.rangeCount)return !1;if(0===this.rangeCount)return !0;if(!this.anchor.isEqual(t.anchor)||!this.focus.isEqual(t.focus))return !1;for(const e of this._ranges){let n=!1;for(const o of t._ranges)if(e.isEqual(o)){n=!0;break}if(!n)return !1}return !0}*getRanges(){for(const t of this._ranges)yield new Ac(t.start,t.end);}getFirstRange(){let t=null;for(const e of this._ranges)t&&!e.start.isBefore(t.start)||(t=e);return t?new Ac(t.start,t.end):null}getLastRange(){let t=null;for(const e of this._ranges)t&&!e.end.isAfter(t.end)||(t=e);return t?new Ac(t.start,t.end):null}getFirstPosition(){const t=this.getFirstRange();return t?t.start.clone():null}getLastPosition(){const t=this.getLastRange();return t?t.end.clone():null}setTo(...t){let[e,n,o]=t;if("object"==typeof n&&(o=n,n=void 0),null===e)this._setRanges([]);else if(e instanceof Ic)this._setRanges(e.getRanges(),e.isBackward);else if(e&&"function"==typeof e.getRanges)this._setRanges(e.getRanges(),e.isBackward);else if(e instanceof Ac)this._setRanges([e],!!o&&!!o.backward);else if(e instanceof pc)this._setRanges([new Ac(e)]);else if(e instanceof cc){const t=!!o&&!!o.backward;let i;if("in"==n)i=Ac._createIn(e);else if("on"==n)i=Ac._createOn(e);else {if(void 0===n)throw new k("model-selection-setto-required-second-parameter",[this,e]);i=new Ac(pc._createAt(e,n));}this._setRanges([i],t);}else {if(!Z(e))throw new k("model-selection-setto-not-selectable",[this,e]);this._setRanges(e,o&&!!o.backward);}}_setRanges(t,e=!1){const n=Array.from(t),o=n.some((e=>{if(!(e instanceof Ac))throw new k("model-selection-set-ranges-not-range",[this,t]);return this._ranges.every((t=>!t.isEqual(e)))}));(n.length!==this._ranges.length||o)&&(this._replaceAllRanges(n),this._lastRangeBackward=!!e,this.fire("change:range",{directChange:!0}));}setFocus(t,e){if(null===this.anchor)throw new k("model-selection-setfocus-no-ranges",[this,t]);const n=pc._createAt(t,e);if("same"==n.compareWith(this.focus))return;const o=this.anchor;this._ranges.length&&this._popRange(),"before"==n.compareWith(o)?(this._pushRange(new Ac(n,o)),this._lastRangeBackward=!0):(this._pushRange(new Ac(o,n)),this._lastRangeBackward=!1),this.fire("change:range",{directChange:!0});}getAttribute(t){return this._attrs.get(t)}getAttributes(){return this._attrs.entries()}getAttributeKeys(){return this._attrs.keys()}hasAttribute(t){return this._attrs.has(t)}removeAttribute(t){this.hasAttribute(t)&&(this._attrs.delete(t),this.fire("change:attribute",{attributeKeys:[t],directChange:!0}));}setAttribute(t,e){this.getAttribute(t)!==e&&(this._attrs.set(t,e),this.fire("change:attribute",{attributeKeys:[t],directChange:!0}));}getSelectedElement(){return 1!==this.rangeCount?null:this.getFirstRange().getContainedElement()}*getSelectedBlocks(){const t=new WeakSet;for(const e of this.getRanges()){const n=Sc(e.start,t);n&&Nc(n,e)&&(yield n);for(const n of e.getWalker()){const o=n.item;"elementEnd"==n.type&&Tc(o,t,e)&&(yield o);}const o=Sc(e.end,t);o&&!e.end.isTouching(pc._createAt(o,0))&&Nc(o,e)&&(yield o);}}containsEntireContent(t=this.anchor.root){const e=pc._createAt(t,0),n=pc._createAt(t,"end");return e.isTouching(this.getFirstPosition())&&n.isTouching(this.getLastPosition())}_pushRange(t){this._checkRange(t),this._ranges.push(new Ac(t.start,t.end));}_checkRange(t){for(let e=0;e<this._ranges.length;e++)if(t.isIntersecting(this._ranges[e]))throw new k("model-selection-range-intersects",[this,t],{addedRange:t,intersectingRange:this._ranges[e]})}_replaceAllRanges(t){this._removeAllRanges();for(const e of t)this._pushRange(e);}_removeAllRanges(){for(;this._ranges.length>0;)this._popRange();}_popRange(){this._ranges.pop();}}function Mc(t,e){return !e.has(t)&&(e.add(t),t.root.document.model.schema.isBlock(t)&&!!t.parent)}function Tc(t,e,n){return Mc(t,e)&&Nc(t,n)}function Sc(t,e){const n=t.parent.root.document.model.schema,o=t.parent.getAncestors({parentFirst:!0,includeSelf:!0});let i=!1;const r=o.find((t=>!i&&(i=n.isLimit(t),!i&&Mc(t,e))));return o.forEach((t=>e.add(t))),r}function Nc(t,e){const n=function(t){const e=t.root.document.model.schema;let n=t.parent;for(;n;){if(e.isBlock(n))return n;n=n.parent;}}(t);if(!n)return !0;return !e.containsRange(Ac._createOn(n),!0)}Ic.prototype.is=function(t){return "selection"===t||"model:selection"===t};class Bc extends(I(Ac)){constructor(t,e){super(t,e),Pc.call(this);}detach(){this.stopListening();}toRange(){return new Ac(this.start,this.end)}static fromRange(t){return new Bc(t.start,t.end)}}function Pc(){this.listenTo(this.root.document.model,"applyOperation",((t,e)=>{const n=e[0];n.isDocumentOperation&&zc.call(this,n);}),{priority:"low"});}function zc(t){const e=this.getTransformedByOperation(t),n=Ac._createFromRanges(e),o=!n.isEqual(this),i=function(t,e){switch(e.type){case"insert":return t.containsPosition(e.position);case"move":case"remove":case"reinsert":case"merge":return t.containsPosition(e.sourcePosition)||t.start.isEqual(e.sourcePosition)||t.containsPosition(e.targetPosition);case"split":return t.containsPosition(e.splitPosition)||t.containsPosition(e.insertionPosition)}return !1}(this,t);let r=null;if(o){"$graveyard"==n.root.rootName&&(r="remove"==t.type?t.sourcePosition:t.deletionPosition);const e=this.toRange();this.start=n.start,this.end=n.end,this.fire("change:range",e,{deletionPosition:r});}else i&&this.fire("change:content",this.toRange(),{deletionPosition:r});}Bc.prototype.is=function(t){return "liveRange"===t||"model:liveRange"===t||"range"==t||"model:range"===t};const Lc="selection:";class Oc extends(I(ac)){constructor(t){super(),this._selection=new Rc(t),this._selection.delegate("change:range").to(this),this._selection.delegate("change:attribute").to(this),this._selection.delegate("change:marker").to(this);}get isCollapsed(){return this._selection.isCollapsed}get anchor(){return this._selection.anchor}get focus(){return this._selection.focus}get rangeCount(){return this._selection.rangeCount}get hasOwnRange(){return this._selection.hasOwnRange}get isBackward(){return this._selection.isBackward}get isGravityOverridden(){return this._selection.isGravityOverridden}get markers(){return this._selection.markers}get _ranges(){return this._selection._ranges}getRanges(){return this._selection.getRanges()}getFirstPosition(){return this._selection.getFirstPosition()}getLastPosition(){return this._selection.getLastPosition()}getFirstRange(){return this._selection.getFirstRange()}getLastRange(){return this._selection.getLastRange()}getSelectedBlocks(){return this._selection.getSelectedBlocks()}getSelectedElement(){return this._selection.getSelectedElement()}containsEntireContent(t){return this._selection.containsEntireContent(t)}destroy(){this._selection.destroy();}getAttributeKeys(){return this._selection.getAttributeKeys()}getAttributes(){return this._selection.getAttributes()}getAttribute(t){return this._selection.getAttribute(t)}hasAttribute(t){return this._selection.hasAttribute(t)}refresh(){this._selection.updateMarkers(),this._selection._updateAttributes(!1);}observeMarkers(t){this._selection.observeMarkers(t);}_setFocus(t,e){this._selection.setFocus(t,e);}_setTo(...t){this._selection.setTo(...t);}_setAttribute(t,e){this._selection.setAttribute(t,e);}_removeAttribute(t){this._selection.removeAttribute(t);}_getStoredAttributes(){return this._selection.getStoredAttributes()}_overrideGravity(){return this._selection.overrideGravity()}_restoreGravity(t){this._selection.restoreGravity(t);}static _getStoreAttributeKey(t){return Lc+t}static _isStoreAttributeKey(t){return t.startsWith(Lc)}}Oc.prototype.is=function(t){return "selection"===t||"model:selection"==t||"documentSelection"==t||"model:documentSelection"==t};class Rc extends Ic{constructor(t){super(),this.markers=new _i({idProperty:"name"}),this._model=t.model,this._document=t,this._attributePriority=new Map,this._selectionRestorePosition=null,this._hasChangedRange=!1,this._overriddenGravityRegister=new Set,this._observedMarkers=new Set,this.listenTo(this._model,"applyOperation",((t,e)=>{const n=e[0];n.isDocumentOperation&&"marker"!=n.type&&"rename"!=n.type&&"noop"!=n.type&&(0==this._ranges.length&&this._selectionRestorePosition&&this._fixGraveyardSelection(this._selectionRestorePosition),this._selectionRestorePosition=null,this._hasChangedRange&&(this._hasChangedRange=!1,this.fire("change:range",{directChange:!1})));}),{priority:"lowest"}),this.on("change:range",(()=>{this._validateSelectionRanges(this.getRanges());})),this.listenTo(this._model.markers,"update",((t,e,n,o)=>{this._updateMarker(e,o);})),this.listenTo(this._document,"change",((t,e)=>{!function(t,e){const n=t.document.differ;for(const o of n.getChanges()){if("insert"!=o.type)continue;const n=o.position.parent;o.length===n.maxOffset&&t.enqueueChange(e,(t=>{const e=Array.from(n.getAttributeKeys()).filter((t=>t.startsWith(Lc)));for(const o of e)t.removeAttribute(o,n);}));}}(this._model,e);}));}get isCollapsed(){return 0===this._ranges.length?this._document._getDefaultRange().isCollapsed:super.isCollapsed}get anchor(){return super.anchor||this._document._getDefaultRange().start}get focus(){return super.focus||this._document._getDefaultRange().end}get rangeCount(){return this._ranges.length?this._ranges.length:1}get hasOwnRange(){return this._ranges.length>0}get isGravityOverridden(){return !!this._overriddenGravityRegister.size}destroy(){for(let t=0;t<this._ranges.length;t++)this._ranges[t].detach();this.stopListening();}*getRanges(){this._ranges.length?yield*super.getRanges():yield this._document._getDefaultRange();}getFirstRange(){return super.getFirstRange()||this._document._getDefaultRange()}getLastRange(){return super.getLastRange()||this._document._getDefaultRange()}setTo(...t){super.setTo(...t),this._updateAttributes(!0),this.updateMarkers();}setFocus(t,e){super.setFocus(t,e),this._updateAttributes(!0),this.updateMarkers();}setAttribute(t,e){if(this._setAttribute(t,e)){const e=[t];this.fire("change:attribute",{attributeKeys:e,directChange:!0});}}removeAttribute(t){if(this._removeAttribute(t)){const e=[t];this.fire("change:attribute",{attributeKeys:e,directChange:!0});}}overrideGravity(){const t=m();return this._overriddenGravityRegister.add(t),1===this._overriddenGravityRegister.size&&this._updateAttributes(!0),t}restoreGravity(t){if(!this._overriddenGravityRegister.has(t))throw new k("document-selection-gravity-wrong-restore",this,{uid:t});this._overriddenGravityRegister.delete(t),this.isGravityOverridden||this._updateAttributes(!0);}observeMarkers(t){this._observedMarkers.add(t),this.updateMarkers();}_replaceAllRanges(t){this._validateSelectionRanges(t),super._replaceAllRanges(t);}_popRange(){this._ranges.pop().detach();}_pushRange(t){const e=this._prepareRange(t);e&&this._ranges.push(e);}_validateSelectionRanges(t){for(const e of t)if(!this._document._validateSelectionRange(e))throw new k("document-selection-wrong-position",this,{range:e})}_prepareRange(t){if(this._checkRange(t),t.root==this._document.graveyard)return;const e=Bc.fromRange(t);return e.on("change:range",((t,n,o)=>{if(this._hasChangedRange=!0,e.root==this._document.graveyard){this._selectionRestorePosition=o.deletionPosition;const t=this._ranges.indexOf(e);this._ranges.splice(t,1),e.detach();}})),e}updateMarkers(){if(!this._observedMarkers.size)return;const t=[];let e=!1;for(const e of this._model.markers){const n=e.name.split(":",1)[0];if(!this._observedMarkers.has(n))continue;const o=e.getRange();for(const n of this.getRanges())o.containsRange(n,!n.isCollapsed)&&t.push(e);}const n=Array.from(this.markers);for(const n of t)this.markers.has(n)||(this.markers.add(n),e=!0);for(const n of Array.from(this.markers))t.includes(n)||(this.markers.remove(n),e=!0);e&&this.fire("change:marker",{oldMarkers:n,directChange:!1});}_updateMarker(t,e){const n=t.name.split(":",1)[0];if(!this._observedMarkers.has(n))return;let o=!1;const i=Array.from(this.markers),r=this.markers.has(t);if(e){let n=!1;for(const t of this.getRanges())if(e.containsRange(t,!t.isCollapsed)){n=!0;break}n&&!r?(this.markers.add(t),o=!0):!n&&r&&(this.markers.remove(t),o=!0);}else r&&(this.markers.remove(t),o=!0);o&&this.fire("change:marker",{oldMarkers:i,directChange:!1});}_updateAttributes(t){const e=yi(this._getSurroundingAttributes()),n=yi(this.getAttributes());if(t)this._attributePriority=new Map,this._attrs=new Map;else for(const[t,e]of this._attributePriority)"low"==e&&(this._attrs.delete(t),this._attributePriority.delete(t));this._setAttributesTo(e);const o=[];for(const[t,e]of this.getAttributes())n.has(t)&&n.get(t)===e||o.push(t);for(const[t]of n)this.hasAttribute(t)||o.push(t);o.length>0&&this.fire("change:attribute",{attributeKeys:o,directChange:!1});}_setAttribute(t,e,n=!0){const o=n?"normal":"low";if("low"==o&&"normal"==this._attributePriority.get(t))return !1;return super.getAttribute(t)!==e&&(this._attrs.set(t,e),this._attributePriority.set(t,o),!0)}_removeAttribute(t,e=!0){const n=e?"normal":"low";return ("low"!=n||"normal"!=this._attributePriority.get(t))&&(this._attributePriority.set(t,n),!!super.hasAttribute(t)&&(this._attrs.delete(t),!0))}_setAttributesTo(t){const e=new Set;for(const[e,n]of this.getAttributes())t.get(e)!==n&&this._removeAttribute(e,!1);for(const[n,o]of t){this._setAttribute(n,o,!1)&&e.add(n);}return e}*getStoredAttributes(){const t=this.getFirstPosition().parent;if(this.isCollapsed&&t.isEmpty)for(const e of t.getAttributeKeys())if(e.startsWith(Lc)){const n=e.substr(Lc.length);yield [n,t.getAttribute(e)];}}_getSurroundingAttributes(){const t=this.getFirstPosition(),e=this._model.schema;let n=null;if(this.isCollapsed){const o=t.textNode?t.textNode:t.nodeBefore,i=t.textNode?t.textNode:t.nodeAfter;if(this.isGravityOverridden||(n=jc(o)),n||(n=jc(i)),!this.isGravityOverridden&&!n){let t=o;for(;t&&!e.isInline(t)&&!n;)t=t.previousSibling,n=jc(t);}if(!n){let t=i;for(;t&&!e.isInline(t)&&!n;)t=t.nextSibling,n=jc(t);}n||(n=this.getStoredAttributes());}else {const t=this.getFirstRange();for(const o of t){if(o.item.is("element")&&e.isObject(o.item))break;if("text"==o.type){n=o.item.getAttributes();break}}}return n}_fixGraveyardSelection(t){const e=this._model.schema.getNearestSelectionRange(t);e&&this._pushRange(e);}}function jc(t){return t instanceof hc||t instanceof dc?t.getAttributes():null}class Fc{constructor(t){this._dispatchers=t;}add(t){for(const e of this._dispatchers)t(e);return this}}const Vc=function(t){return bo(t,5)};class Uc extends Fc{elementToElement(t){return this.add(function(t){const e=Gc(t.model),n=qc(t.view,"container");e.attributes.length&&(e.children=!0);return o=>{o.on(`insert:${e.name}`,function(t,e=tl){return (n,o,i)=>{if(!e(o.item,i.consumable,{preflight:!0}))return;const r=t(o.item,i,o);if(!r)return;e(o.item,i.consumable);const s=i.mapper.toViewPosition(o.range.start);i.mapper.bindElements(o.item,r),i.writer.insert(s,r),i.convertAttributes(o.item),Jc(r,o.item.getChildren(),i,{reconversion:o.reconversion});}}(n,Zc(e)),{priority:t.converterPriority||"normal"}),(e.children||e.attributes.length)&&o.on("reduceChanges",Qc(e),{priority:"low"});}}(t))}elementToStructure(t){return this.add(function(t){const e=Gc(t.model),n=qc(t.view,"container");return e.children=!0,o=>{if(o._conversionApi.schema.checkChild(e.name,"$text"))throw new k("conversion-element-to-structure-disallowed-text",o,{elementName:e.name});var i,r;o.on(`insert:${e.name}`,(i=n,r=Zc(e),(t,e,n)=>{if(!r(e.item,n.consumable,{preflight:!0}))return;const o=new Map;n.writer._registerSlotFactory(function(t,e,n){return (o,i="children")=>{const r=o.createContainerElement("$slot");let s=null;if("children"===i)s=Array.from(t.getChildren());else {if("function"!=typeof i)throw new k("conversion-slot-mode-unknown",n.dispatcher,{modeOrFilter:i});s=Array.from(t.getChildren()).filter((t=>i(t)));}return e.set(r,s),r}}(e.item,o,n));const s=i(e.item,n,e);if(n.writer._clearSlotFactory(),!s)return;!function(t,e,n){const o=Array.from(e.values()).flat(),i=new Set(o);if(i.size!=o.length)throw new k("conversion-slot-filter-overlap",n.dispatcher,{element:t});if(i.size!=t.childCount)throw new k("conversion-slot-filter-incomplete",n.dispatcher,{element:t})}(e.item,o,n),r(e.item,n.consumable);const a=n.mapper.toViewPosition(e.range.start);n.mapper.bindElements(e.item,s),n.writer.insert(a,s),n.convertAttributes(e.item),function(t,e,n,o){n.mapper.on("modelToViewPosition",s,{priority:"highest"});let i=null,r=null;for([i,r]of e)Jc(t,r,n,o),n.writer.move(n.writer.createRangeIn(i),n.writer.createPositionBefore(i)),n.writer.remove(i);function s(t,e){const n=e.modelPosition.nodeAfter,o=r.indexOf(n);o<0||(e.viewPosition=e.mapper.findPositionIn(i,o));}n.mapper.off("modelToViewPosition",s);}(s,o,n,{reconversion:e.reconversion});}),{priority:t.converterPriority||"normal"}),o.on("reduceChanges",Qc(e),{priority:"low"});}}(t))}attributeToElement(t){return this.add(function(t){t=Vc(t);let e=t.model;"string"==typeof e&&(e={key:e});let n=`attribute:${e.key}`;e.name&&(n+=":"+e.name);if(e.values)for(const n of e.values)t.view[n]=qc(t.view[n],"attribute");else t.view=qc(t.view,"attribute");const o=Yc(t);return e=>{e.on(n,function(t){return (e,n,o)=>{if(!o.consumable.test(n.item,e.name))return;const i=t(n.attributeOldValue,o,n),r=t(n.attributeNewValue,o,n);if(!i&&!r)return;o.consumable.consume(n.item,e.name);const s=o.writer,a=s.document.selection;if(n.item instanceof Ic||n.item instanceof Oc)s.wrap(a.getFirstRange(),r);else {let t=o.mapper.toViewRange(n.range);null!==n.attributeOldValue&&i&&(t=s.unwrap(t,i)),null!==n.attributeNewValue&&r&&s.wrap(t,r);}}}(o),{priority:t.converterPriority||"normal"});}}(t))}attributeToAttribute(t){return this.add(function(t){t=Vc(t);let e=t.model;"string"==typeof e&&(e={key:e});let n=`attribute:${e.key}`;e.name&&(n+=":"+e.name);if(e.values)for(const n of e.values)t.view[n]=$c(t.view[n]);else t.view=$c(t.view);const o=Yc(t);return e=>{var i;e.on(n,(i=o,(t,e,n)=>{if(!n.consumable.test(e.item,t.name))return;const o=i(e.attributeOldValue,n,e),r=i(e.attributeNewValue,n,e);if(!o&&!r)return;n.consumable.consume(e.item,t.name);const s=n.mapper.toViewElement(e.item),a=n.writer;if(!s)throw new k("conversion-attribute-to-attribute-on-text",n.dispatcher,e);if(null!==e.attributeOldValue&&o)if("class"==o.key){const t=pi(o.value);for(const e of t)a.removeClass(e,s);}else if("style"==o.key){const t=Object.keys(o.value);for(const e of t)a.removeStyle(e,s);}else a.removeAttribute(o.key,s);if(null!==e.attributeNewValue&&r)if("class"==r.key){const t=pi(r.value);for(const e of t)a.addClass(e,s);}else if("style"==r.key){const t=Object.keys(r.value);for(const e of t)a.setStyle(e,r.value[e],s);}else a.setAttribute(r.key,r.value,s);}),{priority:t.converterPriority||"normal"});}}(t))}markerToElement(t){return this.add(function(t){const e=qc(t.view,"ui");return n=>{var o;n.on(`addMarker:${t.model}`,(o=e,(t,e,n)=>{e.isOpening=!0;const i=o(e,n);e.isOpening=!1;const r=o(e,n);if(!i||!r)return;const s=e.markerRange;if(s.isCollapsed&&!n.consumable.consume(s,t.name))return;for(const e of s)if(!n.consumable.consume(e.item,t.name))return;const a=n.mapper,c=n.writer;c.insert(a.toViewPosition(s.start),i),n.mapper.bindElementToMarker(i,e.markerName),s.isCollapsed||(c.insert(a.toViewPosition(s.end),r),n.mapper.bindElementToMarker(r,e.markerName)),t.stop();}),{priority:t.converterPriority||"normal"}),n.on(`removeMarker:${t.model}`,((t,e,n)=>{const o=n.mapper.markerNameToElements(e.markerName);if(o){for(const t of o)n.mapper.unbindElementFromMarkerName(t,e.markerName),n.writer.clear(n.writer.createRangeOn(t),t);n.writer.clearClonedElementsGroup(e.markerName),t.stop();}}),{priority:t.converterPriority||"normal"});}}(t))}markerToHighlight(t){return this.add(function(t){return e=>{var n;e.on(`addMarker:${t.model}`,(n=t.view,(t,e,o)=>{if(!e.item)return;if(!(e.item instanceof Ic||e.item instanceof Oc||e.item.is("$textProxy")))return;const i=Kc(n,e,o);if(!i)return;if(!o.consumable.consume(e.item,t.name))return;const r=o.writer,s=Hc(r,i),a=r.document.selection;if(e.item instanceof Ic||e.item instanceof Oc)r.wrap(a.getFirstRange(),s);else {const t=o.mapper.toViewRange(e.range),n=r.wrap(t,s);for(const t of n.getItems())if(t.is("attributeElement")&&t.isSimilar(s)){o.mapper.bindElementToMarker(t,e.markerName);break}}}),{priority:t.converterPriority||"normal"}),e.on(`addMarker:${t.model}`,function(t){return (e,n,o)=>{if(!n.item)return;if(!(n.item instanceof uc))return;const i=Kc(t,n,o);if(!i)return;if(!o.consumable.test(n.item,e.name))return;const r=o.mapper.toViewElement(n.item);if(r&&r.getCustomProperty("addHighlight")){o.consumable.consume(n.item,e.name);for(const t of Ac._createIn(n.item))o.consumable.consume(t.item,e.name);r.getCustomProperty("addHighlight")(r,i,o.writer),o.mapper.bindElementToMarker(r,n.markerName);}}}(t.view),{priority:t.converterPriority||"normal"}),e.on(`removeMarker:${t.model}`,function(t){return (e,n,o)=>{if(n.markerRange.isCollapsed)return;const i=Kc(t,n,o);if(!i)return;const r=Hc(o.writer,i),s=o.mapper.markerNameToElements(n.markerName);if(s){for(const t of s)if(o.mapper.unbindElementFromMarkerName(t,n.markerName),t.is("attributeElement"))o.writer.unwrap(o.writer.createRangeOn(t),r);else {t.getCustomProperty("removeHighlight")(t,i.id,o.writer);}o.writer.clearClonedElementsGroup(n.markerName),e.stop();}}}(t.view),{priority:t.converterPriority||"normal"});}}(t))}markerToData(t){return this.add(function(t){t=Vc(t);const e=t.model;let n=t.view;n||(n=n=>({group:e,name:n.substr(t.model.length+1)}));return o=>{var i;o.on(`addMarker:${e}`,(i=n,(t,e,n)=>{const o=i(e.markerName,n);if(!o)return;const r=e.markerRange;n.consumable.consume(r,t.name)&&(Wc(r,!1,n,e,o),Wc(r,!0,n,e,o),t.stop());}),{priority:t.converterPriority||"normal"}),o.on(`removeMarker:${e}`,function(t){return (e,n,o)=>{const i=t(n.markerName,o);if(!i)return;const r=o.mapper.markerNameToElements(n.markerName);if(r){for(const t of r)o.mapper.unbindElementFromMarkerName(t,n.markerName),t.is("containerElement")?(s(`data-${i.group}-start-before`,t),s(`data-${i.group}-start-after`,t),s(`data-${i.group}-end-before`,t),s(`data-${i.group}-end-after`,t)):o.writer.clear(o.writer.createRangeOn(t),t);o.writer.clearClonedElementsGroup(n.markerName),e.stop();}function s(t,e){if(e.hasAttribute(t)){const n=new Set(e.getAttribute(t).split(","));n.delete(i.name),0==n.size?o.writer.removeAttribute(t,e):o.writer.setAttribute(t,Array.from(n).join(","),e);}}}}(n),{priority:t.converterPriority||"normal"});}}(t))}}function Hc(t,e){const n=t.createAttributeElement("span",e.attributes);return e.classes&&n._addClass(e.classes),"number"==typeof e.priority&&(n._priority=e.priority),n._id=e.id,n}function Wc(t,e,n,o,i){const r=e?t.start:t.end,s=r.nodeAfter&&r.nodeAfter.is("element")?r.nodeAfter:null,a=r.nodeBefore&&r.nodeBefore.is("element")?r.nodeBefore:null;if(s||a){let t,r;e&&s||!e&&!a?(t=s,r=!0):(t=a,r=!1);const c=n.mapper.toViewElement(t);if(c)return void function(t,e,n,o,i,r){const s=`data-${r.group}-${e?"start":"end"}-${n?"before":"after"}`,a=t.hasAttribute(s)?t.getAttribute(s).split(","):[];a.unshift(r.name),o.writer.setAttribute(s,a.join(","),t),o.mapper.bindElementToMarker(t,i.markerName);}(c,e,r,n,o,i)}!function(t,e,n,o,i){const r=`${i.group}-${e?"start":"end"}`,s=i.name?{name:i.name}:null,a=n.writer.createUIElement(r,s);n.writer.insert(t,a),n.mapper.bindElementToMarker(a,o.markerName);}(n.mapper.toViewPosition(r),e,n,o,i);}function Gc(t){return "string"==typeof t&&(t={name:t}),t.attributes?Array.isArray(t.attributes)||(t.attributes=[t.attributes]):t.attributes=[],t.children=!!t.children,t}function qc(t,e){return "function"==typeof t?t:(n,o)=>function(t,e,n){"string"==typeof t&&(t={name:t});let o;const i=e.writer,r=Object.assign({},t.attributes);if("container"==n)o=i.createContainerElement(t.name,r);else if("attribute"==n){const e={priority:t.priority||bs.DEFAULT_PRIORITY};o=i.createAttributeElement(t.name,r,e);}else o=i.createUIElement(t.name,r);if(t.styles){const e=Object.keys(t.styles);for(const n of e)i.setStyle(n,t.styles[n],o);}if(t.classes){const e=t.classes;if("string"==typeof e)i.addClass(e,o);else for(const t of e)i.addClass(t,o);}return o}(t,o,e)}function Yc(t){return t.model.values?(e,n,o)=>{const i=t.view[e];return i?i(e,n,o):null}:t.view}function $c(t){return "string"==typeof t?e=>({key:t,value:e}):"object"==typeof t?t.value?()=>t:e=>({key:t.key,value:e}):t}function Kc(t,e,n){const o="function"==typeof t?t(e,n):t;return o?(o.priority||(o.priority=10),o.id||(o.id=e.markerName),o):null}function Qc(t){const e=function(t){return (e,n)=>{if(!e.is("element",t.name))return !1;if("attribute"==n.type){if(t.attributes.includes(n.attributeKey))return !0}else if(t.children)return !0;return !1}}(t);return (t,n)=>{const o=[];n.reconvertedElements||(n.reconvertedElements=new Set);for(const t of n.changes){const i="attribute"==t.type?t.range.start.nodeAfter:t.position.parent;if(i&&e(i,t)){if(!n.reconvertedElements.has(i)){n.reconvertedElements.add(i);const t=pc._createBefore(i);o.push({type:"remove",name:i.name,position:t,length:1},{type:"reinsert",name:i.name,position:t,length:1});}}else o.push(t);}n.changes=o;}}function Zc(t){return (e,n,o={})=>{const i=["insert"];for(const n of t.attributes)e.hasAttribute(n)&&i.push(`attribute:${n}`);return !!i.every((t=>n.test(e,t)))&&(o.preflight||i.forEach((t=>n.consume(e,t))),!0)}}function Jc(t,e,n,o){for(const i of e)Xc(t.root,i,n,o)||n.convertItem(i);}function Xc(t,e,n,o){const{writer:i,mapper:r}=n;if(!o.reconversion)return !1;const s=r.toViewElement(e);return !(!s||s.root==t)&&(!!n.canReuseView(s)&&(i.move(i.createRangeOn(s),r.toViewPosition(pc._createBefore(e))),!0))}function tl(t,e,{preflight:n}={}){return n?e.test(t,"insert"):e.consume(t,"insert")}function el(t){const{schema:e,document:n}=t.model;for(const o of n.getRootNames()){const i=n.getRoot(o);if(i.isEmpty&&!e.checkChild(i,"$text")&&e.checkChild(i,"paragraph"))return t.insertElement("paragraph",i),!0}return !1}function nl(t,e,n){const o=n.createContext(t);return !!n.checkChild(o,"paragraph")&&!!n.checkChild(o.push("paragraph"),e)}function ol(t,e){const n=e.createElement("paragraph");return e.insert(n,t),e.createPositionAt(n,0)}class il extends Fc{elementToElement(t){return this.add(rl(t))}elementToAttribute(t){return this.add(function(t){t=Vc(t),cl(t);const e=ll(t,!1),n=sl(t.view),o=n?`element:${n}`:"element";return n=>{n.on(o,e,{priority:t.converterPriority||"low"});}}(t))}attributeToAttribute(t){return this.add(function(t){t=Vc(t);let e=null;("string"==typeof t.view||t.view.key)&&(e=function(t){"string"==typeof t.view&&(t.view={key:t.view});const e=t.view.key;let n;if("class"==e||"style"==e){n={["class"==e?"classes":"styles"]:t.view.value};}else {n={attributes:{[e]:void 0===t.view.value?/[\s\S]*/:t.view.value}};}t.view.name&&(n.name=t.view.name);return t.view=n,e}(t));cl(t,e);const n=ll(t,!0);return e=>{e.on("element",n,{priority:t.converterPriority||"low"});}}(t))}elementToMarker(t){return this.add(function(t){const e=function(t){return (e,n)=>{const o="string"==typeof t?t:t(e,n);return n.writer.createElement("$marker",{"data-name":o})}}(t.model);return rl({...t,model:e})}(t))}dataToMarker(t){return this.add(function(t){t=Vc(t),t.model||(t.model=e=>e?t.view+":"+e:t.view);const e={view:t.view,model:t.model},n=al(dl(e,"start")),o=al(dl(e,"end"));return i=>{i.on(`element:${t.view}-start`,n,{priority:t.converterPriority||"normal"}),i.on(`element:${t.view}-end`,o,{priority:t.converterPriority||"normal"});const r=p.get("low"),s=p.get("highest"),a=p.get(t.converterPriority)/s;i.on("element",function(t){return (e,n,o)=>{const i=`data-${t.view}`;function r(e,i){for(const r of i){const i=t.model(r,o),s=o.writer.createElement("$marker",{"data-name":i});o.writer.insert(s,e),n.modelCursor.isEqual(e)?n.modelCursor=n.modelCursor.getShiftedBy(1):n.modelCursor=n.modelCursor._getTransformedByInsertion(e,1),n.modelRange=n.modelRange._getTransformedByInsertion(e,1)[0];}}(o.consumable.test(n.viewItem,{attributes:i+"-end-after"})||o.consumable.test(n.viewItem,{attributes:i+"-start-after"})||o.consumable.test(n.viewItem,{attributes:i+"-end-before"})||o.consumable.test(n.viewItem,{attributes:i+"-start-before"}))&&(n.modelRange||Object.assign(n,o.convertChildren(n.viewItem,n.modelCursor)),o.consumable.consume(n.viewItem,{attributes:i+"-end-after"})&&r(n.modelRange.end,n.viewItem.getAttribute(i+"-end-after").split(",")),o.consumable.consume(n.viewItem,{attributes:i+"-start-after"})&&r(n.modelRange.end,n.viewItem.getAttribute(i+"-start-after").split(",")),o.consumable.consume(n.viewItem,{attributes:i+"-end-before"})&&r(n.modelRange.start,n.viewItem.getAttribute(i+"-end-before").split(",")),o.consumable.consume(n.viewItem,{attributes:i+"-start-before"})&&r(n.modelRange.start,n.viewItem.getAttribute(i+"-start-before").split(",")));}}(e),{priority:r+a});}}(t))}}function rl(t){const e=al(t=Vc(t)),n=sl(t.view),o=n?`element:${n}`:"element";return n=>{n.on(o,e,{priority:t.converterPriority||"normal"});}}function sl(t){return "string"==typeof t?t:"object"==typeof t&&"string"==typeof t.name?t.name:null}function al(t){const e=new Ji(t.view);return (n,o,i)=>{const r=e.match(o.viewItem);if(!r)return;const s=r.match;if(s.name=!0,!i.consumable.test(o.viewItem,s))return;const a=function(t,e,n){return t instanceof Function?t(e,n):n.writer.createElement(t)}(t.model,o.viewItem,i);a&&i.safeInsert(a,o.modelCursor)&&(i.consumable.consume(o.viewItem,s),i.convertChildren(o.viewItem,a),i.updateConversionResult(a,o));}}function cl(t,e=null){const n=null===e||(t=>t.getAttribute(e)),o="object"!=typeof t.model?t.model:t.model.key,i="object"!=typeof t.model||void 0===t.model.value?n:t.model.value;t.model={key:o,value:i};}function ll(t,e){const n=new Ji(t.view);return (o,i,r)=>{if(!i.modelRange&&e)return;const s=n.match(i.viewItem);if(!s)return;if(!function(t,e){const n="function"==typeof t?t(e):t;if("object"==typeof n&&!sl(n))return !1;return !n.classes&&!n.attributes&&!n.styles}(t.view,i.viewItem)?delete s.match.name:s.match.name=!0,!r.consumable.test(i.viewItem,s.match))return;const a=t.model.key,c="function"==typeof t.model.value?t.model.value(i.viewItem,r):t.model.value;if(null===c)return;i.modelRange||Object.assign(i,r.convertChildren(i.viewItem,i.modelCursor));const l=function(t,e,n,o){let i=!1;for(const r of Array.from(t.getItems({shallow:n})))o.schema.checkAttribute(r,e.key)&&(i=!0,r.hasAttribute(e.key)||o.writer.setAttribute(e.key,e.value,r));return i}(i.modelRange,{key:a,value:c},e,r);l&&(r.consumable.test(i.viewItem,{name:!0})&&(s.match.name=!0),r.consumable.consume(i.viewItem,s.match));}}function dl(t,e){return {view:`${t.view}-${e}`,model:(e,n)=>{const o=e.getAttribute("name"),i=t.model(o,n);return n.writer.createElement("$marker",{"data-name":i})}}}class hl extends(H()){constructor(t,e){super(),this.model=t,this.view=new sc(e),this.mapper=new Cc,this.downcastDispatcher=new xc({mapper:this.mapper,schema:t.schema});const n=this.model.document,o=n.selection,i=this.model.markers;this.listenTo(this.model,"_beforeChanges",(()=>{this.view._disableRendering(!0);}),{priority:"highest"}),this.listenTo(this.model,"_afterChanges",(()=>{this.view._disableRendering(!1);}),{priority:"lowest"}),this.listenTo(n,"change",(()=>{this.view.change((t=>{this.downcastDispatcher.convertChanges(n.differ,i,t),this.downcastDispatcher.convertSelection(o,i,t);}));}),{priority:"low"}),this.listenTo(this.view.document,"selectionChange",function(t,e){return (n,o)=>{const i=o.newSelection,r=[];for(const t of i.getRanges())r.push(e.toModelRange(t));const s=t.createSelection(r,{backward:i.isBackward});s.isEqual(t.document.selection)||t.change((t=>{t.setSelection(s);}));}}(this.model,this.mapper)),this.downcastDispatcher.on("insert:$text",((t,e,n)=>{if(!n.consumable.consume(e.item,t.name))return;const o=n.writer,i=n.mapper.toViewPosition(e.range.start),r=o.createText(e.item.data);o.insert(i,r);}),{priority:"lowest"}),this.downcastDispatcher.on("insert",((t,e,n)=>{n.convertAttributes(e.item),e.reconversion||!e.item.is("element")||e.item.isEmpty||n.convertChildren(e.item);}),{priority:"lowest"}),this.downcastDispatcher.on("remove",((t,e,n)=>{const o=n.mapper.toViewPosition(e.position),i=e.position.getShiftedBy(e.length),r=n.mapper.toViewPosition(i,{isPhantom:!0}),s=n.writer.createRange(o,r),a=n.writer.remove(s.getTrimmed());for(const t of n.writer.createRangeIn(a).getItems())n.mapper.unbindViewElement(t,{defer:!0});}),{priority:"low"}),this.downcastDispatcher.on("selection",((t,e,n)=>{const o=n.writer,i=o.document.selection;for(const t of i.getRanges())t.isCollapsed&&t.end.parent.isAttached()&&n.writer.mergeAttributes(t.start);o.setSelection(null);}),{priority:"high"}),this.downcastDispatcher.on("selection",((t,e,n)=>{const o=e.selection;if(o.isCollapsed)return;if(!n.consumable.consume(o,"selection"))return;const i=[];for(const t of o.getRanges())i.push(n.mapper.toViewRange(t));n.writer.setSelection(i,{backward:o.isBackward});}),{priority:"low"}),this.downcastDispatcher.on("selection",((t,e,n)=>{const o=e.selection;if(!o.isCollapsed)return;if(!n.consumable.consume(o,"selection"))return;const i=n.writer,r=o.getFirstPosition(),s=n.mapper.toViewPosition(r),a=i.breakAttributes(s);i.setSelection(a);}),{priority:"low"}),this.view.document.roots.bindTo(this.model.document.roots).using((t=>{if("$graveyard"==t.rootName)return null;const e=new os(this.view.document,t.name);return e.rootName=t.rootName,this.mapper.bindElements(t,e),e}));}destroy(){this.view.destroy(),this.stopListening();}reconvertMarker(t){const e="string"==typeof t?t:t.name,n=this.model.markers.get(e);if(!n)throw new k("editingcontroller-reconvertmarker-marker-not-exist",this,{markerName:e});this.model.change((()=>{this.model.markers._refresh(n);}));}reconvertItem(t){this.model.change((()=>{this.model.document.differ._refreshItem(t);}));}}class ul{constructor(){this._consumables=new Map;}add(t,e){let n;t.is("$text")||t.is("documentFragment")?this._consumables.set(t,!0):(this._consumables.has(t)?n=this._consumables.get(t):(n=new ml(t),this._consumables.set(t,n)),n.add(e));}test(t,e){const n=this._consumables.get(t);return void 0===n?null:t.is("$text")||t.is("documentFragment")?n:n.test(e)}consume(t,e){return !!this.test(t,e)&&(t.is("$text")||t.is("documentFragment")?this._consumables.set(t,!1):this._consumables.get(t).consume(e),!0)}revert(t,e){const n=this._consumables.get(t);void 0!==n&&(t.is("$text")||t.is("documentFragment")?this._consumables.set(t,!0):n.revert(e));}static consumablesFromElement(t){const e={element:t,name:!0,attributes:[],classes:[],styles:[]},n=t.getAttributeKeys();for(const t of n)"style"!=t&&"class"!=t&&e.attributes.push(t);const o=t.getClassNames();for(const t of o)e.classes.push(t);const i=t.getStyleNames();for(const t of i)e.styles.push(t);return e}static createFrom(t,e){if(e||(e=new ul),t.is("$text"))return e.add(t),e;t.is("element")&&e.add(t,ul.consumablesFromElement(t)),t.is("documentFragment")&&e.add(t);for(const n of t.getChildren())e=ul.createFrom(n,e);return e}}const gl=["attributes","classes","styles"];class ml{constructor(t){this.element=t,this._canConsumeName=null,this._consumables={attributes:new Map,styles:new Map,classes:new Map};}add(t){t.name&&(this._canConsumeName=!0);for(const e of gl)e in t&&this._add(e,t[e]);}test(t){if(t.name&&!this._canConsumeName)return this._canConsumeName;for(const e of gl)if(e in t){const n=this._test(e,t[e]);if(!0!==n)return n}return !0}consume(t){t.name&&(this._canConsumeName=!1);for(const e of gl)e in t&&this._consume(e,t[e]);}revert(t){t.name&&(this._canConsumeName=!0);for(const e of gl)e in t&&this._revert(e,t[e]);}_add(t,e){const n=ht(e)?e:[e],o=this._consumables[t];for(const e of n){if("attributes"===t&&("class"===e||"style"===e))throw new k("viewconsumable-invalid-attribute",this);if(o.set(e,!0),"styles"===t)for(const t of this.element.document.stylesProcessor.getRelatedStyles(e))o.set(t,!0);}}_test(t,e){const n=ht(e)?e:[e],o=this._consumables[t];for(const e of n)if("attributes"!==t||"class"!==e&&"style"!==e){const t=o.get(e);if(void 0===t)return null;if(!t)return !1}else {const t="class"==e?"classes":"styles",n=this._test(t,[...this._consumables[t].keys()]);if(!0!==n)return n}return !0}_consume(t,e){const n=ht(e)?e:[e],o=this._consumables[t];for(const e of n)if("attributes"!==t||"class"!==e&&"style"!==e){if(o.set(e,!1),"styles"==t)for(const t of this.element.document.stylesProcessor.getRelatedStyles(e))o.set(t,!1);}else {const t="class"==e?"classes":"styles";this._consume(t,[...this._consumables[t].keys()]);}}_revert(t,e){const n=ht(e)?e:[e],o=this._consumables[t];for(const e of n)if("attributes"!==t||"class"!==e&&"style"!==e){!1===o.get(e)&&o.set(e,!0);}else {const t="class"==e?"classes":"styles";this._revert(t,[...this._consumables[t].keys()]);}}}class pl extends(H()){constructor(){super(),this._sourceDefinitions={},this._attributeProperties={},this.decorate("checkChild"),this.decorate("checkAttribute"),this.on("checkAttribute",((t,e)=>{e[0]=new fl(e[0]);}),{priority:"highest"}),this.on("checkChild",((t,e)=>{e[0]=new fl(e[0]),e[1]=this.getDefinition(e[1]);}),{priority:"highest"});}register(t,e){if(this._sourceDefinitions[t])throw new k("schema-cannot-register-item-twice",this,{itemName:t});this._sourceDefinitions[t]=[Object.assign({},e)],this._clearCache();}extend(t,e){if(!this._sourceDefinitions[t])throw new k("schema-cannot-extend-missing-item",this,{itemName:t});this._sourceDefinitions[t].push(Object.assign({},e)),this._clearCache();}getDefinitions(){return this._compiledDefinitions||this._compile(),this._compiledDefinitions}getDefinition(t){let e;return e="string"==typeof t?t:"is"in t&&(t.is("$text")||t.is("$textProxy"))?"$text":t.name,this.getDefinitions()[e]}isRegistered(t){return !!this.getDefinition(t)}isBlock(t){const e=this.getDefinition(t);return !(!e||!e.isBlock)}isLimit(t){const e=this.getDefinition(t);return !!e&&!(!e.isLimit&&!e.isObject)}isObject(t){const e=this.getDefinition(t);return !!e&&!!(e.isObject||e.isLimit&&e.isSelectable&&e.isContent)}isInline(t){const e=this.getDefinition(t);return !(!e||!e.isInline)}isSelectable(t){const e=this.getDefinition(t);return !!e&&!(!e.isSelectable&&!e.isObject)}isContent(t){const e=this.getDefinition(t);return !!e&&!(!e.isContent&&!e.isObject)}checkChild(t,e){return !!e&&this._checkContextMatch(e,t)}checkAttribute(t,e){const n=this.getDefinition(t.last);return !!n&&n.allowAttributes.includes(e)}checkMerge(t,e){if(t instanceof pc){const e=t.nodeBefore,n=t.nodeAfter;if(!(e instanceof uc))throw new k("schema-check-merge-no-element-before",this);if(!(n instanceof uc))throw new k("schema-check-merge-no-element-after",this);return this.checkMerge(e,n)}for(const n of e.getChildren())if(!this.checkChild(t,n))return !1;return !0}addChildCheck(t){this.on("checkChild",((e,[n,o])=>{if(!o)return;const i=t(n,o);"boolean"==typeof i&&(e.stop(),e.return=i);}),{priority:"high"});}addAttributeCheck(t){this.on("checkAttribute",((e,[n,o])=>{const i=t(n,o);"boolean"==typeof i&&(e.stop(),e.return=i);}),{priority:"high"});}setAttributeProperties(t,e){this._attributeProperties[t]=Object.assign(this.getAttributeProperties(t),e);}getAttributeProperties(t){return this._attributeProperties[t]||{}}getLimitElement(t){let e;if(t instanceof pc)e=t.parent;else {e=(t instanceof Ac?[t]:Array.from(t.getRanges())).reduce(((t,e)=>{const n=e.getCommonAncestor();return t?t.getCommonAncestor(n,{includeSelf:!0}):n}),null);}for(;!this.isLimit(e)&&e.parent;)e=e.parent;return e}checkAttributeInSelection(t,e){if(t.isCollapsed){const n=[...t.getFirstPosition().getAncestors(),new dc("",t.getAttributes())];return this.checkAttribute(n,e)}{const n=t.getRanges();for(const t of n)for(const n of t)if(this.checkAttribute(n.item,e))return !0}return !1}*getValidRanges(t,e){t=function*(t){for(const e of t)yield*e.getMinimalFlatRanges();}(t);for(const n of t)yield*this._getValidRangesForRange(n,e);}getNearestSelectionRange(t,e="both"){if(this.checkChild(t,"$text"))return new Ac(t);let n,o;const i=t.getAncestors().reverse().find((t=>this.isLimit(t)))||t.root;"both"!=e&&"backward"!=e||(n=new gc({boundaries:Ac._createIn(i),startPosition:t,direction:"backward"})),"both"!=e&&"forward"!=e||(o=new gc({boundaries:Ac._createIn(i),startPosition:t}));for(const t of function*(t,e){let n=!1;for(;!n;){if(n=!0,t){const e=t.next();e.done||(n=!1,yield {walker:t,value:e.value});}if(e){const t=e.next();t.done||(n=!1,yield {walker:e,value:t.value});}}}(n,o)){const e=t.walker==n?"elementEnd":"elementStart",o=t.value;if(o.type==e&&this.isObject(o.item))return Ac._createOn(o.item);if(this.checkChild(o.nextPosition,"$text"))return new Ac(o.nextPosition)}return null}findAllowedParent(t,e){let n=t.parent;for(;n;){if(this.checkChild(n,e))return n;if(this.isLimit(n))return null;n=n.parent;}return null}setAllowedAttributes(t,e,n){const o=n.model;for(const[i,r]of Object.entries(e))o.schema.checkAttribute(t,i)&&n.setAttribute(i,r,t);}removeDisallowedAttributes(t,e){for(const n of t)if(n.is("$text"))Ml(this,n,e);else {const t=Ac._createIn(n).getPositions();for(const n of t){Ml(this,n.nodeBefore||n.parent,e);}}}getAttributesWithProperty(t,e,n){const o={};for(const[i,r]of t.getAttributes()){const t=this.getAttributeProperties(i);void 0!==t[e]&&(void 0!==n&&n!==t[e]||(o[i]=r));}return o}createContext(t){return new fl(t)}_clearCache(){this._compiledDefinitions=null;}_compile(){const t={},e=this._sourceDefinitions,n=Object.keys(e);for(const o of n)t[o]=kl(e[o],o);for(const e of n)bl(t,e);for(const e of n)wl(t,e);for(const e of n)_l(t,e);for(const e of n)Al(t,e),Cl(t,e);for(const e of n)vl(t,e),yl(t,e),xl(t,e);this._compiledDefinitions=t;}_checkContextMatch(t,e,n=e.length-1){const o=e.getItem(n);if(t.allowIn.includes(o.name)){if(0==n)return !0;{const t=this.getDefinition(o);return this._checkContextMatch(t,e,n-1)}}return !1}*_getValidRangesForRange(t,e){let n=t.start,o=t.start;for(const i of t.getItems({shallow:!0}))i.is("element")&&(yield*this._getValidRangesForRange(Ac._createIn(i),e)),this.checkAttribute(i,e)||(n.isEqual(o)||(yield new Ac(n,o)),n=pc._createAfter(i)),o=pc._createAfter(i);n.isEqual(o)||(yield new Ac(n,o));}}class fl{constructor(t){if(t instanceof fl)return t;let e;e="string"==typeof t?[t]:Array.isArray(t)?t:t.getAncestors({includeSelf:!0}),this._items=e.map(Il);}get length(){return this._items.length}get last(){return this._items[this._items.length-1]}[Symbol.iterator](){return this._items[Symbol.iterator]()}push(t){const e=new fl([t]);return e._items=[...this._items,...e._items],e}getItem(t){return this._items[t]}*getNames(){yield*this._items.map((t=>t.name));}endsWith(t){return Array.from(this.getNames()).join(" ").endsWith(t)}startsWith(t){return Array.from(this.getNames()).join(" ").startsWith(t)}}function kl(t,e){const n={name:e,allowIn:[],allowContentOf:[],allowWhere:[],allowAttributes:[],allowAttributesOf:[],allowChildren:[],inheritTypesFrom:[]};return function(t,e){for(const n of t){const t=Object.keys(n).filter((t=>t.startsWith("is")));for(const o of t)e[o]=!!n[o];}}(t,n),El(t,n,"allowIn"),El(t,n,"allowContentOf"),El(t,n,"allowWhere"),El(t,n,"allowAttributes"),El(t,n,"allowAttributesOf"),El(t,n,"allowChildren"),El(t,n,"inheritTypesFrom"),function(t,e){for(const n of t){const t=n.inheritAllFrom;t&&(e.allowContentOf.push(t),e.allowWhere.push(t),e.allowAttributesOf.push(t),e.inheritTypesFrom.push(t));}}(t,n),n}function bl(t,e){const n=t[e];for(const o of n.allowChildren){const n=t[o];n&&n.allowIn.push(e);}n.allowChildren.length=0;}function wl(t,e){for(const n of t[e].allowContentOf)if(t[n]){Dl(t,n).forEach((t=>{t.allowIn.push(e);}));}delete t[e].allowContentOf;}function _l(t,e){for(const n of t[e].allowWhere){const o=t[n];if(o){const n=o.allowIn;t[e].allowIn.push(...n);}}delete t[e].allowWhere;}function Al(t,e){for(const n of t[e].allowAttributesOf){const o=t[n];if(o){const n=o.allowAttributes;t[e].allowAttributes.push(...n);}}delete t[e].allowAttributesOf;}function Cl(t,e){const n=t[e];for(const e of n.inheritTypesFrom){const o=t[e];if(o){const t=Object.keys(o).filter((t=>t.startsWith("is")));for(const e of t)e in n||(n[e]=o[e]);}}delete n.inheritTypesFrom;}function vl(t,e){const n=t[e],o=n.allowIn.filter((e=>t[e]));n.allowIn=Array.from(new Set(o));}function yl(t,e){const n=t[e];for(const o of n.allowIn){t[o].allowChildren.push(e);}}function xl(t,e){const n=t[e];n.allowAttributes=Array.from(new Set(n.allowAttributes));}function El(t,e,n){for(const o of t){const t=o[n];"string"==typeof t?e[n].push(t):Array.isArray(t)&&e[n].push(...t);}}function Dl(t,e){const n=t[e];return (o=t,Object.keys(o).map((t=>o[t]))).filter((t=>t.allowIn.includes(n.name)));var o;}function Il(t){return "string"==typeof t||t.is("documentFragment")?{name:"string"==typeof t?t:"$documentFragment",*getAttributeKeys(){},getAttribute(){}}:{name:t.is("element")?t.name:"$text",*getAttributeKeys(){yield*t.getAttributeKeys();},getAttribute:e=>t.getAttribute(e)}}function Ml(t,e,n){for(const o of e.getAttributeKeys())t.checkAttribute(e,o)||n.removeAttribute(o,e);}class Tl extends(I()){constructor(t){super(),this._splitParts=new Map,this._cursorParents=new Map,this._modelCursor=null,this._emptyElementsToKeep=new Set,this.conversionApi={...t,consumable:null,writer:null,store:null,convertItem:(t,e)=>this._convertItem(t,e),convertChildren:(t,e)=>this._convertChildren(t,e),safeInsert:(t,e)=>this._safeInsert(t,e),updateConversionResult:(t,e)=>this._updateConversionResult(t,e),splitToAllowedParent:(t,e)=>this._splitToAllowedParent(t,e),getSplitParts:t=>this._getSplitParts(t),keepEmptyElement:t=>this._keepEmptyElement(t)};}convert(t,e,n=["$root"]){this.fire("viewCleanup",t),this._modelCursor=function(t,e){let n;for(const o of new fl(t)){const t={};for(const e of o.getAttributeKeys())t[e]=o.getAttribute(e);const i=e.createElement(o.name,t);n&&e.insert(i,n),n=pc._createAt(i,0);}return n}(n,e),this.conversionApi.writer=e,this.conversionApi.consumable=ul.createFrom(t),this.conversionApi.store={};const{modelRange:o}=this._convertItem(t,this._modelCursor),i=e.createDocumentFragment();if(o){this._removeEmptyElements();for(const t of Array.from(this._modelCursor.parent.getChildren()))e.append(t,i);i.markers=function(t,e){const n=new Set,o=new Map,i=Ac._createIn(t).getItems();for(const t of i)t.is("element","$marker")&&n.add(t);for(const t of n){const n=t.getAttribute("data-name"),i=e.createPositionBefore(t);o.has(n)?o.get(n).end=i.clone():o.set(n,new Ac(i.clone())),e.remove(t);}return o}(i,e);}return this._modelCursor=null,this._splitParts.clear(),this._cursorParents.clear(),this._emptyElementsToKeep.clear(),this.conversionApi.writer=null,this.conversionApi.store=null,i}_convertItem(t,e){const n={viewItem:t,modelCursor:e,modelRange:null};if(t.is("element")?this.fire(`element:${t.name}`,n,this.conversionApi):t.is("$text")?this.fire("text",n,this.conversionApi):this.fire("documentFragment",n,this.conversionApi),n.modelRange&&!(n.modelRange instanceof Ac))throw new k("view-conversion-dispatcher-incorrect-result",this);return {modelRange:n.modelRange,modelCursor:n.modelCursor}}_convertChildren(t,e){let n=e.is("position")?e:pc._createAt(e,0);const o=new Ac(n);for(const e of Array.from(t.getChildren())){const t=this._convertItem(e,n);t.modelRange instanceof Ac&&(o.end=t.modelRange.end,n=t.modelCursor);}return {modelRange:o,modelCursor:n}}_safeInsert(t,e){const n=this._splitToAllowedParent(t,e);return !!n&&(this.conversionApi.writer.insert(t,n.position),!0)}_updateConversionResult(t,e){const n=this._getSplitParts(t),o=this.conversionApi.writer;e.modelRange||(e.modelRange=o.createRange(o.createPositionBefore(t),o.createPositionAfter(n[n.length-1])));const i=this._cursorParents.get(t);e.modelCursor=i?o.createPositionAt(i,0):e.modelRange.end;}_splitToAllowedParent(t,e){const{schema:n,writer:o}=this.conversionApi;let i=n.findAllowedParent(e,t);if(i){if(i===e.parent)return {position:e};this._modelCursor.parent.getAncestors().includes(i)&&(i=null);}if(!i)return nl(e,t,n)?{position:ol(e,o)}:null;const r=this.conversionApi.writer.split(e,i),s=[];for(const t of r.range.getWalker())if("elementEnd"==t.type)s.push(t.item);else {const e=s.pop(),n=t.item;this._registerSplitPair(e,n);}const a=r.range.end.parent;return this._cursorParents.set(t,a),{position:r.position,cursorParent:a}}_registerSplitPair(t,e){this._splitParts.has(t)||this._splitParts.set(t,[t]);const n=this._splitParts.get(t);this._splitParts.set(e,n),n.push(e);}_getSplitParts(t){let e;return e=this._splitParts.has(t)?this._splitParts.get(t):[t],e}_keepEmptyElement(t){this._emptyElementsToKeep.add(t);}_removeEmptyElements(){let t=!1;for(const e of this._splitParts.keys())e.isEmpty&&!this._emptyElementsToKeep.has(e)&&(this.conversionApi.writer.remove(e),this._splitParts.delete(e),t=!0);t&&this._removeEmptyElements();}}class Sl{getHtml(t){const e=document.implementation.createHTMLDocument("").createElement("div");return e.appendChild(t),e.innerHTML}}class Nl{constructor(t){this.skipComments=!0,this.domParser=new DOMParser,this.domConverter=new aa(t,{renderingMode:"data"}),this.htmlWriter=new Sl;}toData(t){const e=this.domConverter.viewToDom(t);return this.htmlWriter.getHtml(e)}toView(t){const e=this._toDom(t);return this.domConverter.domToView(e,{skipComments:this.skipComments})}registerRawContentMatcher(t){this.domConverter.registerRawContentMatcher(t);}useFillerType(t){this.domConverter.blockFillerMode="marked"==t?"markedNbsp":"nbsp";}_toDom(t){t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)||(t=`<body>${t}</body>`);const e=this.domParser.parseFromString(t,"text/html"),n=e.createDocumentFragment(),o=e.body.childNodes;for(;o.length>0;)n.appendChild(o[0]);return n}}class Bl extends(I()){constructor(t,e){super(),this.model=t,this.mapper=new Cc,this.downcastDispatcher=new xc({mapper:this.mapper,schema:t.schema}),this.downcastDispatcher.on("insert:$text",((t,e,n)=>{if(!n.consumable.consume(e.item,t.name))return;const o=n.writer,i=n.mapper.toViewPosition(e.range.start),r=o.createText(e.item.data);o.insert(i,r);}),{priority:"lowest"}),this.downcastDispatcher.on("insert",((t,e,n)=>{n.convertAttributes(e.item),e.reconversion||!e.item.is("element")||e.item.isEmpty||n.convertChildren(e.item);}),{priority:"lowest"}),this.upcastDispatcher=new Tl({schema:t.schema}),this.viewDocument=new ks(e),this.stylesProcessor=e,this.htmlProcessor=new Nl(this.viewDocument),this.processor=this.htmlProcessor,this._viewWriter=new Ms(this.viewDocument),this.upcastDispatcher.on("text",((t,e,{schema:n,consumable:o,writer:i})=>{let r=e.modelCursor;if(!o.test(e.viewItem))return;if(!n.checkChild(r,"$text")){if(!nl(r,"$text",n))return;if(0==e.viewItem.data.trim().length)return;r=ol(r,i);}o.consume(e.viewItem);const s=i.createText(e.viewItem.data);i.insert(s,r),e.modelRange=i.createRange(r,r.getShiftedBy(s.offsetSize)),e.modelCursor=e.modelRange.end;}),{priority:"lowest"}),this.upcastDispatcher.on("element",((t,e,n)=>{if(!e.modelRange&&n.consumable.consume(e.viewItem,{name:!0})){const{modelRange:t,modelCursor:o}=n.convertChildren(e.viewItem,e.modelCursor);e.modelRange=t,e.modelCursor=o;}}),{priority:"lowest"}),this.upcastDispatcher.on("documentFragment",((t,e,n)=>{if(!e.modelRange&&n.consumable.consume(e.viewItem,{name:!0})){const{modelRange:t,modelCursor:o}=n.convertChildren(e.viewItem,e.modelCursor);e.modelRange=t,e.modelCursor=o;}}),{priority:"lowest"}),H().prototype.decorate.call(this,"init"),H().prototype.decorate.call(this,"set"),H().prototype.decorate.call(this,"get"),this.on("init",(()=>{this.fire("ready");}),{priority:"lowest"}),this.on("ready",(()=>{this.model.enqueueChange({isUndoable:!1},el);}),{priority:"lowest"});}get(t={}){const{rootName:e="main",trim:n="empty"}=t;if(!this._checkIfRootsExists([e]))throw new k("datacontroller-get-non-existent-root",this);const o=this.model.document.getRoot(e);return "empty"!==n||this.model.hasContent(o,{ignoreWhitespaces:!0})?this.stringify(o,t):""}stringify(t,e={}){const n=this.toView(t,e);return this.processor.toData(n)}toView(t,e={}){const n=this.viewDocument,o=this._viewWriter;this.mapper.clearBindings();const i=Ac._createIn(t),r=new Is(n);this.mapper.bindElements(t,r);const s=t.is("documentFragment")?t.markers:function(t){const e=[],n=t.root.document;if(!n)return new Map;const o=Ac._createIn(t);for(const t of n.model.markers){const n=t.getRange(),i=n.isCollapsed,r=n.start.isEqual(o.start)||n.end.isEqual(o.end);if(i&&r)e.push([t.name,n]);else {const i=o.getIntersection(n);i&&e.push([t.name,i]);}}return e.sort((([t,e],[n,o])=>{if("after"!==e.end.compareWith(o.start))return 1;if("before"!==e.start.compareWith(o.end))return -1;switch(e.start.compareWith(o.start)){case"before":return 1;case"after":return -1;default:switch(e.end.compareWith(o.end)){case"before":return 1;case"after":return -1;default:return n.localeCompare(t)}}})),new Map(e)}(t);return this.downcastDispatcher.convert(i,s,o,e),r}init(t){if(this.model.document.version)throw new k("datacontroller-init-document-not-empty",this);let e={};if("string"==typeof t?e.main=t:e=t,!this._checkIfRootsExists(Object.keys(e)))throw new k("datacontroller-init-non-existent-root",this);return this.model.enqueueChange({isUndoable:!1},(t=>{for(const n of Object.keys(e)){const o=this.model.document.getRoot(n);t.insert(this.parse(e[n],o),o,0);}})),Promise.resolve()}set(t,e={}){let n={};if("string"==typeof t?n.main=t:n=t,!this._checkIfRootsExists(Object.keys(n)))throw new k("datacontroller-set-non-existent-root",this);this.model.enqueueChange(e.batchType||{},(t=>{t.setSelection(null),t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());for(const e of Object.keys(n)){const o=this.model.document.getRoot(e);t.remove(t.createRangeIn(o)),t.insert(this.parse(n[e],o),o,0);}}));}parse(t,e="$root"){const n=this.processor.toView(t);return this.toModel(n,e)}toModel(t,e="$root"){return this.model.change((n=>this.upcastDispatcher.convert(t,n,e)))}addStyleProcessorRules(t){t(this.stylesProcessor);}registerRawContentMatcher(t){this.processor&&this.processor!==this.htmlProcessor&&this.processor.registerRawContentMatcher(t),this.htmlProcessor.registerRawContentMatcher(t);}destroy(){this.stopListening();}_checkIfRootsExists(t){for(const e of t)if(!this.model.document.getRootNames().includes(e))return !1;return !0}}class Pl{constructor(t,e){this._helpers=new Map,this._downcast=pi(t),this._createConversionHelpers({name:"downcast",dispatchers:this._downcast,isDowncast:!0}),this._upcast=pi(e),this._createConversionHelpers({name:"upcast",dispatchers:this._upcast,isDowncast:!1});}addAlias(t,e){const n=this._downcast.includes(e);if(!this._upcast.includes(e)&&!n)throw new k("conversion-add-alias-dispatcher-not-registered",this);this._createConversionHelpers({name:t,dispatchers:[e],isDowncast:n});}for(t){if(!this._helpers.has(t))throw new k("conversion-for-unknown-group",this);return this._helpers.get(t)}elementToElement(t){this.for("downcast").elementToElement(t);for(const{model:e,view:n}of zl(t))this.for("upcast").elementToElement({model:e,view:n,converterPriority:t.converterPriority});}attributeToElement(t){this.for("downcast").attributeToElement(t);for(const{model:e,view:n}of zl(t))this.for("upcast").elementToAttribute({view:n,model:e,converterPriority:t.converterPriority});}attributeToAttribute(t){this.for("downcast").attributeToAttribute(t);for(const{model:e,view:n}of zl(t))this.for("upcast").attributeToAttribute({view:n,model:e});}_createConversionHelpers({name:t,dispatchers:e,isDowncast:n}){if(this._helpers.has(t))throw new k("conversion-group-exists",this);const o=n?new Uc(e):new il(e);this._helpers.set(t,o);}}function*zl(t){if(t.model.values)for(const e of t.model.values){const n={key:t.model.key,value:e},o=t.view[e],i=t.upcastAlso?t.upcastAlso[e]:void 0;yield*Ll(n,o,i);}else yield*Ll(t.model,t.view,t.upcastAlso);}function*Ll(t,e,n){if(yield {model:t,view:e},n)for(const e of pi(n))yield {model:t,view:e};}class Ol{constructor(t){this.baseVersion=t,this.isDocumentOperation=null!==this.baseVersion,this.batch=null;}_validate(){}toJSON(){const t=Object.assign({},this);return t.__className=this.constructor.className,delete t.batch,delete t.isDocumentOperation,t}static get className(){return "Operation"}static fromJSON(t,e){return new this(t.baseVersion)}}function Rl(t,e){const n=Vl(e),o=n.reduce(((t,e)=>t+e.offsetSize),0),i=t.parent;Hl(t);const r=t.index;return i._insertChild(r,n),Ul(i,r+n.length),Ul(i,r),new Ac(t,t.getShiftedBy(o))}function jl(t){if(!t.isFlat)throw new k("operation-utils-remove-range-not-flat",this);const e=t.start.parent;Hl(t.start),Hl(t.end);const n=e._removeChildren(t.start.index,t.end.index-t.start.index);return Ul(e,t.start.index),n}function Fl(t,e){if(!t.isFlat)throw new k("operation-utils-move-range-not-flat",this);const n=jl(t);return Rl(e=e._getTransformedByDeletion(t.start,t.end.offset-t.start.offset),n)}function Vl(t){const e=[];!function t(n){if("string"==typeof n)e.push(new dc(n));else if(n instanceof hc)e.push(new dc(n.data,n.getAttributes()));else if(n instanceof cc)e.push(n);else if(Z(n))for(const e of n)t(e);}(t);for(let t=1;t<e.length;t++){const n=e[t],o=e[t-1];n instanceof dc&&o instanceof dc&&Wl(n,o)&&(e.splice(t-1,2,new dc(o.data+n.data,o.getAttributes())),t--);}return e}function Ul(t,e){const n=t.getChild(e-1),o=t.getChild(e);if(n&&o&&n.is("$text")&&o.is("$text")&&Wl(n,o)){const i=new dc(n.data+o.data,n.getAttributes());t._removeChildren(e-1,2),t._insertChild(e-1,i);}}function Hl(t){const e=t.textNode,n=t.parent;if(e){const o=t.offset-e.startOffset,i=e.index;n._removeChildren(i,1);const r=new dc(e.data.substr(0,o),e.getAttributes()),s=new dc(e.data.substr(o),e.getAttributes());n._insertChild(i,[r,s]);}}function Wl(t,e){const n=t.getAttributes(),o=e.getAttributes();for(const t of n){if(t[1]!==e.getAttribute(t[0]))return !1;o.next();}return o.next().done}class Gl extends Ol{constructor(t,e,n,o){super(o),this.sourcePosition=t.clone(),this.sourcePosition.stickiness="toNext",this.howMany=e,this.targetPosition=n.clone(),this.targetPosition.stickiness="toNone";}get type(){return "$graveyard"==this.targetPosition.root.rootName?"remove":"$graveyard"==this.sourcePosition.root.rootName?"reinsert":"move"}clone(){return new Gl(this.sourcePosition,this.howMany,this.targetPosition,this.baseVersion)}getMovedRangeStart(){return this.targetPosition._getTransformedByDeletion(this.sourcePosition,this.howMany)}getReversed(){const t=this.sourcePosition._getTransformedByInsertion(this.targetPosition,this.howMany);return new Gl(this.getMovedRangeStart(),this.howMany,t,this.baseVersion+1)}_validate(){const t=this.sourcePosition.parent,e=this.targetPosition.parent,n=this.sourcePosition.offset,o=this.targetPosition.offset;if(n+this.howMany>t.maxOffset)throw new k("move-operation-nodes-do-not-exist",this);if(t===e&&n<o&&o<n+this.howMany)throw new k("move-operation-range-into-itself",this);if(this.sourcePosition.root==this.targetPosition.root&&"prefix"==Q(this.sourcePosition.getParentPath(),this.targetPosition.getParentPath())){const t=this.sourcePosition.path.length-1;if(this.targetPosition.path[t]>=n&&this.targetPosition.path[t]<n+this.howMany)throw new k("move-operation-node-into-itself",this)}}_execute(){Fl(Ac._createFromPositionAndShift(this.sourcePosition,this.howMany),this.targetPosition);}toJSON(){const t=super.toJSON();return t.sourcePosition=this.sourcePosition.toJSON(),t.targetPosition=this.targetPosition.toJSON(),t}static get className(){return "MoveOperation"}static fromJSON(t,e){const n=pc.fromJSON(t.sourcePosition,e),o=pc.fromJSON(t.targetPosition,e);return new this(n,t.howMany,o,t.baseVersion)}}class ql extends Ol{constructor(t,e,n){super(n),this.position=t.clone(),this.position.stickiness="toNone",this.nodes=new lc(Vl(e)),this.shouldReceiveAttributes=!1;}get type(){return "insert"}get howMany(){return this.nodes.maxOffset}clone(){const t=new lc([...this.nodes].map((t=>t._clone(!0)))),e=new ql(this.position,t,this.baseVersion);return e.shouldReceiveAttributes=this.shouldReceiveAttributes,e}getReversed(){const t=this.position.root.document.graveyard,e=new pc(t,[0]);return new Gl(this.position,this.nodes.maxOffset,e,this.baseVersion+1)}_validate(){const t=this.position.parent;if(!t||t.maxOffset<this.position.offset)throw new k("insert-operation-position-invalid",this)}_execute(){const t=this.nodes;this.nodes=new lc([...t].map((t=>t._clone(!0)))),Rl(this.position,t);}toJSON(){const t=super.toJSON();return t.position=this.position.toJSON(),t.nodes=this.nodes.toJSON(),t}static get className(){return "InsertOperation"}static fromJSON(t,e){const n=[];for(const e of t.nodes)e.name?n.push(uc.fromJSON(e)):n.push(dc.fromJSON(e));const o=new ql(pc.fromJSON(t.position,e),n,t.baseVersion);return o.shouldReceiveAttributes=t.shouldReceiveAttributes,o}}class Yl extends Ol{constructor(t,e,n,o,i,r){super(r),this.name=t,this.oldRange=e?e.clone():null,this.newRange=n?n.clone():null,this.affectsData=i,this._markers=o;}get type(){return "marker"}clone(){return new Yl(this.name,this.oldRange,this.newRange,this._markers,this.affectsData,this.baseVersion)}getReversed(){return new Yl(this.name,this.newRange,this.oldRange,this._markers,this.affectsData,this.baseVersion+1)}_execute(){this.newRange?this._markers._set(this.name,this.newRange,!0,this.affectsData):this._markers._remove(this.name);}toJSON(){const t=super.toJSON();return this.oldRange&&(t.oldRange=this.oldRange.toJSON()),this.newRange&&(t.newRange=this.newRange.toJSON()),delete t._markers,t}static get className(){return "MarkerOperation"}static fromJSON(t,e){return new Yl(t.name,t.oldRange?Ac.fromJSON(t.oldRange,e):null,t.newRange?Ac.fromJSON(t.newRange,e):null,e.model.markers,t.affectsData,t.baseVersion)}}const $l=function(t,e){return Ka(t,e)};class Kl extends Ol{constructor(t,e,n,o,i){super(i),this.range=t.clone(),this.key=e,this.oldValue=void 0===n?null:n,this.newValue=void 0===o?null:o;}get type(){return null===this.oldValue?"addAttribute":null===this.newValue?"removeAttribute":"changeAttribute"}clone(){return new Kl(this.range,this.key,this.oldValue,this.newValue,this.baseVersion)}getReversed(){return new Kl(this.range,this.key,this.newValue,this.oldValue,this.baseVersion+1)}toJSON(){const t=super.toJSON();return t.range=this.range.toJSON(),t}_validate(){if(!this.range.isFlat)throw new k("attribute-operation-range-not-flat",this);for(const t of this.range.getItems({shallow:!0})){if(null!==this.oldValue&&!$l(t.getAttribute(this.key),this.oldValue))throw new k("attribute-operation-wrong-old-value",this,{item:t,key:this.key,value:this.oldValue});if(null===this.oldValue&&null!==this.newValue&&t.hasAttribute(this.key))throw new k("attribute-operation-attribute-exists",this,{node:t,key:this.key})}}_execute(){$l(this.oldValue,this.newValue)||function(t,e,n){Hl(t.start),Hl(t.end);for(const o of t.getItems({shallow:!0})){const t=o.is("$textProxy")?o.textNode:o;null!==n?t._setAttribute(e,n):t._removeAttribute(e),Ul(t.parent,t.index);}Ul(t.end.parent,t.end.index);}(this.range,this.key,this.newValue);}static get className(){return "AttributeOperation"}static fromJSON(t,e){return new Kl(Ac.fromJSON(t.range,e),t.key,t.oldValue,t.newValue,t.baseVersion)}}class Ql extends Ol{get type(){return "noop"}clone(){return new Ql(this.baseVersion)}getReversed(){return new Ql(this.baseVersion+1)}_execute(){}static get className(){return "NoOperation"}}class Zl extends Ol{constructor(t,e,n,o){super(o),this.position=t,this.position.stickiness="toNext",this.oldName=e,this.newName=n;}get type(){return "rename"}clone(){return new Zl(this.position.clone(),this.oldName,this.newName,this.baseVersion)}getReversed(){return new Zl(this.position.clone(),this.newName,this.oldName,this.baseVersion+1)}_validate(){const t=this.position.nodeAfter;if(!(t instanceof uc))throw new k("rename-operation-wrong-position",this);if(t.name!==this.oldName)throw new k("rename-operation-wrong-name",this)}_execute(){this.position.nodeAfter.name=this.newName;}toJSON(){const t=super.toJSON();return t.position=this.position.toJSON(),t}static get className(){return "RenameOperation"}static fromJSON(t,e){return new Zl(pc.fromJSON(t.position,e),t.oldName,t.newName,t.baseVersion)}}class Jl extends Ol{constructor(t,e,n,o,i){super(i),this.root=t,this.key=e,this.oldValue=n,this.newValue=o;}get type(){return null===this.oldValue?"addRootAttribute":null===this.newValue?"removeRootAttribute":"changeRootAttribute"}clone(){return new Jl(this.root,this.key,this.oldValue,this.newValue,this.baseVersion)}getReversed(){return new Jl(this.root,this.key,this.newValue,this.oldValue,this.baseVersion+1)}_validate(){if(this.root!=this.root.root||this.root.is("documentFragment"))throw new k("rootattribute-operation-not-a-root",this,{root:this.root,key:this.key});if(null!==this.oldValue&&this.root.getAttribute(this.key)!==this.oldValue)throw new k("rootattribute-operation-wrong-old-value",this,{root:this.root,key:this.key});if(null===this.oldValue&&null!==this.newValue&&this.root.hasAttribute(this.key))throw new k("rootattribute-operation-attribute-exists",this,{root:this.root,key:this.key})}_execute(){null!==this.newValue?this.root._setAttribute(this.key,this.newValue):this.root._removeAttribute(this.key);}toJSON(){const t=super.toJSON();return t.root=this.root.toJSON(),t}static get className(){return "RootAttributeOperation"}static fromJSON(t,e){if(!e.getRoot(t.root))throw new k("rootattribute-operation-fromjson-no-root",this,{rootName:t.root});return new Jl(e.getRoot(t.root),t.key,t.oldValue,t.newValue,t.baseVersion)}}class Xl extends Ol{constructor(t,e,n,o,i){super(i),this.sourcePosition=t.clone(),this.sourcePosition.stickiness="toPrevious",this.howMany=e,this.targetPosition=n.clone(),this.targetPosition.stickiness="toNext",this.graveyardPosition=o.clone();}get type(){return "merge"}get deletionPosition(){return new pc(this.sourcePosition.root,this.sourcePosition.path.slice(0,-1))}get movedRange(){const t=this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);return new Ac(this.sourcePosition,t)}clone(){return new Xl(this.sourcePosition,this.howMany,this.targetPosition,this.graveyardPosition,this.baseVersion)}getReversed(){const t=this.targetPosition._getTransformedByMergeOperation(this),e=this.sourcePosition.path.slice(0,-1),n=new pc(this.sourcePosition.root,e)._getTransformedByMergeOperation(this);return new td(t,this.howMany,n,this.graveyardPosition,this.baseVersion+1)}_validate(){const t=this.sourcePosition.parent,e=this.targetPosition.parent;if(!t.parent)throw new k("merge-operation-source-position-invalid",this);if(!e.parent)throw new k("merge-operation-target-position-invalid",this);if(this.howMany!=t.maxOffset)throw new k("merge-operation-how-many-invalid",this)}_execute(){const t=this.sourcePosition.parent;Fl(Ac._createIn(t),this.targetPosition),Fl(Ac._createOn(t),this.graveyardPosition);}toJSON(){const t=super.toJSON();return t.sourcePosition=t.sourcePosition.toJSON(),t.targetPosition=t.targetPosition.toJSON(),t.graveyardPosition=t.graveyardPosition.toJSON(),t}static get className(){return "MergeOperation"}static fromJSON(t,e){const n=pc.fromJSON(t.sourcePosition,e),o=pc.fromJSON(t.targetPosition,e),i=pc.fromJSON(t.graveyardPosition,e);return new this(n,t.howMany,o,i,t.baseVersion)}}class td extends Ol{constructor(t,e,n,o,i){super(i),this.splitPosition=t.clone(),this.splitPosition.stickiness="toNext",this.howMany=e,this.insertionPosition=n,this.graveyardPosition=o?o.clone():null,this.graveyardPosition&&(this.graveyardPosition.stickiness="toNext");}get type(){return "split"}get moveTargetPosition(){const t=this.insertionPosition.path.slice();return t.push(0),new pc(this.insertionPosition.root,t)}get movedRange(){const t=this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);return new Ac(this.splitPosition,t)}clone(){return new td(this.splitPosition,this.howMany,this.insertionPosition,this.graveyardPosition,this.baseVersion)}getReversed(){const t=this.splitPosition.root.document.graveyard,e=new pc(t,[0]);return new Xl(this.moveTargetPosition,this.howMany,this.splitPosition,e,this.baseVersion+1)}_validate(){const t=this.splitPosition.parent,e=this.splitPosition.offset;if(!t||t.maxOffset<e)throw new k("split-operation-position-invalid",this);if(!t.parent)throw new k("split-operation-split-in-root",this);if(this.howMany!=t.maxOffset-this.splitPosition.offset)throw new k("split-operation-how-many-invalid",this);if(this.graveyardPosition&&!this.graveyardPosition.nodeAfter)throw new k("split-operation-graveyard-position-invalid",this)}_execute(){const t=this.splitPosition.parent;if(this.graveyardPosition)Fl(Ac._createFromPositionAndShift(this.graveyardPosition,1),this.insertionPosition);else {const e=t._clone();Rl(this.insertionPosition,e);}Fl(new Ac(pc._createAt(t,this.splitPosition.offset),pc._createAt(t,t.maxOffset)),this.moveTargetPosition);}toJSON(){const t=super.toJSON();return t.splitPosition=this.splitPosition.toJSON(),t.insertionPosition=this.insertionPosition.toJSON(),this.graveyardPosition&&(t.graveyardPosition=this.graveyardPosition.toJSON()),t}static get className(){return "SplitOperation"}static getInsertionPosition(t){const e=t.path.slice(0,-1);return e[e.length-1]++,new pc(t.root,e,"toPrevious")}static fromJSON(t,e){const n=pc.fromJSON(t.splitPosition,e),o=pc.fromJSON(t.insertionPosition,e),i=t.graveyardPosition?pc.fromJSON(t.graveyardPosition,e):null;return new this(n,t.howMany,o,i,t.baseVersion)}}const ed={};ed[Kl.className]=Kl,ed[ql.className]=ql,ed[Yl.className]=Yl,ed[Gl.className]=Gl,ed[Ql.className]=Ql,ed[Ol.className]=Ol,ed[Zl.className]=Zl,ed[Jl.className]=Jl,ed[td.className]=td,ed[Xl.className]=Xl;class nd{static fromJSON(t,e){return ed[t.__className].fromJSON(t,e)}}const od=new Map;function id(t,e,n){let o=od.get(t);o||(o=new Map,od.set(t,o)),o.set(e,n);}function rd(t){return [t]}function sd(t,e,n={}){const o=function(t,e){const n=od.get(t);return n&&n.has(e)?n.get(e):rd}(t.constructor,e.constructor);try{return o(t=t.clone(),e,n)}catch(t){throw t}}function ad(t,e,n){t=t.slice(),e=e.slice();const o=new cd(n.document,n.useRelations,n.forceWeakRemove);o.setOriginalOperations(t),o.setOriginalOperations(e);const i=o.originalOperations;if(0==t.length||0==e.length)return {operationsA:t,operationsB:e,originalOperations:i};const r=new WeakMap;for(const e of t)r.set(e,0);const s={nextBaseVersionA:t[t.length-1].baseVersion+1,nextBaseVersionB:e[e.length-1].baseVersion+1,originalOperationsACount:t.length,originalOperationsBCount:e.length};let a=0;for(;a<t.length;){const n=t[a],i=r.get(n);if(i==e.length){a++;continue}const s=e[i],c=sd(n,s,o.getContext(n,s,!0)),l=sd(s,n,o.getContext(s,n,!1));o.updateRelation(n,s),o.setOriginalOperations(c,n),o.setOriginalOperations(l,s);for(const t of c)r.set(t,i+l.length);t.splice(a,1,...c),e.splice(i,1,...l);}if(n.padWithNoOps){const n=t.length-s.originalOperationsACount,o=e.length-s.originalOperationsBCount;dd(t,o-n),dd(e,n-o);}return ld(t,s.nextBaseVersionB),ld(e,s.nextBaseVersionA),{operationsA:t,operationsB:e,originalOperations:i}}class cd{constructor(t,e,n=!1){this.originalOperations=new Map,this._history=t.history,this._useRelations=e,this._forceWeakRemove=!!n,this._relations=new Map;}setOriginalOperations(t,e=null){const n=e?this.originalOperations.get(e):null;for(const e of t)this.originalOperations.set(e,n||e);}updateRelation(t,e){if(t instanceof Gl)e instanceof Xl?t.targetPosition.isEqual(e.sourcePosition)||e.movedRange.containsPosition(t.targetPosition)?this._setRelation(t,e,"insertAtSource"):t.targetPosition.isEqual(e.deletionPosition)?this._setRelation(t,e,"insertBetween"):t.targetPosition.isAfter(e.sourcePosition)&&this._setRelation(t,e,"moveTargetAfter"):e instanceof Gl&&(t.targetPosition.isEqual(e.sourcePosition)||t.targetPosition.isBefore(e.sourcePosition)?this._setRelation(t,e,"insertBefore"):this._setRelation(t,e,"insertAfter"));else if(t instanceof td){if(e instanceof Xl)t.splitPosition.isBefore(e.sourcePosition)&&this._setRelation(t,e,"splitBefore");else if(e instanceof Gl)if(t.splitPosition.isEqual(e.sourcePosition)||t.splitPosition.isBefore(e.sourcePosition))this._setRelation(t,e,"splitBefore");else {const n=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany);if(t.splitPosition.hasSameParentAs(e.sourcePosition)&&n.containsPosition(t.splitPosition)){const o=n.end.offset-t.splitPosition.offset,i=t.splitPosition.offset-n.start.offset;this._setRelation(t,e,{howMany:o,offset:i});}}}else if(t instanceof Xl)e instanceof Xl?(t.targetPosition.isEqual(e.sourcePosition)||this._setRelation(t,e,"mergeTargetNotMoved"),t.sourcePosition.isEqual(e.targetPosition)&&this._setRelation(t,e,"mergeSourceNotMoved"),t.sourcePosition.isEqual(e.sourcePosition)&&this._setRelation(t,e,"mergeSameElement")):e instanceof td&&t.sourcePosition.isEqual(e.splitPosition)&&this._setRelation(t,e,"splitAtSource");else if(t instanceof Yl){const n=t.newRange;if(!n)return;if(e instanceof Gl){const o=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany),i=o.containsPosition(n.start)||o.start.isEqual(n.start),r=o.containsPosition(n.end)||o.end.isEqual(n.end);!i&&!r||o.containsRange(n)||this._setRelation(t,e,{side:i?"left":"right",path:i?n.start.path.slice():n.end.path.slice()});}else if(e instanceof Xl){const o=n.start.isEqual(e.targetPosition),i=n.start.isEqual(e.deletionPosition),r=n.end.isEqual(e.deletionPosition),s=n.end.isEqual(e.sourcePosition);(o||i||r||s)&&this._setRelation(t,e,{wasInLeftElement:o,wasStartBeforeMergedElement:i,wasEndBeforeMergedElement:r,wasInRightElement:s});}}}getContext(t,e,n){return {aIsStrong:n,aWasUndone:this._wasUndone(t),bWasUndone:this._wasUndone(e),abRelation:this._useRelations?this._getRelation(t,e):null,baRelation:this._useRelations?this._getRelation(e,t):null,forceWeakRemove:this._forceWeakRemove}}_wasUndone(t){const e=this.originalOperations.get(t);return e.wasUndone||this._history.isUndoneOperation(e)}_getRelation(t,e){const n=this.originalOperations.get(e),o=this._history.getUndoneOperation(n);if(!o)return null;const i=this.originalOperations.get(t),r=this._relations.get(i);return r&&r.get(o)||null}_setRelation(t,e,n){const o=this.originalOperations.get(t),i=this.originalOperations.get(e);let r=this._relations.get(o);r||(r=new Map,this._relations.set(o,r)),r.set(i,n);}}function ld(t,e){for(const n of t)n.baseVersion=e++;}function dd(t,e){for(let n=0;n<e;n++)t.push(new Ql(0));}function hd(t,e,n){const o=t.nodes.getNode(0).getAttribute(e);if(o==n)return null;const i=new Ac(t.position,t.position.getShiftedBy(t.howMany));return new Kl(i,e,o,n,0)}function ud(t,e){return null===t.targetPosition._getTransformedByDeletion(e.sourcePosition,e.howMany)}function gd(t,e){const n=[];for(let o=0;o<t.length;o++){const i=t[o],r=new Gl(i.start,i.end.offset-i.start.offset,e,0);n.push(r);for(let e=o+1;e<t.length;e++)t[e]=t[e]._getTransformedByMove(r.sourcePosition,r.targetPosition,r.howMany)[0];e=e._getTransformedByMove(r.sourcePosition,r.targetPosition,r.howMany);}return n}id(Kl,Kl,((t,e,n)=>{if(t.key===e.key&&t.range.start.hasSameParentAs(e.range.start)){const o=t.range.getDifference(e.range).map((e=>new Kl(e,t.key,t.oldValue,t.newValue,0))),i=t.range.getIntersection(e.range);return i&&n.aIsStrong&&o.push(new Kl(i,e.key,e.newValue,t.newValue,0)),0==o.length?[new Ql(0)]:o}return [t]})),id(Kl,ql,((t,e)=>{if(t.range.start.hasSameParentAs(e.position)&&t.range.containsPosition(e.position)){const n=t.range._getTransformedByInsertion(e.position,e.howMany,!e.shouldReceiveAttributes).map((e=>new Kl(e,t.key,t.oldValue,t.newValue,t.baseVersion)));if(e.shouldReceiveAttributes){const o=hd(e,t.key,t.oldValue);o&&n.unshift(o);}return n}return t.range=t.range._getTransformedByInsertion(e.position,e.howMany,!1)[0],[t]})),id(Kl,Xl,((t,e)=>{const n=[];t.range.start.hasSameParentAs(e.deletionPosition)&&(t.range.containsPosition(e.deletionPosition)||t.range.start.isEqual(e.deletionPosition))&&n.push(Ac._createFromPositionAndShift(e.graveyardPosition,1));const o=t.range._getTransformedByMergeOperation(e);return o.isCollapsed||n.push(o),n.map((e=>new Kl(e,t.key,t.oldValue,t.newValue,t.baseVersion)))})),id(Kl,Gl,((t,e)=>{const n=function(t,e){const n=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany);let o=null,i=[];n.containsRange(t,!0)?o=t:t.start.hasSameParentAs(n.start)?(i=t.getDifference(n),o=t.getIntersection(n)):i=[t];const r=[];for(let t of i){t=t._getTransformedByDeletion(e.sourcePosition,e.howMany);const n=e.getMovedRangeStart(),o=t.start.hasSameParentAs(n),i=t._getTransformedByInsertion(n,e.howMany,o);r.push(...i);}o&&r.push(o._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany,!1)[0]);return r}(t.range,e);return n.map((e=>new Kl(e,t.key,t.oldValue,t.newValue,t.baseVersion)))})),id(Kl,td,((t,e)=>{if(t.range.end.isEqual(e.insertionPosition))return e.graveyardPosition||t.range.end.offset++,[t];if(t.range.start.hasSameParentAs(e.splitPosition)&&t.range.containsPosition(e.splitPosition)){const n=t.clone();return n.range=new Ac(e.moveTargetPosition.clone(),t.range.end._getCombined(e.splitPosition,e.moveTargetPosition)),t.range.end=e.splitPosition.clone(),t.range.end.stickiness="toPrevious",[t,n]}return t.range=t.range._getTransformedBySplitOperation(e),[t]})),id(ql,Kl,((t,e)=>{const n=[t];if(t.shouldReceiveAttributes&&t.position.hasSameParentAs(e.range.start)&&e.range.containsPosition(t.position)){const o=hd(t,e.key,e.newValue);o&&n.push(o);}return n})),id(ql,ql,((t,e,n)=>(t.position.isEqual(e.position)&&n.aIsStrong||(t.position=t.position._getTransformedByInsertOperation(e)),[t]))),id(ql,Gl,((t,e)=>(t.position=t.position._getTransformedByMoveOperation(e),[t]))),id(ql,td,((t,e)=>(t.position=t.position._getTransformedBySplitOperation(e),[t]))),id(ql,Xl,((t,e)=>(t.position=t.position._getTransformedByMergeOperation(e),[t]))),id(Yl,ql,((t,e)=>(t.oldRange&&(t.oldRange=t.oldRange._getTransformedByInsertOperation(e)[0]),t.newRange&&(t.newRange=t.newRange._getTransformedByInsertOperation(e)[0]),[t]))),id(Yl,Yl,((t,e,n)=>{if(t.name==e.name){if(!n.aIsStrong)return [new Ql(0)];t.oldRange=e.newRange?e.newRange.clone():null;}return [t]})),id(Yl,Xl,((t,e)=>(t.oldRange&&(t.oldRange=t.oldRange._getTransformedByMergeOperation(e)),t.newRange&&(t.newRange=t.newRange._getTransformedByMergeOperation(e)),[t]))),id(Yl,Gl,((t,e,n)=>{if(t.oldRange&&(t.oldRange=Ac._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))),t.newRange){if(n.abRelation){const o=Ac._createFromRanges(t.newRange._getTransformedByMoveOperation(e));if("left"==n.abRelation.side&&e.targetPosition.isEqual(t.newRange.start))return t.newRange.end=o.end,t.newRange.start.path=n.abRelation.path,[t];if("right"==n.abRelation.side&&e.targetPosition.isEqual(t.newRange.end))return t.newRange.start=o.start,t.newRange.end.path=n.abRelation.path,[t]}t.newRange=Ac._createFromRanges(t.newRange._getTransformedByMoveOperation(e));}return [t]})),id(Yl,td,((t,e,n)=>{if(t.oldRange&&(t.oldRange=t.oldRange._getTransformedBySplitOperation(e)),t.newRange){if(n.abRelation){const o=t.newRange._getTransformedBySplitOperation(e);return t.newRange.start.isEqual(e.splitPosition)&&n.abRelation.wasStartBeforeMergedElement?t.newRange.start=pc._createAt(e.insertionPosition):t.newRange.start.isEqual(e.splitPosition)&&!n.abRelation.wasInLeftElement&&(t.newRange.start=pc._createAt(e.moveTargetPosition)),t.newRange.end.isEqual(e.splitPosition)&&n.abRelation.wasInRightElement?t.newRange.end=pc._createAt(e.moveTargetPosition):t.newRange.end.isEqual(e.splitPosition)&&n.abRelation.wasEndBeforeMergedElement?t.newRange.end=pc._createAt(e.insertionPosition):t.newRange.end=o.end,[t]}t.newRange=t.newRange._getTransformedBySplitOperation(e);}return [t]})),id(Xl,ql,((t,e)=>(t.sourcePosition.hasSameParentAs(e.position)&&(t.howMany+=e.howMany),t.sourcePosition=t.sourcePosition._getTransformedByInsertOperation(e),t.targetPosition=t.targetPosition._getTransformedByInsertOperation(e),[t]))),id(Xl,Xl,((t,e,n)=>{if(t.sourcePosition.isEqual(e.sourcePosition)&&t.targetPosition.isEqual(e.targetPosition)){if(n.bWasUndone){const n=e.graveyardPosition.path.slice();return n.push(0),t.sourcePosition=new pc(e.graveyardPosition.root,n),t.howMany=0,[t]}return [new Ql(0)]}if(t.sourcePosition.isEqual(e.sourcePosition)&&!t.targetPosition.isEqual(e.targetPosition)&&!n.bWasUndone&&"splitAtSource"!=n.abRelation){const o="$graveyard"==t.targetPosition.root.rootName,i="$graveyard"==e.targetPosition.root.rootName;if(i&&!o||!(o&&!i)&&n.aIsStrong){const n=e.targetPosition._getTransformedByMergeOperation(e),o=t.targetPosition._getTransformedByMergeOperation(e);return [new Gl(n,t.howMany,o,0)]}return [new Ql(0)]}return t.sourcePosition.hasSameParentAs(e.targetPosition)&&(t.howMany+=e.howMany),t.sourcePosition=t.sourcePosition._getTransformedByMergeOperation(e),t.targetPosition=t.targetPosition._getTransformedByMergeOperation(e),t.graveyardPosition.isEqual(e.graveyardPosition)&&n.aIsStrong||(t.graveyardPosition=t.graveyardPosition._getTransformedByMergeOperation(e)),[t]})),id(Xl,Gl,((t,e,n)=>{const o=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany);return "remove"==e.type&&!n.bWasUndone&&!n.forceWeakRemove&&t.deletionPosition.hasSameParentAs(e.sourcePosition)&&o.containsPosition(t.sourcePosition)?[new Ql(0)]:(t.sourcePosition.hasSameParentAs(e.targetPosition)&&(t.howMany+=e.howMany),t.sourcePosition.hasSameParentAs(e.sourcePosition)&&(t.howMany-=e.howMany),t.sourcePosition=t.sourcePosition._getTransformedByMoveOperation(e),t.targetPosition=t.targetPosition._getTransformedByMoveOperation(e),t.graveyardPosition.isEqual(e.targetPosition)||(t.graveyardPosition=t.graveyardPosition._getTransformedByMoveOperation(e)),[t])})),id(Xl,td,((t,e,n)=>{if(e.graveyardPosition&&(t.graveyardPosition=t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition,1),t.deletionPosition.isEqual(e.graveyardPosition)&&(t.howMany=e.howMany)),t.targetPosition.isEqual(e.splitPosition)){const o=0!=e.howMany,i=e.graveyardPosition&&t.deletionPosition.isEqual(e.graveyardPosition);if(o||i||"mergeTargetNotMoved"==n.abRelation)return t.sourcePosition=t.sourcePosition._getTransformedBySplitOperation(e),[t]}if(t.sourcePosition.isEqual(e.splitPosition)){if("mergeSourceNotMoved"==n.abRelation)return t.howMany=0,t.targetPosition=t.targetPosition._getTransformedBySplitOperation(e),[t];if("mergeSameElement"==n.abRelation||t.sourcePosition.offset>0)return t.sourcePosition=e.moveTargetPosition.clone(),t.targetPosition=t.targetPosition._getTransformedBySplitOperation(e),[t]}return t.sourcePosition.hasSameParentAs(e.splitPosition)&&(t.howMany=e.splitPosition.offset),t.sourcePosition=t.sourcePosition._getTransformedBySplitOperation(e),t.targetPosition=t.targetPosition._getTransformedBySplitOperation(e),[t]})),id(Gl,ql,((t,e)=>{const n=Ac._createFromPositionAndShift(t.sourcePosition,t.howMany)._getTransformedByInsertOperation(e,!1)[0];return t.sourcePosition=n.start,t.howMany=n.end.offset-n.start.offset,t.targetPosition.isEqual(e.position)||(t.targetPosition=t.targetPosition._getTransformedByInsertOperation(e)),[t]})),id(Gl,Gl,((t,e,n)=>{const o=Ac._createFromPositionAndShift(t.sourcePosition,t.howMany),i=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany);let r,s=n.aIsStrong,a=!n.aIsStrong;if("insertBefore"==n.abRelation||"insertAfter"==n.baRelation?a=!0:"insertAfter"!=n.abRelation&&"insertBefore"!=n.baRelation||(a=!1),r=t.targetPosition.isEqual(e.targetPosition)&&a?t.targetPosition._getTransformedByDeletion(e.sourcePosition,e.howMany):t.targetPosition._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany),ud(t,e)&&ud(e,t))return [e.getReversed()];if(o.containsPosition(e.targetPosition)&&o.containsRange(i,!0))return o.start=o.start._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany),o.end=o.end._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany),gd([o],r);if(i.containsPosition(t.targetPosition)&&i.containsRange(o,!0))return o.start=o.start._getCombined(e.sourcePosition,e.getMovedRangeStart()),o.end=o.end._getCombined(e.sourcePosition,e.getMovedRangeStart()),gd([o],r);const c=Q(t.sourcePosition.getParentPath(),e.sourcePosition.getParentPath());if("prefix"==c||"extension"==c)return o.start=o.start._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany),o.end=o.end._getTransformedByMove(e.sourcePosition,e.targetPosition,e.howMany),gd([o],r);"remove"!=t.type||"remove"==e.type||n.aWasUndone||n.forceWeakRemove?"remove"==t.type||"remove"!=e.type||n.bWasUndone||n.forceWeakRemove||(s=!1):s=!0;const l=[],d=o.getDifference(i);for(const t of d){t.start=t.start._getTransformedByDeletion(e.sourcePosition,e.howMany),t.end=t.end._getTransformedByDeletion(e.sourcePosition,e.howMany);const n="same"==Q(t.start.getParentPath(),e.getMovedRangeStart().getParentPath()),o=t._getTransformedByInsertion(e.getMovedRangeStart(),e.howMany,n);l.push(...o);}const h=o.getIntersection(i);return null!==h&&s&&(h.start=h.start._getCombined(e.sourcePosition,e.getMovedRangeStart()),h.end=h.end._getCombined(e.sourcePosition,e.getMovedRangeStart()),0===l.length?l.push(h):1==l.length?i.start.isBefore(o.start)||i.start.isEqual(o.start)?l.unshift(h):l.push(h):l.splice(1,0,h)),0===l.length?[new Ql(t.baseVersion)]:gd(l,r)})),id(Gl,td,((t,e,n)=>{let o=t.targetPosition.clone();t.targetPosition.isEqual(e.insertionPosition)&&e.graveyardPosition&&"moveTargetAfter"!=n.abRelation||(o=t.targetPosition._getTransformedBySplitOperation(e));const i=Ac._createFromPositionAndShift(t.sourcePosition,t.howMany);if(i.end.isEqual(e.insertionPosition))return e.graveyardPosition||t.howMany++,t.targetPosition=o,[t];if(i.start.hasSameParentAs(e.splitPosition)&&i.containsPosition(e.splitPosition)){let t=new Ac(e.splitPosition,i.end);t=t._getTransformedBySplitOperation(e);return gd([new Ac(i.start,e.splitPosition),t],o)}t.targetPosition.isEqual(e.splitPosition)&&"insertAtSource"==n.abRelation&&(o=e.moveTargetPosition),t.targetPosition.isEqual(e.insertionPosition)&&"insertBetween"==n.abRelation&&(o=t.targetPosition);const r=[i._getTransformedBySplitOperation(e)];if(e.graveyardPosition){const o=i.start.isEqual(e.graveyardPosition)||i.containsPosition(e.graveyardPosition);t.howMany>1&&o&&!n.aWasUndone&&r.push(Ac._createFromPositionAndShift(e.insertionPosition,1));}return gd(r,o)})),id(Gl,Xl,((t,e,n)=>{const o=Ac._createFromPositionAndShift(t.sourcePosition,t.howMany);if(e.deletionPosition.hasSameParentAs(t.sourcePosition)&&o.containsPosition(e.sourcePosition))if("remove"!=t.type||n.forceWeakRemove){if(1==t.howMany)return n.bWasUndone?(t.sourcePosition=e.graveyardPosition.clone(),t.targetPosition=t.targetPosition._getTransformedByMergeOperation(e),[t]):[new Ql(0)]}else if(!n.aWasUndone){const n=[];let o=e.graveyardPosition.clone(),i=e.targetPosition._getTransformedByMergeOperation(e);t.howMany>1&&(n.push(new Gl(t.sourcePosition,t.howMany-1,t.targetPosition,0)),o=o._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany-1),i=i._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany-1));const r=e.deletionPosition._getCombined(t.sourcePosition,t.targetPosition),s=new Gl(o,1,r,0),a=s.getMovedRangeStart().path.slice();a.push(0);const c=new pc(s.targetPosition.root,a);i=i._getTransformedByMove(o,r,1);const l=new Gl(i,e.howMany,c,0);return n.push(s),n.push(l),n}const i=Ac._createFromPositionAndShift(t.sourcePosition,t.howMany)._getTransformedByMergeOperation(e);return t.sourcePosition=i.start,t.howMany=i.end.offset-i.start.offset,t.targetPosition=t.targetPosition._getTransformedByMergeOperation(e),[t]})),id(Zl,ql,((t,e)=>(t.position=t.position._getTransformedByInsertOperation(e),[t]))),id(Zl,Xl,((t,e)=>t.position.isEqual(e.deletionPosition)?(t.position=e.graveyardPosition.clone(),t.position.stickiness="toNext",[t]):(t.position=t.position._getTransformedByMergeOperation(e),[t]))),id(Zl,Gl,((t,e)=>(t.position=t.position._getTransformedByMoveOperation(e),[t]))),id(Zl,Zl,((t,e,n)=>{if(t.position.isEqual(e.position)){if(!n.aIsStrong)return [new Ql(0)];t.oldName=e.newName;}return [t]})),id(Zl,td,((t,e)=>{if("same"==Q(t.position.path,e.splitPosition.getParentPath())&&!e.graveyardPosition){const e=new Zl(t.position.getShiftedBy(1),t.oldName,t.newName,0);return [t,e]}return t.position=t.position._getTransformedBySplitOperation(e),[t]})),id(Jl,Jl,((t,e,n)=>{if(t.root===e.root&&t.key===e.key){if(!n.aIsStrong||t.newValue===e.newValue)return [new Ql(0)];t.oldValue=e.newValue;}return [t]})),id(td,ql,((t,e)=>(t.splitPosition.hasSameParentAs(e.position)&&t.splitPosition.offset<e.position.offset&&(t.howMany+=e.howMany),t.splitPosition=t.splitPosition._getTransformedByInsertOperation(e),t.insertionPosition=t.insertionPosition._getTransformedByInsertOperation(e),[t]))),id(td,Xl,((t,e,n)=>{if(!t.graveyardPosition&&!n.bWasUndone&&t.splitPosition.hasSameParentAs(e.sourcePosition)){const n=e.graveyardPosition.path.slice();n.push(0);const o=new pc(e.graveyardPosition.root,n),i=td.getInsertionPosition(new pc(e.graveyardPosition.root,n)),r=new td(o,0,i,null,0);return t.splitPosition=t.splitPosition._getTransformedByMergeOperation(e),t.insertionPosition=td.getInsertionPosition(t.splitPosition),t.graveyardPosition=r.insertionPosition.clone(),t.graveyardPosition.stickiness="toNext",[r,t]}return t.splitPosition.hasSameParentAs(e.deletionPosition)&&!t.splitPosition.isAfter(e.deletionPosition)&&t.howMany--,t.splitPosition.hasSameParentAs(e.targetPosition)&&(t.howMany+=e.howMany),t.splitPosition=t.splitPosition._getTransformedByMergeOperation(e),t.insertionPosition=td.getInsertionPosition(t.splitPosition),t.graveyardPosition&&(t.graveyardPosition=t.graveyardPosition._getTransformedByMergeOperation(e)),[t]})),id(td,Gl,((t,e,n)=>{const o=Ac._createFromPositionAndShift(e.sourcePosition,e.howMany);if(t.graveyardPosition){const i=o.start.isEqual(t.graveyardPosition)||o.containsPosition(t.graveyardPosition);if(!n.bWasUndone&&i){const n=t.splitPosition._getTransformedByMoveOperation(e),o=t.graveyardPosition._getTransformedByMoveOperation(e),i=o.path.slice();i.push(0);const r=new pc(o.root,i);return [new Gl(n,t.howMany,r,0)]}t.graveyardPosition=t.graveyardPosition._getTransformedByMoveOperation(e);}const i=t.splitPosition.isEqual(e.targetPosition);if(i&&("insertAtSource"==n.baRelation||"splitBefore"==n.abRelation))return t.howMany+=e.howMany,t.splitPosition=t.splitPosition._getTransformedByDeletion(e.sourcePosition,e.howMany),t.insertionPosition=td.getInsertionPosition(t.splitPosition),[t];if(i&&n.abRelation&&n.abRelation.howMany){const{howMany:e,offset:o}=n.abRelation;return t.howMany+=e,t.splitPosition=t.splitPosition.getShiftedBy(o),[t]}if(t.splitPosition.hasSameParentAs(e.sourcePosition)&&o.containsPosition(t.splitPosition)){const n=e.howMany-(t.splitPosition.offset-e.sourcePosition.offset);return t.howMany-=n,t.splitPosition.hasSameParentAs(e.targetPosition)&&t.splitPosition.offset<e.targetPosition.offset&&(t.howMany+=e.howMany),t.splitPosition=e.sourcePosition.clone(),t.insertionPosition=td.getInsertionPosition(t.splitPosition),[t]}return e.sourcePosition.isEqual(e.targetPosition)||(t.splitPosition.hasSameParentAs(e.sourcePosition)&&t.splitPosition.offset<=e.sourcePosition.offset&&(t.howMany-=e.howMany),t.splitPosition.hasSameParentAs(e.targetPosition)&&t.splitPosition.offset<e.targetPosition.offset&&(t.howMany+=e.howMany)),t.splitPosition.stickiness="toNone",t.splitPosition=t.splitPosition._getTransformedByMoveOperation(e),t.splitPosition.stickiness="toNext",t.graveyardPosition?t.insertionPosition=t.insertionPosition._getTransformedByMoveOperation(e):t.insertionPosition=td.getInsertionPosition(t.splitPosition),[t]})),id(td,td,((t,e,n)=>{if(t.splitPosition.isEqual(e.splitPosition)){if(!t.graveyardPosition&&!e.graveyardPosition)return [new Ql(0)];if(t.graveyardPosition&&e.graveyardPosition&&t.graveyardPosition.isEqual(e.graveyardPosition))return [new Ql(0)];if("splitBefore"==n.abRelation)return t.howMany=0,t.graveyardPosition=t.graveyardPosition._getTransformedBySplitOperation(e),[t]}if(t.graveyardPosition&&e.graveyardPosition&&t.graveyardPosition.isEqual(e.graveyardPosition)){const o="$graveyard"==t.splitPosition.root.rootName,i="$graveyard"==e.splitPosition.root.rootName;if(i&&!o||!(o&&!i)&&n.aIsStrong){const n=[];return e.howMany&&n.push(new Gl(e.moveTargetPosition,e.howMany,e.splitPosition,0)),t.howMany&&n.push(new Gl(t.splitPosition,t.howMany,t.moveTargetPosition,0)),n}return [new Ql(0)]}if(t.graveyardPosition&&(t.graveyardPosition=t.graveyardPosition._getTransformedBySplitOperation(e)),t.splitPosition.isEqual(e.insertionPosition)&&"splitBefore"==n.abRelation)return t.howMany++,[t];if(e.splitPosition.isEqual(t.insertionPosition)&&"splitBefore"==n.baRelation){const n=e.insertionPosition.path.slice();n.push(0);const o=new pc(e.insertionPosition.root,n);return [t,new Gl(t.insertionPosition,1,o,0)]}return t.splitPosition.hasSameParentAs(e.splitPosition)&&t.splitPosition.offset<e.splitPosition.offset&&(t.howMany-=e.howMany),t.splitPosition=t.splitPosition._getTransformedBySplitOperation(e),t.insertionPosition=td.getInsertionPosition(t.splitPosition),[t]}));class md extends(I(pc)){constructor(t,e,n="toNone"){if(super(t,e,n),!this.root.is("rootElement"))throw new k("model-liveposition-root-not-rootelement",t);pd.call(this);}detach(){this.stopListening();}toPosition(){return new pc(this.root,this.path.slice(),this.stickiness)}static fromPosition(t,e){return new this(t.root,t.path.slice(),e||t.stickiness)}}function pd(){this.listenTo(this.root.document.model,"applyOperation",((t,e)=>{const n=e[0];n.isDocumentOperation&&fd.call(this,n);}),{priority:"low"});}function fd(t){const e=this.getTransformedByOperation(t);if(!this.isEqual(e)){const t=this.toPosition();this.path=e.path,this.root=e.root,this.fire("change",t);}}md.prototype.is=function(t){return "livePosition"===t||"model:livePosition"===t||"position"==t||"model:position"===t};class kd{constructor(t={}){"string"==typeof t&&(t="transparent"===t?{isUndoable:!1}:{},b("batch-constructor-deprecated-string-type"));const{isUndoable:e=!0,isLocal:n=!0,isUndo:o=!1,isTyping:i=!1}=t;this.operations=[],this.isUndoable=e,this.isLocal=n,this.isUndo=o,this.isTyping=i;}get type(){return b("batch-type-deprecated"),"default"}get baseVersion(){for(const t of this.operations)if(null!==t.baseVersion)return t.baseVersion;return null}addOperation(t){return t.batch=this,this.operations.push(t),t}}class bd{constructor(t){this._markerCollection=t,this._changesInElement=new Map,this._elementSnapshots=new Map,this._changedMarkers=new Map,this._changeCount=0,this._cachedChanges=null,this._cachedChangesWithGraveyard=null,this._refreshedItems=new Set;}get isEmpty(){return 0==this._changesInElement.size&&0==this._changedMarkers.size}bufferOperation(t){const e=t;switch(e.type){case"insert":if(this._isInInsertedElement(e.position.parent))return;this._markInsert(e.position.parent,e.position.offset,e.nodes.maxOffset);break;case"addAttribute":case"removeAttribute":case"changeAttribute":for(const t of e.range.getItems({shallow:!0}))this._isInInsertedElement(t.parent)||this._markAttribute(t);break;case"remove":case"move":case"reinsert":{if(e.sourcePosition.isEqual(e.targetPosition)||e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition))return;const t=this._isInInsertedElement(e.sourcePosition.parent),n=this._isInInsertedElement(e.targetPosition.parent);t||this._markRemove(e.sourcePosition.parent,e.sourcePosition.offset,e.howMany),n||this._markInsert(e.targetPosition.parent,e.getMovedRangeStart().offset,e.howMany);break}case"rename":{if(this._isInInsertedElement(e.position.parent))return;this._markRemove(e.position.parent,e.position.offset,1),this._markInsert(e.position.parent,e.position.offset,1);const t=Ac._createFromPositionAndShift(e.position,1);for(const e of this._markerCollection.getMarkersIntersectingRange(t)){const t=e.getData();this.bufferMarkerChange(e.name,t,t);}break}case"split":{const t=e.splitPosition.parent;this._isInInsertedElement(t)||this._markRemove(t,e.splitPosition.offset,e.howMany),this._isInInsertedElement(e.insertionPosition.parent)||this._markInsert(e.insertionPosition.parent,e.insertionPosition.offset,1),e.graveyardPosition&&this._markRemove(e.graveyardPosition.parent,e.graveyardPosition.offset,1);break}case"merge":{const t=e.sourcePosition.parent;this._isInInsertedElement(t.parent)||this._markRemove(t.parent,t.startOffset,1);const n=e.graveyardPosition.parent;this._markInsert(n,e.graveyardPosition.offset,1);const o=e.targetPosition.parent;this._isInInsertedElement(o)||this._markInsert(o,e.targetPosition.offset,t.maxOffset);break}}this._cachedChanges=null;}bufferMarkerChange(t,e,n){const o=this._changedMarkers.get(t);o?(o.newMarkerData=n,null==o.oldMarkerData.range&&null==n.range&&this._changedMarkers.delete(t)):this._changedMarkers.set(t,{newMarkerData:n,oldMarkerData:e});}getMarkersToRemove(){const t=[];for(const[e,n]of this._changedMarkers)null!=n.oldMarkerData.range&&t.push({name:e,range:n.oldMarkerData.range});return t}getMarkersToAdd(){const t=[];for(const[e,n]of this._changedMarkers)null!=n.newMarkerData.range&&t.push({name:e,range:n.newMarkerData.range});return t}getChangedMarkers(){return Array.from(this._changedMarkers).map((([t,e])=>({name:t,data:{oldRange:e.oldMarkerData.range,newRange:e.newMarkerData.range}})))}hasDataChanges(){if(this._changesInElement.size>0)return !0;for(const{newMarkerData:t,oldMarkerData:e}of this._changedMarkers.values()){if(t.affectsData!==e.affectsData)return !0;if(t.affectsData){const n=t.range&&!e.range,o=!t.range&&e.range,i=t.range&&e.range&&!t.range.isEqual(e.range);if(n||o||i)return !0}}return !1}getChanges(t={}){if(this._cachedChanges)return t.includeChangesInGraveyard?this._cachedChangesWithGraveyard.slice():this._cachedChanges.slice();let e=[];for(const t of this._changesInElement.keys()){const n=this._changesInElement.get(t).sort(((t,e)=>t.offset===e.offset?t.type!=e.type?"remove"==t.type?-1:1:0:t.offset<e.offset?-1:1)),o=this._elementSnapshots.get(t),i=wd(t.getChildren()),r=_d(o.length,n);let s=0,a=0;for(const n of r)if("i"===n)e.push(this._getInsertDiff(t,s,i[s])),s++;else if("r"===n)e.push(this._getRemoveDiff(t,s,o[a])),a++;else if("a"===n){const n=i[s].attributes,r=o[a].attributes;let c;if("$text"==i[s].name)c=new Ac(pc._createAt(t,s),pc._createAt(t,s+1));else {const e=t.offsetToIndex(s);c=new Ac(pc._createAt(t,s),pc._createAt(t.getChild(e),0));}e.push(...this._getAttributesDiff(c,r,n)),s++,a++;}else s++,a++;}e.sort(((t,e)=>t.position.root!=e.position.root?t.position.root.rootName<e.position.root.rootName?-1:1:t.position.isEqual(e.position)?t.changeCount-e.changeCount:t.position.isBefore(e.position)?-1:1));for(let t=1,n=0;t<e.length;t++){const o=e[n],i=e[t],r="remove"==o.type&&"remove"==i.type&&"$text"==o.name&&"$text"==i.name&&o.position.isEqual(i.position),s="insert"==o.type&&"insert"==i.type&&"$text"==o.name&&"$text"==i.name&&o.position.parent==i.position.parent&&o.position.offset+o.length==i.position.offset,a="attribute"==o.type&&"attribute"==i.type&&o.position.parent==i.position.parent&&o.range.isFlat&&i.range.isFlat&&o.position.offset+o.length==i.position.offset&&o.attributeKey==i.attributeKey&&o.attributeOldValue==i.attributeOldValue&&o.attributeNewValue==i.attributeNewValue;r||s||a?(o.length++,a&&(o.range.end=o.range.end.getShiftedBy(1)),e[t]=null):n=t;}e=e.filter((t=>t));for(const t of e)delete t.changeCount,"attribute"==t.type&&(delete t.position,delete t.length);return this._changeCount=0,this._cachedChangesWithGraveyard=e,this._cachedChanges=e.filter(Ad),t.includeChangesInGraveyard?this._cachedChangesWithGraveyard.slice():this._cachedChanges.slice()}getRefreshedItems(){return new Set(this._refreshedItems)}reset(){this._changesInElement.clear(),this._elementSnapshots.clear(),this._changedMarkers.clear(),this._refreshedItems=new Set,this._cachedChanges=null;}_refreshItem(t){if(this._isInInsertedElement(t.parent))return;this._markRemove(t.parent,t.startOffset,t.offsetSize),this._markInsert(t.parent,t.startOffset,t.offsetSize),this._refreshedItems.add(t);const e=Ac._createOn(t);for(const t of this._markerCollection.getMarkersIntersectingRange(e)){const e=t.getData();this.bufferMarkerChange(t.name,e,e);}this._cachedChanges=null;}_markInsert(t,e,n){const o={type:"insert",offset:e,howMany:n,count:this._changeCount++};this._markChange(t,o);}_markRemove(t,e,n){const o={type:"remove",offset:e,howMany:n,count:this._changeCount++};this._markChange(t,o),this._removeAllNestedChanges(t,e,n);}_markAttribute(t){const e={type:"attribute",offset:t.startOffset,howMany:t.offsetSize,count:this._changeCount++};this._markChange(t.parent,e);}_markChange(t,e){this._makeSnapshot(t);const n=this._getChangesForElement(t);this._handleChange(e,n),n.push(e);for(let t=0;t<n.length;t++)n[t].howMany<1&&(n.splice(t,1),t--);}_getChangesForElement(t){let e;return this._changesInElement.has(t)?e=this._changesInElement.get(t):(e=[],this._changesInElement.set(t,e)),e}_makeSnapshot(t){this._elementSnapshots.has(t)||this._elementSnapshots.set(t,wd(t.getChildren()));}_handleChange(t,e){t.nodesToHandle=t.howMany;for(const n of e){const o=t.offset+t.howMany,i=n.offset+n.howMany;if("insert"==t.type&&("insert"==n.type&&(t.offset<=n.offset?n.offset+=t.howMany:t.offset<i&&(n.howMany+=t.nodesToHandle,t.nodesToHandle=0)),"remove"==n.type&&t.offset<n.offset&&(n.offset+=t.howMany),"attribute"==n.type))if(t.offset<=n.offset)n.offset+=t.howMany;else if(t.offset<i){const i=n.howMany;n.howMany=t.offset-n.offset,e.unshift({type:"attribute",offset:o,howMany:i-n.howMany,count:this._changeCount++});}if("remove"==t.type){if("insert"==n.type)if(o<=n.offset)n.offset-=t.howMany;else if(o<=i)if(t.offset<n.offset){const e=o-n.offset;n.offset=t.offset,n.howMany-=e,t.nodesToHandle-=e;}else n.howMany-=t.nodesToHandle,t.nodesToHandle=0;else if(t.offset<=n.offset)t.nodesToHandle-=n.howMany,n.howMany=0;else if(t.offset<i){const e=i-t.offset;n.howMany-=e,t.nodesToHandle-=e;}if("remove"==n.type&&(o<=n.offset?n.offset-=t.howMany:t.offset<n.offset&&(t.nodesToHandle+=n.howMany,n.howMany=0)),"attribute"==n.type)if(o<=n.offset)n.offset-=t.howMany;else if(t.offset<n.offset){const e=o-n.offset;n.offset=t.offset,n.howMany-=e;}else if(t.offset<i)if(o<=i){const o=n.howMany;n.howMany=t.offset-n.offset;const i=o-n.howMany-t.nodesToHandle;e.unshift({type:"attribute",offset:t.offset,howMany:i,count:this._changeCount++});}else n.howMany-=i-t.offset;}if("attribute"==t.type){if("insert"==n.type)if(t.offset<n.offset&&o>n.offset){if(o>i){const t={type:"attribute",offset:i,howMany:o-i,count:this._changeCount++};this._handleChange(t,e),e.push(t);}t.nodesToHandle=n.offset-t.offset,t.howMany=t.nodesToHandle;}else t.offset>=n.offset&&t.offset<i&&(o>i?(t.nodesToHandle=o-i,t.offset=i):t.nodesToHandle=0);if("remove"==n.type&&t.offset<n.offset&&o>n.offset){const i={type:"attribute",offset:n.offset,howMany:o-n.offset,count:this._changeCount++};this._handleChange(i,e),e.push(i),t.nodesToHandle=n.offset-t.offset,t.howMany=t.nodesToHandle;}"attribute"==n.type&&(t.offset>=n.offset&&o<=i?(t.nodesToHandle=0,t.howMany=0,t.offset=0):t.offset<=n.offset&&o>=i&&(n.howMany=0));}}t.howMany=t.nodesToHandle,delete t.nodesToHandle;}_getInsertDiff(t,e,n){return {type:"insert",position:pc._createAt(t,e),name:n.name,attributes:new Map(n.attributes),length:1,changeCount:this._changeCount++}}_getRemoveDiff(t,e,n){return {type:"remove",position:pc._createAt(t,e),name:n.name,attributes:new Map(n.attributes),length:1,changeCount:this._changeCount++}}_getAttributesDiff(t,e,n){const o=[];n=new Map(n);for(const[i,r]of e){const e=n.has(i)?n.get(i):null;e!==r&&o.push({type:"attribute",position:t.start,range:t.clone(),length:1,attributeKey:i,attributeOldValue:r,attributeNewValue:e,changeCount:this._changeCount++}),n.delete(i);}for(const[e,i]of n)o.push({type:"attribute",position:t.start,range:t.clone(),length:1,attributeKey:e,attributeOldValue:null,attributeNewValue:i,changeCount:this._changeCount++});return o}_isInInsertedElement(t){const e=t.parent;if(!e)return !1;const n=this._changesInElement.get(e),o=t.startOffset;if(n)for(const t of n)if("insert"==t.type&&o>=t.offset&&o<t.offset+t.howMany)return !0;return this._isInInsertedElement(e)}_removeAllNestedChanges(t,e,n){const o=new Ac(pc._createAt(t,e),pc._createAt(t,e+n));for(const t of o.getItems({shallow:!0}))t.is("element")&&(this._elementSnapshots.delete(t),this._changesInElement.delete(t),this._removeAllNestedChanges(t,0,t.maxOffset));}}function wd(t){const e=[];for(const n of t)if(n.is("$text"))for(let t=0;t<n.data.length;t++)e.push({name:"$text",attributes:new Map(n.getAttributes())});else e.push({name:n.name,attributes:new Map(n.getAttributes())});return e}function _d(t,e){const n=[];let o=0,i=0;for(const t of e){if(t.offset>o){for(let e=0;e<t.offset-o;e++)n.push("e");i+=t.offset-o;}if("insert"==t.type){for(let e=0;e<t.howMany;e++)n.push("i");o=t.offset+t.howMany;}else if("remove"==t.type){for(let e=0;e<t.howMany;e++)n.push("r");o=t.offset,i+=t.howMany;}else n.push(..."a".repeat(t.howMany).split("")),o=t.offset+t.howMany,i+=t.howMany;}if(i<t)for(let e=0;e<t-i-o;e++)n.push("e");return n}function Ad(t){const e="position"in t&&"$graveyard"==t.position.root.rootName,n="range"in t&&"$graveyard"==t.range.root.rootName;return !e&&!n}class Cd{constructor(){this._operations=[],this._undoPairs=new Map,this._undoneOperations=new Set,this._baseVersionToOperationIndex=new Map,this._version=0,this._gaps=new Map;}get version(){return this._version}set version(t){this._operations.length&&t>this._version+1&&this._gaps.set(this._version,t),this._version=t;}get lastOperation(){return this._operations[this._operations.length-1]}addOperation(t){if(t.baseVersion!==this.version)throw new k("model-document-history-addoperation-incorrect-version",this,{operation:t,historyVersion:this.version});this._operations.push(t),this._version++,this._baseVersionToOperationIndex.set(t.baseVersion,this._operations.length-1);}getOperations(t,e=this.version){if(!this._operations.length)return [];const n=this._operations[0];void 0===t&&(t=n.baseVersion);let o=e-1;for(const[e,n]of this._gaps)t>e&&t<n&&(t=n),o>e&&o<n&&(o=e-1);if(o<n.baseVersion||t>this.lastOperation.baseVersion)return [];let i=this._baseVersionToOperationIndex.get(t);void 0===i&&(i=0);let r=this._baseVersionToOperationIndex.get(o);return void 0===r&&(r=this._operations.length-1),this._operations.slice(i,r+1)}getOperation(t){const e=this._baseVersionToOperationIndex.get(t);if(void 0!==e)return this._operations[e]}setOperationAsUndone(t,e){this._undoPairs.set(e,t),this._undoneOperations.add(t);}isUndoingOperation(t){return this._undoPairs.has(t)}isUndoneOperation(t){return this._undoneOperations.has(t)}getUndoneOperation(t){return this._undoPairs.get(t)}reset(){this._version=0,this._undoPairs=new Map,this._operations=[],this._undoneOperations=new Set,this._gaps=new Map,this._baseVersionToOperationIndex=new Map;}}class vd extends uc{constructor(t,e,n="main"){super(e),this._document=t,this.rootName=n;}get document(){return this._document}toJSON(){return this.rootName}}vd.prototype.is=function(t,e){return e?e===this.name&&("rootElement"===t||"model:rootElement"===t||"element"===t||"model:element"===t):"rootElement"===t||"model:rootElement"===t||"element"===t||"model:element"===t||"node"===t||"model:node"===t};const yd="$graveyard";class xd extends(I()){constructor(t){super(),this.model=t,this.history=new Cd,this.selection=new Oc(this),this.roots=new _i({idProperty:"rootName"}),this.differ=new bd(t.markers),this._postFixers=new Set,this._hasSelectionChangedFromTheLastChangeBlock=!1,this.createRoot("$root",yd),this.listenTo(t,"applyOperation",((t,e)=>{const n=e[0];n.isDocumentOperation&&this.differ.bufferOperation(n);}),{priority:"high"}),this.listenTo(t,"applyOperation",((t,e)=>{const n=e[0];n.isDocumentOperation&&this.history.addOperation(n);}),{priority:"low"}),this.listenTo(this.selection,"change",(()=>{this._hasSelectionChangedFromTheLastChangeBlock=!0;})),this.listenTo(t.markers,"update",((t,e,n,o,i)=>{const r={...e.getData(),range:o};this.differ.bufferMarkerChange(e.name,i,r),null===n&&e.on("change",((t,n)=>{const o=e.getData();this.differ.bufferMarkerChange(e.name,{...o,range:n},o);}));}));}get version(){return this.history.version}set version(t){this.history.version=t;}get graveyard(){return this.getRoot(yd)}createRoot(t="$root",e="main"){if(this.roots.get(e))throw new k("model-document-createroot-name-exists",this,{name:e});const n=new vd(this,t,e);return this.roots.add(n),n}destroy(){this.selection.destroy(),this.stopListening();}getRoot(t="main"){return this.roots.get(t)}getRootNames(){return Array.from(this.roots,(t=>t.rootName)).filter((t=>t!=yd))}registerPostFixer(t){this._postFixers.add(t);}toJSON(){const t=$i(this);return t.selection="[engine.model.DocumentSelection]",t.model="[engine.model.Model]",t}_handleChangeBlock(t){this._hasDocumentChangedFromTheLastChangeBlock()&&(this._callPostFixers(t),this.selection.refresh(),this.differ.hasDataChanges()?this.fire("change:data",t.batch):this.fire("change",t.batch),this.selection.refresh(),this.differ.reset()),this._hasSelectionChangedFromTheLastChangeBlock=!1;}_hasDocumentChangedFromTheLastChangeBlock(){return !this.differ.isEmpty||this._hasSelectionChangedFromTheLastChangeBlock}_getDefaultRoot(){for(const t of this.roots)if(t!==this.graveyard)return t;return this.graveyard}_getDefaultRange(){const t=this._getDefaultRoot(),e=this.model,n=e.schema,o=e.createPositionFromPath(t,[0]);return n.getNearestSelectionRange(o)||e.createRange(o)}_validateSelectionRange(t){return Ed(t.start)&&Ed(t.end)}_callPostFixers(t){let e=!1;do{for(const n of this._postFixers)if(this.selection.refresh(),e=n(t),e)break}while(e)}}function Ed(t){const e=t.textNode;if(e){const n=e.data,o=t.offset-e.startOffset;return !xi(n,o)&&!Ei(n,o)}return !0}class Dd extends(I()){constructor(){super(),this._markers=new Map;}[Symbol.iterator](){return this._markers.values()}has(t){const e=t instanceof Id?t.name:t;return this._markers.has(e)}get(t){return this._markers.get(t)||null}_set(t,e,n=!1,o=!1){const i=t instanceof Id?t.name:t;if(i.includes(","))throw new k("markercollection-incorrect-marker-name",this);const r=this._markers.get(i);if(r){const t=r.getData(),s=r.getRange();let a=!1;return s.isEqual(e)||(r._attachLiveRange(Bc.fromRange(e)),a=!0),n!=r.managedUsingOperations&&(r._managedUsingOperations=n,a=!0),"boolean"==typeof o&&o!=r.affectsData&&(r._affectsData=o,a=!0),a&&this.fire(`update:${i}`,r,s,e,t),r}const s=Bc.fromRange(e),a=new Id(i,s,n,o);return this._markers.set(i,a),this.fire(`update:${i}`,a,null,e,{...a.getData(),range:null}),a}_remove(t){const e=t instanceof Id?t.name:t,n=this._markers.get(e);return !!n&&(this._markers.delete(e),this.fire(`update:${e}`,n,n.getRange(),null,n.getData()),this._destroyMarker(n),!0)}_refresh(t){const e=t instanceof Id?t.name:t,n=this._markers.get(e);if(!n)throw new k("markercollection-refresh-marker-not-exists",this);const o=n.getRange();this.fire(`update:${e}`,n,o,o,n.getData());}*getMarkersAtPosition(t){for(const e of this)e.getRange().containsPosition(t)&&(yield e);}*getMarkersIntersectingRange(t){for(const e of this)null!==e.getRange().getIntersection(t)&&(yield e);}destroy(){for(const t of this._markers.values())this._destroyMarker(t);this._markers=null,this.stopListening();}*getMarkersGroup(t){for(const e of this._markers.values())e.name.startsWith(t+":")&&(yield e);}_destroyMarker(t){t.stopListening(),t._detachLiveRange();}}class Id extends(I(ac)){constructor(t,e,n,o){super(),this.name=t,this._liveRange=this._attachLiveRange(e),this._managedUsingOperations=n,this._affectsData=o;}get managedUsingOperations(){if(!this._liveRange)throw new k("marker-destroyed",this);return this._managedUsingOperations}get affectsData(){if(!this._liveRange)throw new k("marker-destroyed",this);return this._affectsData}getData(){return {range:this.getRange(),affectsData:this.affectsData,managedUsingOperations:this.managedUsingOperations}}getStart(){if(!this._liveRange)throw new k("marker-destroyed",this);return this._liveRange.start.clone()}getEnd(){if(!this._liveRange)throw new k("marker-destroyed",this);return this._liveRange.end.clone()}getRange(){if(!this._liveRange)throw new k("marker-destroyed",this);return this._liveRange.toRange()}_attachLiveRange(t){return this._liveRange&&this._detachLiveRange(),t.delegate("change:range").to(this),t.delegate("change:content").to(this),this._liveRange=t,t}_detachLiveRange(){this._liveRange.stopDelegating("change:range",this),this._liveRange.stopDelegating("change:content",this),this._liveRange.detach(),this._liveRange=null;}}Id.prototype.is=function(t){return "marker"===t||"model:marker"===t};class Md extends Ol{constructor(t,e){super(null),this.sourcePosition=t.clone(),this.howMany=e;}get type(){return "detach"}toJSON(){const t=super.toJSON();return t.sourcePosition=this.sourcePosition.toJSON(),t}_validate(){if(this.sourcePosition.root.document)throw new k("detach-operation-on-document-node",this)}_execute(){jl(Ac._createFromPositionAndShift(this.sourcePosition,this.howMany));}static get className(){return "DetachOperation"}}class Td extends ac{constructor(t){super(),this.markers=new Map,this._children=new lc,t&&this._insertChild(0,t);}[Symbol.iterator](){return this.getChildren()}get childCount(){return this._children.length}get maxOffset(){return this._children.maxOffset}get isEmpty(){return 0===this.childCount}get nextSibling(){return null}get previousSibling(){return null}get root(){return this}get parent(){return null}get document(){return null}getAncestors(){return []}getChild(t){return this._children.getNode(t)}getChildren(){return this._children[Symbol.iterator]()}getChildIndex(t){return this._children.getNodeIndex(t)}getChildStartOffset(t){return this._children.getNodeStartOffset(t)}getPath(){return []}getNodeByPath(t){let e=this;for(const n of t)e=e.getChild(e.offsetToIndex(n));return e}offsetToIndex(t){return this._children.offsetToIndex(t)}toJSON(){const t=[];for(const e of this._children)t.push(e.toJSON());return t}static fromJSON(t){const e=[];for(const n of t)n.name?e.push(uc.fromJSON(n)):e.push(dc.fromJSON(n));return new Td(e)}_appendChild(t){this._insertChild(this.childCount,t);}_insertChild(t,e){const n=function(t){if("string"==typeof t)return [new dc(t)];Z(t)||(t=[t]);return Array.from(t).map((t=>"string"==typeof t?new dc(t):t instanceof hc?new dc(t.data,t.getAttributes()):t))}(e);for(const t of n)null!==t.parent&&t._remove(),t.parent=this;this._children._insertNodes(t,n);}_removeChildren(t,e=1){const n=this._children._removeNodes(t,e);for(const t of n)t.parent=null;return n}}Td.prototype.is=function(t){return "documentFragment"===t||"model:documentFragment"===t};class Sd{constructor(t,e){this.model=t,this.batch=e;}createText(t,e){return new dc(t,e)}createElement(t,e){return new uc(t,e)}createDocumentFragment(){return new Td}cloneElement(t,e=!0){return t._clone(e)}insert(t,e,n=0){if(this._assertWriterUsedCorrectly(),t instanceof dc&&""==t.data)return;const o=pc._createAt(e,n);if(t.parent){if(Ld(t.root,o.root))return void this.move(Ac._createOn(t),o);if(t.root.document)throw new k("model-writer-insert-forbidden-move",this);this.remove(t);}const i=o.root.document?o.root.document.version:null,r=new ql(o,t,i);if(t instanceof dc&&(r.shouldReceiveAttributes=!0),this.batch.addOperation(r),this.model.applyOperation(r),t instanceof Td)for(const[e,n]of t.markers){const t=pc._createAt(n.root,0),i={range:new Ac(n.start._getCombined(t,o),n.end._getCombined(t,o)),usingOperation:!0,affectsData:!0};this.model.markers.has(e)?this.updateMarker(e,i):this.addMarker(e,i);}}insertText(t,e,n,o){e instanceof Td||e instanceof uc||e instanceof pc?this.insert(this.createText(t),e,n):this.insert(this.createText(t,e),n,o);}insertElement(t,e,n,o){e instanceof Td||e instanceof uc||e instanceof pc?this.insert(this.createElement(t),e,n):this.insert(this.createElement(t,e),n,o);}append(t,e){this.insert(t,e,"end");}appendText(t,e,n){e instanceof Td||e instanceof uc?this.insert(this.createText(t),e,"end"):this.insert(this.createText(t,e),n,"end");}appendElement(t,e,n){e instanceof Td||e instanceof uc?this.insert(this.createElement(t),e,"end"):this.insert(this.createElement(t,e),n,"end");}setAttribute(t,e,n){if(this._assertWriterUsedCorrectly(),n instanceof Ac){const o=n.getMinimalFlatRanges();for(const n of o)Nd(this,t,e,n);}else Bd(this,t,e,n);}setAttributes(t,e){for(const[n,o]of yi(t))this.setAttribute(n,o,e);}removeAttribute(t,e){if(this._assertWriterUsedCorrectly(),e instanceof Ac){const n=e.getMinimalFlatRanges();for(const e of n)Nd(this,t,null,e);}else Bd(this,t,null,e);}clearAttributes(t){this._assertWriterUsedCorrectly();const e=t=>{for(const e of t.getAttributeKeys())this.removeAttribute(e,t);};if(t instanceof Ac)for(const n of t.getItems())e(n);else e(t);}move(t,e,n){if(this._assertWriterUsedCorrectly(),!(t instanceof Ac))throw new k("writer-move-invalid-range",this);if(!t.isFlat)throw new k("writer-move-range-not-flat",this);const o=pc._createAt(e,n);if(o.isEqual(t.start))return;if(this._addOperationForAffectedMarkers("move",t),!Ld(t.root,o.root))throw new k("writer-move-different-document",this);const i=t.root.document?t.root.document.version:null,r=new Gl(t.start,t.end.offset-t.start.offset,o,i);this.batch.addOperation(r),this.model.applyOperation(r);}remove(t){this._assertWriterUsedCorrectly();const e=(t instanceof Ac?t:Ac._createOn(t)).getMinimalFlatRanges().reverse();for(const t of e)this._addOperationForAffectedMarkers("move",t),zd(t.start,t.end.offset-t.start.offset,this.batch,this.model);}merge(t){this._assertWriterUsedCorrectly();const e=t.nodeBefore,n=t.nodeAfter;if(this._addOperationForAffectedMarkers("merge",t),!(e instanceof uc))throw new k("writer-merge-no-element-before",this);if(!(n instanceof uc))throw new k("writer-merge-no-element-after",this);t.root.document?this._merge(t):this._mergeDetached(t);}createPositionFromPath(t,e,n){return this.model.createPositionFromPath(t,e,n)}createPositionAt(t,e){return this.model.createPositionAt(t,e)}createPositionAfter(t){return this.model.createPositionAfter(t)}createPositionBefore(t){return this.model.createPositionBefore(t)}createRange(t,e){return this.model.createRange(t,e)}createRangeIn(t){return this.model.createRangeIn(t)}createRangeOn(t){return this.model.createRangeOn(t)}createSelection(...t){return this.model.createSelection(...t)}_mergeDetached(t){const e=t.nodeBefore,n=t.nodeAfter;this.move(Ac._createIn(n),pc._createAt(e,"end")),this.remove(n);}_merge(t){const e=pc._createAt(t.nodeBefore,"end"),n=pc._createAt(t.nodeAfter,0),o=t.root.document.graveyard,i=new pc(o,[0]),r=t.root.document.version,s=new Xl(n,t.nodeAfter.maxOffset,e,i,r);this.batch.addOperation(s),this.model.applyOperation(s);}rename(t,e){if(this._assertWriterUsedCorrectly(),!(t instanceof uc))throw new k("writer-rename-not-element-instance",this);const n=t.root.document?t.root.document.version:null,o=new Zl(pc._createBefore(t),t.name,e,n);this.batch.addOperation(o),this.model.applyOperation(o);}split(t,e){this._assertWriterUsedCorrectly();let n,o,i=t.parent;if(!i.parent)throw new k("writer-split-element-no-parent",this);if(e||(e=i.parent),!t.parent.getAncestors({includeSelf:!0}).includes(e))throw new k("writer-split-invalid-limit-element",this);do{const e=i.root.document?i.root.document.version:null,r=i.maxOffset-t.offset,s=td.getInsertionPosition(t),a=new td(t,r,s,null,e);this.batch.addOperation(a),this.model.applyOperation(a),n||o||(n=i,o=t.parent.nextSibling),i=(t=this.createPositionAfter(t.parent)).parent;}while(i!==e);return {position:t,range:new Ac(pc._createAt(n,"end"),pc._createAt(o,0))}}wrap(t,e){if(this._assertWriterUsedCorrectly(),!t.isFlat)throw new k("writer-wrap-range-not-flat",this);const n=e instanceof uc?e:new uc(e);if(n.childCount>0)throw new k("writer-wrap-element-not-empty",this);if(null!==n.parent)throw new k("writer-wrap-element-attached",this);this.insert(n,t.start);const o=new Ac(t.start.getShiftedBy(1),t.end.getShiftedBy(1));this.move(o,pc._createAt(n,0));}unwrap(t){if(this._assertWriterUsedCorrectly(),null===t.parent)throw new k("writer-unwrap-element-no-parent",this);this.move(Ac._createIn(t),this.createPositionAfter(t)),this.remove(t);}addMarker(t,e){if(this._assertWriterUsedCorrectly(),!e||"boolean"!=typeof e.usingOperation)throw new k("writer-addmarker-no-usingoperation",this);const n=e.usingOperation,o=e.range,i=void 0!==e.affectsData&&e.affectsData;if(this.model.markers.has(t))throw new k("writer-addmarker-marker-exists",this);if(!o)throw new k("writer-addmarker-no-range",this);return n?(Pd(this,t,null,o,i),this.model.markers.get(t)):this.model.markers._set(t,o,n,i)}updateMarker(t,e){this._assertWriterUsedCorrectly();const n="string"==typeof t?t:t.name,o=this.model.markers.get(n);if(!o)throw new k("writer-updatemarker-marker-not-exists",this);if(!e)return b("writer-updatemarker-reconvert-using-editingcontroller",{markerName:n}),void this.model.markers._refresh(o);const i="boolean"==typeof e.usingOperation,r="boolean"==typeof e.affectsData,s=r?e.affectsData:o.affectsData;if(!i&&!e.range&&!r)throw new k("writer-updatemarker-wrong-options",this);const a=o.getRange(),c=e.range?e.range:a;i&&e.usingOperation!==o.managedUsingOperations?e.usingOperation?Pd(this,n,null,c,s):(Pd(this,n,a,null,s),this.model.markers._set(n,c,void 0,s)):o.managedUsingOperations?Pd(this,n,a,c,s):this.model.markers._set(n,c,void 0,s);}removeMarker(t){this._assertWriterUsedCorrectly();const e="string"==typeof t?t:t.name;if(!this.model.markers.has(e))throw new k("writer-removemarker-no-marker",this);const n=this.model.markers.get(e);if(!n.managedUsingOperations)return void this.model.markers._remove(e);Pd(this,e,n.getRange(),null,n.affectsData);}setSelection(...t){this._assertWriterUsedCorrectly(),this.model.document.selection._setTo(...t);}setSelectionFocus(t,e){this._assertWriterUsedCorrectly(),this.model.document.selection._setFocus(t,e);}setSelectionAttribute(t,e){if(this._assertWriterUsedCorrectly(),"string"==typeof t)this._setSelectionAttribute(t,e);else for(const[e,n]of yi(t))this._setSelectionAttribute(e,n);}removeSelectionAttribute(t){if(this._assertWriterUsedCorrectly(),"string"==typeof t)this._removeSelectionAttribute(t);else for(const e of t)this._removeSelectionAttribute(e);}overrideSelectionGravity(){return this.model.document.selection._overrideGravity()}restoreSelectionGravity(t){this.model.document.selection._restoreGravity(t);}_setSelectionAttribute(t,e){const n=this.model.document.selection;if(n.isCollapsed&&n.anchor.parent.isEmpty){const o=Oc._getStoreAttributeKey(t);this.setAttribute(o,e,n.anchor.parent);}n._setAttribute(t,e);}_removeSelectionAttribute(t){const e=this.model.document.selection;if(e.isCollapsed&&e.anchor.parent.isEmpty){const n=Oc._getStoreAttributeKey(t);this.removeAttribute(n,e.anchor.parent);}e._removeAttribute(t);}_assertWriterUsedCorrectly(){if(this.model._currentWriter!==this)throw new k("writer-incorrect-use",this)}_addOperationForAffectedMarkers(t,e){for(const n of this.model.markers){if(!n.managedUsingOperations)continue;const o=n.getRange();let i=!1;if("move"===t){const t=e;i=t.containsPosition(o.start)||t.start.isEqual(o.start)||t.containsPosition(o.end)||t.end.isEqual(o.end);}else {const t=e,n=t.nodeBefore,r=t.nodeAfter,s=o.start.parent==n&&o.start.isAtEnd,a=o.end.parent==r&&0==o.end.offset,c=o.end.nodeAfter==r,l=o.start.nodeAfter==r;i=s||a||c||l;}i&&this.updateMarker(n.name,{range:o});}}}function Nd(t,e,n,o){const i=t.model,r=i.document;let s,a,c,l=o.start;for(const t of o.getWalker({shallow:!0}))c=t.item.getAttribute(e),s&&a!=c&&(a!=n&&d(),l=s),s=t.nextPosition,a=c;function d(){const o=new Ac(l,s),c=o.root.document?r.version:null,d=new Kl(o,e,a,n,c);t.batch.addOperation(d),i.applyOperation(d);}s instanceof pc&&s!=l&&a!=n&&d();}function Bd(t,e,n,o){const i=t.model,r=i.document,s=o.getAttribute(e);let a,c;if(s!=n){if(o.root===o){const t=o.document?r.version:null;c=new Jl(o,e,s,n,t);}else {a=new Ac(pc._createBefore(o),t.createPositionAfter(o));const i=a.root.document?r.version:null;c=new Kl(a,e,s,n,i);}t.batch.addOperation(c),i.applyOperation(c);}}function Pd(t,e,n,o,i){const r=t.model,s=r.document,a=new Yl(e,n,o,r.markers,!!i,s.version);t.batch.addOperation(a),r.applyOperation(a);}function zd(t,e,n,o){let i;if(t.root.document){const n=o.document,r=new pc(n.graveyard,[0]);i=new Gl(t,e,r,n.version);}else i=new Md(t,e);n.addOperation(i),o.applyOperation(i);}function Ld(t,e){return t===e||t instanceof vd&&e instanceof vd}function Od(t){t.document.registerPostFixer((e=>function(t,e){const n=e.document.selection,o=e.schema,i=[];let r=!1;for(const t of n.getRanges()){const e=Rd(t,o);e&&!e.isEqual(t)?(i.push(e),r=!0):i.push(t);}r&&t.setSelection(function(t){const e=[...t],n=new Set;let o=1;for(;o<e.length;){const t=e[o],i=e.slice(0,o);for(const[r,s]of i.entries())if(!n.has(r))if(t.isEqual(s))n.add(r);else if(t.isIntersecting(s)){n.add(r),n.add(o);const i=t.getJoined(s);e.push(i);}o++;}return e.filter(((t,e)=>!n.has(e)))}(i),{backward:n.isBackward});return !1}(e,t)));}function Rd(t,e){return t.isCollapsed?function(t,e){const n=t.start,o=e.getNearestSelectionRange(n);if(!o){const t=n.getAncestors().reverse().find((t=>e.isObject(t)));return t?Ac._createOn(t):null}if(!o.isCollapsed)return o;const i=o.start;if(n.isEqual(i))return null;return new Ac(i)}(t,e):function(t,e){const{start:n,end:o}=t,i=e.checkChild(n,"$text"),r=e.checkChild(o,"$text"),s=e.getLimitElement(n),a=e.getLimitElement(o);if(s===a){if(i&&r)return null;if(function(t,e,n){const o=t.nodeAfter&&!n.isLimit(t.nodeAfter)||n.checkChild(t,"$text"),i=e.nodeBefore&&!n.isLimit(e.nodeBefore)||n.checkChild(e,"$text");return o||i}(n,o,e)){const t=n.nodeAfter&&e.isSelectable(n.nodeAfter)?null:e.getNearestSelectionRange(n,"forward"),i=o.nodeBefore&&e.isSelectable(o.nodeBefore)?null:e.getNearestSelectionRange(o,"backward"),r=t?t.start:n,s=i?i.end:o;return new Ac(r,s)}}const c=s&&!s.is("rootElement"),l=a&&!a.is("rootElement");if(c||l){const t=n.nodeAfter&&o.nodeBefore&&n.nodeAfter.parent===o.nodeBefore.parent,i=c&&(!t||!Fd(n.nodeAfter,e)),r=l&&(!t||!Fd(o.nodeBefore,e));let d=n,h=o;return i&&(d=pc._createBefore(jd(s,e))),r&&(h=pc._createAfter(jd(a,e))),new Ac(d,h)}return null}(t,e)}function jd(t,e){let n=t,o=n;for(;e.isLimit(o)&&o.parent;)n=o,o=o.parent;return n}function Fd(t,e){return t&&e.isSelectable(t)}function Vd(t,e,n={}){if(e.isCollapsed)return;const o=e.getFirstRange();if("$graveyard"==o.root.rootName)return;const i=t.schema;t.change((t=>{if(!n.doNotResetEntireContent&&function(t,e){const n=t.getLimitElement(e);if(!e.containsEntireContent(n))return !1;const o=e.getFirstRange();if(o.start.parent==o.end.parent)return !1;return t.checkChild(n,"paragraph")}(i,e))return void function(t,e){const n=t.model.schema.getLimitElement(e);t.remove(t.createRangeIn(n)),Gd(t,t.createPositionAt(n,0),e);}(t,e);const r={};if(!n.doNotAutoparagraph){const t=e.getSelectedElement();t&&Object.assign(r,i.getAttributesWithProperty(t,"copyOnReplace",!0));}const[s,a]=function(t){const e=t.root.document.model,n=t.start;let o=t.end;if(e.hasContent(t,{ignoreMarkers:!0})){const n=function(t){const e=t.parent,n=e.root.document.model.schema,o=e.getAncestors({parentFirst:!0,includeSelf:!0});for(const t of o){if(n.isLimit(t))return null;if(n.isBlock(t))return t}}(o);if(n&&o.isTouching(e.createPositionAt(n,0))){const n=e.createSelection(t);e.modifySelection(n,{direction:"backward"});const i=n.getLastPosition(),r=e.createRange(i,o);e.hasContent(r,{ignoreMarkers:!0})||(o=i);}}return [md.fromPosition(n,"toPrevious"),md.fromPosition(o,"toNext")]}(o);s.isTouching(a)||t.remove(t.createRange(s,a)),n.leaveUnmerged||(!function(t,e,n){const o=t.model;if(!Wd(t.model.schema,e,n))return;const[i,r]=function(t,e){const n=t.getAncestors(),o=e.getAncestors();let i=0;for(;n[i]&&n[i]==o[i];)i++;return [n[i],o[i]]}(e,n);if(!i||!r)return;!o.hasContent(i,{ignoreMarkers:!0})&&o.hasContent(r,{ignoreMarkers:!0})?Hd(t,e,n,i.parent):Ud(t,e,n,i.parent);}(t,s,a),i.removeDisallowedAttributes(s.parent.getChildren(),t)),qd(t,e,s),!n.doNotAutoparagraph&&function(t,e){const n=t.checkChild(e,"$text"),o=t.checkChild(e,"paragraph");return !n&&o}(i,s)&&Gd(t,s,e,r),s.detach(),a.detach();}));}function Ud(t,e,n,o){const i=e.parent,r=n.parent;if(i!=o&&r!=o){for(e=t.createPositionAfter(i),(n=t.createPositionBefore(r)).isEqual(e)||t.insert(r,e),t.merge(e);n.parent.isEmpty;){const e=n.parent;n=t.createPositionBefore(e),t.remove(e);}Wd(t.model.schema,e,n)&&Ud(t,e,n,o);}}function Hd(t,e,n,o){const i=e.parent,r=n.parent;if(i!=o&&r!=o){for(e=t.createPositionAfter(i),(n=t.createPositionBefore(r)).isEqual(e)||t.insert(i,n);e.parent.isEmpty;){const n=e.parent;e=t.createPositionBefore(n),t.remove(n);}n=t.createPositionBefore(r),function(t,e){const n=e.nodeBefore,o=e.nodeAfter;n.name!=o.name&&t.rename(n,o.name);t.clearAttributes(n),t.setAttributes(Object.fromEntries(o.getAttributes()),n),t.merge(e);}(t,n),Wd(t.model.schema,e,n)&&Hd(t,e,n,o);}}function Wd(t,e,n){const o=e.parent,i=n.parent;return o!=i&&(!t.isLimit(o)&&!t.isLimit(i)&&function(t,e,n){const o=new Ac(t,e);for(const t of o.getWalker())if(n.isLimit(t.item))return !1;return !0}(e,n,t))}function Gd(t,e,n,o={}){const i=t.createElement("paragraph");t.model.schema.setAllowedAttributes(i,o,t),t.insert(i,e),qd(t,n,t.createPositionAt(i,0));}function qd(t,e,n){e instanceof Oc?t.setSelection(n):e.setTo(n);}function Yd(t,e){const n=[];Array.from(t.getItems({direction:"backward"})).map((t=>e.createRangeOn(t))).filter((e=>(e.start.isAfter(t.start)||e.start.isEqual(t.start))&&(e.end.isBefore(t.end)||e.end.isEqual(t.end)))).forEach((t=>{n.push(t.start.parent),e.remove(t);})),n.forEach((t=>{let n=t;for(;n.parent&&n.isEmpty;){const t=e.createRangeOn(n);n=n.parent,e.remove(t);}}));}class $d{constructor(t,e,n){this.model=t,this.writer=e,this.position=n,this.canMergeWith=new Set([this.position.parent]),this.schema=t.schema,this._documentFragment=e.createDocumentFragment(),this._documentFragmentPosition=e.createPositionAt(this._documentFragment,0),this._firstNode=null,this._lastNode=null,this._lastAutoParagraph=null,this._filterAttributesOf=[],this._affectedStart=null,this._affectedEnd=null;}handleNodes(t){for(const e of Array.from(t))this._handleNode(e);this._insertPartialFragment(),this._lastAutoParagraph&&this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph),this._mergeOnRight(),this.schema.removeDisallowedAttributes(this._filterAttributesOf,this.writer),this._filterAttributesOf=[];}_updateLastNodeFromAutoParagraph(t){const e=this.writer.createPositionAfter(this._lastNode),n=this.writer.createPositionAfter(t);if(n.isAfter(e)){if(this._lastNode=t,this.position.parent!=t||!this.position.isAtEnd)throw new k("insertcontent-invalid-insertion-position",this);this.position=n,this._setAffectedBoundaries(this.position);}}getSelectionRange(){return this._nodeToSelect?Ac._createOn(this._nodeToSelect):this.model.schema.getNearestSelectionRange(this.position)}getAffectedRange(){return this._affectedStart?new Ac(this._affectedStart,this._affectedEnd):null}destroy(){this._affectedStart&&this._affectedStart.detach(),this._affectedEnd&&this._affectedEnd.detach();}_handleNode(t){if(this.schema.isObject(t))return void this._handleObject(t);let e=this._checkAndAutoParagraphToAllowedPosition(t);e||(e=this._checkAndSplitToAllowedPosition(t),e)?(this._appendToFragment(t),this._firstNode||(this._firstNode=t),this._lastNode=t):this._handleDisallowedNode(t);}_insertPartialFragment(){if(this._documentFragment.isEmpty)return;const t=md.fromPosition(this.position,"toNext");this._setAffectedBoundaries(this.position),this._documentFragment.getChild(0)==this._firstNode&&(this.writer.insert(this._firstNode,this.position),this._mergeOnLeft(),this.position=t.toPosition()),this._documentFragment.isEmpty||this.writer.insert(this._documentFragment,this.position),this._documentFragmentPosition=this.writer.createPositionAt(this._documentFragment,0),this.position=t.toPosition(),t.detach();}_handleObject(t){this._checkAndSplitToAllowedPosition(t)?this._appendToFragment(t):this._tryAutoparagraphing(t);}_handleDisallowedNode(t){t.is("element")?this.handleNodes(t.getChildren()):this._tryAutoparagraphing(t);}_appendToFragment(t){if(!this.schema.checkChild(this.position,t))throw new k("insertcontent-wrong-position",this,{node:t,position:this.position});this.writer.insert(t,this._documentFragmentPosition),this._documentFragmentPosition=this._documentFragmentPosition.getShiftedBy(t.offsetSize),this.schema.isObject(t)&&!this.schema.checkChild(this.position,"$text")?this._nodeToSelect=t:this._nodeToSelect=null,this._filterAttributesOf.push(t);}_setAffectedBoundaries(t){this._affectedStart||(this._affectedStart=md.fromPosition(t,"toPrevious")),this._affectedEnd&&!this._affectedEnd.isBefore(t)||(this._affectedEnd&&this._affectedEnd.detach(),this._affectedEnd=md.fromPosition(t,"toNext"));}_mergeOnLeft(){const t=this._firstNode;if(!(t instanceof uc))return;if(!this._canMergeLeft(t))return;const e=md._createBefore(t);e.stickiness="toNext";const n=md.fromPosition(this.position,"toNext");this._affectedStart.isEqual(e)&&(this._affectedStart.detach(),this._affectedStart=md._createAt(e.nodeBefore,"end","toPrevious")),this._firstNode===this._lastNode&&(this._firstNode=e.nodeBefore,this._lastNode=e.nodeBefore),this.writer.merge(e),e.isEqual(this._affectedEnd)&&this._firstNode===this._lastNode&&(this._affectedEnd.detach(),this._affectedEnd=md._createAt(e.nodeBefore,"end","toNext")),this.position=n.toPosition(),n.detach(),this._filterAttributesOf.push(this.position.parent),e.detach();}_mergeOnRight(){const t=this._lastNode;if(!(t instanceof uc))return;if(!this._canMergeRight(t))return;const e=md._createAfter(t);if(e.stickiness="toNext",!this.position.isEqual(e))throw new k("insertcontent-invalid-insertion-position",this);this.position=pc._createAt(e.nodeBefore,"end");const n=md.fromPosition(this.position,"toPrevious");this._affectedEnd.isEqual(e)&&(this._affectedEnd.detach(),this._affectedEnd=md._createAt(e.nodeBefore,"end","toNext")),this._firstNode===this._lastNode&&(this._firstNode=e.nodeBefore,this._lastNode=e.nodeBefore),this.writer.merge(e),e.getShiftedBy(-1).isEqual(this._affectedStart)&&this._firstNode===this._lastNode&&(this._affectedStart.detach(),this._affectedStart=md._createAt(e.nodeBefore,0,"toPrevious")),this.position=n.toPosition(),n.detach(),this._filterAttributesOf.push(this.position.parent),e.detach();}_canMergeLeft(t){const e=t.previousSibling;return e instanceof uc&&this.canMergeWith.has(e)&&this.model.schema.checkMerge(e,t)}_canMergeRight(t){const e=t.nextSibling;return e instanceof uc&&this.canMergeWith.has(e)&&this.model.schema.checkMerge(t,e)}_tryAutoparagraphing(t){const e=this.writer.createElement("paragraph");this._getAllowedIn(this.position.parent,e)&&this.schema.checkChild(e,t)&&(e._appendChild(t),this._handleNode(e));}_checkAndAutoParagraphToAllowedPosition(t){if(this.schema.checkChild(this.position.parent,t))return !0;if(!this.schema.checkChild(this.position.parent,"paragraph")||!this.schema.checkChild("paragraph",t))return !1;this._insertPartialFragment();const e=this.writer.createElement("paragraph");return this.writer.insert(e,this.position),this._setAffectedBoundaries(this.position),this._lastAutoParagraph=e,this.position=this.writer.createPositionAt(e,0),!0}_checkAndSplitToAllowedPosition(t){const e=this._getAllowedIn(this.position.parent,t);if(!e)return !1;for(e!=this.position.parent&&this._insertPartialFragment();e!=this.position.parent;)if(this.position.isAtStart){const t=this.position.parent;this.position=this.writer.createPositionBefore(t),t.isEmpty&&t.parent===e&&this.writer.remove(t);}else if(this.position.isAtEnd)this.position=this.writer.createPositionAfter(this.position.parent);else {const t=this.writer.createPositionAfter(this.position.parent);this._setAffectedBoundaries(this.position),this.writer.split(this.position),this.position=t,this.canMergeWith.add(this.position.nodeAfter);}return !0}_getAllowedIn(t,e){return this.schema.checkChild(t,e)?t:this.schema.isLimit(t)?null:this._getAllowedIn(t.parent,e)}}function Kd(t,e,n="auto"){const o=t.getSelectedElement();if(o&&e.schema.isObject(o)&&!e.schema.isInline(o))return "before"==n||"after"==n?e.createRange(e.createPositionAt(o,n)):e.createRangeOn(o);const i=Ai(t.getSelectedBlocks());if(!i)return e.createRange(t.focus);if(i.isEmpty)return e.createRange(e.createPositionAt(i,0));const r=e.createPositionAfter(i);return t.focus.isTouching(r)?e.createRange(r):e.createRange(e.createPositionBefore(i))}function Qd(t,e,n,o,i={}){if(!t.schema.isObject(e))throw new k("insertobject-element-not-an-object",t,{object:e});let r;r=n?n instanceof Ic||n instanceof Oc?n:t.createSelection(n,o):t.document.selection;let s=r;i.findOptimalPosition&&t.schema.isBlock(e)&&(s=t.createSelection(Kd(r,t,i.findOptimalPosition)));const a=Ai(r.getSelectedBlocks()),c={};return a&&Object.assign(c,t.schema.getAttributesWithProperty(a,"copyOnReplace",!0)),t.change((n=>{s.isCollapsed||t.deleteContent(s,{doNotAutoparagraph:!0});let o=e;const r=s.anchor.parent;!t.schema.checkChild(r,e)&&t.schema.checkChild(r,"paragraph")&&t.schema.checkChild("paragraph",e)&&(o=n.createElement("paragraph"),n.insert(e,o)),t.schema.setAllowedAttributes(o,c,n);const a=t.insertContent(o,s);return a.isCollapsed||i.setSelection&&function(t,e,n,o){const i=t.model;if("on"==n)return void t.setSelection(e,"on");if("after"!=n)throw new k("insertobject-invalid-place-parameter-value",i);let r=e.nextSibling;if(i.schema.isInline(e))return void t.setSelection(e,"after");const s=r&&i.schema.checkChild(r,"$text");!s&&i.schema.checkChild(e.parent,"paragraph")&&(r=t.createElement("paragraph"),i.schema.setAllowedAttributes(r,o,t),i.insertContent(r,t.createPositionAfter(e)));r&&t.setSelection(r,0);}(n,e,i.setSelection,c),a}))}function Zd(t,e){const{isForward:n,walker:o,unit:i,schema:r,treatEmojiAsSingleUnit:s}=t,{type:a,item:c,nextPosition:l}=e;if("text"==a)return "word"===t.unit?function(t,e){let n=t.position.textNode;n||(n=e?t.position.nodeAfter:t.position.nodeBefore);for(;n&&n.is("$text");){const o=t.position.offset-n.startOffset;if(th(n,o,e))n=e?t.position.nodeAfter:t.position.nodeBefore;else {if(Xd(n.data,o,e))break;t.next();}}return t.position}(o,n):function(t,e,n){const o=t.position.textNode;if(o){const i=o.data;let r=t.position.offset-o.startOffset;for(;xi(i,r)||"character"==e&&Ei(i,r)||n&&Ii(i,r);)t.next(),r=t.position.offset-o.startOffset;}return t.position}(o,i,s);if(a==(n?"elementStart":"elementEnd")){if(r.isSelectable(c))return pc._createAt(c,n?"after":"before");if(r.checkChild(l,"$text"))return l}else {if(r.isLimit(c))return void o.skip((()=>!0));if(r.checkChild(l,"$text"))return l}}function Jd(t,e){const n=t.root,o=pc._createAt(n,e?"end":0);return e?new Ac(t,o):new Ac(o,t)}function Xd(t,e,n){const o=e+(n?0:-1);return ' ,.?!:;"-()'.includes(t.charAt(o))}function th(t,e,n){return e===(n?t.offsetSize:0)}class eh extends(H()){constructor(){super(),this.markers=new Dd,this.document=new xd(this),this.schema=new pl,this._pendingChanges=[],this._currentWriter=null,["insertContent","insertObject","deleteContent","modifySelection","getSelectedContent","applyOperation"].forEach((t=>this.decorate(t))),this.on("applyOperation",((t,e)=>{e[0]._validate();}),{priority:"highest"}),this.schema.register("$root",{isLimit:!0}),this.schema.register("$container",{allowIn:["$root","$container"]}),this.schema.register("$block",{allowIn:["$root","$container"],isBlock:!0}),this.schema.register("$blockObject",{allowWhere:"$block",isBlock:!0,isObject:!0}),this.schema.register("$inlineObject",{allowWhere:"$text",allowAttributesOf:"$text",isInline:!0,isObject:!0}),this.schema.register("$text",{allowIn:"$block",isInline:!0,isContent:!0}),this.schema.register("$clipboardHolder",{allowContentOf:"$root",allowChildren:"$text",isLimit:!0}),this.schema.register("$documentFragment",{allowContentOf:"$root",allowChildren:"$text",isLimit:!0}),this.schema.register("$marker"),this.schema.addChildCheck(((t,e)=>{if("$marker"===e.name)return !0})),Od(this),this.document.registerPostFixer(el);}change(t){try{return 0===this._pendingChanges.length?(this._pendingChanges.push({batch:new kd,callback:t}),this._runPendingChanges()[0]):t(this._currentWriter)}catch(t){k.rethrowUnexpectedError(t,this);}}enqueueChange(t,e){try{t?"function"==typeof t?(e=t,t=new kd):t instanceof kd||(t=new kd(t)):t=new kd,this._pendingChanges.push({batch:t,callback:e}),1==this._pendingChanges.length&&this._runPendingChanges();}catch(t){k.rethrowUnexpectedError(t,this);}}applyOperation(t){t._execute();}insertContent(t,e,n){return function(t,e,n,o){return t.change((i=>{let r;r=n?n instanceof Ic||n instanceof Oc?n:i.createSelection(n,o):t.document.selection,r.isCollapsed||t.deleteContent(r,{doNotAutoparagraph:!0});const s=new $d(t,i,r.anchor),a=[];let c;if(e.is("documentFragment")){if(e.markers.size){const t=[];for(const[n,o]of e.markers){const{start:e,end:i}=o,r=e.isEqual(i);t.push({position:e,name:n,isCollapsed:r},{position:i,name:n,isCollapsed:r});}t.sort((({position:t},{position:e})=>t.isBefore(e)?1:-1));for(const{position:n,name:o,isCollapsed:r}of t){let t=null,s=null;const c=n.parent===e&&n.isAtStart,l=n.parent===e&&n.isAtEnd;c||l?r&&(s=c?"start":"end"):(t=i.createElement("$marker"),i.insert(t,n)),a.push({name:o,element:t,collapsed:s});}}c=e.getChildren();}else c=[e];s.handleNodes(c);let l=s.getSelectionRange();if(e.is("documentFragment")&&a.length){const t=l?Bc.fromRange(l):null,e={};for(let t=a.length-1;t>=0;t--){const{name:n,element:o,collapsed:r}=a[t],c=!e[n];if(c&&(e[n]=[]),o){const t=i.createPositionAt(o,"before");e[n].push(t),i.remove(o);}else {const t=s.getAffectedRange();if(!t){r&&e[n].push(s.position);continue}r?e[n].push(t[r]):e[n].push(c?t.start:t.end);}}for(const[t,[n,o]]of Object.entries(e))n&&o&&n.root===o.root&&i.addMarker(t,{usingOperation:!0,affectsData:!0,range:new Ac(n,o)});t&&(l=t.toRange(),t.detach());}l&&(r instanceof Oc?i.setSelection(l):r.setTo(l));const d=s.getAffectedRange()||t.createRange(r.anchor);return s.destroy(),d}))}(this,t,e,n)}insertObject(t,e,n,o){return Qd(this,t,e,n,o)}deleteContent(t,e){Vd(this,t,e);}modifySelection(t,e){!function(t,e,n={}){const o=t.schema,i="backward"!=n.direction,r=n.unit?n.unit:"character",s=!!n.treatEmojiAsSingleUnit,a=e.focus,c=new gc({boundaries:Jd(a,i),singleCharacters:!0,direction:i?"forward":"backward"}),l={walker:c,schema:o,isForward:i,unit:r,treatEmojiAsSingleUnit:s};let d;for(;d=c.next();){if(d.done)return;const n=Zd(l,d.value);if(n)return void(e instanceof Oc?t.change((t=>{t.setSelectionFocus(n);})):e.setFocus(n))}}(this,t,e);}getSelectedContent(t){return function(t,e){return t.change((t=>{const n=t.createDocumentFragment(),o=e.getFirstRange();if(!o||o.isCollapsed)return n;const i=o.start.root,r=o.start.getCommonPath(o.end),s=i.getNodeByPath(r);let a;a=o.start.parent==o.end.parent?o:t.createRange(t.createPositionAt(s,o.start.path[r.length]),t.createPositionAt(s,o.end.path[r.length]+1));const c=a.end.offset-a.start.offset;for(const e of a.getItems({shallow:!0}))e.is("$textProxy")?t.appendText(e.data,e.getAttributes(),n):t.append(t.cloneElement(e,!0),n);if(a!=o){const e=o._getTransformedByMove(a.start,t.createPositionAt(n,0),c)[0],i=t.createRange(t.createPositionAt(n,0),e.start);Yd(t.createRange(e.end,t.createPositionAt(n,"end")),t),Yd(i,t);}return n}))}(this,t)}hasContent(t,e={}){const n=t instanceof Ac?t:Ac._createIn(t);if(n.isCollapsed)return !1;const{ignoreWhitespaces:o=!1,ignoreMarkers:i=!1}=e;if(!i)for(const t of this.markers.getMarkersIntersectingRange(n))if(t.affectsData)return !0;for(const t of n.getItems())if(this.schema.isContent(t)){if(!t.is("$textProxy"))return !0;if(!o)return !0;if(-1!==t.data.search(/\S/))return !0}return !1}createPositionFromPath(t,e,n){return new pc(t,e,n)}createPositionAt(t,e){return pc._createAt(t,e)}createPositionAfter(t){return pc._createAfter(t)}createPositionBefore(t){return pc._createBefore(t)}createRange(t,e){return new Ac(t,e)}createRangeIn(t){return Ac._createIn(t)}createRangeOn(t){return Ac._createOn(t)}createSelection(...t){return new Ic(...t)}createBatch(t){return new kd(t)}createOperationFromJSON(t){return nd.fromJSON(t,this.document)}destroy(){this.document.destroy(),this.stopListening();}_runPendingChanges(){const t=[];this.fire("_beforeChanges");try{for(;this._pendingChanges.length;){const e=this._pendingChanges[0].batch;this._currentWriter=new Sd(this,e);const n=this._pendingChanges[0].callback(this._currentWriter);t.push(n),this.document._handleChangeBlock(this._currentWriter),this._pendingChanges.shift(),this._currentWriter=null;}}finally{this._pendingChanges.length=0,this._currentWriter=null,this.fire("_afterChanges");}return t}}class nh extends ma{constructor(t){super(t),this.domEventType="click";}onDomEvent(t){this.fire(t.type,t);}}class oh extends ma{constructor(t){super(t),this.domEventType=["mousedown","mouseup","mouseover","mouseout"];}onDomEvent(t){this.fire(t.type,t);}}class ih{constructor(t){this.document=t;}createDocumentFragment(t){return new Is(this.document,t)}createElement(t,e,n){return new Zr(this.document,t,e,n)}createText(t){return new Qi(this.document,t)}clone(t,e=!1){return t._clone(e)}appendChild(t,e){return e._appendChild(t)}insertChild(t,e,n){return n._insertChild(t,e)}removeChildren(t,e,n){return n._removeChildren(t,e)}remove(t){const e=t.parent;return e?this.removeChildren(e.getChildIndex(t),1,e):[]}replace(t,e){const n=t.parent;if(n){const o=n.getChildIndex(t);return this.removeChildren(o,1,n),this.insertChild(o,e,n),!0}return !1}unwrapElement(t){const e=t.parent;if(e){const n=e.getChildIndex(t);this.remove(t),this.insertChild(n,t.getChildren(),e);}}rename(t,e){const n=new Zr(this.document,t,e.getAttributes(),e.getChildren());return this.replace(e,n)?n:null}setAttribute(t,e,n){n._setAttribute(t,e);}removeAttribute(t,e){e._removeAttribute(t);}addClass(t,e){e._addClass(t);}removeClass(t,e){e._removeClass(t);}setStyle(t,e,n){Ct(t)&&void 0===n?e._setStyle(t):n._setStyle(t,e);}removeStyle(t,e){e._removeStyle(t);}setCustomProperty(t,e,n){n._setCustomProperty(t,e);}removeCustomProperty(t,e){return e._removeCustomProperty(t)}createPositionAt(t,e){return rs._createAt(t,e)}createPositionAfter(t){return rs._createAfter(t)}createPositionBefore(t){return rs._createBefore(t)}createRange(t,e){return new ss(t,e)}createRangeOn(t){return ss._createOn(t)}createRangeIn(t){return ss._createIn(t)}createSelection(...t){return new cs(...t)}}class rh{constructor(){this._commands=new Map;}add(t,e){this._commands.set(t,e);}get(t){return this._commands.get(t)}execute(t,...e){const n=this.get(t);if(!n)throw new k("commandcollection-command-not-found",this,{commandName:t});return n.execute(...e)}*names(){yield*this._commands.keys();}*commands(){yield*this._commands.values();}[Symbol.iterator](){return this._commands[Symbol.iterator]()}destroy(){for(const t of this.commands())t.destroy();}}class sh extends vi{constructor(t){super(),this.editor=t;}set(t,e,n={}){if("string"==typeof e){const t=e;e=(e,n)=>{this.editor.execute(t),n();};}super.set(t,e,n);}}class ah extends(H()){constructor(t={}){super();const e=this.constructor,n=t.language||e.defaultConfig&&e.defaultConfig.language;this._context=t.context||new zi({language:n}),this._context._addEditor(this,!t.context);const o=Array.from(e.builtinPlugins||[]);this.config=new Ao(t,e.defaultConfig),this.config.define("plugins",o),this.config.define(this._context._getEditorConfig()),this.plugins=new Pi(this,o,this._context.plugins),this.locale=this._context.locale,this.t=this.locale.t,this._readOnlyLocks=new Set,this.commands=new rh,this.set("state","initializing"),this.once("ready",(()=>this.state="ready"),{priority:"high"}),this.once("destroy",(()=>this.state="destroyed"),{priority:"high"}),this.model=new eh;const i=new $r;this.data=new Bl(this.model,i),this.editing=new hl(this.model,i),this.editing.view.document.bind("isReadOnly").to(this),this.conversion=new Pl([this.editing.downcastDispatcher,this.data.downcastDispatcher],this.data.upcastDispatcher),this.conversion.addAlias("dataDowncast",this.data.downcastDispatcher),this.conversion.addAlias("editingDowncast",this.editing.downcastDispatcher),this.keystrokes=new sh(this),this.keystrokes.listenTo(this.editing.view.document);}get isReadOnly(){return this._readOnlyLocks.size>0}set isReadOnly(t){throw new k("editor-isreadonly-has-no-setter")}enableReadOnlyMode(t){if("string"!=typeof t&&"symbol"!=typeof t)throw new k("editor-read-only-lock-id-invalid",null,{lockId:t});this._readOnlyLocks.has(t)||(this._readOnlyLocks.add(t),1===this._readOnlyLocks.size&&this.fire("change:isReadOnly","isReadOnly",!0,!1));}disableReadOnlyMode(t){if("string"!=typeof t&&"symbol"!=typeof t)throw new k("editor-read-only-lock-id-invalid",null,{lockId:t});this._readOnlyLocks.has(t)&&(this._readOnlyLocks.delete(t),0===this._readOnlyLocks.size&&this.fire("change:isReadOnly","isReadOnly",!1,!0));}initPlugins(){const t=this.config,e=t.get("plugins"),n=t.get("removePlugins")||[],o=t.get("extraPlugins")||[],i=t.get("substitutePlugins")||[];return this.plugins.init(e.concat(o),n,i)}destroy(){let t=Promise.resolve();return "initializing"==this.state&&(t=new Promise((t=>this.once("ready",t)))),t.then((()=>{this.fire("destroy"),this.stopListening(),this.commands.destroy();})).then((()=>this.plugins.destroy())).then((()=>{this.model.destroy(),this.data.destroy(),this.editing.destroy(),this.keystrokes.destroy();})).then((()=>this._context._removeEditor(this)))}execute(t,...e){try{return this.commands.execute(t,...e)}catch(t){k.rethrowUnexpectedError(t,this);}}focus(){this.editing.view.focus();}}class ch{constructor(t){this.editor=t,this._components=new Map;}*names(){for(const t of this._components.values())yield t.originalName;}add(t,e){this._components.set(lh(t),{callback:e,originalName:t});}create(t){if(!this.has(t))throw new k("componentfactory-item-missing",this,{name:t});return this._components.get(lh(t)).callback(this.editor.locale)}has(t){return this._components.has(lh(t))}}function lh(t){return String(t).toLowerCase()}class dh extends _i{constructor(t=[]){super(t,{idProperty:"viewUid"}),this.on("add",((t,e,n)=>{this._renderViewIntoCollectionParent(e,n);})),this.on("remove",((t,e)=>{e.element&&this._parentElement&&e.element.remove();})),this._parentElement=null;}destroy(){this.map((t=>t.destroy()));}setParent(t){this._parentElement=t;for(const t of this)this._renderViewIntoCollectionParent(t);}delegate(...t){if(!t.length||!t.every((t=>"string"==typeof t)))throw new k("ui-viewcollection-delegate-wrong-events",this);return {to:e=>{for(const n of this)for(const o of t)n.delegate(o).to(e);this.on("add",((n,o)=>{for(const n of t)o.delegate(n).to(e);})),this.on("remove",((n,o)=>{for(const n of t)o.stopDelegating(n,e);}));}}}_renderViewIntoCollectionParent(t,e){t.isRendered||t.render(),t.element&&this._parentElement&&this._parentElement.insertBefore(t.element,this._parentElement.children[e]);}}class hh extends(I()){constructor(t){super(),Object.assign(this,Ah(_h(t))),this._isRendered=!1,this._revertData=null;}render(){const t=this._renderNode({intoFragment:!0});return this._isRendered=!0,t}apply(t){return this._revertData={children:[],bindings:[],attributes:{}},this._renderNode({node:t,intoFragment:!1,isApplying:!0,revertData:this._revertData}),t}revert(t){if(!this._revertData)throw new k("ui-template-revert-not-applied",[this,t]);this._revertTemplateFromNode(t,this._revertData);}*getViews(){yield*function*t(e){if(e.children)for(const n of e.children)Dh(n)?yield n:Ih(n)&&(yield*t(n));}(this);}static bind(t,e){return {to:(n,o)=>new gh({eventNameOrFunction:n,attribute:n,observable:t,emitter:e,callback:o}),if:(n,o,i)=>new mh({observable:t,emitter:e,attribute:n,valueIfTrue:o,callback:i})}}static extend(t,e){if(t._isRendered)throw new k("template-extend-render",[this,t]);xh(t,Ah(_h(e)));}_renderNode(t){let e;if(e=t.node?this.tag&&this.text:this.tag?this.text:!this.text,e)throw new k("ui-template-wrong-syntax",this);return this.text?this._renderText(t):this._renderElement(t)}_renderElement(t){let e=t.node;return e||(e=t.node=document.createElementNS(this.ns||"http://www.w3.org/1999/xhtml",this.tag)),this._renderAttributes(t),this._renderElementChildren(t),this._setUpListeners(t),e}_renderText(t){let e=t.node;return e?t.revertData.text=e.textContent:e=t.node=document.createTextNode(""),ph(this.text)?this._bindToObservable({schema:this.text,updater:kh(e),data:t}):e.textContent=this.text.join(""),e}_renderAttributes(t){if(!this.attributes)return;const e=t.node,n=t.revertData;for(const o in this.attributes){const i=e.getAttribute(o),r=this.attributes[o];n&&(n.attributes[o]=i);const s=Th(r)?r[0].ns:null;if(ph(r)){const a=Th(r)?r[0].value:r;n&&Sh(o)&&a.unshift(i),this._bindToObservable({schema:a,updater:bh(e,o,s),data:t});}else if("style"==o&&"string"!=typeof r[0])this._renderStyleAttribute(r[0],t);else {n&&i&&Sh(o)&&r.unshift(i);const t=r.map((t=>t&&t.value||t)).reduce(((t,e)=>t.concat(e)),[]).reduce(vh,"");Eh(t)||e.setAttributeNS(s,o,t);}}}_renderStyleAttribute(t,e){const n=e.node;for(const o in t){const i=t[o];ph(i)?this._bindToObservable({schema:[i],updater:wh(n,o),data:e}):n.style[o]=i;}}_renderElementChildren(t){const e=t.node,n=t.intoFragment?document.createDocumentFragment():e,o=t.isApplying;let i=0;for(const r of this.children)if(Mh(r)){if(!o){r.setParent(e);for(const t of r)n.appendChild(t.element);}}else if(Dh(r))o||(r.isRendered||r.render(),n.appendChild(r.element));else if(yo(r))n.appendChild(r);else if(o){const e={children:[],bindings:[],attributes:{}};t.revertData.children.push(e),r._renderNode({intoFragment:!1,node:n.childNodes[i++],isApplying:!0,revertData:e});}else n.appendChild(r.render());t.intoFragment&&e.appendChild(n);}_setUpListeners(t){if(this.eventListeners)for(const e in this.eventListeners){const n=this.eventListeners[e].map((n=>{const[o,i]=e.split("@");return n.activateDomEventListener(o,i,t)}));t.revertData&&t.revertData.bindings.push(n);}}_bindToObservable({schema:t,updater:e,data:n}){const o=n.revertData;fh(t,e,n);const i=t.filter((t=>!Eh(t))).filter((t=>t.observable)).map((o=>o.activateAttributeListener(t,e,n)));o&&o.bindings.push(i);}_revertTemplateFromNode(t,e){for(const t of e.bindings)for(const e of t)e();if(e.text)return void(t.textContent=e.text);const n=t;for(const t in e.attributes){const o=e.attributes[t];null===o?n.removeAttribute(t):n.setAttribute(t,o);}for(let t=0;t<e.children.length;++t)this._revertTemplateFromNode(n.childNodes[t],e.children[t]);}}class uh{constructor(t){this.attribute=t.attribute,this.observable=t.observable,this.emitter=t.emitter,this.callback=t.callback;}getValue(t){const e=this.observable[this.attribute];return this.callback?this.callback(e,t):e}activateAttributeListener(t,e,n){const o=()=>fh(t,e,n);return this.emitter.listenTo(this.observable,`change:${this.attribute}`,o),()=>{this.emitter.stopListening(this.observable,`change:${this.attribute}`,o);}}}class gh extends uh{constructor(t){super(t),this.eventNameOrFunction=t.eventNameOrFunction;}activateDomEventListener(t,e,n){const o=(t,n)=>{e&&!n.target.matches(e)||("function"==typeof this.eventNameOrFunction?this.eventNameOrFunction(n):this.observable.fire(this.eventNameOrFunction,n));};return this.emitter.listenTo(n.node,t,o),()=>{this.emitter.stopListening(n.node,t,o);}}}class mh extends uh{constructor(t){super(t),this.valueIfTrue=t.valueIfTrue;}getValue(t){return !Eh(super.getValue(t))&&(this.valueIfTrue||!0)}}function ph(t){return !!t&&(t.value&&(t=t.value),Array.isArray(t)?t.some(ph):t instanceof uh)}function fh(t,e,{node:n}){const o=function(t,e){return t.map((t=>t instanceof uh?t.getValue(e):t))}(t,n);let i;i=1==t.length&&t[0]instanceof mh?o[0]:o.reduce(vh,""),Eh(i)?e.remove():e.set(i);}function kh(t){return {set(e){t.textContent=e;},remove(){t.textContent="";}}}function bh(t,e,n){return {set(o){t.setAttributeNS(n,e,o);},remove(){t.removeAttributeNS(n,e);}}}function wh(t,e){return {set(n){t.style[e]=n;},remove(){t.style[e]=null;}}}function _h(t){return wo(t,(t=>{if(t&&(t instanceof uh||Ih(t)||Dh(t)||Mh(t)))return t}))}function Ah(t){if("string"==typeof t?t=function(t){return {text:[t]}}(t):t.text&&function(t){t.text=pi(t.text);}(t),t.on&&(t.eventListeners=function(t){for(const e in t)Ch(t,e);return t}(t.on),delete t.on),!t.text){t.attributes&&function(t){for(const e in t)t[e].value&&(t[e].value=pi(t[e].value)),Ch(t,e);}(t.attributes);const e=[];if(t.children)if(Mh(t.children))e.push(t.children);else for(const n of t.children)Ih(n)||Dh(n)||yo(n)?e.push(n):e.push(new hh(n));t.children=e;}return t}function Ch(t,e){t[e]=pi(t[e]);}function vh(t,e){return Eh(e)?t:Eh(t)?e:`${t} ${e}`}function yh(t,e){for(const n in e)t[n]?t[n].push(...e[n]):t[n]=e[n];}function xh(t,e){if(e.attributes&&(t.attributes||(t.attributes={}),yh(t.attributes,e.attributes)),e.eventListeners&&(t.eventListeners||(t.eventListeners={}),yh(t.eventListeners,e.eventListeners)),e.text&&t.text.push(...e.text),e.children&&e.children.length){if(t.children.length!=e.children.length)throw new k("ui-template-extend-children-mismatch",t);let n=0;for(const o of e.children)xh(t.children[n++],o);}}function Eh(t){return !t&&0!==t}function Dh(t){return t instanceof Ph}function Ih(t){return t instanceof hh}function Mh(t){return t instanceof dh}function Th(t){return L(t[0])&&t[0].ns}function Sh(t){return "class"==t||"style"==t}var Nh=n(4793),Bh={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Nh.Z,Bh);Nh.Z.locals;class Ph extends(Do(H())){constructor(t){super(),this.element=null,this.isRendered=!1,this.locale=t,this.t=t&&t.t,this._viewCollections=new _i,this._unboundChildren=this.createCollection(),this._viewCollections.on("add",((e,n)=>{n.locale=t,n.t=t&&t.t;})),this.decorate("render");}get bindTemplate(){return this._bindTemplate?this._bindTemplate:this._bindTemplate=hh.bind(this,this)}createCollection(t){const e=new dh(t);return this._viewCollections.add(e),e}registerChild(t){Z(t)||(t=[t]);for(const e of t)this._unboundChildren.add(e);}deregisterChild(t){Z(t)||(t=[t]);for(const e of t)this._unboundChildren.remove(e);}setTemplate(t){this.template=new hh(t);}extendTemplate(t){hh.extend(this.template,t);}render(){if(this.isRendered)throw new k("ui-view-render-already-rendered",this);this.template&&(this.element=this.template.render(),this.registerChild(this.template.getViews())),this.isRendered=!0;}destroy(){this.stopListening(),this._viewCollections.map((t=>t.destroy())),this.template&&this.template._revertData&&this.template.revert(this.element);}}var zh=n(8793),Lh={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(zh.Z,Lh);zh.Z.locals;const Oh=Ho("px"),Rh=So.document.body;class jh extends Ph{constructor(t){super(t);const e=this.bindTemplate;this.set("top",0),this.set("left",0),this.set("position","arrow_nw"),this.set("isVisible",!1),this.set("withArrow",!0),this.set("class",void 0),this._pinWhenIsVisibleCallback=null,this.content=this.createCollection(),this.setTemplate({tag:"div",attributes:{class:["ck","ck-balloon-panel",e.to("position",(t=>`ck-balloon-panel_${t}`)),e.if("isVisible","ck-balloon-panel_visible"),e.if("withArrow","ck-balloon-panel_with-arrow"),e.to("class")],style:{top:e.to("top",Oh),left:e.to("left",Oh)}},children:this.content});}show(){this.isVisible=!0;}hide(){this.isVisible=!1;}attachTo(t){this.show();const e=jh.defaultPositions,n=Object.assign({},{element:this.element,positions:[e.southArrowNorth,e.southArrowNorthMiddleWest,e.southArrowNorthMiddleEast,e.southArrowNorthWest,e.southArrowNorthEast,e.northArrowSouth,e.northArrowSouthMiddleWest,e.northArrowSouthMiddleEast,e.northArrowSouthWest,e.northArrowSouthEast,e.viewportStickyNorth],limiter:Rh,fitInViewport:!0},t),o=jh._getOptimalPosition(n),i=parseInt(o.left),r=parseInt(o.top),s=o.name,a=o.config||{},{withArrow:c=!0}=a;this.top=r,this.left=i,this.position=s,this.withArrow=c;}pin(t){this.unpin(),this._pinWhenIsVisibleCallback=()=>{this.isVisible?this._startPinning(t):this._stopPinning();},this._startPinning(t),this.listenTo(this,"change:isVisible",this._pinWhenIsVisibleCallback);}unpin(){this._pinWhenIsVisibleCallback&&(this._stopPinning(),this.stopListening(this,"change:isVisible",this._pinWhenIsVisibleCallback),this._pinWhenIsVisibleCallback=null,this.hide());}_startPinning(t){this.attachTo(t);const e=Fh(t.target),n=t.limiter?Fh(t.limiter):Rh;this.listenTo(So.document,"scroll",((o,i)=>{const r=i.target,s=e&&r.contains(e),a=n&&r.contains(n);!s&&!a&&e&&n||this.attachTo(t);}),{useCapture:!0}),this.listenTo(So.window,"resize",(()=>{this.attachTo(t);}));}_stopPinning(){this.stopListening(So.document,"scroll"),this.stopListening(So.window,"resize");}}function Fh(t){return _o(t)?t:Po(t)?t.commonAncestorContainer:"function"==typeof t?Fh(t()):null}function Vh(t={}){const{sideOffset:e=jh.arrowSideOffset,heightOffset:n=jh.arrowHeightOffset,stickyVerticalOffset:o=jh.stickyVerticalOffset,config:i}=t;return {northWestArrowSouthWest:(t,n)=>({top:r(t,n),left:t.left-e,name:"arrow_sw",...i&&{config:i}}),northWestArrowSouthMiddleWest:(t,n)=>({top:r(t,n),left:t.left-.25*n.width-e,name:"arrow_smw",...i&&{config:i}}),northWestArrowSouth:(t,e)=>({top:r(t,e),left:t.left-e.width/2,name:"arrow_s",...i&&{config:i}}),northWestArrowSouthMiddleEast:(t,n)=>({top:r(t,n),left:t.left-.75*n.width+e,name:"arrow_sme",...i&&{config:i}}),northWestArrowSouthEast:(t,n)=>({top:r(t,n),left:t.left-n.width+e,name:"arrow_se",...i&&{config:i}}),northArrowSouthWest:(t,n)=>({top:r(t,n),left:t.left+t.width/2-e,name:"arrow_sw",...i&&{config:i}}),northArrowSouthMiddleWest:(t,n)=>({top:r(t,n),left:t.left+t.width/2-.25*n.width-e,name:"arrow_smw",...i&&{config:i}}),northArrowSouth:(t,e)=>({top:r(t,e),left:t.left+t.width/2-e.width/2,name:"arrow_s",...i&&{config:i}}),northArrowSouthMiddleEast:(t,n)=>({top:r(t,n),left:t.left+t.width/2-.75*n.width+e,name:"arrow_sme",...i&&{config:i}}),northArrowSouthEast:(t,n)=>({top:r(t,n),left:t.left+t.width/2-n.width+e,name:"arrow_se",...i&&{config:i}}),northEastArrowSouthWest:(t,n)=>({top:r(t,n),left:t.right-e,name:"arrow_sw",...i&&{config:i}}),northEastArrowSouthMiddleWest:(t,n)=>({top:r(t,n),left:t.right-.25*n.width-e,name:"arrow_smw",...i&&{config:i}}),northEastArrowSouth:(t,e)=>({top:r(t,e),left:t.right-e.width/2,name:"arrow_s",...i&&{config:i}}),northEastArrowSouthMiddleEast:(t,n)=>({top:r(t,n),left:t.right-.75*n.width+e,name:"arrow_sme",...i&&{config:i}}),northEastArrowSouthEast:(t,n)=>({top:r(t,n),left:t.right-n.width+e,name:"arrow_se",...i&&{config:i}}),southWestArrowNorthWest:t=>({top:s(t),left:t.left-e,name:"arrow_nw",...i&&{config:i}}),southWestArrowNorthMiddleWest:(t,n)=>({top:s(t),left:t.left-.25*n.width-e,name:"arrow_nmw",...i&&{config:i}}),southWestArrowNorth:(t,e)=>({top:s(t),left:t.left-e.width/2,name:"arrow_n",...i&&{config:i}}),southWestArrowNorthMiddleEast:(t,n)=>({top:s(t),left:t.left-.75*n.width+e,name:"arrow_nme",...i&&{config:i}}),southWestArrowNorthEast:(t,n)=>({top:s(t),left:t.left-n.width+e,name:"arrow_ne",...i&&{config:i}}),southArrowNorthWest:t=>({top:s(t),left:t.left+t.width/2-e,name:"arrow_nw",...i&&{config:i}}),southArrowNorthMiddleWest:(t,n)=>({top:s(t),left:t.left+t.width/2-.25*n.width-e,name:"arrow_nmw",...i&&{config:i}}),southArrowNorth:(t,e)=>({top:s(t),left:t.left+t.width/2-e.width/2,name:"arrow_n",...i&&{config:i}}),southArrowNorthMiddleEast:(t,n)=>({top:s(t),left:t.left+t.width/2-.75*n.width+e,name:"arrow_nme",...i&&{config:i}}),southArrowNorthEast:(t,n)=>({top:s(t),left:t.left+t.width/2-n.width+e,name:"arrow_ne",...i&&{config:i}}),southEastArrowNorthWest:t=>({top:s(t),left:t.right-e,name:"arrow_nw",...i&&{config:i}}),southEastArrowNorthMiddleWest:(t,n)=>({top:s(t),left:t.right-.25*n.width-e,name:"arrow_nmw",...i&&{config:i}}),southEastArrowNorth:(t,e)=>({top:s(t),left:t.right-e.width/2,name:"arrow_n",...i&&{config:i}}),southEastArrowNorthMiddleEast:(t,n)=>({top:s(t),left:t.right-.75*n.width+e,name:"arrow_nme",...i&&{config:i}}),southEastArrowNorthEast:(t,n)=>({top:s(t),left:t.right-n.width+e,name:"arrow_ne",...i&&{config:i}}),westArrowEast:(t,e)=>({top:t.top+t.height/2-e.height/2,left:t.left-e.width-n,name:"arrow_e",...i&&{config:i}}),eastArrowWest:(t,e)=>({top:t.top+t.height/2-e.height/2,left:t.right+n,name:"arrow_w",...i&&{config:i}}),viewportStickyNorth:(t,e,n)=>t.getIntersection(n)?{top:n.top+o,left:t.left+t.width/2-e.width/2,name:"arrowless",config:{withArrow:!1,...i}}:null};function r(t,e){return t.top-e.height-n}function s(t){return t.bottom+n}}jh.arrowSideOffset=25,jh.arrowHeightOffset=10,jh.stickyVerticalOffset=20,jh._getOptimalPosition=$o,jh.defaultPositions=Vh();var Uh=n(3332),Hh={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Uh.Z,Hh);Uh.Z.locals;const Wh="ck-tooltip";class Gh extends(Do()){constructor(t){if(super(),Gh._editors.add(t),Gh._instance)return Gh._instance;Gh._instance=this,this.tooltipTextView=new Ph(t.locale),this.tooltipTextView.set("text",""),this.tooltipTextView.setTemplate({tag:"span",attributes:{class:["ck","ck-tooltip__text"]},children:[{text:this.tooltipTextView.bindTemplate.to("text")}]}),this.balloonPanelView=new jh(t.locale),this.balloonPanelView.class=Wh,this.balloonPanelView.content.add(this.tooltipTextView),this._resizeObserver=null,this._currentElementWithTooltip=null,this._currentTooltipPosition=null,this._pinTooltipDebounced=Ia(this._pinTooltip,600),this.listenTo(So.document,"mouseenter",this._onEnterOrFocus.bind(this),{useCapture:!0}),this.listenTo(So.document,"mouseleave",this._onLeaveOrBlur.bind(this),{useCapture:!0}),this.listenTo(So.document,"focus",this._onEnterOrFocus.bind(this),{useCapture:!0}),this.listenTo(So.document,"blur",this._onLeaveOrBlur.bind(this),{useCapture:!0}),this.listenTo(So.document,"scroll",this._onScroll.bind(this),{useCapture:!0}),this._watchdogExcluded=!0;}destroy(t){const e=t.ui.view&&t.ui.view.body;Gh._editors.delete(t),this.stopListening(t.ui),e&&e.has(this.balloonPanelView)&&e.remove(this.balloonPanelView),Gh._editors.size||(this._unpinTooltip(),this.balloonPanelView.destroy(),this.stopListening(),Gh._instance=null);}static getPositioningFunctions(t){const e=Gh.defaultBalloonPositions;return {s:[e.southArrowNorth,e.southArrowNorthEast,e.southArrowNorthWest],n:[e.northArrowSouth],e:[e.eastArrowWest],w:[e.westArrowEast],sw:[e.southArrowNorthEast],se:[e.southArrowNorthWest]}[t]}_onEnterOrFocus(t,{target:e}){const n=qh(e);var o;n&&(n!==this._currentElementWithTooltip&&(this._unpinTooltip(),this._pinTooltipDebounced(n,{text:(o=n).dataset.ckeTooltipText,position:o.dataset.ckeTooltipPosition||"s",cssClass:o.dataset.ckeTooltipClass||""})));}_onLeaveOrBlur(t,{target:e,relatedTarget:n}){if("mouseleave"===t.name){if(!_o(e))return;if(this._currentElementWithTooltip&&e!==this._currentElementWithTooltip)return;const t=qh(e),o=qh(n);t&&t!==o&&this._unpinTooltip();}else {if(this._currentElementWithTooltip&&e!==this._currentElementWithTooltip)return;this._unpinTooltip();}}_onScroll(t,{target:e}){this._currentElementWithTooltip&&(e.contains(this.balloonPanelView.element)&&e.contains(this._currentElementWithTooltip)||this._unpinTooltip());}_pinTooltip(t,{text:e,position:n,cssClass:o}){const i=Ai(Gh._editors.values()).ui.view.body;i.has(this.balloonPanelView)||i.add(this.balloonPanelView),this.tooltipTextView.text=e,this.balloonPanelView.pin({target:t,positions:Gh.getPositioningFunctions(n)}),this._resizeObserver=new Vo(t,(()=>{Yo(t)||this._unpinTooltip();})),this.balloonPanelView.class=[Wh,o].filter((t=>t)).join(" ");for(const t of Gh._editors)this.listenTo(t.ui,"update",this._updateTooltipPosition.bind(this),{priority:"low"});this._currentElementWithTooltip=t,this._currentTooltipPosition=n;}_unpinTooltip(){this._pinTooltipDebounced.cancel(),this.balloonPanelView.unpin();for(const t of Gh._editors)this.stopListening(t.ui,"update");this._currentElementWithTooltip=null,this._currentTooltipPosition=null,this._resizeObserver&&this._resizeObserver.destroy();}_updateTooltipPosition(){Yo(this._currentElementWithTooltip)?this.balloonPanelView.pin({target:this._currentElementWithTooltip,positions:Gh.getPositioningFunctions(this._currentTooltipPosition)}):this._unpinTooltip();}}function qh(t){return _o(t)?t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])"):null}Gh.defaultBalloonPositions=Vh({heightOffset:5,sideOffset:13}),Gh._editors=new Set,Gh._instance=null;class Yh extends(H()){constructor(t){super(),this.editor=t,this.componentFactory=new ch(t),this.focusTracker=new Ci,this.tooltipManager=new Gh(t),this.set("viewportOffset",this._readViewportOffsetFromConfig()),this.isReady=!1,this.once("ready",(()=>{this.isReady=!0;})),this._editableElementsMap=new Map,this._focusableToolbarDefinitions=[],this.listenTo(t.editing.view.document,"layoutChanged",(()=>this.update())),this._initFocusTracking();}get element(){return null}update(){this.fire("update");}destroy(){this.stopListening(),this.focusTracker.destroy(),this.tooltipManager.destroy(this.editor);for(const t of this._editableElementsMap.values())t.ckeditorInstance=null;this._editableElementsMap=new Map,this._focusableToolbarDefinitions=[];}setEditableElement(t,e){this._editableElementsMap.set(t,e),e.ckeditorInstance||(e.ckeditorInstance=this.editor),this.focusTracker.add(e);const n=()=>{this.editor.editing.view.getDomRoot(t)||this.editor.keystrokes.listenTo(e);};this.isReady?n():this.once("ready",n);}getEditableElement(t="main"){return this._editableElementsMap.get(t)}getEditableElementsNames(){return this._editableElementsMap.keys()}addToolbar(t,e={}){t.isRendered?(this.focusTracker.add(t.element),this.editor.keystrokes.listenTo(t.element)):t.once("render",(()=>{this.focusTracker.add(t.element),this.editor.keystrokes.listenTo(t.element);})),this._focusableToolbarDefinitions.push({toolbarView:t,options:e});}get _editableElements(){return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",{editorUI:this}),this._editableElementsMap}_readViewportOffsetFromConfig(){const t=this.editor,e=t.config.get("ui.viewportOffset");if(e)return e;const n=t.config.get("toolbar.viewportTopOffset");return n?(console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."),{top:n}):{top:0}}_initFocusTracking(){const t=this.editor,e=t.editing.view;let n,o;t.keystrokes.set("Alt+F10",((t,i)=>{const r=this.focusTracker.focusedElement;Array.from(this._editableElementsMap.values()).includes(r)&&!Array.from(e.domRoots.values()).includes(r)&&(n=r);const s=this._getCurrentFocusedToolbarDefinition();s&&o||(o=this._getFocusableCandidateToolbarDefinitions());for(let t=0;t<o.length;t++){const t=o.shift();if(o.push(t),t!==s&&this._focusFocusableCandidateToolbar(t)){s&&s.options.afterBlur&&s.options.afterBlur();break}}i();})),t.keystrokes.set("Esc",((e,o)=>{const i=this._getCurrentFocusedToolbarDefinition();i&&(n?(n.focus(),n=null):t.editing.view.focus(),i.options.afterBlur&&i.options.afterBlur(),o());}));}_getFocusableCandidateToolbarDefinitions(){const t=[];for(const e of this._focusableToolbarDefinitions){const{toolbarView:n,options:o}=e;(Yo(n.element)||o.beforeFocus)&&t.push(e);}return t.sort(((t,e)=>$h(t)-$h(e))),t}_getCurrentFocusedToolbarDefinition(){for(const t of this._focusableToolbarDefinitions)if(t.toolbarView.element&&t.toolbarView.element.contains(this.focusTracker.focusedElement))return t;return null}_focusFocusableCandidateToolbar(t){const{toolbarView:e,options:{beforeFocus:n}}=t;return n&&n(),!!Yo(e.element)&&(e.focus(),!0)}}function $h(t){const{toolbarView:e,options:n}=t;let o=10;return Yo(e.element)&&o--,n.isContextual&&o--,o}function Kh(t){return class extends t{setData(t){this.data.set(t);}getData(t){return this.data.get(t)}}}{const t=Kh(Object);Kh.setData=t.prototype.setData,Kh.getData=t.prototype.getData;}function Qh(t){return class extends t{updateSourceElement(t=this.data.get()){if(!this.sourceElement)throw new k("editor-missing-sourceelement",this);const e=this.config.get("updateSourceElementOnDestroy"),n=this.sourceElement instanceof HTMLTextAreaElement;Uo(this.sourceElement,e||n?t:"");}}}Qh.updateSourceElement=Qh(Object).prototype.updateSourceElement;class Zh extends Li{static get pluginName(){return "PendingActions"}init(){this.set("hasAny",!1),this._actions=new _i({idProperty:"_id"}),this._actions.delegate("add","remove").to(this);}add(t){if("string"!=typeof t)throw new k("pendingactions-add-invalid-message",this);const e=new(H());return e.set("message",t),this._actions.add(e),this.hasAny=!0,e}remove(t){this._actions.remove(t),this.hasAny=!!this._actions.length;}get first(){return this._actions.get(0)}[Symbol.iterator](){return this._actions[Symbol.iterator]()}}const Jh={bold:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',cancel:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',caption:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',check:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',cog:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',eraser:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',image:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',lowVision:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',importExport:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',paragraph:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',plus:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',text:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',alignBottom:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',alignMiddle:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',alignTop:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',alignLeft:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',alignCenter:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',alignRight:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',alignJustify:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',objectLeft:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',objectCenter:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',objectRight:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',objectFullWidth:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',objectInline:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',objectBlockLeft:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',objectBlockRight:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',objectSizeFull:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',objectSizeLarge:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',objectSizeSmall:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',objectSizeMedium:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',pencil:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',pilcrow:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',quote:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',threeVerticalDots:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'};function Xh({emitter:t,activator:e,callback:n,contextElements:o}){t.listenTo(document,"mousedown",((t,i)=>{if(!e())return;const r="function"==typeof i.composedPath?i.composedPath():[];for(const t of o)if(t.contains(i.target)||r.includes(t))return;n();}));}function tu(t){const e=t;e.set("_isCssTransitionsDisabled",!1),e.disableCssTransitions=()=>{e._isCssTransitionsDisabled=!0;},e.enableCssTransitions=()=>{e._isCssTransitionsDisabled=!1;},e.extendTemplate({attributes:{class:[e.bindTemplate.if("_isCssTransitionsDisabled","ck-transitions-disabled")]}});}function eu({view:t}){t.listenTo(t.element,"submit",((e,n)=>{n.preventDefault(),t.fire("submit");}),{useCapture:!0});}class nu extends dh{constructor(t,e=[]){super(e),this.locale=t;}attachToDom(){this._bodyCollectionContainer=new hh({tag:"div",attributes:{class:["ck","ck-reset_all","ck-body","ck-rounded-corners"],dir:this.locale.uiLanguageDirection},children:this}).render();let t=document.querySelector(".ck-body-wrapper");t||(t=mt(document,"div",{class:"ck-body-wrapper"}),document.body.appendChild(t)),t.appendChild(this._bodyCollectionContainer);}detachFromDom(){super.destroy(),this._bodyCollectionContainer&&this._bodyCollectionContainer.remove();const t=document.querySelector(".ck-body-wrapper");t&&0==t.childElementCount&&t.remove();}}var ou=n(6574),iu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(ou.Z,iu);ou.Z.locals;class ru extends Ph{constructor(){super();const t=this.bindTemplate;this.set("content",""),this.set("viewBox","0 0 20 20"),this.set("fillColor",""),this.set("isColorInherited",!0),this.setTemplate({tag:"svg",ns:"http://www.w3.org/2000/svg",attributes:{class:["ck","ck-icon","ck-reset_all-excluded",t.if("isColorInherited","ck-icon_inherit-color")],viewBox:t.to("viewBox")}});}render(){super.render(),this._updateXMLContent(),this._colorFillPaths(),this.on("change:content",(()=>{this._updateXMLContent(),this._colorFillPaths();})),this.on("change:fillColor",(()=>{this._colorFillPaths();}));}_updateXMLContent(){if(this.content){const t=(new DOMParser).parseFromString(this.content.trim(),"image/svg+xml").querySelector("svg"),e=t.getAttribute("viewBox");e&&(this.viewBox=e);for(const{name:e,value:n}of Array.from(t.attributes))ru.presentationalAttributeNames.includes(e)&&this.element.setAttribute(e,n);for(;this.element.firstChild;)this.element.removeChild(this.element.firstChild);for(;t.childNodes.length>0;)this.element.appendChild(t.childNodes[0]);}}_colorFillPaths(){this.fillColor&&this.element.querySelectorAll(".ck-icon__fill").forEach((t=>{t.style.fill=this.fillColor;}));}}ru.presentationalAttributeNames=["alignment-baseline","baseline-shift","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-rendering","cursor","direction","display","dominant-baseline","fill","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","lighting-color","marker-end","marker-mid","marker-start","mask","opacity","overflow","paint-order","pointer-events","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-overflow","text-rendering","transform","unicode-bidi","vector-effect","visibility","white-space","word-spacing","writing-mode"];var su=n(4906),au={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(su.Z,au);su.Z.locals;class cu extends Ph{constructor(t){super(t);const e=this.bindTemplate,n=m();this.set("class",void 0),this.set("labelStyle",void 0),this.set("icon",void 0),this.set("isEnabled",!0),this.set("isOn",!1),this.set("isVisible",!0),this.set("isToggleable",!1),this.set("keystroke",void 0),this.set("label",void 0),this.set("tabindex",-1),this.set("tooltip",!1),this.set("tooltipPosition","s"),this.set("type","button"),this.set("withText",!1),this.set("withKeystroke",!1),this.children=this.createCollection(),this.labelView=this._createLabelView(n),this.iconView=new ru,this.iconView.extendTemplate({attributes:{class:"ck-button__icon"}}),this.keystrokeView=this._createKeystrokeView(),this.bind("_tooltipString").to(this,"tooltip",this,"label",this,"keystroke",this._getTooltipString.bind(this));const o={tag:"button",attributes:{class:["ck","ck-button",e.to("class"),e.if("isEnabled","ck-disabled",(t=>!t)),e.if("isVisible","ck-hidden",(t=>!t)),e.to("isOn",(t=>t?"ck-on":"ck-off")),e.if("withText","ck-button_with-text"),e.if("withKeystroke","ck-button_with-keystroke")],type:e.to("type",(t=>t||"button")),tabindex:e.to("tabindex"),"aria-labelledby":`ck-editor__aria-label_${n}`,"aria-disabled":e.if("isEnabled",!0,(t=>!t)),"aria-pressed":e.to("isOn",(t=>!!this.isToggleable&&String(!!t))),"data-cke-tooltip-text":e.to("_tooltipString"),"data-cke-tooltip-position":e.to("tooltipPosition")},children:this.children,on:{click:e.to((t=>{this.isEnabled?this.fire("execute"):t.preventDefault();}))}};i.isSafari&&(o.on.mousedown=e.to((t=>{this.focus(),t.preventDefault();}))),this.setTemplate(o);}render(){super.render(),this.icon&&(this.iconView.bind("content").to(this,"icon"),this.children.add(this.iconView)),this.children.add(this.labelView),this.withKeystroke&&this.keystroke&&this.children.add(this.keystrokeView);}focus(){this.element.focus();}_createLabelView(t){const e=new Ph,n=this.bindTemplate;return e.setTemplate({tag:"span",attributes:{class:["ck","ck-button__label"],style:n.to("labelStyle"),id:`ck-editor__aria-label_${t}`},children:[{text:this.bindTemplate.to("label")}]}),e}_createKeystrokeView(){const t=new Ph;return t.setTemplate({tag:"span",attributes:{class:["ck","ck-button__keystroke"]},children:[{text:this.bindTemplate.to("keystroke",(t=>gi(t)))}]}),t}_getTooltipString(t,e,n){return t?"string"==typeof t?t:(n&&(n=gi(n)),t instanceof Function?t(e,n):`${e}${n?` (${n})`:""}`):""}}var lu=n(5332),du={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(lu.Z,du);lu.Z.locals;class hu extends cu{constructor(t){super(t),this.isToggleable=!0,this.toggleSwitchView=this._createToggleView(),this.extendTemplate({attributes:{class:"ck-switchbutton"}});}render(){super.render(),this.children.add(this.toggleSwitchView);}_createToggleView(){const t=new Ph;return t.setTemplate({tag:"span",attributes:{class:["ck","ck-button__toggle"]},children:[{tag:"span",attributes:{class:["ck","ck-button__toggle__inner"]}}]}),t}}var uu=n(6781),gu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(uu.Z,gu);uu.Z.locals;const mu='<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';class pu extends cu{constructor(t){super(t),this.arrowView=this._createArrowView(),this.extendTemplate({attributes:{"aria-haspopup":!0,"aria-expanded":this.bindTemplate.to("isOn",(t=>String(t)))}}),this.delegate("execute").to(this,"open");}render(){super.render(),this.children.add(this.arrowView);}_createArrowView(){const t=new ru;return t.content=mu,t.extendTemplate({attributes:{class:"ck-dropdown__arrow"}}),t}}var fu=n(7686),ku={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(fu.Z,ku);fu.Z.locals;class bu extends Ph{constructor(t){super(t);const e=this.bindTemplate;this.set("class",void 0),this.set("labelStyle",void 0),this.set("icon",void 0),this.set("isEnabled",!0),this.set("isOn",!1),this.set("isToggleable",!1),this.set("isVisible",!0),this.set("keystroke",void 0),this.set("withKeystroke",!1),this.set("label",void 0),this.set("tabindex",-1),this.set("tooltip",!1),this.set("tooltipPosition","s"),this.set("type","button"),this.set("withText",!1),this.children=this.createCollection(),this.actionView=this._createActionView(),this.arrowView=this._createArrowView(),this.keystrokes=new vi,this.focusTracker=new Ci,this.setTemplate({tag:"div",attributes:{class:["ck","ck-splitbutton",e.to("class"),e.if("isVisible","ck-hidden",(t=>!t)),this.arrowView.bindTemplate.if("isOn","ck-splitbutton_open")]},children:this.children});}render(){super.render(),this.children.add(this.actionView),this.children.add(this.arrowView),this.focusTracker.add(this.actionView.element),this.focusTracker.add(this.arrowView.element),this.keystrokes.listenTo(this.element),this.keystrokes.set("arrowright",((t,e)=>{this.focusTracker.focusedElement===this.actionView.element&&(this.arrowView.focus(),e());})),this.keystrokes.set("arrowleft",((t,e)=>{this.focusTracker.focusedElement===this.arrowView.element&&(this.actionView.focus(),e());}));}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}focus(){this.actionView.focus();}_createActionView(){const t=new cu;return t.bind("icon","isEnabled","isOn","isToggleable","keystroke","label","tabindex","tooltip","tooltipPosition","type","withText").to(this),t.extendTemplate({attributes:{class:"ck-splitbutton__action"}}),t.delegate("execute").to(this),t}_createArrowView(){const t=new cu,e=t.bindTemplate;return t.icon=mu,t.extendTemplate({attributes:{class:["ck-splitbutton__arrow"],"data-cke-tooltip-disabled":e.to("isOn"),"aria-haspopup":!0,"aria-expanded":e.to("isOn",(t=>String(t)))}}),t.bind("isEnabled").to(this),t.bind("label").to(this),t.bind("tooltip").to(this),t.delegate("execute").to(this,"open"),t}}class wu extends Ph{constructor(t){super(t);const e=this.bindTemplate;this.set("isVisible",!1),this.set("position","se"),this.children=this.createCollection(),this.setTemplate({tag:"div",attributes:{class:["ck","ck-reset","ck-dropdown__panel",e.to("position",(t=>`ck-dropdown__panel_${t}`)),e.if("isVisible","ck-dropdown__panel-visible")]},children:this.children,on:{selectstart:e.to((t=>t.preventDefault()))}});}focus(){if(this.children.length){const t=this.children.first;"function"==typeof t.focus?t.focus():b("ui-dropdown-panel-focus-child-missing-focus",{childView:this.children.first,dropdownPanel:this});}}focusLast(){if(this.children.length){const t=this.children.last;"function"==typeof t.focusLast?t.focusLast():t.focus();}}}var _u=n(5485),Au={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(_u.Z,Au);_u.Z.locals;class Cu extends Ph{constructor(t,e,n){super(t);const o=this.bindTemplate;this.buttonView=e,this.panelView=n,this.set("isOpen",!1),this.set("isEnabled",!0),this.set("class",void 0),this.set("id",void 0),this.set("panelPosition","auto"),this.keystrokes=new vi,this.focusTracker=new Ci,this.setTemplate({tag:"div",attributes:{class:["ck","ck-dropdown",o.to("class"),o.if("isEnabled","ck-disabled",(t=>!t))],id:o.to("id"),"aria-describedby":o.to("ariaDescribedById")},children:[e,n]}),e.extendTemplate({attributes:{class:["ck-dropdown__button"],"data-cke-tooltip-disabled":o.to("isOpen")}});}render(){super.render(),this.focusTracker.add(this.buttonView.element),this.focusTracker.add(this.panelView.element),this.listenTo(this.buttonView,"open",(()=>{this.isOpen=!this.isOpen;})),this.panelView.bind("isVisible").to(this,"isOpen"),this.on("change:isOpen",((t,e,n)=>{n&&("auto"===this.panelPosition?this.panelView.position=Cu._getOptimalPosition({element:this.panelView.element,target:this.buttonView.element,fitInViewport:!0,positions:this._panelPositions}).name:this.panelView.position=this.panelPosition);})),this.keystrokes.listenTo(this.element);const t=(t,e)=>{this.isOpen&&(this.isOpen=!1,e());};this.keystrokes.set("arrowdown",((t,e)=>{this.buttonView.isEnabled&&!this.isOpen&&(this.isOpen=!0,e());})),this.keystrokes.set("arrowright",((t,e)=>{this.isOpen&&e();})),this.keystrokes.set("arrowleft",t),this.keystrokes.set("esc",t);}focus(){this.buttonView.focus();}get _panelPositions(){const{south:t,north:e,southEast:n,southWest:o,northEast:i,northWest:r,southMiddleEast:s,southMiddleWest:a,northMiddleEast:c,northMiddleWest:l}=Cu.defaultPanelPositions;return "rtl"!==this.locale.uiLanguageDirection?[n,o,s,a,t,i,r,c,l,e]:[o,n,a,s,t,r,i,l,c,e]}}Cu.defaultPanelPositions={south:(t,e)=>({top:t.bottom,left:t.left-(e.width-t.width)/2,name:"s"}),southEast:t=>({top:t.bottom,left:t.left,name:"se"}),southWest:(t,e)=>({top:t.bottom,left:t.left-e.width+t.width,name:"sw"}),southMiddleEast:(t,e)=>({top:t.bottom,left:t.left-(e.width-t.width)/4,name:"sme"}),southMiddleWest:(t,e)=>({top:t.bottom,left:t.left-3*(e.width-t.width)/4,name:"smw"}),north:(t,e)=>({top:t.top-e.height,left:t.left-(e.width-t.width)/2,name:"n"}),northEast:(t,e)=>({top:t.top-e.height,left:t.left,name:"ne"}),northWest:(t,e)=>({top:t.top-e.height,left:t.left-e.width+t.width,name:"nw"}),northMiddleEast:(t,e)=>({top:t.top-e.height,left:t.left-(e.width-t.width)/4,name:"nme"}),northMiddleWest:(t,e)=>({top:t.top-e.height,left:t.left-3*(e.width-t.width)/4,name:"nmw"})},Cu._getOptimalPosition=$o;class vu{constructor(t){if(this.focusables=t.focusables,this.focusTracker=t.focusTracker,this.keystrokeHandler=t.keystrokeHandler,this.actions=t.actions,t.actions&&t.keystrokeHandler)for(const e in t.actions){let n=t.actions[e];"string"==typeof n&&(n=[n]);for(const o of n)t.keystrokeHandler.set(o,((t,n)=>{this[e](),n();}));}}get first(){return this.focusables.find(yu)||null}get last(){return this.focusables.filter(yu).slice(-1)[0]||null}get next(){return this._getFocusableItem(1)}get previous(){return this._getFocusableItem(-1)}get current(){let t=null;return null===this.focusTracker.focusedElement?null:(this.focusables.find(((e,n)=>{const o=e.element===this.focusTracker.focusedElement;return o&&(t=n),o})),t)}focusFirst(){this._focus(this.first);}focusLast(){this._focus(this.last);}focusNext(){this._focus(this.next);}focusPrevious(){this._focus(this.previous);}_focus(t){t&&t.focus();}_getFocusableItem(t){const e=this.current,n=this.focusables.length;if(!n)return null;if(null===e)return this[1===t?"first":"last"];let o=(e+n+t)%n;do{const e=this.focusables.get(o);if(yu(e))return e;o=(o+n+t)%n;}while(o!==e);return null}}function yu(t){return !(!t.focus||!Yo(t.element))}class xu extends Ph{constructor(t){super(t),this.setTemplate({tag:"span",attributes:{class:["ck","ck-toolbar__separator"]}});}}class Eu extends Ph{constructor(t){super(t),this.setTemplate({tag:"span",attributes:{class:["ck","ck-toolbar__line-break"]}});}}function Du(t){return Array.isArray(t)?{items:t,removeItems:[]}:t?Object.assign({items:[],removeItems:[]},t):{items:[],removeItems:[]}}var Iu=n(5542),Mu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Iu.Z,Mu);Iu.Z.locals;const{threeVerticalDots:Tu}=Jh,Su={alignLeft:Jh.alignLeft,bold:Jh.bold,importExport:Jh.importExport,paragraph:Jh.paragraph,plus:Jh.plus,text:Jh.text,threeVerticalDots:Jh.threeVerticalDots};class Nu extends Ph{constructor(t,e){super(t);const n=this.bindTemplate,o=this.t;this.options=e||{},this.set("ariaLabel",o("Editor toolbar")),this.set("maxWidth","auto"),this.items=this.createCollection(),this.focusTracker=new Ci,this.keystrokes=new vi,this.set("class",void 0),this.set("isCompact",!1),this.itemsView=new Bu(t),this.children=this.createCollection(),this.children.add(this.itemsView),this.focusables=this.createCollection();const i="rtl"===t.uiLanguageDirection;this._focusCycler=new vu({focusables:this.focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:[i?"arrowright":"arrowleft","arrowup"],focusNext:[i?"arrowleft":"arrowright","arrowdown"]}});const r=["ck","ck-toolbar",n.to("class"),n.if("isCompact","ck-toolbar_compact")];var s;this.options.shouldGroupWhenFull&&this.options.isFloating&&r.push("ck-toolbar_floating"),this.setTemplate({tag:"div",attributes:{class:r,role:"toolbar","aria-label":n.to("ariaLabel"),style:{maxWidth:n.to("maxWidth")}},children:this.children,on:{mousedown:(s=this,s.bindTemplate.to((t=>{t.target===s.element&&t.preventDefault();})))}}),this._behavior=this.options.shouldGroupWhenFull?new zu(this):new Pu(this);}render(){super.render();for(const t of this.items)this.focusTracker.add(t.element);this.items.on("add",((t,e)=>{this.focusTracker.add(e.element);})),this.items.on("remove",((t,e)=>{this.focusTracker.remove(e.element);})),this.keystrokes.listenTo(this.element),this._behavior.render(this);}destroy(){return this._behavior.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy(),super.destroy()}focus(){this._focusCycler.focusFirst();}focusLast(){this._focusCycler.focusLast();}fillFromConfig(t,e,n){const o=Du(t),i=n||o.removeItems,r=this._cleanItemsConfiguration(o.items,e,i).map((t=>L(t)?this._createNestedToolbarDropdown(t,e,i):"|"===t?new xu:"-"===t?new Eu:e.create(t))).filter((t=>!!t));this.items.addMany(r);}_cleanItemsConfiguration(t,e,n){const o=t.filter(((t,o,i)=>"|"===t||-1===n.indexOf(t)&&("-"===t?!this.options.shouldGroupWhenFull||(b("toolbarview-line-break-ignored-when-grouping-items",i),!1):!(!L(t)&&!e.has(t))||(b("toolbarview-item-unavailable",{item:t}),!1))));return this._cleanSeparatorsAndLineBreaks(o)}_cleanSeparatorsAndLineBreaks(t){const e=t=>"-"!==t&&"|"!==t,n=t.length,o=t.findIndex(e);if(-1===o)return [];const i=n-t.slice().reverse().findIndex(e);return t.slice(o,i).filter(((t,n,o)=>{if(e(t))return !0;return !(n>0&&o[n-1]===t)}))}_createNestedToolbarDropdown(t,e,n){let{label:o,icon:i,items:r,tooltip:s=!0,withText:a=!1}=t;if(r=this._cleanItemsConfiguration(r,e,n),!r.length)return null;const c=Gu(this.locale);return o||b("toolbarview-nested-toolbar-dropdown-missing-label",t),c.class="ck-toolbar__nested-toolbar-dropdown",c.buttonView.set({label:o,tooltip:s,withText:!!a}),!1!==i?c.buttonView.icon=Su[i]||i||Tu:c.buttonView.withText=!0,qu(c,[]),c.toolbarView.fillFromConfig(r,e,n),c}}class Bu extends Ph{constructor(t){super(t),this.children=this.createCollection(),this.setTemplate({tag:"div",attributes:{class:["ck","ck-toolbar__items"]},children:this.children});}}class Pu{constructor(t){const e=t.bindTemplate;t.set("isVertical",!1),t.itemsView.children.bindTo(t.items).using((t=>t)),t.focusables.bindTo(t.items).using((t=>t)),t.extendTemplate({attributes:{class:[e.if("isVertical","ck-toolbar_vertical")]}});}render(){}destroy(){}}class zu{constructor(t){this.view=t,this.viewChildren=t.children,this.viewFocusables=t.focusables,this.viewItemsView=t.itemsView,this.viewFocusTracker=t.focusTracker,this.viewLocale=t.locale,this.ungroupedItems=t.createCollection(),this.groupedItems=t.createCollection(),this.groupedItemsDropdown=this._createGroupedItemsDropdown(),this.resizeObserver=null,this.cachedPadding=null,this.shouldUpdateGroupingOnNextResize=!1,t.itemsView.children.bindTo(this.ungroupedItems).using((t=>t)),this.ungroupedItems.on("change",this._updateFocusCycleableItems.bind(this)),t.children.on("change",this._updateFocusCycleableItems.bind(this)),t.items.on("change",((t,e)=>{const n=e.index,o=Array.from(e.added);for(const t of e.removed)n>=this.ungroupedItems.length?this.groupedItems.remove(t):this.ungroupedItems.remove(t);for(let t=n;t<n+o.length;t++){const e=o[t-n];t>this.ungroupedItems.length?this.groupedItems.add(e,t-this.ungroupedItems.length):this.ungroupedItems.add(e,t);}this._updateGrouping();})),t.extendTemplate({attributes:{class:["ck-toolbar_grouping"]}});}render(t){this.viewElement=t.element,this._enableGroupingOnResize(),this._enableGroupingOnMaxWidthChange(t);}destroy(){this.groupedItemsDropdown.destroy(),this.resizeObserver.destroy();}_updateGrouping(){if(!this.viewElement.ownerDocument.body.contains(this.viewElement))return;if(!Yo(this.viewElement))return void(this.shouldUpdateGroupingOnNextResize=!0);const t=this.groupedItems.length;let e;for(;this._areItemsOverflowing;)this._groupLastItem(),e=!0;if(!e&&this.groupedItems.length){for(;this.groupedItems.length&&!this._areItemsOverflowing;)this._ungroupFirstItem();this._areItemsOverflowing&&this._groupLastItem();}this.groupedItems.length!==t&&this.view.fire("groupedItemsUpdate");}get _areItemsOverflowing(){if(!this.ungroupedItems.length)return !1;const t=this.viewElement,e=this.viewLocale.uiLanguageDirection,n=new Oo(t.lastChild),o=new Oo(t);if(!this.cachedPadding){const n=So.window.getComputedStyle(t),o="ltr"===e?"paddingRight":"paddingLeft";this.cachedPadding=Number.parseInt(n[o]);}return "ltr"===e?n.right>o.right-this.cachedPadding:n.left<o.left+this.cachedPadding}_enableGroupingOnResize(){let t;this.resizeObserver=new Vo(this.viewElement,(e=>{t&&t===e.contentRect.width&&!this.shouldUpdateGroupingOnNextResize||(this.shouldUpdateGroupingOnNextResize=!1,this._updateGrouping(),t=e.contentRect.width);})),this._updateGrouping();}_enableGroupingOnMaxWidthChange(t){t.on("change:maxWidth",(()=>{this._updateGrouping();}));}_groupLastItem(){this.groupedItems.length||(this.viewChildren.add(new xu),this.viewChildren.add(this.groupedItemsDropdown),this.viewFocusTracker.add(this.groupedItemsDropdown.element)),this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last),0);}_ungroupFirstItem(){this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)),this.groupedItems.length||(this.viewChildren.remove(this.groupedItemsDropdown),this.viewChildren.remove(this.viewChildren.last),this.viewFocusTracker.remove(this.groupedItemsDropdown.element));}_createGroupedItemsDropdown(){const t=this.viewLocale,e=t.t,n=Gu(t);return n.class="ck-toolbar__grouped-dropdown",n.panelPosition="ltr"===t.uiLanguageDirection?"sw":"se",qu(n,[]),n.buttonView.set({label:e("Show more items"),tooltip:!0,tooltipPosition:"rtl"===t.uiLanguageDirection?"se":"sw",icon:Tu}),n.toolbarView.items.bindTo(this.groupedItems).using((t=>t)),n}_updateFocusCycleableItems(){this.viewFocusables.clear(),this.ungroupedItems.map((t=>{this.viewFocusables.add(t);})),this.groupedItems.length&&this.viewFocusables.add(this.groupedItemsDropdown);}}var Lu=n(1046),Ou={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Lu.Z,Ou);Lu.Z.locals;class Ru extends Ph{constructor(t){super(t),this.items=this.createCollection(),this.focusTracker=new Ci,this.keystrokes=new vi,this._focusCycler=new vu({focusables:this.items,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:"arrowup",focusNext:"arrowdown"}}),this.setTemplate({tag:"ul",attributes:{class:["ck","ck-reset","ck-list"]},children:this.items});}render(){super.render();for(const t of this.items)this.focusTracker.add(t.element);this.items.on("add",((t,e)=>{this.focusTracker.add(e.element);})),this.items.on("remove",((t,e)=>{this.focusTracker.remove(e.element);})),this.keystrokes.listenTo(this.element);}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}focus(){this._focusCycler.focusFirst();}focusLast(){this._focusCycler.focusLast();}}class ju extends Ph{constructor(t){super(t);const e=this.bindTemplate;this.set("isVisible",!0),this.children=this.createCollection(),this.setTemplate({tag:"li",attributes:{class:["ck","ck-list__item",e.if("isVisible","ck-hidden",(t=>!t))]},children:this.children});}focus(){this.children.first.focus();}}class Fu extends Ph{constructor(t){super(t),this.setTemplate({tag:"li",attributes:{class:["ck","ck-list__separator"]}});}}var Vu=n(7339),Uu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Vu.Z,Uu);Vu.Z.locals;var Hu=n(3949),Wu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Hu.Z,Wu);Hu.Z.locals;function Gu(t,e=pu){const n=new e(t),o=new wu(t),i=new Cu(t,n,o);return n.bind("isEnabled").to(i),n instanceof bu?n.arrowView.bind("isOn").to(i,"isOpen"):n.bind("isOn").to(i,"isOpen"),function(t){((function(t){t.on("render",(()=>{Xh({emitter:t,activator:()=>t.isOpen,callback:()=>{t.isOpen=!1;},contextElements:[t.element]});}));}))(t),function(t){t.on("execute",(e=>{e.source instanceof hu||(t.isOpen=!1);}));}(t),function(t){t.focusTracker.on("change:isFocused",((e,n,o)=>{t.isOpen&&!o&&(t.isOpen=!1);}));}(t),function(t){t.keystrokes.set("arrowdown",((e,n)=>{t.isOpen&&(t.panelView.focus(),n());})),t.keystrokes.set("arrowup",((e,n)=>{t.isOpen&&(t.panelView.focusLast(),n());}));}(t),function(t){t.on("change:isOpen",((e,n,o)=>{o||t.panelView.element.contains(So.document.activeElement)&&t.buttonView.focus();}));}(t),function(t){t.on("change:isOpen",((e,n,o)=>{o&&t.panelView.focus();}),{priority:"low"});}(t);}(i),i}function qu(t,e,n={}){const o=t.locale,i=o.t,r=t.toolbarView=new Nu(o);r.set("ariaLabel",i("Dropdown toolbar")),t.extendTemplate({attributes:{class:["ck-toolbar-dropdown"]}}),e.map((t=>r.items.add(t))),n.enableActiveItemFocusOnDropdownOpen&&$u(t,(()=>r.items.find((t=>t.isOn)))),t.panelView.children.add(r),r.items.delegate("execute").to(t);}function Yu(t,e){const n=t.locale,o=t.listView=new Ru(n);o.items.bindTo(e).using((t=>{if("separator"===t.type)return new Fu(n);if("button"===t.type||"switchbutton"===t.type){const e=new ju(n);let o;return o="button"===t.type?new cu(n):new hu(n),o.bind(...Object.keys(t.model)).to(t.model),o.delegate("execute").to(e),e.children.add(o),e}return null})),t.panelView.children.add(o),o.items.delegate("execute").to(t),$u(t,(()=>o.items.find((t=>t instanceof ju&&t.children.first.isOn))));}function $u(t,e){t.on("change:isOpen",(()=>{if(!t.isOpen)return;const n=e();n&&("function"==typeof n.focus?n.focus():b("ui-dropdown-focus-child-on-open-child-missing-focus",{view:n}));}),{priority:p.low-10});}var Ku=n(9688),Qu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Ku.Z,Qu);Ku.Z.locals;class Zu extends Ph{constructor(t){super(t),this.body=new nu(t);}render(){super.render(),this.body.attachToDom();}destroy(){return this.body.detachFromDom(),super.destroy()}}var Ju=n(3662),Xu={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Ju.Z,Xu);Ju.Z.locals;class tg extends Ph{constructor(t){super(t),this.set("text",void 0),this.set("for",void 0),this.id=`ck-editor__label_${m()}`;const e=this.bindTemplate;this.setTemplate({tag:"label",attributes:{class:["ck","ck-label"],id:this.id,for:e.to("for")},children:[{text:e.to("text")}]});}}class eg extends Ph{constructor(t,e,n){super(t),this.setTemplate({tag:"div",attributes:{class:["ck","ck-content","ck-editor__editable","ck-rounded-corners"],lang:t.contentLanguage,dir:t.contentLanguageDirection}}),this.name=null,this.set("isFocused",!1),this._editableElement=n,this._hasExternalElement=!!this._editableElement,this._editingView=e;}render(){super.render(),this._hasExternalElement?this.template.apply(this.element=this._editableElement):this._editableElement=this.element,this.on("change:isFocused",(()=>this._updateIsFocusedClasses())),this._updateIsFocusedClasses();}destroy(){this._hasExternalElement&&this.template.revert(this._editableElement),super.destroy();}_updateIsFocusedClasses(){const t=this._editingView;function e(e){t.change((n=>{const o=t.document.getRoot(e.name);n.addClass(e.isFocused?"ck-focused":"ck-blurred",o),n.removeClass(e.isFocused?"ck-blurred":"ck-focused",o);}));}t.isRenderingInProgress?function n(o){t.once("change:isRenderingInProgress",((t,i,r)=>{r?n(o):e(o);}));}(this):e(this);}}class ng extends eg{constructor(t,e,n,o={}){super(t,e,n);const i=t.t;this.extendTemplate({attributes:{role:"textbox",class:"ck-editor__editable_inline"}}),this._generateLabel=o.label||(()=>i("Editor editing area: %0",this.name));}render(){super.render();const t=this._editingView;t.change((e=>{const n=t.document.getRoot(this.name);e.setAttribute("aria-label",this._generateLabel(this),n);}));}}var og=n(8847),ig={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(og.Z,ig);og.Z.locals;var rg=n(4879),sg={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(rg.Z,sg);rg.Z.locals;class ag extends Ph{constructor(t){super(t),this.set("value",void 0),this.set("id",void 0),this.set("placeholder",void 0),this.set("isReadOnly",!1),this.set("hasError",!1),this.set("ariaDescribedById",void 0),this.focusTracker=new Ci,this.bind("isFocused").to(this.focusTracker),this.set("isEmpty",!0),this.set("inputMode","text");const e=this.bindTemplate;this.setTemplate({tag:"input",attributes:{class:["ck","ck-input",e.if("isFocused","ck-input_focused"),e.if("isEmpty","ck-input-text_empty"),e.if("hasError","ck-error")],id:e.to("id"),placeholder:e.to("placeholder"),readonly:e.to("isReadOnly"),inputmode:e.to("inputMode"),"aria-invalid":e.if("hasError",!0),"aria-describedby":e.to("ariaDescribedById")},on:{input:e.to(((...t)=>{this.fire("input",...t),this._updateIsEmpty();})),change:e.to(this._updateIsEmpty.bind(this))}});}render(){super.render(),this.focusTracker.add(this.element),this._setDomElementValue(this.value),this._updateIsEmpty(),this.on("change:value",((t,e,n)=>{this._setDomElementValue(n),this._updateIsEmpty();}));}destroy(){super.destroy(),this.focusTracker.destroy();}select(){this.element.select();}focus(){this.element.focus();}_updateIsEmpty(){this.isEmpty=!this.element.value;}_setDomElementValue(t){this.element.value=t||0===t?t:"";}}class cg extends ag{constructor(t){super(t),this.extendTemplate({attributes:{type:"text",class:["ck-input-text"]}});}}var lg=n(2577),dg={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(lg.Z,dg);lg.Z.locals;class hg extends Ph{constructor(t,e){super(t);const n=`ck-labeled-field-view-${m()}`,o=`ck-labeled-field-view-status-${m()}`;this.fieldView=e(this,n,o),this.set("label",void 0),this.set("isEnabled",!0),this.set("isEmpty",!0),this.set("isFocused",!1),this.set("errorText",null),this.set("infoText",null),this.set("class",void 0),this.set("placeholder",void 0),this.labelView=this._createLabelView(n),this.statusView=this._createStatusView(o),this.fieldWrapperChildren=this.createCollection([this.fieldView,this.labelView]),this.bind("_statusText").to(this,"errorText",this,"infoText",((t,e)=>t||e));const i=this.bindTemplate;this.setTemplate({tag:"div",attributes:{class:["ck","ck-labeled-field-view",i.to("class"),i.if("isEnabled","ck-disabled",(t=>!t)),i.if("isEmpty","ck-labeled-field-view_empty"),i.if("isFocused","ck-labeled-field-view_focused"),i.if("placeholder","ck-labeled-field-view_placeholder"),i.if("errorText","ck-error")]},children:[{tag:"div",attributes:{class:["ck","ck-labeled-field-view__input-wrapper"]},children:this.fieldWrapperChildren},this.statusView]});}_createLabelView(t){const e=new tg(this.locale);return e.for=t,e.bind("text").to(this,"label"),e}_createStatusView(t){const e=new Ph(this.locale),n=this.bindTemplate;return e.setTemplate({tag:"div",attributes:{class:["ck","ck-labeled-field-view__status",n.if("errorText","ck-labeled-field-view__status_error"),n.if("_statusText","ck-hidden",(t=>!t))],id:t,role:n.if("errorText","alert")},children:[{text:n.to("_statusText")}]}),e}focus(){this.fieldView.focus();}}function ug(t,e,n){const o=new cg(t.locale);return o.set({id:e,ariaDescribedById:n}),o.bind("isReadOnly").to(t,"isEnabled",(t=>!t)),o.bind("hasError").to(t,"errorText",(t=>!!t)),o.on("input",(()=>{t.errorText=null;})),t.bind("isEmpty","isFocused","placeholder").to(o),o}class gg extends Li{static get pluginName(){return "Notification"}init(){this.on("show:warning",((t,e)=>{window.alert(e.message);}),{priority:"lowest"});}showSuccess(t,e={}){this._showNotification({message:t,type:"success",namespace:e.namespace,title:e.title});}showInfo(t,e={}){this._showNotification({message:t,type:"info",namespace:e.namespace,title:e.title});}showWarning(t,e={}){this._showNotification({message:t,type:"warning",namespace:e.namespace,title:e.title});}_showNotification(t){const e=t.namespace?`show:${t.type}:${t.namespace}`:`show:${t.type}`;this.fire(e,{message:t.message,type:t.type,title:t.title||""});}}class mg extends(H()){constructor(t,e){super(),e&&ua(this,e),t&&this.set(t);}}var pg=n(4650),fg={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(pg.Z,fg);pg.Z.locals;var kg=n(7676),bg={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(kg.Z,bg);kg.Z.locals;const wg=Ho("px");class _g extends Mi{static get pluginName(){return "ContextualBalloon"}constructor(t){super(t),this.positionLimiter=()=>{const t=this.editor.editing.view,e=t.document.selection.editableElement;return e?t.domConverter.mapViewToDom(e.root):null},this.set("visibleView",null),this.view=new jh(t.locale),t.ui.view.body.add(this.view),t.ui.focusTracker.add(this.view.element),this._viewToStack=new Map,this._idToStack=new Map,this.set("_numberOfStacks",0),this.set("_singleViewMode",!1),this._rotatorView=this._createRotatorView(),this._fakePanelsView=this._createFakePanelsView();}destroy(){super.destroy(),this.view.destroy(),this._rotatorView.destroy(),this._fakePanelsView.destroy();}hasView(t){return Array.from(this._viewToStack.keys()).includes(t)}add(t){if(this.hasView(t.view))throw new k("contextualballoon-add-view-exist",[this,t]);const e=t.stackId||"main";if(!this._idToStack.has(e))return this._idToStack.set(e,new Map([[t.view,t]])),this._viewToStack.set(t.view,this._idToStack.get(e)),this._numberOfStacks=this._idToStack.size,void(this._visibleStack&&!t.singleViewMode||this.showStack(e));const n=this._idToStack.get(e);t.singleViewMode&&this.showStack(e),n.set(t.view,t),this._viewToStack.set(t.view,n),n===this._visibleStack&&this._showView(t);}remove(t){if(!this.hasView(t))throw new k("contextualballoon-remove-view-not-exist",[this,t]);const e=this._viewToStack.get(t);this._singleViewMode&&this.visibleView===t&&(this._singleViewMode=!1),this.visibleView===t&&(1===e.size?this._idToStack.size>1?this._showNextStack():(this.view.hide(),this.visibleView=null,this._rotatorView.hideView()):this._showView(Array.from(e.values())[e.size-2])),1===e.size?(this._idToStack.delete(this._getStackId(e)),this._numberOfStacks=this._idToStack.size):e.delete(t),this._viewToStack.delete(t);}updatePosition(t){t&&(this._visibleStack.get(this.visibleView).position=t),this.view.pin(this._getBalloonPosition()),this._fakePanelsView.updatePosition();}showStack(t){this.visibleStack=t;const e=this._idToStack.get(t);if(!e)throw new k("contextualballoon-showstack-stack-not-exist",this);this._visibleStack!==e&&this._showView(Array.from(e.values()).pop());}get _visibleStack(){return this._viewToStack.get(this.visibleView)}_getStackId(t){return Array.from(this._idToStack.entries()).find((e=>e[1]===t))[0]}_showNextStack(){const t=Array.from(this._idToStack.values());let e=t.indexOf(this._visibleStack)+1;t[e]||(e=0),this.showStack(this._getStackId(t[e]));}_showPrevStack(){const t=Array.from(this._idToStack.values());let e=t.indexOf(this._visibleStack)-1;t[e]||(e=t.length-1),this.showStack(this._getStackId(t[e]));}_createRotatorView(){const t=new Ag(this.editor.locale),e=this.editor.locale.t;return this.view.content.add(t),t.bind("isNavigationVisible").to(this,"_numberOfStacks",this,"_singleViewMode",((t,e)=>!e&&t>1)),t.on("change:isNavigationVisible",(()=>this.updatePosition()),{priority:"low"}),t.bind("counter").to(this,"visibleView",this,"_numberOfStacks",((t,n)=>{if(n<2)return "";const o=Array.from(this._idToStack.values()).indexOf(this._visibleStack)+1;return e("%0 of %1",[o,n])})),t.buttonNextView.on("execute",(()=>{t.focusTracker.isFocused&&this.editor.editing.view.focus(),this._showNextStack();})),t.buttonPrevView.on("execute",(()=>{t.focusTracker.isFocused&&this.editor.editing.view.focus(),this._showPrevStack();})),t}_createFakePanelsView(){const t=new Cg(this.editor.locale,this.view);return t.bind("numberOfPanels").to(this,"_numberOfStacks",this,"_singleViewMode",((t,e)=>!e&&t>=2?Math.min(t-1,2):0)),t.listenTo(this.view,"change:top",(()=>t.updatePosition())),t.listenTo(this.view,"change:left",(()=>t.updatePosition())),this.editor.ui.view.body.add(t),t}_showView({view:t,balloonClassName:e="",withArrow:n=!0,singleViewMode:o=!1}){this.view.class=e,this.view.withArrow=n,this._rotatorView.showView(t),this.visibleView=t,this.view.pin(this._getBalloonPosition()),this._fakePanelsView.updatePosition(),o&&(this._singleViewMode=!0);}_getBalloonPosition(){let t=Array.from(this._visibleStack.values()).pop().position;return t&&(t.limiter||(t=Object.assign({},t,{limiter:this.positionLimiter})),t=Object.assign({},t,{viewportOffsetConfig:this.editor.ui.viewportOffset})),t}}class Ag extends Ph{constructor(t){super(t);const e=t.t,n=this.bindTemplate;this.set("isNavigationVisible",!0),this.focusTracker=new Ci,this.buttonPrevView=this._createButtonView(e("Previous"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'),this.buttonNextView=this._createButtonView(e("Next"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'),this.content=this.createCollection(),this.setTemplate({tag:"div",attributes:{class:["ck","ck-balloon-rotator"],"z-index":"-1"},children:[{tag:"div",attributes:{class:["ck-balloon-rotator__navigation",n.to("isNavigationVisible",(t=>t?"":"ck-hidden"))]},children:[this.buttonPrevView,{tag:"span",attributes:{class:["ck-balloon-rotator__counter"]},children:[{text:n.to("counter")}]},this.buttonNextView]},{tag:"div",attributes:{class:"ck-balloon-rotator__content"},children:this.content}]});}render(){super.render(),this.focusTracker.add(this.element);}destroy(){super.destroy(),this.focusTracker.destroy();}showView(t){this.hideView(),this.content.add(t);}hideView(){this.content.clear();}_createButtonView(t,e){const n=new cu(this.locale);return n.set({label:t,icon:e,tooltip:!0}),n}}class Cg extends Ph{constructor(t,e){super(t);const n=this.bindTemplate;this.set("top",0),this.set("left",0),this.set("height",0),this.set("width",0),this.set("numberOfPanels",0),this.content=this.createCollection(),this._balloonPanelView=e,this.setTemplate({tag:"div",attributes:{class:["ck-fake-panel",n.to("numberOfPanels",(t=>t?"":"ck-hidden"))],style:{top:n.to("top",wg),left:n.to("left",wg),width:n.to("width",wg),height:n.to("height",wg)}},children:this.content}),this.on("change:numberOfPanels",((t,e,n,o)=>{n>o?this._addPanels(n-o):this._removePanels(o-n),this.updatePosition();}));}_addPanels(t){for(;t--;){const t=new Ph;t.setTemplate({tag:"div"}),this.content.add(t),this.registerChild(t);}}_removePanels(t){for(;t--;){const t=this.content.last;this.content.remove(t),this.deregisterChild(t),t.destroy();}}updatePosition(){if(this.numberOfPanels){const{top:t,left:e}=this._balloonPanelView,{width:n,height:o}=new Oo(this._balloonPanelView.element);Object.assign(this,{top:t,left:e,width:n,height:o});}}}var vg=n(5868),yg={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(vg.Z,yg);vg.Z.locals;const xg=Ho("px");class Eg extends Mi{static get pluginName(){return "BalloonToolbar"}static get requires(){return [_g]}constructor(t){super(t),this._balloonConfig=Du(t.config.get("balloonToolbar")),this.toolbarView=this._createToolbarView(),this.focusTracker=new Ci,t.ui.once("ready",(()=>{this.focusTracker.add(t.ui.getEditableElement()),this.focusTracker.add(this.toolbarView.element);})),t.ui.addToolbar(this.toolbarView,{beforeFocus:()=>this.show(!0),afterBlur:()=>this.hide(),isContextual:!0}),this._resizeObserver=null,this._balloon=t.plugins.get(_g),this._fireSelectionChangeDebounced=Ia((()=>this.fire("_selectionChangeDebounced")),200),this.decorate("show");}init(){const t=this.editor,e=t.model.document.selection;this.listenTo(this.focusTracker,"change:isFocused",((t,e,n)=>{const o=this._balloon.visibleView===this.toolbarView;!n&&o?this.hide():n&&this.show();})),this.listenTo(e,"change:range",((t,n)=>{(n.directChange||e.isCollapsed)&&this.hide(),this._fireSelectionChangeDebounced();})),this.listenTo(this,"_selectionChangeDebounced",(()=>{this.editor.editing.view.document.isFocused&&this.show();})),this._balloonConfig.shouldNotGroupWhenFull||this.listenTo(t,"ready",(()=>{const e=t.ui.view.editable.element;this._resizeObserver=new Vo(e,(()=>{this.toolbarView.maxWidth=xg(.9*new Oo(e).width);}));})),this.listenTo(this.toolbarView,"groupedItemsUpdate",(()=>{this._updatePosition();}));}afterInit(){const t=this.editor.ui.componentFactory;this.toolbarView.fillFromConfig(this._balloonConfig,t);}_createToolbarView(){const t=this.editor.locale.t,e=!this._balloonConfig.shouldNotGroupWhenFull,n=new Nu(this.editor.locale,{shouldGroupWhenFull:e,isFloating:!0});return n.ariaLabel=t("Editor contextual toolbar"),n.render(),n}show(t=!1){const e=this.editor,n=e.model.document.selection,o=e.model.schema;this._balloon.hasView(this.toolbarView)||n.isCollapsed&&!t||function(t,e){if(1===t.rangeCount)return !1;return [...t.getRanges()].every((t=>{const n=t.getContainedElement();return n&&e.isSelectable(n)}))}(n,o)||Array.from(this.toolbarView.items).every((t=>void 0!==t.isEnabled&&!t.isEnabled))||(this.listenTo(this.editor.ui,"update",(()=>{this._updatePosition();})),this._balloon.add({view:this.toolbarView,position:this._getBalloonPositionData(),balloonClassName:"ck-toolbar-container"}));}hide(){this._balloon.hasView(this.toolbarView)&&(this.stopListening(this.editor.ui,"update"),this._balloon.remove(this.toolbarView));}_getBalloonPositionData(){const t=this.editor.editing.view,e=t.document,n=e.selection,o=e.selection.isBackward;return {target:()=>{const e=o?n.getFirstRange():n.getLastRange(),i=Oo.getDomRangeRects(t.domConverter.viewRangeToDom(e));return o?i[0]:(i.length>1&&0===i[i.length-1].width&&i.pop(),i[i.length-1])},positions:this._getBalloonPositions(o)}}_updatePosition(){this._balloon.updatePosition(this._getBalloonPositionData());}destroy(){super.destroy(),this.stopListening(),this._fireSelectionChangeDebounced.cancel(),this.toolbarView.destroy(),this.focusTracker.destroy(),this._resizeObserver&&this._resizeObserver.destroy();}_getBalloonPositions(t){const e=i.isSafari&&i.isiOS?Vh({heightOffset:Math.max(jh.arrowHeightOffset,Math.round(20/So.window.visualViewport.scale))}):jh.defaultPositions;return t?[e.northWestArrowSouth,e.northWestArrowSouthWest,e.northWestArrowSouthEast,e.northWestArrowSouthMiddleEast,e.northWestArrowSouthMiddleWest,e.southWestArrowNorth,e.southWestArrowNorthWest,e.southWestArrowNorthEast,e.southWestArrowNorthMiddleWest,e.southWestArrowNorthMiddleEast]:[e.southEastArrowNorth,e.southEastArrowNorthEast,e.southEastArrowNorthWest,e.southEastArrowNorthMiddleEast,e.southEastArrowNorthMiddleWest,e.northEastArrowSouth,e.northEastArrowSouthEast,e.northEastArrowSouthWest,e.northEastArrowSouthMiddleEast,e.northEastArrowSouthMiddleWest]}}var Dg=n(9695),Ig={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Dg.Z,Ig);Dg.Z.locals;class Tg extends Yh{constructor(t,e){super(t),this.view=e;}get element(){return this.view.editable.element}init(){const t=this.editor,e=this.view,n=t.editing.view,o=e.editable,i=n.document.getRoot();o.name=i.rootName,e.render();const r=o.element;this.setEditableElement(o.name,r),o.bind("isFocused").to(this.focusTracker),n.attachDomRoot(r),this._initPlaceholder(),this.fire("ready");}destroy(){super.destroy();const t=this.view;this.editor.editing.view.detachDomRoot(t.editable.name),t.destroy();}_initPlaceholder(){const t=this.editor,e=t.editing.view,n=e.document.getRoot(),o=t.sourceElement,i=t.config.get("placeholder")||o&&"textarea"===o.tagName.toLowerCase()&&o.getAttribute("placeholder");i&&Ui({view:e,element:n,text:i,isDirectHost:!1,keepOnFocus:!0});}}class Sg extends Zu{constructor(t,e,n){super(t);const o=t.t;this.editable=new ng(t,e,n,{label:t=>o("Rich Text Editor. Editing area: %0",t.name)});}render(){super.render(),this.registerChild(this.editable);}}class Ng extends(Kh(Qh(ah))){constructor(t,e={}){if(!Bg(t)&&void 0!==e.initialData)throw new k("editor-create-initial-data",null);super(e),void 0===this.config.get("initialData")&&this.config.set("initialData",function(t){return Bg(t)?(e=t,e instanceof HTMLTextAreaElement?e.value:e.innerHTML):t;var e;}(t)),Bg(t)&&(this.sourceElement=t,function(t){const e=t.sourceElement;if(e){if(e.ckeditorInstance)throw new k("editor-source-element-already-used",t);e.ckeditorInstance=t,t.once("destroy",(()=>{delete e.ckeditorInstance;}));}}(this));const n=this.config.get("plugins");n.push(Eg),this.config.set("plugins",n),this.config.define("balloonToolbar",this.config.get("toolbar")),this.model.document.createRoot();const o=new Sg(this.locale,this.editing.view,this.sourceElement);this.ui=new Tg(this,o),function(t){if(!Ot(t.updateSourceElement))throw new k("attachtoform-missing-elementapi-interface",t);const e=t.sourceElement;if(function(t){return !!t&&"textarea"===t.tagName.toLowerCase()}(e)&&e.form){let n;const o=e.form,i=()=>t.updateSourceElement();Ot(o.submit)&&(n=o.submit,o.submit=()=>{i(),n.apply(o);}),o.addEventListener("submit",i),t.on("destroy",(()=>{o.removeEventListener("submit",i),n&&(o.submit=n);}));}}(this);}destroy(){const t=this.getData();return this.ui.destroy(),super.destroy().then((()=>{this.sourceElement&&this.updateSourceElement(t);}))}static create(t,e={}){return new Promise((n=>{if(Bg(t)&&"TEXTAREA"===t.tagName)throw new k("editor-wrong-element",null);const o=new this(t,e);n(o.initPlugins().then((()=>o.ui.init())).then((()=>o.data.init(o.config.get("initialData")))).then((()=>o.fire("ready"))).then((()=>o)));}))}}function Bg(t){return _o(t)}class Pg extends ma{constructor(t){super(t);const e=this.document;function n(t){return (n,o)=>{o.preventDefault();const i=o.dropRange?[o.dropRange]:null,r=new u(e,t);e.fire(r,{dataTransfer:o.dataTransfer,method:n.name,targetRanges:i,target:o.target}),r.stop.called&&o.stopPropagation();}}this.domEventType=["paste","copy","cut","drop","dragover","dragstart","dragend","dragenter","dragleave"],this.listenTo(e,"paste",n("clipboardInput"),{priority:"low"}),this.listenTo(e,"drop",n("clipboardInput"),{priority:"low"}),this.listenTo(e,"dragover",n("dragging"),{priority:"low"});}onDomEvent(t){const e={dataTransfer:new nc("clipboardData"in t?t.clipboardData:t.dataTransfer)};"drop"!=t.type&&"dragover"!=t.type||(e.dropRange=function(t,e){const n=e.target.ownerDocument,o=e.clientX,i=e.clientY;let r;n.caretRangeFromPoint&&n.caretRangeFromPoint(o,i)?r=n.caretRangeFromPoint(o,i):e.rangeParent&&(r=n.createRange(),r.setStart(e.rangeParent,e.rangeOffset),r.collapse(!0));if(r)return t.domConverter.domRangeToView(r);return null}(this.view,t)),this.fire(t.type,t,e);}}const zg=["figcaption","li"];function Lg(t){let e="";if(t.is("$text")||t.is("$textProxy"))e=t.data;else if(t.is("element","img")&&t.hasAttribute("alt"))e=t.getAttribute("alt");else if(t.is("element","br"))e="\n";else {let n=null;for(const o of t.getChildren()){const t=Lg(o);n&&(n.is("containerElement")||o.is("containerElement"))&&(zg.includes(n.name)||zg.includes(o.name)?e+="\n":e+="\n\n"),e+=t,n=o;}}return e}class Og extends Mi{static get pluginName(){return "ClipboardPipeline"}init(){this.editor.editing.view.addObserver(Pg),this._setupPasteDrop(),this._setupCopyCut();}_setupPasteDrop(){const t=this.editor,e=t.model,n=t.editing.view,o=n.document;this.listenTo(o,"clipboardInput",(e=>{t.isReadOnly&&e.stop();}),{priority:"highest"}),this.listenTo(o,"clipboardInput",((t,e)=>{const o=e.dataTransfer;let i;if(e.content)i=e.content;else {let t="";o.getData("text/html")?t=function(t){return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,((t,e)=>1==e.length?" ":e)).replace(/<!--[\s\S]*?-->/g,"")}(o.getData("text/html")):o.getData("text/plain")&&(((r=(r=o.getData("text/plain")).replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\r?\n\r?\n/g,"</p><p>").replace(/\r?\n/g,"<br>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/,"&nbsp;").replace(/\s$/,"&nbsp;").replace(/\s\s/g," &nbsp;")).includes("</p><p>")||r.includes("<br>"))&&(r=`<p>${r}</p>`),t=r),i=this.editor.data.htmlProcessor.toView(t);}var r;const s=new u(this,"inputTransformation");this.fire(s,{content:i,dataTransfer:o,targetRanges:e.targetRanges,method:e.method}),s.stop.called&&t.stop(),n.scrollToTheSelection();}),{priority:"low"}),this.listenTo(this,"inputTransformation",((t,n)=>{if(n.content.isEmpty)return;const o=this.editor.data.toModel(n.content,"$clipboardHolder");0!=o.childCount&&(t.stop(),e.change((()=>{this.fire("contentInsertion",{content:o,method:n.method,dataTransfer:n.dataTransfer,targetRanges:n.targetRanges});})));}),{priority:"low"}),this.listenTo(this,"contentInsertion",((t,n)=>{n.resultRange=e.insertContent(n.content);}),{priority:"low"});}_setupCopyCut(){const t=this.editor,e=t.model.document,n=t.editing.view.document,o=(o,i)=>{const r=i.dataTransfer;i.preventDefault();const s=t.data.toView(t.model.getSelectedContent(e.selection));n.fire("clipboardOutput",{dataTransfer:r,content:s,method:o.name});};this.listenTo(n,"copy",o,{priority:"low"}),this.listenTo(n,"cut",((e,n)=>{t.isReadOnly?n.preventDefault():o(e,n);}),{priority:"low"}),this.listenTo(n,"clipboardOutput",((n,o)=>{o.content.isEmpty||(o.dataTransfer.setData("text/html",this.editor.data.htmlProcessor.toData(o.content)),o.dataTransfer.setData("text/plain",Lg(o.content))),"cut"==o.method&&t.model.deleteContent(e.selection);}),{priority:"low"});}}class Rg{constructor(t,e=20){this._batch=null,this.model=t,this._size=0,this.limit=e,this._isLocked=!1,this._changeCallback=(t,e)=>{e.isLocal&&e.isUndoable&&e!==this._batch&&this._reset(!0);},this._selectionChangeCallback=()=>{this._reset();},this.model.document.on("change",this._changeCallback),this.model.document.selection.on("change:range",this._selectionChangeCallback),this.model.document.selection.on("change:attribute",this._selectionChangeCallback);}get batch(){return this._batch||(this._batch=this.model.createBatch({isTyping:!0})),this._batch}get size(){return this._size}input(t){this._size+=t,this._size>=this.limit&&this._reset(!0);}get isLocked(){return this._isLocked}lock(){this._isLocked=!0;}unlock(){this._isLocked=!1;}destroy(){this.model.document.off("change",this._changeCallback),this.model.document.selection.off("change:range",this._selectionChangeCallback),this.model.document.selection.off("change:attribute",this._selectionChangeCallback);}_reset(t=!1){this.isLocked&&!t||(this._batch=null,this._size=0);}}class jg extends Si{constructor(t,e){super(t),this._buffer=new Rg(t.model,e);}get buffer(){return this._buffer}destroy(){super.destroy(),this._buffer.destroy();}execute(t={}){const e=this.editor.model,n=e.document,o=t.text||"",i=o.length;let r=n.selection;t.selection?r=t.selection:t.range&&(r=e.createSelection(t.range));const s=t.resultRange;e.enqueueChange(this._buffer.batch,(t=>{this._buffer.lock(),e.deleteContent(r),o&&e.insertContent(t.createText(o,n.selection.getAttributes()),r),s?t.setSelection(s):r.is("documentSelection")||t.setSelection(r),this._buffer.unlock(),this._buffer.input(i);}));}}const Fg=["insertText","insertReplacementText"];class Vg extends ha{constructor(t){super(t),i.isAndroid&&Fg.push("insertCompositionText");const e=t.document;e.on("beforeinput",((n,o)=>{if(!this.isEnabled)return;const{data:i,targetRanges:r,inputType:s,domEvent:a}=o;if(!Fg.includes(s))return;const c=new u(e,"insertText");e.fire(c,new ga(t,a,{text:i,selection:t.createSelection(r)})),c.stop.called&&n.stop();})),e.on("compositionend",((n,{data:o,domEvent:r})=>{this.isEnabled&&!i.isAndroid&&o&&e.fire("insertText",new ga(t,r,{text:o,selection:e.selection}));}),{priority:"lowest"});}observe(){}}class Ug extends Mi{static get pluginName(){return "Input"}init(){const t=this.editor,e=t.model,n=t.editing.view,o=e.document.selection;n.addObserver(Vg);const r=new jg(t,t.config.get("typing.undoStep")||20);t.commands.add("insertText",r),t.commands.add("input",r),this.listenTo(n.document,"insertText",((o,r)=>{n.document.isComposing||r.preventDefault();const{text:s,selection:a,resultRange:c}=r,l=Array.from(a.getRanges()).map((e=>t.editing.mapper.toModelRange(e)));let d=s;if(i.isAndroid){const t=Array.from(l[0].getItems()).reduce(((t,e)=>t+(e.is("$textProxy")?e.data:"")),"");t&&(t.length<=d.length?d.startsWith(t)&&(d=d.substring(t.length),l[0].start=l[0].start.getShiftedBy(t.length)):t.startsWith(d)&&(l[0].start=l[0].start.getShiftedBy(d.length),d=""));}const h={text:d,selection:e.createSelection(l)};c&&(h.resultRange=t.editing.mapper.toModelRange(c)),t.execute("insertText",h);})),i.isAndroid?this.listenTo(n.document,"keydown",((t,i)=>{!o.isCollapsed&&229==i.keyCode&&n.document.isComposing&&Hg(e,r);})):this.listenTo(n.document,"compositionstart",(()=>{o.isCollapsed||Hg(e,r);}));}}function Hg(t,e){if(!e.isEnabled)return;const n=e.buffer;n.lock(),t.enqueueChange(n.batch,(()=>{t.deleteContent(t.document.selection);})),n.unlock();}class Wg extends Si{constructor(t,e){super(t),this.direction=e,this._buffer=new Rg(t.model,t.config.get("typing.undoStep"));}get buffer(){return this._buffer}execute(t={}){const e=this.editor.model,n=e.document;e.enqueueChange(this._buffer.batch,(o=>{this._buffer.lock();const i=o.createSelection(t.selection||n.selection),r=t.sequence||1,s=i.isCollapsed;if(i.isCollapsed&&e.modifySelection(i,{direction:this.direction,unit:t.unit,treatEmojiAsSingleUnit:!0}),this._shouldEntireContentBeReplacedWithParagraph(r))return void this._replaceEntireContentWithParagraph(o);if(this._shouldReplaceFirstBlockWithParagraph(i,r))return void this.editor.execute("paragraph",{selection:i});if(i.isCollapsed)return;let a=0;i.getFirstRange().getMinimalFlatRanges().forEach((t=>{a+=K(t.getWalker({singleCharacters:!0,ignoreElementEnd:!0,shallow:!0}));})),e.deleteContent(i,{doNotResetEntireContent:s,direction:this.direction}),this._buffer.input(a),o.setSelection(i),this._buffer.unlock();}));}_shouldEntireContentBeReplacedWithParagraph(t){if(t>1)return !1;const e=this.editor.model,n=e.document.selection,o=e.schema.getLimitElement(n);if(!(n.isCollapsed&&n.containsEntireContent(o)))return !1;if(!e.schema.checkChild(o,"paragraph"))return !1;const i=o.getChild(0);return !i||!i.is("element","paragraph")}_replaceEntireContentWithParagraph(t){const e=this.editor.model,n=e.document.selection,o=e.schema.getLimitElement(n),i=t.createElement("paragraph");t.remove(t.createRangeIn(o)),t.insert(i,o),t.setSelection(i,0);}_shouldReplaceFirstBlockWithParagraph(t,e){const n=this.editor.model;if(e>1||"backward"!=this.direction)return !1;if(!t.isCollapsed)return !1;const o=t.getFirstPosition(),i=n.schema.getLimitElement(o),r=i.getChild(0);return o.parent==r&&(!!t.containsEntireContent(r)&&(!!n.schema.checkChild(i,"paragraph")&&"paragraph"!=r.name))}}const Gg="word",qg="selection",Yg="backward",$g="forward",Kg={deleteContent:{unit:qg,direction:Yg},deleteContentBackward:{unit:"codePoint",direction:Yg},deleteWordBackward:{unit:Gg,direction:Yg},deleteHardLineBackward:{unit:qg,direction:Yg},deleteSoftLineBackward:{unit:qg,direction:Yg},deleteContentForward:{unit:"character",direction:$g},deleteWordForward:{unit:Gg,direction:$g},deleteHardLineForward:{unit:qg,direction:$g},deleteSoftLineForward:{unit:qg,direction:$g}};class Qg extends ha{constructor(t){super(t);const e=t.document;let n=0;e.on("keydown",(()=>{n++;})),e.on("keyup",(()=>{n=0;})),e.on("beforeinput",((o,r)=>{if(!this.isEnabled)return;const{targetRanges:s,domEvent:a,inputType:c}=r,l=Kg[c];if(!l)return;const d={direction:l.direction,unit:l.unit,sequence:n};d.unit==qg&&(d.selectionToRemove=t.createSelection(s[0])),i.isAndroid&&"deleteContentBackward"===c&&(d.sequence=1,1!=s.length||s[0].start.parent==s[0].end.parent&&s[0].start.offset+1==s[0].end.offset||(d.unit=qg,d.selectionToRemove=t.createSelection(s)));const h=new ds(e,"delete",s[0]);e.fire(h,new ga(t,a,d)),h.stop.called&&o.stop();})),i.isBlink&&function(t){const e=t.view,n=e.document;let o=null,i=!1;function r(t){return t==li.backspace||t==li.delete}function s(t){return t==li.backspace?Yg:$g}n.on("keydown",((t,{keyCode:e})=>{o=e,i=!1;})),n.on("keyup",((a,{keyCode:c,domEvent:l})=>{const d=n.selection,h=t.isEnabled&&c==o&&r(c)&&!d.isCollapsed&&!i;if(o=null,h){const t=d.getFirstRange(),o=new ds(n,"delete",t),i={unit:qg,direction:s(c),selectionToRemove:d};n.fire(o,new ga(e,l,i));}})),n.on("beforeinput",((t,{inputType:e})=>{const n=Kg[e];r(o)&&n&&n.direction==s(o)&&(i=!0);}),{priority:"high"}),n.on("beforeinput",((t,{inputType:e,data:n})=>{o==li.delete&&"insertText"==e&&""==n&&t.stop();}),{priority:"high"});}(this);}observe(){}}class Zg extends Mi{static get pluginName(){return "Delete"}init(){const t=this.editor,e=t.editing.view,n=e.document,o=t.model.document;e.addObserver(Qg),this._undoOnBackspace=!1;const i=new Wg(t,"forward");t.commands.add("deleteForward",i),t.commands.add("forwardDelete",i),t.commands.add("delete",new Wg(t,"backward")),this.listenTo(n,"delete",((o,i)=>{n.isComposing||i.preventDefault();const{direction:r,sequence:s,selectionToRemove:a,unit:c}=i,l="forward"===r?"deleteForward":"delete",d={sequence:s};if("selection"==c){const e=Array.from(a.getRanges()).map((e=>t.editing.mapper.toModelRange(e)));d.selection=t.model.createSelection(e);}else d.unit=c;t.execute(l,d),e.scrollToTheSelection();}),{priority:"low"}),this.editor.plugins.has("UndoEditing")&&(this.listenTo(n,"delete",((e,n)=>{this._undoOnBackspace&&"backward"==n.direction&&1==n.sequence&&"codePoint"==n.unit&&(this._undoOnBackspace=!1,t.execute("undo"),n.preventDefault(),e.stop());}),{context:"$capture"}),this.listenTo(o,"change",(()=>{this._undoOnBackspace=!1;})));}requestUndoOnBackspace(){this.editor.plugins.has("UndoEditing")&&(this._undoOnBackspace=!0);}}class Jg extends Mi{static get requires(){return [Ug,Zg]}static get pluginName(){return "Typing"}}function Xg(t,e){let n=t.start;return {text:Array.from(t.getItems()).reduce(((t,o)=>o.is("$text")||o.is("$textProxy")?t+o.data:(n=e.createPositionAfter(o),"")),""),range:e.createRange(n,t.end)}}class tm extends(H()){constructor(t,e){super(),this.model=t,this.testCallback=e,this._hasMatch=!1,this.set("isEnabled",!0),this.on("change:isEnabled",(()=>{this.isEnabled?this._startListening():(this.stopListening(t.document.selection),this.stopListening(t.document));})),this._startListening();}get hasMatch(){return this._hasMatch}_startListening(){const t=this.model.document;this.listenTo(t.selection,"change:range",((e,{directChange:n})=>{n&&(t.selection.isCollapsed?this._evaluateTextBeforeSelection("selection"):this.hasMatch&&(this.fire("unmatched"),this._hasMatch=!1));})),this.listenTo(t,"change:data",((t,e)=>{!e.isUndo&&e.isLocal&&this._evaluateTextBeforeSelection("data",{batch:e});}));}_evaluateTextBeforeSelection(t,e={}){const n=this.model,o=n.document.selection,i=n.createRange(n.createPositionAt(o.focus.parent,0),o.focus),{text:r,range:s}=Xg(i,n),a=this.testCallback(r);if(!a&&this.hasMatch&&this.fire("unmatched"),this._hasMatch=!!a,a){const n=Object.assign(e,{text:r,range:s});"object"==typeof a&&Object.assign(n,a),this.fire(`matched:${t}`,n);}}}class em extends Mi{static get pluginName(){return "TwoStepCaretMovement"}constructor(t){super(t),this.attributes=new Set,this._overrideUid=null;}init(){const t=this.editor,e=t.model,n=t.editing.view,o=t.locale,i=e.document.selection;this.listenTo(n.document,"arrowKey",((t,e)=>{if(!i.isCollapsed)return;if(e.shiftKey||e.altKey||e.ctrlKey)return;const n=e.keyCode==li.arrowright,r=e.keyCode==li.arrowleft;if(!n&&!r)return;const s=o.contentLanguageDirection;let a=!1;a="ltr"===s&&n||"rtl"===s&&r?this._handleForwardMovement(e):this._handleBackwardMovement(e),!0===a&&t.stop();}),{context:"$text",priority:"highest"}),this._isNextGravityRestorationSkipped=!1,this.listenTo(i,"change:range",((t,e)=>{this._isNextGravityRestorationSkipped?this._isNextGravityRestorationSkipped=!1:this._isGravityOverridden&&(!e.directChange&&rm(i.getFirstPosition(),this.attributes)||this._restoreGravity());}));}registerAttribute(t){this.attributes.add(t);}_handleForwardMovement(t){const e=this.attributes,n=this.editor.model.document.selection,o=n.getFirstPosition();return !this._isGravityOverridden&&((!o.isAtStart||!nm(n,e))&&(!!rm(o,e)&&(im(t),this._overrideGravity(),!0)))}_handleBackwardMovement(t){const e=this.attributes,n=this.editor.model,o=n.document.selection,i=o.getFirstPosition();return this._isGravityOverridden?(im(t),this._restoreGravity(),om(n,e,i),!0):i.isAtStart?!!nm(o,e)&&(im(t),om(n,e,i),!0):!!function(t,e){const n=t.getShiftedBy(-1);return rm(n,e)}(i,e)&&(i.isAtEnd&&!nm(o,e)&&rm(i,e)?(im(t),om(n,e,i),!0):(this._isNextGravityRestorationSkipped=!0,this._overrideGravity(),!1))}get _isGravityOverridden(){return !!this._overrideUid}_overrideGravity(){this._overrideUid=this.editor.model.change((t=>t.overrideSelectionGravity()));}_restoreGravity(){this.editor.model.change((t=>{t.restoreSelectionGravity(this._overrideUid),this._overrideUid=null;}));}}function nm(t,e){for(const n of e)if(t.hasAttribute(n))return !0;return !1}function om(t,e,n){const o=n.nodeBefore;t.change((t=>{o?t.setSelectionAttribute(o.getAttributes()):t.removeSelectionAttribute(e);}));}function im(t){t.preventDefault();}function rm(t,e){const{nodeBefore:n,nodeAfter:o}=t;for(const t of e){const e=n?n.getAttribute(t):void 0;if((o?o.getAttribute(t):void 0)!==e)return !0}return !1}var sm=/[\\^$.*+?()[\]{}|]/g,am=RegExp(sm.source);const cm=function(t){return (t=pr(t))&&am.test(t)?t.replace(sm,"\\$&"):t},lm={copyright:{from:"(c)",to:"©"},registeredTrademark:{from:"(r)",to:"®"},trademark:{from:"(tm)",to:"™"},oneHalf:{from:/(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,to:[null,"½",null]},oneThird:{from:/(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,to:[null,"⅓",null]},twoThirds:{from:/(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,to:[null,"⅔",null]},oneForth:{from:/(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,to:[null,"¼",null]},threeQuarters:{from:/(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,to:[null,"¾",null]},lessThanOrEqual:{from:"<=",to:"≤"},greaterThanOrEqual:{from:">=",to:"≥"},notEqual:{from:"!=",to:"≠"},arrowLeft:{from:"<-",to:"←"},arrowRight:{from:"->",to:"→"},horizontalEllipsis:{from:"...",to:"…"},enDash:{from:/(^| )(--)( )$/,to:[null,"–",null]},emDash:{from:/(^| )(---)( )$/,to:[null,"—",null]},quotesPrimary:{from:pm('"'),to:[null,"“",null,"”"]},quotesSecondary:{from:pm("'"),to:[null,"‘",null,"’"]},quotesPrimaryEnGb:{from:pm("'"),to:[null,"‘",null,"’"]},quotesSecondaryEnGb:{from:pm('"'),to:[null,"“",null,"”"]},quotesPrimaryPl:{from:pm('"'),to:[null,"„",null,"”"]},quotesSecondaryPl:{from:pm("'"),to:[null,"‚",null,"’"]}},dm={symbols:["copyright","registeredTrademark","trademark"],mathematical:["oneHalf","oneThird","twoThirds","oneForth","threeQuarters","lessThanOrEqual","greaterThanOrEqual","notEqual","arrowLeft","arrowRight"],typography:["horizontalEllipsis","enDash","emDash"],quotes:["quotesPrimary","quotesSecondary"]},hm=["symbols","mathematical","typography","quotes"];function um(t){return "string"==typeof t?new RegExp(`(${cm(t)})$`):t}function gm(t){return "string"==typeof t?()=>[t]:t instanceof Array?()=>t:t}function mm(t){return (t.textNode?t.textNode:t.nodeAfter).getAttributes()}function pm(t){return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)}function fm(t,e,n,o){return o.createRange(km(t,e,n,!0,o),km(t,e,n,!1,o))}function km(t,e,n,o,i){let r=t.textNode||(o?t.nodeBefore:t.nodeAfter),s=null;for(;r&&r.getAttribute(e)==n;)s=r,r=o?r.previousSibling:r.nextSibling;return s?i.createPositionAt(s,o?"before":"after"):t}function*bm(t,e){for(const n of e)n&&t.getAttributeProperties(n[0]).copyOnEnter&&(yield n);}class wm extends Si{execute(){this.editor.model.change((t=>{this.enterBlock(t),this.fire("afterExecute",{writer:t});}));}enterBlock(t){const e=this.editor.model,n=e.document.selection,o=e.schema,i=n.isCollapsed,r=n.getFirstRange(),s=r.start.parent,a=r.end.parent;if(o.isLimit(s)||o.isLimit(a))return i||s!=a||e.deleteContent(n),!1;if(i){const e=bm(t.model.schema,n.getAttributes());return _m(t,r.start),t.setSelectionAttribute(e),!0}{const o=!(r.start.isAtStart&&r.end.isAtEnd),i=s==a;if(e.deleteContent(n,{leaveUnmerged:o}),o){if(i)return _m(t,n.focus),!0;t.setSelection(a,0);}}return !1}}function _m(t,e){t.split(e),t.setSelection(e.parent.nextSibling,0);}const Am={insertParagraph:{isSoft:!1},insertLineBreak:{isSoft:!0}};class Cm extends ha{constructor(t){super(t);const e=this.document;e.on("beforeinput",((n,o)=>{if(!this.isEnabled)return;const i=o.domEvent,r=Am[o.inputType];if(!r)return;const s=new ds(e,"enter",o.targetRanges[0]);e.fire(s,new ga(t,i,{isSoft:r.isSoft})),s.stop.called&&n.stop();}));}observe(){}}class vm extends Mi{static get pluginName(){return "Enter"}init(){const t=this.editor,e=t.editing.view,n=e.document;e.addObserver(Cm),t.commands.add("enter",new wm(t)),this.listenTo(n,"enter",((o,i)=>{n.isComposing||i.preventDefault(),i.isSoft||(t.execute("enter"),e.scrollToTheSelection());}),{priority:"low"});}}class ym extends Si{execute(){const t=this.editor.model,e=t.document;t.change((n=>{!function(t,e,n){const o=n.isCollapsed,i=n.getFirstRange(),r=i.start.parent,s=i.end.parent,a=r==s;if(o){const o=bm(t.schema,n.getAttributes());xm(t,e,i.end),e.removeSelectionAttribute(n.getAttributeKeys()),e.setSelectionAttribute(o);}else {const o=!(i.start.isAtStart&&i.end.isAtEnd);t.deleteContent(n,{leaveUnmerged:o}),a?xm(t,e,n.focus):o&&e.setSelection(s,0);}}(t,n,e.selection),this.fire("afterExecute",{writer:n});}));}refresh(){const t=this.editor.model,e=t.document;this.isEnabled=function(t,e){if(e.rangeCount>1)return !1;const n=e.anchor;if(!n||!t.checkChild(n,"softBreak"))return !1;const o=e.getFirstRange(),i=o.start.parent,r=o.end.parent;if((Em(i,t)||Em(r,t))&&i!==r)return !1;return !0}(t.schema,e.selection);}}function xm(t,e,n){const o=e.createElement("softBreak");t.insertContent(o,n),e.setSelection(o,"after");}function Em(t,e){return !t.is("rootElement")&&(e.isLimit(t)||Em(t.parent,e))}class Dm extends Mi{static get pluginName(){return "ShiftEnter"}init(){const t=this.editor,e=t.model.schema,n=t.conversion,o=t.editing.view,i=o.document;e.register("softBreak",{allowWhere:"$text",isInline:!0}),n.for("upcast").elementToElement({model:"softBreak",view:"br"}),n.for("downcast").elementToElement({model:"softBreak",view:(t,{writer:e})=>e.createEmptyElement("br")}),o.addObserver(Cm),t.commands.add("shiftEnter",new ym(t)),this.listenTo(i,"enter",((e,n)=>{i.isComposing||n.preventDefault(),n.isSoft&&(t.execute("shiftEnter"),o.scrollToTheSelection());}),{priority:"low"});}}class Im extends(I()){constructor(){super(),this._stack=[];}add(t,e){const n=this._stack,o=n[0];this._insertDescriptor(t);const i=n[0];o===i||Mm(o,i)||this.fire("change:top",{oldDescriptor:o,newDescriptor:i,writer:e});}remove(t,e){const n=this._stack,o=n[0];this._removeDescriptor(t);const i=n[0];o===i||Mm(o,i)||this.fire("change:top",{oldDescriptor:o,newDescriptor:i,writer:e});}_insertDescriptor(t){const e=this._stack,n=e.findIndex((e=>e.id===t.id));if(Mm(t,e[n]))return;n>-1&&e.splice(n,1);let o=0;for(;e[o]&&Tm(e[o],t);)o++;e.splice(o,0,t);}_removeDescriptor(t){const e=this._stack,n=e.findIndex((e=>e.id===t));n>-1&&e.splice(n,1);}}function Mm(t,e){return t&&e&&t.priority==e.priority&&Sm(t.classes)==Sm(e.classes)}function Tm(t,e){return t.priority>e.priority||!(t.priority<e.priority)&&Sm(t.classes)>Sm(e.classes)}function Sm(t){return Array.isArray(t)?t.sort().join(","):t}const Nm='<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',Bm="ck-widget_selected";function Pm(t){return !!t.is("element")&&!!t.getCustomProperty("widget")}function zm(t,e,n={}){if(!t.is("containerElement"))throw new k("widget-to-widget-wrong-element-type",null,{element:t});return e.setAttribute("contenteditable","false",t),e.addClass("ck-widget",t),e.setCustomProperty("widget",!0,t),t.getFillerOffset=Vm,e.setCustomProperty("widgetLabel",[],t),n.label&&function(t,e){const n=t.getCustomProperty("widgetLabel");n.push(e);}(t,n.label),n.hasSelectionHandle&&function(t,e){const n=e.createUIElement("div",{class:"ck ck-widget__selection-handle"},(function(t){const e=this.toDomElement(t),n=new ru;return n.set("content",Nm),n.render(),e.appendChild(n.element),e}));e.insert(e.createPositionAt(t,0),n),e.addClass(["ck-widget_with-selection-handle"],t);}(t,e),Rm(t,e),t}function Lm(t,e,n){if(e.classes&&n.addClass(pi(e.classes),t),e.attributes)for(const o in e.attributes)n.setAttribute(o,e.attributes[o],t);}function Om(t,e,n){if(e.classes&&n.removeClass(pi(e.classes),t),e.attributes)for(const o in e.attributes)n.removeAttribute(o,t);}function Rm(t,e,n=Lm,o=Om){const i=new Im;i.on("change:top",((e,i)=>{i.oldDescriptor&&o(t,i.oldDescriptor,i.writer),i.newDescriptor&&n(t,i.newDescriptor,i.writer);}));e.setCustomProperty("addHighlight",((t,e,n)=>i.add(e,n)),t),e.setCustomProperty("removeHighlight",((t,e,n)=>i.remove(e,n)),t);}function jm(t,e,n={}){return e.addClass(["ck-editor__editable","ck-editor__nested-editable"],t),e.setAttribute("role","textbox",t),n.label&&e.setAttribute("aria-label",n.label,t),e.setAttribute("contenteditable",t.isReadOnly?"false":"true",t),t.on("change:isReadOnly",((n,o,i)=>{e.setAttribute("contenteditable",i?"false":"true",t);})),t.on("change:isFocused",((n,o,i)=>{i?e.addClass("ck-editor__nested-editable_focused",t):e.removeClass("ck-editor__nested-editable_focused",t);})),Rm(t,e),t}function Fm(t,e){const n=t.getSelectedElement();if(n){const o=Wm(t);if(o)return e.createRange(e.createPositionAt(n,o))}return Kd(t,e)}function Vm(){return null}const Um="widget-type-around";function Hm(t,e,n){return !!t&&Pm(t)&&!n.isInline(e)}function Wm(t){return t.getAttribute(Um)}var Gm=n(4921),qm={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Gm.Z,qm);Gm.Z.locals;const Ym=["before","after"],$m=(new DOMParser).parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',"image/svg+xml").firstChild,Km="ck-widget__type-around_disabled";class Qm extends Mi{static get pluginName(){return "WidgetTypeAround"}static get requires(){return [vm,Zg]}constructor(t){super(t),this._currentFakeCaretModelElement=null;}init(){const t=this.editor,e=t.editing.view;this.on("change:isEnabled",((n,o,i)=>{e.change((t=>{for(const n of e.document.roots)i?t.removeClass(Km,n):t.addClass(Km,n);})),i||t.model.change((t=>{t.removeSelectionAttribute(Um);}));})),this._enableTypeAroundUIInjection(),this._enableInsertingParagraphsOnButtonClick(),this._enableInsertingParagraphsOnEnterKeypress(),this._enableInsertingParagraphsOnTypingKeystroke(),this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),this._enableDeleteIntegration(),this._enableInsertContentIntegration(),this._enableInsertObjectIntegration(),this._enableDeleteContentIntegration();}destroy(){super.destroy(),this._currentFakeCaretModelElement=null;}_insertParagraph(t,e){const n=this.editor,o=n.editing.view,i=n.model.schema.getAttributesWithProperty(t,"copyOnReplace",!0);n.execute("insertParagraph",{position:n.model.createPositionAt(t,e),attributes:i}),o.focus(),o.scrollToTheSelection();}_listenToIfEnabled(t,e,n,o){this.listenTo(t,e,((...t)=>{this.isEnabled&&n(...t);}),o);}_insertParagraphAccordingToFakeCaretPosition(){const t=this.editor.model.document.selection,e=Wm(t);if(!e)return !1;const n=t.getSelectedElement();return this._insertParagraph(n,e),!0}_enableTypeAroundUIInjection(){const t=this.editor,e=t.model.schema,n=t.locale.t,o={before:n("Insert paragraph before block"),after:n("Insert paragraph after block")};t.editing.downcastDispatcher.on("insert",((t,i,r)=>{const s=r.mapper.toViewElement(i.item);if(s&&Hm(s,i.item,e)){!function(t,e,n){const o=t.createUIElement("div",{class:"ck ck-reset_all ck-widget__type-around"},(function(t){const n=this.toDomElement(t);return function(t,e){for(const n of Ym){const o=new hh({tag:"div",attributes:{class:["ck","ck-widget__type-around__button",`ck-widget__type-around__button_${n}`],title:e[n],"aria-hidden":"true"},children:[t.ownerDocument.importNode($m,!0)]});t.appendChild(o.render());}}(n,e),function(t){const e=new hh({tag:"div",attributes:{class:["ck","ck-widget__type-around__fake-caret"]}});t.appendChild(e.render());}(n),n}));t.insert(t.createPositionAt(n,"end"),o);}(r.writer,o,s);s.getCustomProperty("widgetLabel").push((()=>this.isEnabled?n("Press Enter to type after or press Shift + Enter to type before the widget"):""));}}),{priority:"low"});}_enableTypeAroundFakeCaretActivationUsingKeyboardArrows(){const t=this.editor,e=t.model,n=e.document.selection,o=e.schema,i=t.editing.view;function r(t){return `ck-widget_type-around_show-fake-caret_${t}`}this._listenToIfEnabled(i.document,"arrowKey",((t,e)=>{this._handleArrowKeyPress(t,e);}),{context:[Pm,"$text"],priority:"high"}),this._listenToIfEnabled(n,"change:range",((e,n)=>{n.directChange&&t.model.change((t=>{t.removeSelectionAttribute(Um);}));})),this._listenToIfEnabled(e.document,"change:data",(()=>{const e=n.getSelectedElement();if(e){if(Hm(t.editing.mapper.toViewElement(e),e,o))return}t.model.change((t=>{t.removeSelectionAttribute(Um);}));})),this._listenToIfEnabled(t.editing.downcastDispatcher,"selection",((t,e,n)=>{const i=n.writer;if(this._currentFakeCaretModelElement){const t=n.mapper.toViewElement(this._currentFakeCaretModelElement);t&&(i.removeClass(Ym.map(r),t),this._currentFakeCaretModelElement=null);}const s=e.selection.getSelectedElement();if(!s)return;const a=n.mapper.toViewElement(s);if(!Hm(a,s,o))return;const c=Wm(e.selection);c&&(i.addClass(r(c),a),this._currentFakeCaretModelElement=s);})),this._listenToIfEnabled(t.ui.focusTracker,"change:isFocused",((e,n,o)=>{o||t.model.change((t=>{t.removeSelectionAttribute(Um);}));}));}_handleArrowKeyPress(t,e){const n=this.editor,o=n.model,i=o.document.selection,r=o.schema,s=n.editing.view,a=function(t,e){const n=mi(t,e);return "down"===n||"right"===n}(e.keyCode,n.locale.contentLanguageDirection),c=s.document.selection.getSelectedElement();let l;Hm(c,n.editing.mapper.toModelElement(c),r)?l=this._handleArrowKeyPressOnSelectedWidget(a):i.isCollapsed?l=this._handleArrowKeyPressWhenSelectionNextToAWidget(a):e.shiftKey||(l=this._handleArrowKeyPressWhenNonCollapsedSelection(a)),l&&(e.preventDefault(),t.stop());}_handleArrowKeyPressOnSelectedWidget(t){const e=this.editor.model,n=Wm(e.document.selection);return e.change((e=>{if(!n)return e.setSelectionAttribute(Um,t?"after":"before"),!0;if(!(n===(t?"after":"before")))return e.removeSelectionAttribute(Um),!0;return !1}))}_handleArrowKeyPressWhenSelectionNextToAWidget(t){const e=this.editor,n=e.model,o=n.schema,i=e.plugins.get("Widget"),r=i._getObjectElementNextToSelection(t);return !!Hm(e.editing.mapper.toViewElement(r),r,o)&&(n.change((e=>{i._setSelectionOverElement(r),e.setSelectionAttribute(Um,t?"before":"after");})),!0)}_handleArrowKeyPressWhenNonCollapsedSelection(t){const e=this.editor,n=e.model,o=n.schema,i=e.editing.mapper,r=n.document.selection,s=t?r.getLastPosition().nodeBefore:r.getFirstPosition().nodeAfter;return !!Hm(i.toViewElement(s),s,o)&&(n.change((e=>{e.setSelection(s,"on"),e.setSelectionAttribute(Um,t?"after":"before");})),!0)}_enableInsertingParagraphsOnButtonClick(){const t=this.editor,e=t.editing.view;this._listenToIfEnabled(e.document,"mousedown",((n,o)=>{const i=o.domTarget.closest(".ck-widget__type-around__button");if(!i)return;const r=function(t){return t.classList.contains("ck-widget__type-around__button_before")?"before":"after"}(i),s=function(t,e){const n=t.closest(".ck-widget");return e.mapDomToView(n)}(i,e.domConverter),a=t.editing.mapper.toModelElement(s);this._insertParagraph(a,r),o.preventDefault(),n.stop();}));}_enableInsertingParagraphsOnEnterKeypress(){const t=this.editor,e=t.model.document.selection,n=t.editing.view;this._listenToIfEnabled(n.document,"enter",((n,o)=>{if("atTarget"!=n.eventPhase)return;const i=e.getSelectedElement(),r=t.editing.mapper.toViewElement(i),s=t.model.schema;let a;this._insertParagraphAccordingToFakeCaretPosition()?a=!0:Hm(r,i,s)&&(this._insertParagraph(i,o.isSoft?"before":"after"),a=!0),a&&(o.preventDefault(),n.stop());}),{context:Pm});}_enableInsertingParagraphsOnTypingKeystroke(){const t=this.editor.editing.view.document;this._listenToIfEnabled(t,"insertText",((e,n)=>{this._insertParagraphAccordingToFakeCaretPosition()&&(n.selection=t.selection);}),{priority:"high"}),i.isAndroid?this._listenToIfEnabled(t,"keydown",((t,e)=>{229==e.keyCode&&this._insertParagraphAccordingToFakeCaretPosition();})):this._listenToIfEnabled(t,"compositionstart",(()=>{this._insertParagraphAccordingToFakeCaretPosition();}),{priority:"high"});}_enableDeleteIntegration(){const t=this.editor,e=t.editing.view,n=t.model,o=n.schema;this._listenToIfEnabled(e.document,"delete",((e,i)=>{if("atTarget"!=e.eventPhase)return;const r=Wm(n.document.selection);if(!r)return;const s=i.direction,a=n.document.selection.getSelectedElement(),c="forward"==s;if("before"===r===c)t.execute("delete",{selection:n.createSelection(a,"on")});else {const e=o.getNearestSelectionRange(n.createPositionAt(a,r),s);if(e)if(e.isCollapsed){const i=n.createSelection(e.start);if(n.modifySelection(i,{direction:s}),i.focus.isEqual(e.start)){const t=function(t,e){let n=e;for(const o of e.getAncestors({parentFirst:!0})){if(o.childCount>1||t.isLimit(o))break;n=o;}return n}(o,e.start.parent);n.deleteContent(n.createSelection(t,"on"),{doNotAutoparagraph:!0});}else n.change((n=>{n.setSelection(e),t.execute(c?"deleteForward":"delete");}));}else n.change((n=>{n.setSelection(e),t.execute(c?"deleteForward":"delete");}));}i.preventDefault(),e.stop();}),{context:Pm});}_enableInsertContentIntegration(){const t=this.editor,e=this.editor.model,n=e.document.selection;this._listenToIfEnabled(t.model,"insertContent",((t,[o,i])=>{if(i&&!i.is("documentSelection"))return;const r=Wm(n);return r?(t.stop(),e.change((t=>{const i=n.getSelectedElement(),s=e.createPositionAt(i,r),a=t.createSelection(s),c=e.insertContent(o,a);return t.setSelection(a),c}))):void 0}),{priority:"high"});}_enableInsertObjectIntegration(){const t=this.editor,e=this.editor.model.document.selection;this._listenToIfEnabled(t.model,"insertObject",((t,n)=>{const[,o,,i={}]=n;if(o&&!o.is("documentSelection"))return;const r=Wm(e);r&&(i.findOptimalPosition=r,n[3]=i);}),{priority:"high"});}_enableDeleteContentIntegration(){const t=this.editor,e=this.editor.model.document.selection;this._listenToIfEnabled(t.model,"deleteContent",((t,[n])=>{if(n&&!n.is("documentSelection"))return;Wm(e)&&t.stop();}),{priority:"high"});}}function Zm(t){const e=t.model;return (n,o)=>{const i=o.keyCode==li.arrowup,r=o.keyCode==li.arrowdown,s=o.shiftKey,a=e.document.selection;if(!i&&!r)return;const c=r;if(s&&function(t,e){return !t.isCollapsed&&t.isBackward==e}(a,c))return;const l=function(t,e,n){const o=t.model;if(n){const t=e.isCollapsed?e.focus:e.getLastPosition(),n=Jm(o,t,"forward");if(!n)return null;const i=o.createRange(t,n),r=Xm(o.schema,i,"backward");return r?o.createRange(t,r):null}{const t=e.isCollapsed?e.focus:e.getFirstPosition(),n=Jm(o,t,"backward");if(!n)return null;const i=o.createRange(n,t),r=Xm(o.schema,i,"forward");return r?o.createRange(r,t):null}}(t,a,c);if(l){if(l.isCollapsed){if(a.isCollapsed)return;if(s)return}(l.isCollapsed||function(t,e,n){const o=t.model,i=t.view.domConverter;if(n){const t=o.createSelection(e.start);o.modifySelection(t),t.focus.isAtEnd||e.start.isEqual(t.focus)||(e=o.createRange(t.focus,e.end));}const r=t.mapper.toViewRange(e),s=i.viewRangeToDom(r),a=Oo.getDomRangeRects(s);let c;for(const t of a)if(void 0!==c){if(Math.round(t.top)>=c)return !1;c=Math.max(c,Math.round(t.bottom));}else c=Math.round(t.bottom);return !0}(t,l,c))&&(e.change((t=>{const n=c?l.end:l.start;if(s){const o=e.createSelection(a.anchor);o.setFocus(n),t.setSelection(o);}else t.setSelection(n);})),n.stop(),o.preventDefault(),o.stopPropagation());}}}function Jm(t,e,n){const o=t.schema,i=t.createRangeIn(e.root),r="forward"==n?"elementStart":"elementEnd";for(const{previousPosition:t,item:s,type:a}of i.getWalker({startPosition:e,direction:n})){if(o.isLimit(s)&&!o.isInline(s))return t;if(a==r&&o.isBlock(s))return null}return null}function Xm(t,e,n){const o="backward"==n?e.end:e.start;if(t.checkChild(o,"$text"))return o;for(const{nextPosition:o}of e.getWalker({direction:n}))if(t.checkChild(o,"$text"))return o;return null}var tp=n(3488),ep={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(tp.Z,ep);tp.Z.locals;class np extends Mi{static get pluginName(){return "Widget"}static get requires(){return [Qm,Zg]}init(){const t=this.editor,e=t.editing.view,n=e.document;this._previouslySelected=new Set,this.editor.editing.downcastDispatcher.on("selection",((e,n,o)=>{const i=o.writer,r=n.selection;if(r.isCollapsed)return;const s=r.getSelectedElement();if(!s)return;const a=t.editing.mapper.toViewElement(s);var c;Pm(a)&&(o.consumable.consume(r,"selection")&&i.setSelection(i.createRangeOn(a),{fake:!0,label:(c=a,c.getCustomProperty("widgetLabel").reduce(((t,e)=>"function"==typeof e?t?t+". "+e():e():t?t+". "+e:e),""))}));})),this.editor.editing.downcastDispatcher.on("selection",((t,e,n)=>{this._clearPreviouslySelectedWidgets(n.writer);const o=n.writer,i=o.document.selection;let r=null;for(const t of i.getRanges())for(const e of t){const t=e.item;Pm(t)&&!op(t,r)&&(o.addClass(Bm,t),this._previouslySelected.add(t),r=t);}}),{priority:"low"}),e.addObserver(oh),this.listenTo(n,"mousedown",((...t)=>this._onMousedown(...t))),this.listenTo(n,"arrowKey",((...t)=>{this._handleSelectionChangeOnArrowKeyPress(...t);}),{context:[Pm,"$text"]}),this.listenTo(n,"arrowKey",((...t)=>{this._preventDefaultOnArrowKeyPress(...t);}),{context:"$root"}),this.listenTo(n,"arrowKey",Zm(this.editor.editing),{context:"$text"}),this.listenTo(n,"delete",((t,e)=>{this._handleDelete("forward"==e.direction)&&(e.preventDefault(),t.stop());}),{context:"$root"});}_onMousedown(t,e){const n=this.editor,o=n.editing.view,r=o.document;let s=e.target;if(function(t){let e=t;for(;e;){if(e.is("editableElement")&&!e.is("rootElement"))return !0;if(Pm(e))return !1;e=e.parent;}return !1}(s)){if((i.isSafari||i.isGecko)&&e.domEvent.detail>=3){const t=n.editing.mapper,o=s.is("attributeElement")?s.findAncestor((t=>!t.is("attributeElement"))):s,i=t.toModelElement(o);e.preventDefault(),this.editor.model.change((t=>{t.setSelection(i,"in");}));}return}if(!Pm(s)&&(s=s.findAncestor(Pm),!s))return;i.isAndroid&&e.preventDefault(),r.isFocused||o.focus();const a=n.editing.mapper.toModelElement(s);this._setSelectionOverElement(a);}_handleSelectionChangeOnArrowKeyPress(t,e){const n=e.keyCode,o=this.editor.model,i=o.schema,r=o.document.selection,s=r.getSelectedElement(),a=mi(n,this.editor.locale.contentLanguageDirection),c="down"==a||"right"==a,l="up"==a||"down"==a;if(s&&i.isObject(s)){const n=c?r.getLastPosition():r.getFirstPosition(),s=i.getNearestSelectionRange(n,c?"forward":"backward");return void(s&&(o.change((t=>{t.setSelection(s);})),e.preventDefault(),t.stop()))}if(!r.isCollapsed&&!e.shiftKey){const n=r.getFirstPosition(),s=r.getLastPosition(),a=n.nodeAfter,l=s.nodeBefore;return void((a&&i.isObject(a)||l&&i.isObject(l))&&(o.change((t=>{t.setSelection(c?s:n);})),e.preventDefault(),t.stop()))}if(!r.isCollapsed)return;const d=this._getObjectElementNextToSelection(c);if(d&&i.isObject(d)){if(i.isInline(d)&&l)return;this._setSelectionOverElement(d),e.preventDefault(),t.stop();}}_preventDefaultOnArrowKeyPress(t,e){const n=this.editor.model,o=n.schema,i=n.document.selection.getSelectedElement();i&&o.isObject(i)&&(e.preventDefault(),t.stop());}_handleDelete(t){if(this.editor.isReadOnly)return;const e=this.editor.model.document.selection;if(!e.isCollapsed)return;const n=this._getObjectElementNextToSelection(t);return n?(this.editor.model.change((t=>{let o=e.anchor.parent;for(;o.isEmpty;){const e=o;o=e.parent,t.remove(e);}this._setSelectionOverElement(n);})),!0):void 0}_setSelectionOverElement(t){this.editor.model.change((e=>{e.setSelection(e.createRangeOn(t));}));}_getObjectElementNextToSelection(t){const e=this.editor.model,n=e.schema,o=e.document.selection,i=e.createSelection(o);if(e.modifySelection(i,{direction:t?"forward":"backward"}),i.isEqual(o))return null;const r=t?i.focus.nodeBefore:i.focus.nodeAfter;return r&&n.isObject(r)?r:null}_clearPreviouslySelectedWidgets(t){for(const e of this._previouslySelected)t.removeClass(Bm,e);this._previouslySelected.clear();}}function op(t,e){return !!e&&Array.from(t.getAncestors()).includes(e)}class ip extends Mi{static get requires(){return [_g]}static get pluginName(){return "WidgetToolbarRepository"}init(){const t=this.editor;if(t.plugins.has("BalloonToolbar")){const e=t.plugins.get("BalloonToolbar");this.listenTo(e,"show",(e=>{(function(t){const e=t.getSelectedElement();return !(!e||!Pm(e))})(t.editing.view.document.selection)&&e.stop();}),{priority:"high"});}this._toolbarDefinitions=new Map,this._balloon=this.editor.plugins.get("ContextualBalloon"),this.on("change:isEnabled",(()=>{this._updateToolbarsVisibility();})),this.listenTo(t.ui,"update",(()=>{this._updateToolbarsVisibility();})),this.listenTo(t.ui.focusTracker,"change:isFocused",(()=>{this._updateToolbarsVisibility();}),{priority:"low"});}destroy(){super.destroy();for(const t of this._toolbarDefinitions.values())t.view.destroy();}register(t,{ariaLabel:e,items:n,getRelatedElement:o,balloonClassName:i="ck-toolbar-container"}){if(!n.length)return void b("widget-toolbar-no-items",{toolbarId:t});const r=this.editor,s=r.t,a=new Nu(r.locale);if(a.ariaLabel=e||s("Widget toolbar"),this._toolbarDefinitions.has(t))throw new k("widget-toolbar-duplicated",this,{toolbarId:t});a.fillFromConfig(n,r.ui.componentFactory);const c={view:a,getRelatedElement:o,balloonClassName:i};r.ui.addToolbar(a,{isContextual:!0,beforeFocus:()=>{const t=o(r.editing.view.document.selection);t&&this._showToolbar(c,t);},afterBlur:()=>{this._hideToolbar(c);}}),this._toolbarDefinitions.set(t,c);}_updateToolbarsVisibility(){let t=0,e=null,n=null;for(const o of this._toolbarDefinitions.values()){const i=o.getRelatedElement(this.editor.editing.view.document.selection);if(this.isEnabled&&i)if(this.editor.ui.focusTracker.isFocused){const r=i.getAncestors().length;r>t&&(t=r,e=i,n=o);}else this._isToolbarVisible(o)&&this._hideToolbar(o);else this._isToolbarInBalloon(o)&&this._hideToolbar(o);}n&&this._showToolbar(n,e);}_hideToolbar(t){this._balloon.remove(t.view),this.stopListening(this._balloon,"change:visibleView");}_showToolbar(t,e){this._isToolbarVisible(t)?rp(this.editor,e):this._isToolbarInBalloon(t)||(this._balloon.add({view:t.view,position:sp(this.editor,e),balloonClassName:t.balloonClassName}),this.listenTo(this._balloon,"change:visibleView",(()=>{for(const t of this._toolbarDefinitions.values())if(this._isToolbarVisible(t)){const e=t.getRelatedElement(this.editor.editing.view.document.selection);rp(this.editor,e);}})));}_isToolbarVisible(t){return this._balloon.visibleView===t.view}_isToolbarInBalloon(t){return this._balloon.hasView(t.view)}}function rp(t,e){const n=t.plugins.get("ContextualBalloon"),o=sp(t,e);n.updatePosition(o);}function sp(t,e){const n=t.editing.view,o=jh.defaultPositions;return {target:n.domConverter.mapViewToDom(e),positions:[o.northArrowSouth,o.northArrowSouthWest,o.northArrowSouthEast,o.southArrowNorth,o.southArrowNorthWest,o.southArrowNorthEast,o.viewportStickyNorth]}}var lp=n(8506),dp={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(lp.Z,dp);lp.Z.locals;const hp=function(t,e,n){var o=!0,i=!0;if("function"!=typeof t)throw new TypeError("Expected a function");return L(n)&&(o="leading"in n?!!n.leading:o,i="trailing"in n?!!n.trailing:i),Ia(t,e,{leading:o,maxWait:e,trailing:i})};var up=n(903),gp={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(up.Z,gp);up.Z.locals;class mp extends Mi{static get pluginName(){return "DragDrop"}static get requires(){return [Og,np]}init(){const t=this.editor,e=t.editing.view;this._draggedRange=null,this._draggingUid="",this._draggableElement=null,this._updateDropMarkerThrottled=hp((t=>this._updateDropMarker(t)),40),this._removeDropMarkerDelayed=kp((()=>this._removeDropMarker()),40),this._clearDraggableAttributesDelayed=kp((()=>this._clearDraggableAttributes()),40),e.addObserver(Pg),e.addObserver(oh),this._setupDragging(),this._setupContentInsertionIntegration(),this._setupClipboardInputIntegration(),this._setupDropMarker(),this._setupDraggableAttributeHandling(),this.listenTo(t,"change:isReadOnly",((t,e,n)=>{n?this.forceDisabled("readOnlyMode"):this.clearForceDisabled("readOnlyMode");})),this.on("change:isEnabled",((t,e,n)=>{n||this._finalizeDragging(!1);})),i.isAndroid&&this.forceDisabled("noAndroidSupport");}destroy(){return this._draggedRange&&(this._draggedRange.detach(),this._draggedRange=null),this._updateDropMarkerThrottled.cancel(),this._removeDropMarkerDelayed.cancel(),this._clearDraggableAttributesDelayed.cancel(),super.destroy()}_setupDragging(){const t=this.editor,e=t.model,n=e.document,o=t.editing.view,r=o.document;this.listenTo(r,"dragstart",((o,i)=>{const s=n.selection;if(i.target&&i.target.is("editableElement"))return void i.preventDefault();const a=i.target?bp(i.target):null;if(a){const n=t.editing.mapper.toModelElement(a);this._draggedRange=Bc.fromRange(e.createRangeOn(n)),t.plugins.has("WidgetToolbarRepository")&&t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");}else if(!r.selection.isCollapsed){const t=r.selection.getSelectedElement();t&&Pm(t)||(this._draggedRange=Bc.fromRange(s.getFirstRange()));}if(!this._draggedRange)return void i.preventDefault();this._draggingUid=m(),i.dataTransfer.effectAllowed=this.isEnabled?"copyMove":"copy",i.dataTransfer.setData("application/ckeditor5-dragging-uid",this._draggingUid);const c=e.createSelection(this._draggedRange.toRange()),l=t.data.toView(e.getSelectedContent(c));r.fire("clipboardOutput",{dataTransfer:i.dataTransfer,content:l,method:"dragstart"}),this.isEnabled||(this._draggedRange.detach(),this._draggedRange=null,this._draggingUid="");}),{priority:"low"}),this.listenTo(r,"dragend",((t,e)=>{this._finalizeDragging(!e.dataTransfer.isCanceled&&"move"==e.dataTransfer.dropEffect);}),{priority:"low"}),this.listenTo(r,"dragenter",(()=>{this.isEnabled&&o.focus();})),this.listenTo(r,"dragleave",(()=>{this._removeDropMarkerDelayed();})),this.listenTo(r,"dragging",((e,n)=>{if(!this.isEnabled)return void(n.dataTransfer.dropEffect="none");this._removeDropMarkerDelayed.cancel();const o=pp(t,n.targetRanges,n.target);this._draggedRange||(n.dataTransfer.dropEffect="copy"),i.isGecko||("copy"==n.dataTransfer.effectAllowed?n.dataTransfer.dropEffect="copy":["all","copyMove"].includes(n.dataTransfer.effectAllowed)&&(n.dataTransfer.dropEffect="move")),o&&this._updateDropMarkerThrottled(o);}),{priority:"low"});}_setupClipboardInputIntegration(){const t=this.editor,e=t.editing.view.document;this.listenTo(e,"clipboardInput",((e,n)=>{if("drop"!=n.method)return;const o=pp(t,n.targetRanges,n.target);if(this._removeDropMarker(),!o)return this._finalizeDragging(!1),void e.stop();this._draggedRange&&this._draggingUid!=n.dataTransfer.getData("application/ckeditor5-dragging-uid")&&(this._draggedRange.detach(),this._draggedRange=null,this._draggingUid="");if("move"==fp(n.dataTransfer)&&this._draggedRange&&this._draggedRange.containsRange(o,!0))return this._finalizeDragging(!1),void e.stop();n.targetRanges=[t.editing.mapper.toViewRange(o)];}),{priority:"high"});}_setupContentInsertionIntegration(){const t=this.editor.plugins.get(Og);t.on("contentInsertion",((t,e)=>{if(!this.isEnabled||"drop"!==e.method)return;const n=e.targetRanges.map((t=>this.editor.editing.mapper.toModelRange(t)));this.editor.model.change((t=>t.setSelection(n)));}),{priority:"high"}),t.on("contentInsertion",((t,e)=>{if(!this.isEnabled||"drop"!==e.method)return;const n="move"==fp(e.dataTransfer),o=!e.resultRange||!e.resultRange.isCollapsed;this._finalizeDragging(o&&n);}),{priority:"lowest"});}_setupDraggableAttributeHandling(){const t=this.editor,e=t.editing.view,n=e.document;this.listenTo(n,"mousedown",((o,r)=>{if(i.isAndroid||!r)return;this._clearDraggableAttributesDelayed.cancel();let s=bp(r.target);if(i.isBlink&&!t.isReadOnly&&!s&&!n.selection.isCollapsed){const t=n.selection.getSelectedElement();t&&Pm(t)||(s=n.selection.editableElement);}s&&(e.change((t=>{t.setAttribute("draggable","true",s);})),this._draggableElement=t.editing.mapper.toModelElement(s));})),this.listenTo(n,"mouseup",(()=>{i.isAndroid||this._clearDraggableAttributesDelayed();}));}_clearDraggableAttributes(){const t=this.editor.editing;t.view.change((e=>{this._draggableElement&&"$graveyard"!=this._draggableElement.root.rootName&&e.removeAttribute("draggable",t.mapper.toViewElement(this._draggableElement)),this._draggableElement=null;}));}_setupDropMarker(){const t=this.editor;t.conversion.for("editingDowncast").markerToHighlight({model:"drop-target",view:{classes:["ck-clipboard-drop-target-range"]}}),t.conversion.for("editingDowncast").markerToElement({model:"drop-target",view:(e,{writer:n})=>{if(t.model.schema.checkChild(e.markerRange.start,"$text"))return n.createUIElement("span",{class:"ck ck-clipboard-drop-target-position"},(function(t){const e=this.toDomElement(t);return e.append("⁠",t.createElement("span"),"⁠"),e}))}});}_updateDropMarker(t){const e=this.editor,n=e.model.markers;e.model.change((e=>{n.has("drop-target")?n.get("drop-target").getRange().isEqual(t)||e.updateMarker("drop-target",{range:t}):e.addMarker("drop-target",{range:t,usingOperation:!1,affectsData:!1});}));}_removeDropMarker(){const t=this.editor.model;this._removeDropMarkerDelayed.cancel(),this._updateDropMarkerThrottled.cancel(),t.markers.has("drop-target")&&t.change((t=>{t.removeMarker("drop-target");}));}_finalizeDragging(t){const e=this.editor,n=e.model;this._removeDropMarker(),this._clearDraggableAttributes(),e.plugins.has("WidgetToolbarRepository")&&e.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"),this._draggingUid="",this._draggedRange&&(t&&this.isEnabled&&n.deleteContent(n.createSelection(this._draggedRange),{doNotAutoparagraph:!0}),this._draggedRange.detach(),this._draggedRange=null);}}function pp(t,e,n){const o=t.model,r=t.editing.mapper;let s=null;const a=e?e[0].start:null;if(n.is("uiElement")&&(n=n.parent),s=function(t,e){const n=t.model,o=t.editing.mapper;if(Pm(e))return n.createRangeOn(o.toModelElement(e));if(!e.is("editableElement")){const t=e.findAncestor((t=>Pm(t)||t.is("editableElement")));if(Pm(t))return n.createRangeOn(o.toModelElement(t))}return null}(t,n),s)return s;const c=function(t,e){const n=t.editing.mapper,o=t.editing.view,i=n.toModelElement(e);if(i)return i;const r=o.createPositionBefore(e),s=n.findMappedViewAncestor(r);return n.toModelElement(s)}(t,n),l=a?r.toModelPosition(a):null;return l?(s=function(t,e,n){const o=t.model;if(!o.schema.checkChild(n,"$block"))return null;const i=o.createPositionAt(n,0),r=e.path.slice(0,i.path.length),s=o.createPositionFromPath(e.root,r),a=s.nodeAfter;if(a&&o.schema.isObject(a))return o.createRangeOn(a);return null}(t,l,c),s||(s=o.schema.getNearestSelectionRange(l,i.isGecko?"forward":"backward"),s||function(t,e){const n=t.model;let o=e;for(;o;){if(n.schema.isObject(o))return n.createRangeOn(o);o=o.parent;}return null}(t,l.parent))):function(t,e){const n=t.model,o=n.schema,i=n.createPositionAt(e,0);return o.getNearestSelectionRange(i,"forward")}(t,c)}function fp(t){return i.isGecko?t.dropEffect:["all","copyMove"].includes(t.effectAllowed)?"move":"copy"}function kp(t,e){let n;function o(...i){o.cancel(),n=setTimeout((()=>t(...i)),e);}return o.cancel=()=>{clearTimeout(n);},o}function bp(t){if(t.is("editableElement"))return null;if(t.hasClass("ck-widget__selection-handle"))return t.findAncestor(Pm);if(Pm(t))return t;const e=t.findAncestor((t=>Pm(t)||t.is("editableElement")));return Pm(e)?e:null}class wp extends Mi{static get pluginName(){return "PastePlainText"}static get requires(){return [Og]}init(){const t=this.editor,e=t.model,n=t.editing.view,o=n.document,i=e.document.selection;let r=!1;n.addObserver(Pg),this.listenTo(o,"keydown",((t,e)=>{r=e.shiftKey;})),t.plugins.get(Og).on("contentInsertion",((t,n)=>{(r||function(t,e){if(t.childCount>1)return !1;const n=t.getChild(0);if(e.isObject(n))return !1;return 0==Array.from(n.getAttributeKeys()).length}(n.content,e.schema))&&e.change((t=>{const o=Array.from(i.getAttributes()).filter((([t])=>e.schema.getAttributeProperties(t).isFormatting));i.isCollapsed||e.deleteContent(i,{doNotAutoparagraph:!0}),o.push(...i.getAttributes());const r=t.createRangeIn(n.content);for(const e of r.getItems())e.is("$textProxy")&&t.setAttributes(o,e);}));}));}}class _p extends Mi{static get pluginName(){return "Clipboard"}static get requires(){return [Og,mp,wp]}}class Ap extends Si{constructor(t){super(t),this.affectsData=!1;}execute(){const t=this.editor.model,e=t.document.selection;let n=t.schema.getLimitElement(e);if(e.containsEntireContent(n)||!Cp(t.schema,n))do{if(n=n.parent,!n)return}while(!Cp(t.schema,n));t.change((t=>{t.setSelection(n,"in");}));}}function Cp(t,e){return t.isLimit(e)&&(t.checkChild(e,"$text")||t.checkChild(e,"paragraph"))}const vp=ui("Ctrl+A");class yp extends Mi{static get pluginName(){return "SelectAllEditing"}init(){const t=this.editor,e=t.editing.view.document;t.commands.add("selectAll",new Ap(t)),this.listenTo(e,"keydown",((e,n)=>{hi(n)===vp&&(t.execute("selectAll"),n.preventDefault());}));}}class xp extends Mi{static get pluginName(){return "SelectAllUI"}init(){const t=this.editor;t.ui.componentFactory.add("selectAll",(e=>{const n=t.commands.get("selectAll"),o=new cu(e),i=e.t;return o.set({label:i("Select all"),icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',keystroke:"Ctrl+A",tooltip:!0}),o.bind("isEnabled").to(n,"isEnabled"),this.listenTo(o,"execute",(()=>{t.execute("selectAll"),t.editing.view.focus();})),o}));}}class Ep extends Mi{static get requires(){return [yp,xp]}static get pluginName(){return "SelectAll"}}class Dp extends Si{constructor(t){super(t),this._stack=[],this._createdBatches=new WeakSet,this.refresh(),this.listenTo(t.data,"set",((t,e)=>{e[1]={...e[1]};const n=e[1];n.batchType||(n.batchType={isUndoable:!1});}),{priority:"high"}),this.listenTo(t.data,"set",((t,e)=>{e[1].batchType.isUndoable||this.clearStack();}));}refresh(){this.isEnabled=this._stack.length>0;}addBatch(t){const e=this.editor.model.document.selection,n={ranges:e.hasOwnRange?Array.from(e.getRanges()):[],isBackward:e.isBackward};this._stack.push({batch:t,selection:n}),this.refresh();}clearStack(){this._stack=[],this.refresh();}_restoreSelection(t,e,n){const o=this.editor.model,i=o.document,r=[],s=t.map((t=>t.getTransformedByOperations(n))),a=s.flat();for(const t of s){const e=t.filter((t=>t.root!=i.graveyard)).filter((t=>!Mp(t,a)));e.length&&(Ip(e),r.push(e[0]));}r.length&&o.change((t=>{t.setSelection(r,{backward:e});}));}_undo(t,e){const n=this.editor.model,o=n.document;this._createdBatches.add(e);const i=t.operations.slice().filter((t=>t.isDocumentOperation));i.reverse();for(const t of i){const i=t.baseVersion+1,r=Array.from(o.history.getOperations(i)),s=ad([t.getReversed()],r,{useRelations:!0,document:this.editor.model.document,padWithNoOps:!1,forceWeakRemove:!0}).operationsA;for(const i of s)e.addOperation(i),n.applyOperation(i),o.history.setOperationAsUndone(t,i);}}}function Ip(t){t.sort(((t,e)=>t.start.isBefore(e.start)?-1:1));for(let e=1;e<t.length;e++){const n=t[e-1].getJoined(t[e],!0);n&&(e--,t.splice(e,2,n));}}function Mp(t,e){return e.some((e=>e!==t&&e.containsRange(t,!0)))}class Tp extends Dp{execute(t=null){const e=t?this._stack.findIndex((e=>e.batch==t)):this._stack.length-1,n=this._stack.splice(e,1)[0],o=this.editor.model.createBatch({isUndo:!0});this.editor.model.enqueueChange(o,(()=>{this._undo(n.batch,o);const t=this.editor.model.document.history.getOperations(n.batch.baseVersion);this._restoreSelection(n.selection.ranges,n.selection.isBackward,t),this.fire("revert",n.batch,o);})),this.refresh();}}class Sp extends Dp{execute(){const t=this._stack.pop(),e=this.editor.model.createBatch({isUndo:!0});this.editor.model.enqueueChange(e,(()=>{const n=t.batch.operations[t.batch.operations.length-1].baseVersion+1,o=this.editor.model.document.history.getOperations(n);this._restoreSelection(t.selection.ranges,t.selection.isBackward,o),this._undo(t.batch,e);})),this.refresh();}}class Np extends Mi{static get pluginName(){return "UndoEditing"}constructor(t){super(t),this._batchRegistry=new WeakSet;}init(){const t=this.editor;this._undoCommand=new Tp(t),this._redoCommand=new Sp(t),t.commands.add("undo",this._undoCommand),t.commands.add("redo",this._redoCommand),this.listenTo(t.model,"applyOperation",((t,e)=>{const n=e[0];if(!n.isDocumentOperation)return;const o=n.batch,i=this._redoCommand._createdBatches.has(o),r=this._undoCommand._createdBatches.has(o);this._batchRegistry.has(o)||(this._batchRegistry.add(o),o.isUndoable&&(i?this._undoCommand.addBatch(o):r||(this._undoCommand.addBatch(o),this._redoCommand.clearStack())));}),{priority:"highest"}),this.listenTo(this._undoCommand,"revert",((t,e,n)=>{this._redoCommand.addBatch(n);})),t.keystrokes.set("CTRL+Z","undo"),t.keystrokes.set("CTRL+Y","redo"),t.keystrokes.set("CTRL+SHIFT+Z","redo");}}const Bp='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',Pp='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';class zp extends Mi{static get pluginName(){return "UndoUI"}init(){const t=this.editor,e=t.locale,n=t.t,o="ltr"==e.uiLanguageDirection?Bp:Pp,i="ltr"==e.uiLanguageDirection?Pp:Bp;this._addButton("undo",n("Undo"),"CTRL+Z",o),this._addButton("redo",n("Redo"),"CTRL+Y",i);}_addButton(t,e,n,o){const i=this.editor;i.ui.componentFactory.add(t,(r=>{const s=i.commands.get(t),a=new cu(r);return a.set({label:e,icon:o,keystroke:n,tooltip:!0}),a.bind("isEnabled").to(s,"isEnabled"),this.listenTo(a,"execute",(()=>{i.execute(t),i.editing.view.focus();})),a}));}}class Lp extends Mi{static get requires(){return [Np,zp]}static get pluginName(){return "Undo"}}class Op extends(H()){constructor(){super();const t=new window.FileReader;this._reader=t,this._data=void 0,this.set("loaded",0),t.onprogress=t=>{this.loaded=t.loaded;};}get error(){return this._reader.error}get data(){return this._data}read(t){const e=this._reader;return this.total=t.size,new Promise(((n,o)=>{e.onload=()=>{const t=e.result;this._data=t,n(t);},e.onerror=()=>{o("error");},e.onabort=()=>{o("aborted");},this._reader.readAsDataURL(t);}))}abort(){this._reader.abort();}}class Rp extends Mi{static get pluginName(){return "FileRepository"}static get requires(){return [Zh]}init(){this.loaders=new _i,this.loaders.on("change",(()=>this._updatePendingAction())),this._loadersMap=new Map,this._pendingAction=null,this.set("uploaded",0),this.set("uploadTotal",null),this.bind("uploadedPercent").to(this,"uploaded",this,"uploadTotal",((t,e)=>e?t/e*100:0));}getLoader(t){return this._loadersMap.get(t)||null}createLoader(t){if(!this.createUploadAdapter)return b("filerepository-no-upload-adapter"),null;const e=new jp(Promise.resolve(t),this.createUploadAdapter);return this.loaders.add(e),this._loadersMap.set(t,e),t instanceof Promise&&e.file.then((t=>{this._loadersMap.set(t,e);})).catch((()=>{})),e.on("change:uploaded",(()=>{let t=0;for(const e of this.loaders)t+=e.uploaded;this.uploaded=t;})),e.on("change:uploadTotal",(()=>{let t=0;for(const e of this.loaders)e.uploadTotal&&(t+=e.uploadTotal);this.uploadTotal=t;})),e}destroyLoader(t){const e=t instanceof jp?t:this.getLoader(t);e._destroy(),this.loaders.remove(e),this._loadersMap.forEach(((t,n)=>{t===e&&this._loadersMap.delete(n);}));}_updatePendingAction(){const t=this.editor.plugins.get(Zh);if(this.loaders.length){if(!this._pendingAction){const e=this.editor.t,n=t=>`${e("Upload in progress")} ${parseInt(t)}%.`;this._pendingAction=t.add(n(this.uploadedPercent)),this._pendingAction.bind("message").to(this,"uploadedPercent",n);}}else t.remove(this._pendingAction),this._pendingAction=null;}}class jp extends(H()){constructor(t,e){super(),this.id=m(),this._filePromiseWrapper=this._createFilePromiseWrapper(t),this._adapter=e(this),this._reader=new Op,this.set("status","idle"),this.set("uploaded",0),this.set("uploadTotal",null),this.bind("uploadedPercent").to(this,"uploaded",this,"uploadTotal",((t,e)=>e?t/e*100:0)),this.set("uploadResponse",null);}get file(){return this._filePromiseWrapper?this._filePromiseWrapper.promise.then((t=>this._filePromiseWrapper?t:null)):Promise.resolve(null)}get data(){return this._reader.data}read(){if("idle"!=this.status)throw new k("filerepository-read-wrong-status",this);return this.status="reading",this.file.then((t=>this._reader.read(t))).then((t=>{if("reading"!==this.status)throw this.status;return this.status="idle",t})).catch((t=>{if("aborted"===t)throw this.status="aborted","aborted";throw this.status="error",this._reader.error?this._reader.error:t}))}upload(){if("idle"!=this.status)throw new k("filerepository-upload-wrong-status",this);return this.status="uploading",this.file.then((()=>this._adapter.upload())).then((t=>(this.uploadResponse=t,this.status="idle",t))).catch((t=>{if("aborted"===this.status)throw "aborted";throw this.status="error",t}))}abort(){const t=this.status;this.status="aborted",this._filePromiseWrapper.isFulfilled?"reading"==t?this._reader.abort():"uploading"==t&&this._adapter.abort&&this._adapter.abort():(this._filePromiseWrapper.promise.catch((()=>{})),this._filePromiseWrapper.rejecter("aborted")),this._destroy();}_destroy(){this._filePromiseWrapper=void 0,this._reader=void 0,this._adapter=void 0,this.uploadResponse=void 0;}_createFilePromiseWrapper(t){const e={};return e.promise=new Promise(((n,o)=>{e.rejecter=o,e.isFulfilled=!1,t.then((t=>{e.isFulfilled=!0,n(t);})).catch((t=>{e.isFulfilled=!0,o(t);}));})),e}}class Fp extends Ph{constructor(t){super(t),this.buttonView=new cu(t),this._fileInputView=new Vp(t),this._fileInputView.bind("acceptedType").to(this),this._fileInputView.bind("allowMultipleFiles").to(this),this._fileInputView.delegate("done").to(this),this.setTemplate({tag:"span",attributes:{class:"ck-file-dialog-button"},children:[this.buttonView,this._fileInputView]}),this.buttonView.on("execute",(()=>{this._fileInputView.open();}));}focus(){this.buttonView.focus();}}class Vp extends Ph{constructor(t){super(t),this.set("acceptedType",void 0),this.set("allowMultipleFiles",!1);const e=this.bindTemplate;this.setTemplate({tag:"input",attributes:{class:["ck-hidden"],type:"file",tabindex:"-1",accept:e.to("acceptedType"),multiple:e.to("allowMultipleFiles")},on:{change:e.to((()=>{this.element&&this.element.files&&this.element.files.length&&this.fire("done",this.element.files),this.element.value="";}))}});}open(){this.element.click();}}const Up="ckCsrfToken",Hp="abcdefghijklmnopqrstuvwxyz0123456789";function Wp(){let t=function(t){t=t.toLowerCase();const e=document.cookie.split(";");for(const n of e){const e=n.split("=");if(decodeURIComponent(e[0].trim().toLowerCase())===t)return decodeURIComponent(e[1])}return null}(Up);var e,n;return t&&40==t.length||(t=function(t){let e="";const n=new Uint8Array(t);window.crypto.getRandomValues(n);for(let t=0;t<n.length;t++){const o=Hp.charAt(n[t]%Hp.length);e+=Math.random()>.5?o.toUpperCase():o;}return e}(40),e=Up,n=t,document.cookie=encodeURIComponent(e)+"="+encodeURIComponent(n)+";path=/"),t}class Gp{constructor(t,e,n){this.loader=t,this.url=e,this.t=n;}upload(){return this.loader.file.then((t=>new Promise(((e,n)=>{this._initRequest(),this._initListeners(e,n,t),this._sendRequest(t);}))))}abort(){this.xhr&&this.xhr.abort();}_initRequest(){const t=this.xhr=new XMLHttpRequest;t.open("POST",this.url,!0),t.responseType="json";}_initListeners(t,e,n){const o=this.xhr,i=this.loader,r=(0, this.t)("Cannot upload file:")+` ${n.name}.`;o.addEventListener("error",(()=>e(r))),o.addEventListener("abort",(()=>e())),o.addEventListener("load",(()=>{const n=o.response;if(!n||!n.uploaded)return e(n&&n.error&&n.error.message?n.error.message:r);t({default:n.url});})),o.upload&&o.upload.addEventListener("progress",(t=>{t.lengthComputable&&(i.uploadTotal=t.total,i.uploaded=t.loaded);}));}_sendRequest(t){const e=new FormData;e.append("upload",t),e.append("ckCsrfToken",Wp()),this.xhr.send(e);}}function qp(t,e,n,o){let i,r=null;"function"==typeof o?i=o:(r=t.commands.get(o),i=()=>{t.execute(o);}),t.model.document.on("change:data",((s,a)=>{if(r&&!r.isEnabled||!e.isEnabled)return;const c=Ai(t.model.document.selection.getRanges());if(!c.isCollapsed)return;if(a.isUndo||!a.isLocal)return;const l=Array.from(t.model.document.differ.getChanges()),d=l[0];if(1!=l.length||"insert"!==d.type||"$text"!=d.name||1!=d.length)return;const h=d.position.parent;if(h.is("element","codeBlock"))return;if(h.is("element","listItem")&&"function"!=typeof o&&!["numberedList","bulletedList","todoList"].includes(o))return;if(r&&!0===r.value)return;const u=h.getChild(0),g=t.model.createRangeOn(u);if(!g.containsRange(c)&&!c.end.isEqual(g.end))return;const m=n.exec(u.data.substr(0,c.end.offset));m&&t.model.enqueueChange((e=>{const n=e.createPositionAt(h,0),o=e.createPositionAt(h,m[0].length),r=new Bc(n,o);if(!1!==i({match:m})){e.remove(r);const n=t.model.document.selection.getFirstRange(),o=e.createRangeIn(h);!h.isEmpty||o.isEqual(n)||o.containsRange(n,!0)||e.remove(h);}r.detach(),t.model.enqueueChange((()=>{t.plugins.get("Delete").requestUndoOnBackspace();}));}));}));}function Yp(t,e,n,o){let i,r;n instanceof RegExp?i=n:r=n,r=r||(t=>{let e;const n=[],o=[];for(;null!==(e=i.exec(t))&&!(e&&e.length<4);){let{index:t,1:i,2:r,3:s}=e;const a=i+r+s;t+=e[0].length-a.length;const c=[t,t+i.length],l=[t+i.length+r.length,t+i.length+r.length+s.length];n.push(c),n.push(l),o.push([t+i.length,t+i.length+r.length]);}return {remove:n,format:o}}),t.model.document.on("change:data",((n,i)=>{if(i.isUndo||!i.isLocal||!e.isEnabled)return;const s=t.model,a=s.document.selection;if(!a.isCollapsed)return;const c=Array.from(s.document.differ.getChanges()),l=c[0];if(1!=c.length||"insert"!==l.type||"$text"!=l.name||1!=l.length)return;const d=a.focus,h=d.parent,{text:u,range:g}=function(t,e){let n=t.start;const o=Array.from(t.getItems()).reduce(((t,o)=>!o.is("$text")&&!o.is("$textProxy")||o.getAttribute("code")?(n=e.createPositionAfter(o),""):t+o.data),"");return {text:o,range:e.createRange(n,t.end)}}(s.createRange(s.createPositionAt(h,0),d),s),m=r(u),p=$p(g.start,m.format,s),f=$p(g.start,m.remove,s);p.length&&f.length&&s.enqueueChange((e=>{if(!1!==o(e,p)){for(const t of f.reverse())e.remove(t);s.enqueueChange((()=>{t.plugins.get("Delete").requestUndoOnBackspace();}));}}));}));}function $p(t,e,n){return e.filter((t=>void 0!==t[0]&&void 0!==t[1])).map((e=>n.createRange(t.getShiftedBy(e[0]),t.getShiftedBy(e[1]))))}function Kp(t,e){return (n,o)=>{if(!t.commands.get(e).isEnabled)return !1;const i=t.model.schema.getValidRanges(o,e);for(const t of i)n.setAttribute(e,!0,t);n.removeSelectionAttribute(e);}}class Qp extends Si{constructor(t,e){super(t),this.attributeKey=e;}refresh(){const t=this.editor.model,e=t.document;this.value=this._getValueFromFirstAllowedNode(),this.isEnabled=t.schema.checkAttributeInSelection(e.selection,this.attributeKey);}execute(t={}){const e=this.editor.model,n=e.document.selection,o=void 0===t.forceValue?!this.value:t.forceValue;e.change((t=>{if(n.isCollapsed)o?t.setSelectionAttribute(this.attributeKey,!0):t.removeSelectionAttribute(this.attributeKey);else {const i=e.schema.getValidRanges(n.getRanges(),this.attributeKey);for(const e of i)o?t.setAttribute(this.attributeKey,o,e):t.removeAttribute(this.attributeKey,e);}}));}_getValueFromFirstAllowedNode(){const t=this.editor.model,e=t.schema,n=t.document.selection;if(n.isCollapsed)return n.hasAttribute(this.attributeKey);for(const t of n.getRanges())for(const n of t.getItems())if(e.checkAttribute(n,this.attributeKey))return n.hasAttribute(this.attributeKey);return !1}}const Zp="bold";class Jp extends Mi{static get pluginName(){return "BoldEditing"}init(){const t=this.editor;t.model.schema.extend("$text",{allowAttributes:Zp}),t.model.schema.setAttributeProperties(Zp,{isFormatting:!0,copyOnEnter:!0}),t.conversion.attributeToElement({model:Zp,view:"strong",upcastAlso:["b",t=>{const e=t.getStyle("font-weight");return e?"bold"==e||Number(e)>=600?{name:!0,styles:["font-weight"]}:void 0:null}]}),t.commands.add(Zp,new Qp(t,Zp)),t.keystrokes.set("CTRL+B",Zp);}}const Xp="bold";class tf extends Mi{static get pluginName(){return "BoldUI"}init(){const t=this.editor,e=t.t;t.ui.componentFactory.add(Xp,(n=>{const o=t.commands.get(Xp),i=new cu(n);return i.set({label:e("Bold"),icon:Jh.bold,keystroke:"CTRL+B",tooltip:!0,isToggleable:!0}),i.bind("isOn","isEnabled").to(o,"value","isEnabled"),this.listenTo(i,"execute",(()=>{t.execute(Xp),t.editing.view.focus();})),i}));}}const ef="italic";class nf extends Mi{static get pluginName(){return "ItalicEditing"}init(){const t=this.editor;t.model.schema.extend("$text",{allowAttributes:ef}),t.model.schema.setAttributeProperties(ef,{isFormatting:!0,copyOnEnter:!0}),t.conversion.attributeToElement({model:ef,view:"i",upcastAlso:["em",{styles:{"font-style":"italic"}}]}),t.commands.add(ef,new Qp(t,ef)),t.keystrokes.set("CTRL+I",ef);}}const of="italic";class rf extends Mi{static get pluginName(){return "ItalicUI"}init(){const t=this.editor,e=t.t;t.ui.componentFactory.add(of,(n=>{const o=t.commands.get(of),i=new cu(n);return i.set({label:e("Italic"),icon:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',keystroke:"CTRL+I",tooltip:!0,isToggleable:!0}),i.bind("isOn","isEnabled").to(o,"value","isEnabled"),this.listenTo(i,"execute",(()=>{t.execute(of),t.editing.view.focus();})),i}));}}class sf extends Si{refresh(){this.value=this._getValue(),this.isEnabled=this._checkEnabled();}execute(t={}){const e=this.editor.model,n=e.schema,o=e.document.selection,i=Array.from(o.getSelectedBlocks()),r=void 0===t.forceValue?!this.value:t.forceValue;e.change((t=>{if(r){const e=i.filter((t=>af(t)||lf(n,t)));this._applyQuote(t,e);}else this._removeQuote(t,i.filter(af));}));}_getValue(){const t=Ai(this.editor.model.document.selection.getSelectedBlocks());return !(!t||!af(t))}_checkEnabled(){if(this.value)return !0;const t=this.editor.model.document.selection,e=this.editor.model.schema,n=Ai(t.getSelectedBlocks());return !!n&&lf(e,n)}_removeQuote(t,e){cf(t,e).reverse().forEach((e=>{if(e.start.isAtStart&&e.end.isAtEnd)return void t.unwrap(e.start.parent);if(e.start.isAtStart){const n=t.createPositionBefore(e.start.parent);return void t.move(e,n)}e.end.isAtEnd||t.split(e.end);const n=t.createPositionAfter(e.end.parent);t.move(e,n);}));}_applyQuote(t,e){const n=[];cf(t,e).reverse().forEach((e=>{let o=af(e.start);o||(o=t.createElement("blockQuote"),t.wrap(e,o)),n.push(o);})),n.reverse().reduce(((e,n)=>e.nextSibling==n?(t.merge(t.createPositionAfter(e)),e):n));}}function af(t){return "blockQuote"==t.parent.name?t.parent:null}function cf(t,e){let n,o=0;const i=[];for(;o<e.length;){const r=e[o],s=e[o+1];n||(n=t.createPositionBefore(r)),s&&r.nextSibling==s||(i.push(t.createRange(n,t.createPositionAfter(r))),n=null),o++;}return i}function lf(t,e){const n=t.checkChild(e.parent,"blockQuote"),o=t.checkChild(["$root","blockQuote"],e);return n&&o}class df extends Mi{static get pluginName(){return "BlockQuoteEditing"}static get requires(){return [vm,Zg]}init(){const t=this.editor,e=t.model.schema;t.commands.add("blockQuote",new sf(t)),e.register("blockQuote",{inheritAllFrom:"$container"}),t.conversion.elementToElement({model:"blockQuote",view:"blockquote"}),t.model.document.registerPostFixer((n=>{const o=t.model.document.differ.getChanges();for(const t of o)if("insert"==t.type){const o=t.position.nodeAfter;if(!o)continue;if(o.is("element","blockQuote")&&o.isEmpty)return n.remove(o),!0;if(o.is("element","blockQuote")&&!e.checkChild(t.position,o))return n.unwrap(o),!0;if(o.is("element")){const t=n.createRangeIn(o);for(const o of t.getItems())if(o.is("element","blockQuote")&&!e.checkChild(n.createPositionBefore(o),o))return n.unwrap(o),!0}}else if("remove"==t.type){const e=t.position.parent;if(e.is("element","blockQuote")&&e.isEmpty)return n.remove(e),!0}return !1}));const n=this.editor.editing.view.document,o=t.model.document.selection,i=t.commands.get("blockQuote");this.listenTo(n,"enter",((e,n)=>{if(!o.isCollapsed||!i.value)return;o.getLastPosition().parent.isEmpty&&(t.execute("blockQuote"),t.editing.view.scrollToTheSelection(),n.preventDefault(),e.stop());}),{context:"blockquote"}),this.listenTo(n,"delete",((e,n)=>{if("backward"!=n.direction||!o.isCollapsed||!i.value)return;const r=o.getLastPosition().parent;r.isEmpty&&!r.previousSibling&&(t.execute("blockQuote"),t.editing.view.scrollToTheSelection(),n.preventDefault(),e.stop());}),{context:"blockquote"});}}var hf=n(3062),uf={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(hf.Z,uf);hf.Z.locals;class gf extends Mi{static get pluginName(){return "BlockQuoteUI"}init(){const t=this.editor,e=t.t;t.ui.componentFactory.add("blockQuote",(n=>{const o=t.commands.get("blockQuote"),i=new cu(n);return i.set({label:e("Block quote"),icon:Jh.quote,tooltip:!0,isToggleable:!0}),i.bind("isOn","isEnabled").to(o,"value","isEnabled"),this.listenTo(i,"execute",(()=>{t.execute("blockQuote"),t.editing.view.focus();})),i}));}}class mf extends Mi{static get pluginName(){return "CKBoxUI"}afterInit(){const t=this.editor;if(!t.commands.get("ckbox"))return;const e=t.t;t.ui.componentFactory.add("ckbox",(n=>{const o=t.commands.get("ckbox"),i=new cu(n);return i.set({label:e("Open file manager"),icon:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',tooltip:!0}),i.bind("isOn","isEnabled").to(o,"value","isEnabled"),i.on("execute",(()=>{t.execute("ckbox");})),i}));}}function pf({token:t,id:e,origin:n,width:o,extension:i}){const r=ff(t),s=function(t){const e=[10*t/100,80],n=Math.floor(Math.max(...e)),o=[Math.min(t,4e3)];let i=o[0];for(;i-n>=n;)i-=n,o.unshift(i);return o}(o),a=function(t){if("bmp"===t||"tiff"===t||"jpg"===t)return "jpeg";return t}(i);return {imageFallbackUrl:kf({environmentId:r,id:e,origin:n,width:o,extension:a}),imageSources:[{srcset:s.map((t=>`${kf({environmentId:r,id:e,origin:n,width:t,extension:"webp"})} ${t}w`)).join(","),sizes:`(max-width: ${o}px) 100vw, ${o}px`,type:"image/webp"}]}}function ff(t){const[,e]=t.value.split(".");return JSON.parse(atob(e)).aud}function kf({environmentId:t,id:e,origin:n,width:o,extension:i}){return new URL(`${t}/assets/${e}/images/${o}.${i}`,n).toString()}class bf extends Si{constructor(t){super(t),this._chosenAssets=new Set,this._wrapper=null,this._initListeners();}refresh(){this.value=this._getValue(),this.isEnabled=this._checkEnabled();}execute(){this.fire("ckbox:open");}_getValue(){return null!==this._wrapper}_checkEnabled(){const t=this.editor.commands.get("insertImage"),e=this.editor.commands.get("link");return !(!t.isEnabled&&!e.isEnabled)}_prepareOptions(){const t=this.editor.config.get("ckbox");return {theme:t.theme,language:t.language,tokenUrl:t.tokenUrl,serviceOrigin:t.serviceOrigin,assetsOrigin:t.assetsOrigin,dialog:{onClose:()=>this.fire("ckbox:close")},assets:{onChoose:t=>this.fire("ckbox:choose",t)}}}_initListeners(){const t=this.editor,e=t.model,n=!t.config.get("ckbox.ignoreDataId");this.on("ckbox",(()=>{this.refresh();}),{priority:"low"}),this.on("ckbox:open",(()=>{this.isEnabled&&!this.value&&(this._wrapper=mt(document,"div",{class:"ck ckbox-wrapper"}),document.body.appendChild(this._wrapper),window.CKBox.mount(this._wrapper,this._prepareOptions()));})),this.on("ckbox:close",(()=>{this.value&&(this._wrapper.remove(),this._wrapper=null);})),this.on("ckbox:choose",((o,i)=>{if(!this.isEnabled)return;const r=t.commands.get("insertImage"),s=t.commands.get("link"),a=t.plugins.get("CKBoxEditing"),c=function({assets:t,origin:e,token:n,isImageAllowed:o,isLinkAllowed:i}){return t.map((t=>({id:t.data.id,type:_f(t)?"image":"link",attributes:wf(t,n,e)}))).filter((t=>"image"===t.type?o:i))}({assets:i,origin:t.config.get("ckbox.assetsOrigin"),token:a.getToken(),isImageAllowed:r.isEnabled,isLinkAllowed:s.isEnabled});0!==c.length&&e.change((t=>{for(const e of c){const o=e===c[c.length-1];this._insertAsset(e,o,t),n&&(setTimeout((()=>this._chosenAssets.delete(e)),1e3),this._chosenAssets.add(e));}}));})),this.listenTo(t,"destroy",(()=>{this.fire("ckbox:close"),this._chosenAssets.clear();}));}_insertAsset(t,e,n){const o=this.editor.model.document.selection;n.removeSelectionAttribute("linkHref"),"image"===t.type?this._insertImage(t):this._insertLink(t,n),e||n.setSelection(o.getLastPosition());}_insertImage(t){const e=this.editor,{imageFallbackUrl:n,imageSources:o,imageTextAlternative:i}=t.attributes;e.execute("insertImage",{source:{src:n,sources:o,alt:i}});}_insertLink(t,e){const n=this.editor,o=n.model,i=o.document.selection,{linkName:r,linkHref:s}=t.attributes;if(i.isCollapsed){const t=yi(i.getAttributes()),n=e.createText(r,t),s=o.insertContent(n);e.setSelection(s);}n.execute("link",s);}}function wf(t,e,n){if(_f(t)){const{imageFallbackUrl:o,imageSources:i}=pf({token:e,origin:n,id:t.data.id,width:t.data.metadata.width,extension:t.data.extension});return {imageFallbackUrl:o,imageSources:i,imageTextAlternative:t.data.metadata.description||""}}return {linkName:t.data.name,linkHref:Af(t,e,n)}}function _f(t){const e=t.data.metadata;return !!e&&(e.width&&e.height)}function Af(t,e,n){const o=ff(e),i=new URL(`${o}/assets/${t.data.id}/file`,n);return i.searchParams.set("download","true"),i.toString()}class Cf extends Mi{static get requires(){return ["ImageUploadEditing","ImageUploadProgress",Rp,xf]}static get pluginName(){return "CKBoxUploadAdapter"}async afterInit(){const t=this.editor,e=!!t.config.get("ckbox"),n=!!window.CKBox;if(!e&&!n)return;const o=t.plugins.get(Rp),i=t.plugins.get(xf);o.createUploadAdapter=e=>new vf(e,i.getToken(),t);const r=!t.config.get("ckbox.ignoreDataId"),s=t.plugins.get("ImageUploadEditing");r&&s.on("uploadComplete",((e,{imageElement:n,data:o})=>{t.model.change((t=>{t.setAttribute("ckboxImageId",o.ckboxImageId,n);}));}));}}class vf{constructor(t,e,n){this.loader=t,this.token=e,this.editor=n,this.controller=new AbortController,this.serviceOrigin=n.config.get("ckbox.serviceOrigin"),this.assetsOrigin=n.config.get("ckbox.assetsOrigin");}async getAvailableCategories(t=0){const e=new URL("categories",this.serviceOrigin);return e.searchParams.set("limit",50..toString()),e.searchParams.set("offset",t.toString()),this._sendHttpRequest({url:e}).then((async e=>{if(e.totalCount-(t+50)>0){const n=await this.getAvailableCategories(t+50);return [...e.items,...n]}return e.items})).catch((()=>{this.controller.signal.throwIfAborted(),w("ckbox-fetch-category-http-error");}))}async getCategoryIdForFile(t){const e=yf(t.name),n=await this.getAvailableCategories();if(!n)return null;const o=this.editor.config.get("ckbox.defaultUploadCategories");if(o){const t=Object.keys(o).find((t=>o[t].includes(e)));if(t){const e=n.find((e=>e.id===t||e.name===t));return e?e.id:null}}const i=n.find((t=>t.extensions.includes(e)));return i?i.id:null}async upload(){const t=this.editor.t,e=t("Cannot determine a category for the uploaded file."),n=await this.loader.file,o=await this.getCategoryIdForFile(n);if(!o)return Promise.reject(e);const i=new URL("assets",this.serviceOrigin),r=new FormData;r.append("categoryId",o),r.append("file",n);const s={method:"POST",url:i,data:r,onUploadProgress:t=>{t.lengthComputable&&(this.loader.uploadTotal=t.total,this.loader.uploaded=t.loaded);}};return this._sendHttpRequest(s).then((async t=>{const e=await this._getImageWidth(),o=yf(n.name),i=pf({token:this.token,id:t.id,origin:this.assetsOrigin,width:e,extension:o});return {ckboxImageId:t.id,default:i.imageFallbackUrl,sources:i.imageSources}})).catch((()=>{const e=t("Cannot upload file:")+` ${n.name}.`;return Promise.reject(e)}))}abort(){this.controller.abort();}_sendHttpRequest(t){const{url:e,data:n,onUploadProgress:o}=t,i=t.method||"GET",r=this.controller.signal,s=new XMLHttpRequest;s.open(i,e.toString(),!0),s.setRequestHeader("Authorization",this.token.value),s.setRequestHeader("CKBox-Version","CKEditor 5"),s.responseType="json";const a=()=>{s.abort();};return new Promise(((t,e)=>{r.addEventListener("abort",a),s.addEventListener("loadstart",(()=>{r.addEventListener("abort",a);})),s.addEventListener("loadend",(()=>{r.removeEventListener("abort",a);})),s.addEventListener("error",(()=>{e();})),s.addEventListener("abort",(()=>{e();})),s.addEventListener("load",(async()=>{const n=s.response;return !n||n.statusCode>=400?e(n&&n.message):t(n)})),o&&s.upload.addEventListener("progress",(t=>{o(t);})),s.send(n);}))}_getImageWidth(){return new Promise((t=>{const e=new Image;e.onload=()=>{URL.revokeObjectURL(e.src),t(e.width);},e.src=this.loader.data;}))}}function yf(t){return t.match(/\.(?<ext>[^.]+)$/).groups.ext}class xf extends Mi{static get pluginName(){return "CKBoxEditing"}static get requires(){return ["CloudServices","LinkEditing","PictureEditing",Cf]}async init(){const t=this.editor,e=!!t.config.get("ckbox"),n=!!window.CKBox;if(!e&&!n)return;this._initConfig();const o=t.plugins.get("CloudServicesCore"),i=t.config.get("ckbox.tokenUrl"),r=t.config.get("cloudServices.tokenUrl");this._token=i===r?t.plugins.get("CloudServices").token:await o.createToken(i).init(),t.config.get("ckbox.ignoreDataId")||(this._initSchema(),this._initConversion(),this._initFixers()),n&&t.commands.add("ckbox",new bf(t));}getToken(){return this._token}_initConfig(){const t=this.editor;t.config.define("ckbox",{serviceOrigin:"https://api.ckbox.io",assetsOrigin:"https://ckbox.cloud",defaultUploadCategories:null,ignoreDataId:!1,language:t.locale.uiLanguage,theme:"default",tokenUrl:t.config.get("cloudServices.tokenUrl")});if(!t.config.get("ckbox.tokenUrl"))throw new k("ckbox-plugin-missing-token-url",this);t.plugins.has("ImageBlockEditing")||t.plugins.has("ImageInlineEditing")||w("ckbox-plugin-image-feature-missing",t);}_initSchema(){const t=this.editor.model.schema;t.extend("$text",{allowAttributes:"ckboxLinkId"}),t.isRegistered("imageBlock")&&t.extend("imageBlock",{allowAttributes:["ckboxImageId","ckboxLinkId"]}),t.isRegistered("imageInline")&&t.extend("imageInline",{allowAttributes:["ckboxImageId","ckboxLinkId"]}),t.addAttributeCheck(((t,e)=>{if(!!!t.last.getAttribute("linkHref")&&"ckboxLinkId"===e)return !1}));}_initConversion(){const t=this.editor;t.conversion.for("downcast").add((t=>{t.on("attribute:ckboxLinkId:imageBlock",((t,e,n)=>{const{writer:o,mapper:i,consumable:r}=n;if(!r.consume(e.item,t.name))return;const s=[...i.toViewElement(e.item).getChildren()].find((t=>"a"===t.name));s&&(e.item.hasAttribute("ckboxLinkId")?o.setAttribute("data-ckbox-resource-id",e.item.getAttribute("ckboxLinkId"),s):o.removeAttribute("data-ckbox-resource-id",s));}),{priority:"low"}),t.on("attribute:ckboxLinkId",((t,e,n)=>{const{writer:o,mapper:i,consumable:r}=n;if(r.consume(e.item,t.name)){if(e.attributeOldValue){const t=Df(o,e.attributeOldValue);o.unwrap(i.toViewRange(e.range),t);}if(e.attributeNewValue){const t=Df(o,e.attributeNewValue);if(e.item.is("selection")){const e=o.document.selection;o.wrap(e.getFirstRange(),t);}else o.wrap(i.toViewRange(e.range),t);}}}),{priority:"low"});})),t.conversion.for("upcast").add((t=>{t.on("element:a",((t,e,n)=>{const{writer:o,consumable:i}=n;if(!e.viewItem.getAttribute("href"))return;if(!i.consume(e.viewItem,{attributes:["data-ckbox-resource-id"]}))return;const r=e.viewItem.getAttribute("data-ckbox-resource-id");if(r)if(e.modelRange)for(let t of e.modelRange.getItems())t.is("$textProxy")&&(t=t.textNode),If(t)&&o.setAttribute("ckboxLinkId",r,t);else {const t=e.modelCursor.nodeBefore||e.modelCursor.parent;o.setAttribute("ckboxLinkId",r,t);}}),{priority:"low"});})),t.conversion.for("downcast").attributeToAttribute({model:"ckboxImageId",view:"data-ckbox-resource-id"}),t.conversion.for("upcast").elementToAttribute({model:{key:"ckboxImageId",value:t=>t.getAttribute("data-ckbox-resource-id")},view:{attributes:{"data-ckbox-resource-id":/[\s\S]+/}}});}_initFixers(){const t=this.editor,e=t.model,n=e.document.selection;e.document.registerPostFixer(function(t){return e=>{let n=!1;const o=t.model,i=t.commands.get("ckbox");if(!i)return n;for(const t of o.document.differ.getChanges()){if("insert"!==t.type&&"attribute"!==t.type)continue;const o="insert"===t.type?new Ac(t.position,t.position.getShiftedBy(t.length)):t.range,r="attribute"===t.type&&"linkHref"===t.attributeKey&&null===t.attributeNewValue;for(const t of o.getItems()){if(r&&t.hasAttribute("ckboxLinkId")){e.removeAttribute("ckboxLinkId",t),n=!0;continue}const o=Ef(t,i._chosenAssets);for(const i of o){const o="image"===i.type?"ckboxImageId":"ckboxLinkId";i.id!==t.getAttribute(o)&&(e.setAttribute(o,i.id,t),n=!0);}}}return n}}(t)),e.document.registerPostFixer(function(t){return e=>{!t.hasAttribute("linkHref")&&t.hasAttribute("ckboxLinkId")&&e.removeSelectionAttribute("ckboxLinkId");}}(n));}}function Ef(t,e){const n=t.is("element","imageInline")||t.is("element","imageBlock"),o=t.hasAttribute("linkHref");return [...e].filter((e=>"image"===e.type&&n?e.attributes.imageFallbackUrl===t.getAttribute("src"):"link"===e.type&&o?e.attributes.linkHref===t.getAttribute("linkHref"):void 0))}function Df(t,e){const n=t.createAttributeElement("a",{"data-ckbox-resource-id":e},{priority:5});return t.setCustomProperty("link",!0,n),n}function If(t){return !!t.is("$text")||!(!t.is("element","imageInline")&&!t.is("element","imageBlock"))}class Mf extends Mi{static get pluginName(){return "CKFinderUI"}init(){const t=this.editor,e=t.ui.componentFactory,n=t.t;e.add("ckfinder",(e=>{const o=t.commands.get("ckfinder"),i=new cu(e);return i.set({label:n("Insert image or file"),icon:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',tooltip:!0}),i.bind("isEnabled").to(o),i.on("execute",(()=>{t.execute("ckfinder"),t.editing.view.focus();})),i}));}}class Tf extends Si{constructor(t){super(t),this.stopListening(this.editor.model.document,"change"),this.listenTo(this.editor.model.document,"change",(()=>this.refresh()),{priority:"low"});}refresh(){const t=this.editor.commands.get("insertImage"),e=this.editor.commands.get("link");this.isEnabled=t.isEnabled||e.isEnabled;}execute(){const t=this.editor,e=this.editor.config.get("ckfinder.openerMethod")||"modal";if("popup"!=e&&"modal"!=e)throw new k("ckfinder-unknown-openermethod",t);const n=this.editor.config.get("ckfinder.options")||{};n.chooseFiles=!0;const o=n.onInit;n.language||(n.language=t.locale.uiLanguage),n.onInit=e=>{o&&o(e),e.on("files:choose",(n=>{const o=n.data.files.toArray(),i=o.filter((t=>!t.isImage())),r=o.filter((t=>t.isImage()));for(const e of i)t.execute("link",e.getUrl());const s=[];for(const t of r){const n=t.getUrl();s.push(n||e.request("file:getProxyUrl",{file:t}));}s.length&&Sf(t,s);})),e.on("file:choose:resizedImage",(e=>{const n=e.data.resizedUrl;if(n)Sf(t,[n]);else {const e=t.plugins.get("Notification"),n=t.locale.t;e.showWarning(n("Could not obtain resized image URL."),{title:n("Selecting resized image failed"),namespace:"ckfinder"});}}));},window.CKFinder[e](n);}}function Sf(t,e){if(t.commands.get("insertImage").isEnabled)t.execute("insertImage",{source:e});else {const e=t.plugins.get("Notification"),n=t.locale.t;e.showWarning(n("Could not insert image at the current position."),{title:n("Inserting image failed"),namespace:"ckfinder"});}}class Nf extends Mi{static get pluginName(){return "CKFinderEditing"}static get requires(){return [gg,"LinkEditing"]}init(){const t=this.editor;if(!t.plugins.has("ImageBlockEditing")&&!t.plugins.has("ImageInlineEditing"))throw new k("ckfinder-missing-image-plugin",t);t.commands.add("ckfinder",new Tf(t));}}class Bf extends Mi{static get pluginName(){return "CloudServicesUploadAdapter"}static get requires(){return ["CloudServices",Rp]}init(){const t=this.editor,e=t.plugins.get("CloudServices"),n=e.token,o=e.uploadUrl;n&&(this._uploadGateway=t.plugins.get("CloudServicesCore").createUploadGateway(n,o),t.plugins.get(Rp).createUploadAdapter=t=>new Pf(this._uploadGateway,t));}}class Pf{constructor(t,e){this.uploadGateway=t,this.loader=e;}upload(){return this.loader.file.then((t=>(this.fileUploader=this.uploadGateway.upload(t),this.fileUploader.on("progress",((t,e)=>{this.loader.uploadTotal=e.total,this.loader.uploaded=e.uploaded;})),this.fileUploader.send())))}abort(){this.fileUploader.abort();}}class zf extends Si{refresh(){const t=this.editor.model,e=Ai(t.document.selection.getSelectedBlocks());this.value=!!e&&e.is("element","paragraph"),this.isEnabled=!!e&&Lf(e,t.schema);}execute(t={}){const e=this.editor.model,n=e.document;e.change((o=>{const i=(t.selection||n.selection).getSelectedBlocks();for(const t of i)!t.is("element","paragraph")&&Lf(t,e.schema)&&o.rename(t,"paragraph");}));}}function Lf(t,e){return e.checkChild(t.parent,"paragraph")&&!e.isObject(t)}class Of extends Si{execute(t){const e=this.editor.model,n=t.attributes;let o=t.position;e.change((t=>{const i=t.createElement("paragraph");if(n&&e.schema.setAllowedAttributes(i,n,t),!e.schema.checkChild(o.parent,i)){const n=e.schema.findAllowedParent(o,i);if(!n)return;o=t.split(o,n).position;}e.insertContent(i,o),t.setSelection(i,"in");}));}}class Rf extends Mi{static get pluginName(){return "Paragraph"}init(){const t=this.editor,e=t.model;t.commands.add("paragraph",new zf(t)),t.commands.add("insertParagraph",new Of(t)),e.schema.register("paragraph",{inheritAllFrom:"$block"}),t.conversion.elementToElement({model:"paragraph",view:"p"}),t.conversion.for("upcast").elementToElement({model:(t,{writer:e})=>Rf.paragraphLikeElements.has(t.name)?t.isEmpty?null:e.createElement("paragraph"):null,view:/.+/,converterPriority:"low"});}}Rf.paragraphLikeElements=new Set(["blockquote","dd","div","dt","h1","h2","h3","h4","h5","h6","li","p","td","th"]);class jf extends Si{constructor(t,e){super(t),this.modelElements=e;}refresh(){const t=Ai(this.editor.model.document.selection.getSelectedBlocks());this.value=!!t&&this.modelElements.includes(t.name)&&t.name,this.isEnabled=!!t&&this.modelElements.some((e=>Ff(t,e,this.editor.model.schema)));}execute(t){const e=this.editor.model,n=e.document,o=t.value;e.change((t=>{const i=Array.from(n.selection.getSelectedBlocks()).filter((t=>Ff(t,o,e.schema)));for(const e of i)e.is("element",o)||t.rename(e,o);}));}}function Ff(t,e,n){return n.checkChild(t.parent,e)&&!n.isObject(t)}const Vf="paragraph";class Uf extends Mi{static get pluginName(){return "HeadingEditing"}constructor(t){super(t),t.config.define("heading",{options:[{model:"paragraph",title:"Paragraph",class:"ck-heading_paragraph"},{model:"heading1",view:"h2",title:"Heading 1",class:"ck-heading_heading1"},{model:"heading2",view:"h3",title:"Heading 2",class:"ck-heading_heading2"},{model:"heading3",view:"h4",title:"Heading 3",class:"ck-heading_heading3"}]});}static get requires(){return [Rf]}init(){const t=this.editor,e=t.config.get("heading.options"),n=[];for(const o of e)o.model!==Vf&&(t.model.schema.register(o.model,{inheritAllFrom:"$block"}),t.conversion.elementToElement(o),n.push(o.model));this._addDefaultH1Conversion(t),t.commands.add("heading",new jf(t,n));}afterInit(){const t=this.editor,e=t.commands.get("enter"),n=t.config.get("heading.options");e&&this.listenTo(e,"afterExecute",((e,o)=>{const i=t.model.document.selection.getFirstPosition().parent;n.some((t=>i.is("element",t.model)))&&!i.is("element",Vf)&&0===i.childCount&&o.writer.rename(i,Vf);}));}_addDefaultH1Conversion(t){t.conversion.for("upcast").elementToElement({model:"heading1",view:"h1",converterPriority:p.get("low")+1});}}var Hf=n(8733),Wf={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Hf.Z,Wf);Hf.Z.locals;class Gf extends Mi{static get pluginName(){return "HeadingUI"}init(){const t=this.editor,e=t.t,n=function(t){const e=t.t,n={Paragraph:e("Paragraph"),"Heading 1":e("Heading 1"),"Heading 2":e("Heading 2"),"Heading 3":e("Heading 3"),"Heading 4":e("Heading 4"),"Heading 5":e("Heading 5"),"Heading 6":e("Heading 6")};return t.config.get("heading.options").map((t=>{const e=n[t.title];return e&&e!=t.title&&(t.title=e),t}))}(t),o=e("Choose heading"),i=e("Heading");t.ui.componentFactory.add("heading",(e=>{const r={},s=new _i,a=t.commands.get("heading"),c=t.commands.get("paragraph"),l=[a];for(const t of n){const e={type:"button",model:new mg({label:t.title,class:t.class,withText:!0})};"paragraph"===t.model?(e.model.bind("isOn").to(c,"value"),e.model.set("commandName","paragraph"),l.push(c)):(e.model.bind("isOn").to(a,"value",(e=>e===t.model)),e.model.set({commandName:"heading",commandValue:t.model})),s.add(e),r[t.model]=t.title;}const d=Gu(e);return Yu(d,s),d.buttonView.set({isOn:!1,withText:!0,tooltip:i}),d.extendTemplate({attributes:{class:["ck-heading-dropdown"]}}),d.bind("isEnabled").toMany(l,"isEnabled",((...t)=>t.some((t=>t)))),d.buttonView.bind("label").to(a,"value",c,"value",((t,e)=>{const n=t||e&&"paragraph";return r[n]?r[n]:o})),this.listenTo(d,"execute",(e=>{t.execute(e.source.commandName,e.source.commandValue?{value:e.source.commandValue}:void 0),t.editing.view.focus();})),d}));}}class qf extends Si{refresh(){const t=this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);this.isEnabled=!!t,this.isEnabled&&t.hasAttribute("alt")?this.value=t.getAttribute("alt"):this.value=!1;}execute(t){const e=this.editor,n=e.plugins.get("ImageUtils"),o=e.model,i=n.getClosestSelectedImageElement(o.document.selection);o.change((e=>{e.setAttribute("alt",t.newValue,i);}));}}function Yf(t){return t.createContainerElement("figure",{class:"image"},[t.createEmptyElement("img"),t.createSlot()])}function $f(t,e){const n=t.plugins.get("ImageUtils"),o=t.plugins.has("ImageInlineEditing")&&t.plugins.has("ImageBlockEditing");return t=>{if(!n.isInlineImageView(t))return null;if(!o)return i(t);return ("block"==t.getStyle("display")||t.findAncestor(n.isBlockImageView)?"imageBlock":"imageInline")!==e?null:i(t)};function i(t){const e={name:!0};return t.hasAttribute("src")&&(e.attributes=["src"]),e}}function Kf(t,e){const n=Ai(e.getSelectedBlocks());return !n||t.isObject(n)||n.isEmpty&&"listItem"!=n.name?"imageBlock":"imageInline"}class Qf extends Mi{static get pluginName(){return "ImageUtils"}isImage(t){return this.isInlineImage(t)||this.isBlockImage(t)}isInlineImageView(t){return !!t&&t.is("element","img")}isBlockImageView(t){return !!t&&t.is("element","figure")&&t.hasClass("image")}insertImage(t={},e=null,n=null){const o=this.editor,i=o.model,r=i.document.selection;n=Zf(o,e||r,n),t={...Object.fromEntries(r.getAttributes()),...t};for(const e in t)i.schema.checkAttribute(n,e)||delete t[e];return i.change((o=>{const r=o.createElement(n,t);return i.insertObject(r,e,null,{setSelection:"on",findOptimalPosition:!e&&"imageInline"!=n}),r.parent?r:null}))}getClosestSelectedImageWidget(t){const e=t.getFirstPosition();if(!e)return null;const n=t.getSelectedElement();if(n&&this.isImageWidget(n))return n;let o=e.parent;for(;o;){if(o.is("element")&&this.isImageWidget(o))return o;o=o.parent;}return null}getClosestSelectedImageElement(t){const e=t.getSelectedElement();return this.isImage(e)?e:t.getFirstPosition().findAncestor("imageBlock")}isImageAllowed(){const t=this.editor.model.document.selection;return function(t,e){const n=Zf(t,e);if("imageBlock"==n){const n=function(t,e){const n=Fm(t,e),o=n.start.parent;if(o.isEmpty&&!o.is("element","$root"))return o.parent;return o}(e,t.model);if(t.model.schema.checkChild(n,"imageBlock"))return !0}else if(t.model.schema.checkChild(e.focus,"imageInline"))return !0;return !1}(this.editor,t)&&function(t){return [...t.focus.getAncestors()].every((t=>!t.is("element","imageBlock")))}(t)}toImageWidget(t,e,n){e.setCustomProperty("image",!0,t);return zm(t,e,{label:()=>{const e=this.findViewImgElement(t).getAttribute("alt");return e?`${e} ${n}`:n}})}isImageWidget(t){return !!t.getCustomProperty("image")&&Pm(t)}isBlockImage(t){return !!t&&t.is("element","imageBlock")}isInlineImage(t){return !!t&&t.is("element","imageInline")}findViewImgElement(t){if(this.isInlineImageView(t))return t;const e=this.editor.editing.view;for(const{item:n}of e.createRangeIn(t))if(this.isInlineImageView(n))return n}}function Zf(t,e,n){const o=t.model.schema,i=t.config.get("image.insert.type");return t.plugins.has("ImageBlockEditing")?t.plugins.has("ImageInlineEditing")?n||("inline"===i?"imageInline":"block"===i?"imageBlock":e.is("selection")?Kf(o,e):o.checkChild(e,"imageInline")?"imageInline":"imageBlock"):"imageBlock":"imageInline"}class Jf extends Mi{static get requires(){return [Qf]}static get pluginName(){return "ImageTextAlternativeEditing"}init(){this.editor.commands.add("imageTextAlternative",new qf(this.editor));}}var Xf=n(1905),tk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Xf.Z,tk);Xf.Z.locals;var ek=n(6764),nk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(ek.Z,nk);ek.Z.locals;class ok extends Ph{constructor(t){super(t);const e=this.locale.t;this.focusTracker=new Ci,this.keystrokes=new vi,this.labeledInput=this._createLabeledInputView(),this.saveButtonView=this._createButton(e("Save"),Jh.check,"ck-button-save"),this.saveButtonView.type="submit",this.cancelButtonView=this._createButton(e("Cancel"),Jh.cancel,"ck-button-cancel","cancel"),this._focusables=new dh,this._focusCycler=new vu({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:"shift + tab",focusNext:"tab"}}),this.setTemplate({tag:"form",attributes:{class:["ck","ck-text-alternative-form","ck-responsive-form"],tabindex:"-1"},children:[this.labeledInput,this.saveButtonView,this.cancelButtonView]}),tu(this);}render(){super.render(),this.keystrokes.listenTo(this.element),eu({view:this}),[this.labeledInput,this.saveButtonView,this.cancelButtonView].forEach((t=>{this._focusables.add(t),this.focusTracker.add(t.element);}));}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}_createButton(t,e,n,o){const i=new cu(this.locale);return i.set({label:t,icon:e,tooltip:!0}),i.extendTemplate({attributes:{class:n}}),o&&i.delegate("execute").to(this,o),i}_createLabeledInputView(){const t=this.locale.t,e=new hg(this.locale,ug);return e.label=t("Text alternative"),e}}function ik(t){const e=t.editing.view,n=jh.defaultPositions,o=t.plugins.get("ImageUtils");return {target:e.domConverter.mapViewToDom(o.getClosestSelectedImageWidget(e.document.selection)),positions:[n.northArrowSouth,n.northArrowSouthWest,n.northArrowSouthEast,n.southArrowNorth,n.southArrowNorthWest,n.southArrowNorthEast,n.viewportStickyNorth]}}class rk extends Mi{static get requires(){return [_g]}static get pluginName(){return "ImageTextAlternativeUI"}init(){this._createButton(),this._createForm();}destroy(){super.destroy(),this._form.destroy();}_createButton(){const t=this.editor,e=t.t;t.ui.componentFactory.add("imageTextAlternative",(n=>{const o=t.commands.get("imageTextAlternative"),i=new cu(n);return i.set({label:e("Change image text alternative"),icon:Jh.lowVision,tooltip:!0}),i.bind("isEnabled").to(o,"isEnabled"),i.bind("isOn").to(o,"value",(t=>!!t)),this.listenTo(i,"execute",(()=>{this._showForm();})),i}));}_createForm(){const t=this.editor,e=t.editing.view.document,n=t.plugins.get("ImageUtils");this._balloon=this.editor.plugins.get("ContextualBalloon"),this._form=new ok(t.locale),this._form.render(),this.listenTo(this._form,"submit",(()=>{t.execute("imageTextAlternative",{newValue:this._form.labeledInput.fieldView.element.value}),this._hideForm(!0);})),this.listenTo(this._form,"cancel",(()=>{this._hideForm(!0);})),this._form.keystrokes.set("Esc",((t,e)=>{this._hideForm(!0),e();})),this.listenTo(t.ui,"update",(()=>{n.getClosestSelectedImageWidget(e.selection)?this._isVisible&&function(t){const e=t.plugins.get("ContextualBalloon");if(t.plugins.get("ImageUtils").getClosestSelectedImageWidget(t.editing.view.document.selection)){const n=ik(t);e.updatePosition(n);}}(t):this._hideForm(!0);})),Xh({emitter:this._form,activator:()=>this._isVisible,contextElements:[this._balloon.view.element],callback:()=>this._hideForm()});}_showForm(){if(this._isVisible)return;const t=this.editor,e=t.commands.get("imageTextAlternative"),n=this._form.labeledInput;this._form.disableCssTransitions(),this._isInBalloon||this._balloon.add({view:this._form,position:ik(t)}),n.fieldView.value=n.fieldView.element.value=e.value||"",this._form.labeledInput.fieldView.select(),this._form.enableCssTransitions();}_hideForm(t){this._isInBalloon&&(this._form.focusTracker.isFocused&&this._form.saveButtonView.focus(),this._balloon.remove(this._form),t&&this.editor.editing.view.focus());}get _isVisible(){return this._balloon.visibleView===this._form}get _isInBalloon(){return this._balloon.hasView(this._form)}}class sk extends Mi{static get requires(){return [Jf,rk]}static get pluginName(){return "ImageTextAlternative"}}function ak(t,e){return t=>{t.on(`attribute:srcset:${e}`,n);};function n(e,n,o){if(!o.consumable.consume(n.item,e.name))return;const i=o.writer,r=o.mapper.toViewElement(n.item),s=t.findViewImgElement(r);if(null===n.attributeNewValue){const t=n.attributeOldValue;t.data&&(i.removeAttribute("srcset",s),i.removeAttribute("sizes",s),t.width&&i.removeAttribute("width",s));}else {const t=n.attributeNewValue;t.data&&(i.setAttribute("srcset",t.data,s),i.setAttribute("sizes","100vw",s),t.width&&i.setAttribute("width",t.width,s));}}}function ck(t,e,n){return t=>{t.on(`attribute:${n}:${e}`,o);};function o(e,n,o){if(!o.consumable.consume(n.item,e.name))return;const i=o.writer,r=o.mapper.toViewElement(n.item),s=t.findViewImgElement(r);i.setAttribute(n.attributeKey,n.attributeNewValue||"",s);}}class lk extends ha{observe(t){this.listenTo(t,"load",((t,e)=>{const n=e.target;this.checkShouldIgnoreEventFromTarget(n)||"IMG"==n.tagName&&this._fireEvents(e);}),{useCapture:!0});}_fireEvents(t){this.isEnabled&&(this.document.fire("layoutChanged"),this.document.fire("imageLoaded",t));}}class dk extends Si{constructor(t){super(t);const e=t.config.get("image.insert.type");t.plugins.has("ImageBlockEditing")||"block"===e&&b("image-block-plugin-required"),t.plugins.has("ImageInlineEditing")||"inline"===e&&b("image-inline-plugin-required");}refresh(){this.isEnabled=this.editor.plugins.get("ImageUtils").isImageAllowed();}execute(t){const e=pi(t.source),n=this.editor.model.document.selection,o=this.editor.plugins.get("ImageUtils"),i=Object.fromEntries(n.getAttributes());e.forEach(((t,e)=>{const r=n.getSelectedElement();if("string"==typeof t&&(t={src:t}),e&&r&&o.isImage(r)){const e=this.editor.model.createPositionAfter(r);o.insertImage({...t,...i},e);}else o.insertImage({...t,...i});}));}}class hk extends Mi{static get requires(){return [Qf]}static get pluginName(){return "ImageEditing"}init(){const t=this.editor,e=t.conversion;t.editing.view.addObserver(lk),e.for("upcast").attributeToAttribute({view:{name:"img",key:"alt"},model:"alt"}).attributeToAttribute({view:{name:"img",key:"srcset"},model:{key:"srcset",value:t=>{const e={data:t.getAttribute("srcset")};return t.hasAttribute("width")&&(e.width=t.getAttribute("width")),e}}});const n=new dk(t);t.commands.add("insertImage",n),t.commands.add("imageInsert",n);}}class uk extends Si{constructor(t,e){super(t),this._modelElementName=e;}refresh(){const t=this.editor.plugins.get("ImageUtils"),e=t.getClosestSelectedImageElement(this.editor.model.document.selection);"imageBlock"===this._modelElementName?this.isEnabled=t.isInlineImage(e):this.isEnabled=t.isBlockImage(e);}execute(){const t=this.editor,e=this.editor.model,n=t.plugins.get("ImageUtils"),o=n.getClosestSelectedImageElement(e.document.selection),i=Object.fromEntries(o.getAttributes());return i.src||i.uploadId?e.change((t=>{const r=Array.from(e.markers).filter((t=>t.getRange().containsItem(o))),s=n.insertImage(i,e.createSelection(o,"on"),this._modelElementName);if(!s)return null;const a=t.createRangeOn(s);for(const e of r){const n=e.getRange(),o="$graveyard"!=n.root.rootName?n.getJoined(a,!0):a;t.updateMarker(e,{range:o});}return {oldElement:o,newElement:s}})):null}}class gk extends Mi{static get requires(){return [hk,Qf,Og]}static get pluginName(){return "ImageBlockEditing"}init(){const t=this.editor;t.model.schema.register("imageBlock",{inheritAllFrom:"$blockObject",allowAttributes:["alt","src","srcset"]}),this._setupConversion(),t.plugins.has("ImageInlineEditing")&&(t.commands.add("imageTypeBlock",new uk(this.editor,"imageBlock")),this._setupClipboardIntegration());}_setupConversion(){const t=this.editor,e=t.t,n=t.conversion,o=t.plugins.get("ImageUtils");n.for("dataDowncast").elementToStructure({model:"imageBlock",view:(t,{writer:e})=>Yf(e)}),n.for("editingDowncast").elementToStructure({model:"imageBlock",view:(t,{writer:n})=>o.toImageWidget(Yf(n),n,e("image widget"))}),n.for("downcast").add(ck(o,"imageBlock","src")).add(ck(o,"imageBlock","alt")).add(ak(o,"imageBlock")),n.for("upcast").elementToElement({view:$f(t,"imageBlock"),model:(t,{writer:e})=>e.createElement("imageBlock",t.hasAttribute("src")?{src:t.getAttribute("src")}:null)}).add(function(t){return t=>{t.on("element:figure",e);};function e(e,n,o){if(!o.consumable.test(n.viewItem,{name:!0,classes:"image"}))return;const i=t.findViewImgElement(n.viewItem);if(!i||!o.consumable.test(i,{name:!0}))return;o.consumable.consume(n.viewItem,{name:!0,classes:"image"});const r=Ai(o.convertItem(i,n.modelCursor).modelRange.getItems());r?(o.convertChildren(n.viewItem,r),o.updateConversionResult(r,n)):o.consumable.revert(n.viewItem,{name:!0,classes:"image"});}}(o));}_setupClipboardIntegration(){const t=this.editor,e=t.model,n=t.editing.view,o=t.plugins.get("ImageUtils");this.listenTo(t.plugins.get("ClipboardPipeline"),"inputTransformation",((i,r)=>{const s=Array.from(r.content.getChildren());let a;if(!s.every(o.isInlineImageView))return;a=r.targetRanges?t.editing.mapper.toModelRange(r.targetRanges[0]):e.document.selection.getFirstRange();const c=e.createSelection(a);if("imageBlock"===Kf(e.schema,c)){const t=new ih(n.document),e=s.map((e=>t.createElement("figure",{class:"image"},e)));r.content=t.createDocumentFragment(e);}}));}}var mk=n(3508),pk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(mk.Z,pk);mk.Z.locals;class fk extends Mi{static get requires(){return [gk,np,sk]}static get pluginName(){return "ImageBlock"}}class kk extends Mi{static get requires(){return [hk,Qf,Og]}static get pluginName(){return "ImageInlineEditing"}init(){const t=this.editor,e=t.model.schema;e.register("imageInline",{inheritAllFrom:"$inlineObject",allowAttributes:["alt","src","srcset"]}),e.addChildCheck(((t,e)=>{if(t.endsWith("caption")&&"imageInline"===e.name)return !1})),this._setupConversion(),t.plugins.has("ImageBlockEditing")&&(t.commands.add("imageTypeInline",new uk(this.editor,"imageInline")),this._setupClipboardIntegration());}_setupConversion(){const t=this.editor,e=t.t,n=t.conversion,o=t.plugins.get("ImageUtils");n.for("dataDowncast").elementToElement({model:"imageInline",view:(t,{writer:e})=>e.createEmptyElement("img")}),n.for("editingDowncast").elementToStructure({model:"imageInline",view:(t,{writer:n})=>o.toImageWidget(function(t){return t.createContainerElement("span",{class:"image-inline"},t.createEmptyElement("img"))}(n),n,e("image widget"))}),n.for("downcast").add(ck(o,"imageInline","src")).add(ck(o,"imageInline","alt")).add(ak(o,"imageInline")),n.for("upcast").elementToElement({view:$f(t,"imageInline"),model:(t,{writer:e})=>e.createElement("imageInline",t.hasAttribute("src")?{src:t.getAttribute("src")}:null)});}_setupClipboardIntegration(){const t=this.editor,e=t.model,n=t.editing.view,o=t.plugins.get("ImageUtils");this.listenTo(t.plugins.get("ClipboardPipeline"),"inputTransformation",((i,r)=>{const s=Array.from(r.content.getChildren());let a;if(!s.every(o.isBlockImageView))return;a=r.targetRanges?t.editing.mapper.toModelRange(r.targetRanges[0]):e.document.selection.getFirstRange();const c=e.createSelection(a);if("imageInline"===Kf(e.schema,c)){const t=new ih(n.document),e=s.map((e=>1===e.childCount?(Array.from(e.getAttributes()).forEach((n=>t.setAttribute(...n,o.findViewImgElement(e)))),e.getChild(0)):e));r.content=t.createDocumentFragment(e);}}));}}class bk extends Mi{static get requires(){return [kk,np,sk]}static get pluginName(){return "ImageInline"}}class wk extends Si{refresh(){const t=this.editor,e=t.plugins.get("ImageCaptionUtils");if(!t.plugins.has(gk))return this.isEnabled=!1,void(this.value=!1);const n=t.model.document.selection,o=n.getSelectedElement();if(!o){const t=e.getCaptionFromModelSelection(n);return this.isEnabled=!!t,void(this.value=!!t)}this.isEnabled=this.editor.plugins.get("ImageUtils").isImage(o),this.isEnabled?this.value=!!e.getCaptionFromImageModelElement(o):this.value=!1;}execute(t={}){const{focusCaptionOnShow:e}=t;this.editor.model.change((t=>{this.value?this._hideImageCaption(t):this._showImageCaption(t,e);}));}_showImageCaption(t,e){const n=this.editor.model.document.selection,o=this.editor.plugins.get("ImageCaptionEditing");let i=n.getSelectedElement();const r=o._getSavedCaption(i);this.editor.plugins.get("ImageUtils").isInlineImage(i)&&(this.editor.execute("imageTypeBlock"),i=n.getSelectedElement());const s=r||t.createElement("caption");t.append(s,i),e&&t.setSelection(s,"in");}_hideImageCaption(t){const e=this.editor,n=e.model.document.selection,o=e.plugins.get("ImageCaptionEditing"),i=e.plugins.get("ImageCaptionUtils");let r,s=n.getSelectedElement();s?r=i.getCaptionFromImageModelElement(s):(r=i.getCaptionFromModelSelection(n),s=r.parent),o._saveCaption(s,r),t.setSelection(s,"on"),t.remove(r);}}class _k extends Mi{static get pluginName(){return "ImageCaptionUtils"}static get requires(){return [Qf]}getCaptionFromImageModelElement(t){for(const e of t.getChildren())if(e&&e.is("element","caption"))return e;return null}getCaptionFromModelSelection(t){const e=this.editor.plugins.get("ImageUtils"),n=t.getFirstPosition().findAncestor("caption");return n&&e.isBlockImage(n.parent)?n:null}matchImageCaptionViewElement(t){const e=this.editor.plugins.get("ImageUtils");return "figcaption"==t.name&&e.isBlockImageView(t.parent)?{name:!0}:null}}class Ak extends Mi{static get requires(){return [Qf,_k]}static get pluginName(){return "ImageCaptionEditing"}constructor(t){super(t),this._savedCaptionsMap=new WeakMap;}init(){const t=this.editor,e=t.model.schema;e.isRegistered("caption")?e.extend("caption",{allowIn:"imageBlock"}):e.register("caption",{allowIn:"imageBlock",allowContentOf:"$block",isLimit:!0}),t.commands.add("toggleImageCaption",new wk(this.editor)),this._setupConversion(),this._setupImageTypeCommandsIntegration(),this._registerCaptionReconversion();}_setupConversion(){const t=this.editor,e=t.editing.view,n=t.plugins.get("ImageUtils"),o=t.plugins.get("ImageCaptionUtils"),i=t.t;t.conversion.for("upcast").elementToElement({view:t=>o.matchImageCaptionViewElement(t),model:"caption"}),t.conversion.for("dataDowncast").elementToElement({model:"caption",view:(t,{writer:e})=>n.isBlockImage(t.parent)?e.createContainerElement("figcaption"):null}),t.conversion.for("editingDowncast").elementToElement({model:"caption",view:(t,{writer:o})=>{if(!n.isBlockImage(t.parent))return null;const r=o.createEditableElement("figcaption");o.setCustomProperty("imageCaption",!0,r),Ui({view:e,element:r,text:i("Enter image caption"),keepOnFocus:!0});const s=t.parent.getAttribute("alt");return jm(r,o,{label:s?i("Caption for image: %0",[s]):i("Caption for the image")})}});}_setupImageTypeCommandsIntegration(){const t=this.editor,e=t.plugins.get("ImageUtils"),n=t.plugins.get("ImageCaptionUtils"),o=t.commands.get("imageTypeInline"),i=t.commands.get("imageTypeBlock"),r=t=>{if(!t.return)return;const{oldElement:o,newElement:i}=t.return;if(!o)return;if(e.isBlockImage(o)){const t=n.getCaptionFromImageModelElement(o);if(t)return void this._saveCaption(i,t)}const r=this._getSavedCaption(o);r&&this._saveCaption(i,r);};o&&this.listenTo(o,"execute",r,{priority:"low"}),i&&this.listenTo(i,"execute",r,{priority:"low"});}_getSavedCaption(t){const e=this._savedCaptionsMap.get(t);return e?uc.fromJSON(e):null}_saveCaption(t,e){this._savedCaptionsMap.set(t,e.toJSON());}_registerCaptionReconversion(){const t=this.editor,e=t.model,n=t.plugins.get("ImageUtils"),o=t.plugins.get("ImageCaptionUtils");e.document.on("change:data",(()=>{const i=e.document.differ.getChanges();for(const e of i){if("alt"!==e.attributeKey)continue;const i=e.range.start.nodeAfter;if(n.isBlockImage(i)){const e=o.getCaptionFromImageModelElement(i);if(!e)return;t.editing.reconvertItem(e);}}}));}}class Ck extends Mi{static get requires(){return [_k]}static get pluginName(){return "ImageCaptionUI"}init(){const t=this.editor,e=t.editing.view,n=t.plugins.get("ImageCaptionUtils"),o=t.t;t.ui.componentFactory.add("toggleImageCaption",(i=>{const r=t.commands.get("toggleImageCaption"),s=new cu(i);return s.set({icon:Jh.caption,tooltip:!0,isToggleable:!0}),s.bind("isOn","isEnabled").to(r,"value","isEnabled"),s.bind("label").to(r,"value",(t=>o(t?"Toggle caption off":"Toggle caption on"))),this.listenTo(s,"execute",(()=>{t.execute("toggleImageCaption",{focusCaptionOnShow:!0});const o=n.getCaptionFromModelSelection(t.model.document.selection);if(o){const n=t.editing.mapper.toViewElement(o);e.scrollToTheSelection(),e.change((t=>{t.addClass("image__caption_highlighted",n);}));}t.editing.view.focus();})),s}));}}var vk=n(2640),yk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(vk.Z,yk);vk.Z.locals;class xk extends Si{constructor(t,e){super(t),this._defaultStyles={imageBlock:!1,imageInline:!1},this._styles=new Map(e.map((t=>{if(t.isDefault)for(const e of t.modelElements)this._defaultStyles[e]=t.name;return [t.name,t]})));}refresh(){const t=this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);this.isEnabled=!!t,this.isEnabled?t.hasAttribute("imageStyle")?this.value=t.getAttribute("imageStyle"):this.value=this._defaultStyles[t.name]:this.value=!1;}execute(t={}){const e=this.editor,n=e.model,o=e.plugins.get("ImageUtils");n.change((e=>{const i=t.value;let r=o.getClosestSelectedImageElement(n.document.selection);i&&this.shouldConvertImageType(i,r)&&(this.editor.execute(o.isBlockImage(r)?"imageTypeInline":"imageTypeBlock"),r=o.getClosestSelectedImageElement(n.document.selection)),!i||this._styles.get(i).isDefault?e.removeAttribute("imageStyle",r):e.setAttribute("imageStyle",i,r);}));}shouldConvertImageType(t,e){return !this._styles.get(t).modelElements.includes(e.name)}}const{objectFullWidth:Ek,objectInline:Dk,objectLeft:Ik,objectRight:Mk,objectCenter:Tk,objectBlockLeft:Sk,objectBlockRight:Nk}=Jh,Bk={get inline(){return {name:"inline",title:"In line",icon:Dk,modelElements:["imageInline"],isDefault:!0}},get alignLeft(){return {name:"alignLeft",title:"Left aligned image",icon:Ik,modelElements:["imageBlock","imageInline"],className:"image-style-align-left"}},get alignBlockLeft(){return {name:"alignBlockLeft",title:"Left aligned image",icon:Sk,modelElements:["imageBlock"],className:"image-style-block-align-left"}},get alignCenter(){return {name:"alignCenter",title:"Centered image",icon:Tk,modelElements:["imageBlock"],className:"image-style-align-center"}},get alignRight(){return {name:"alignRight",title:"Right aligned image",icon:Mk,modelElements:["imageBlock","imageInline"],className:"image-style-align-right"}},get alignBlockRight(){return {name:"alignBlockRight",title:"Right aligned image",icon:Nk,modelElements:["imageBlock"],className:"image-style-block-align-right"}},get block(){return {name:"block",title:"Centered image",icon:Tk,modelElements:["imageBlock"],isDefault:!0}},get side(){return {name:"side",title:"Side image",icon:Mk,modelElements:["imageBlock"],className:"image-style-side"}}},Pk={full:Ek,left:Sk,right:Nk,center:Tk,inlineLeft:Ik,inlineRight:Mk,inline:Dk},zk=[{name:"imageStyle:wrapText",title:"Wrap text",defaultItem:"imageStyle:alignLeft",items:["imageStyle:alignLeft","imageStyle:alignRight"]},{name:"imageStyle:breakText",title:"Break text",defaultItem:"imageStyle:block",items:["imageStyle:alignBlockLeft","imageStyle:block","imageStyle:alignBlockRight"]}];function Lk(t){b("image-style-configuration-definition-invalid",t);}const Ok={normalizeStyles:function(t){return (t.configuredStyles.options||[]).map((t=>function(t){t="string"==typeof t?Bk[t]?{...Bk[t]}:{name:t}:function(t,e){const n={...e};for(const o in t)Object.prototype.hasOwnProperty.call(e,o)||(n[o]=t[o]);return n}(Bk[t.name],t);"string"==typeof t.icon&&(t.icon=Pk[t.icon]||t.icon);return t}(t))).filter((e=>function(t,{isBlockPluginLoaded:e,isInlinePluginLoaded:n}){const{modelElements:o,name:i}=t;if(!(o&&o.length&&i))return Lk({style:t}),!1;{const i=[e?"imageBlock":null,n?"imageInline":null];if(!o.some((t=>i.includes(t))))return b("image-style-missing-dependency",{style:t,missingPlugins:o.map((t=>"imageBlock"===t?"ImageBlockEditing":"ImageInlineEditing"))}),!1}return !0}(e,t)))},getDefaultStylesConfiguration:function(t,e){return t&&e?{options:["inline","alignLeft","alignRight","alignCenter","alignBlockLeft","alignBlockRight","block","side"]}:t?{options:["block","side"]}:e?{options:["inline","alignLeft","alignRight"]}:{}},getDefaultDropdownDefinitions:function(t){return t.has("ImageBlockEditing")&&t.has("ImageInlineEditing")?[...zk]:[]},warnInvalidStyle:Lk,DEFAULT_OPTIONS:Bk,DEFAULT_ICONS:Pk,DEFAULT_DROPDOWN_DEFINITIONS:zk};function Rk(t,e){for(const n of e)if(n.name===t)return n}class jk extends Mi{static get pluginName(){return "ImageStyleEditing"}static get requires(){return [Qf]}init(){const{normalizeStyles:t,getDefaultStylesConfiguration:e}=Ok,n=this.editor,o=n.plugins.has("ImageBlockEditing"),i=n.plugins.has("ImageInlineEditing");n.config.define("image.styles",e(o,i)),this.normalizedStyles=t({configuredStyles:n.config.get("image.styles"),isBlockPluginLoaded:o,isInlinePluginLoaded:i}),this._setupConversion(o,i),this._setupPostFixer(),n.commands.add("imageStyle",new xk(n,this.normalizedStyles));}_setupConversion(t,e){const n=this.editor,o=n.model.schema,i=(r=this.normalizedStyles,(t,e,n)=>{if(!n.consumable.consume(e.item,t.name))return;const o=Rk(e.attributeNewValue,r),i=Rk(e.attributeOldValue,r),s=n.mapper.toViewElement(e.item),a=n.writer;i&&a.removeClass(i.className,s),o&&a.addClass(o.className,s);});var r;const s=function(t){const e={imageInline:t.filter((t=>!t.isDefault&&t.modelElements.includes("imageInline"))),imageBlock:t.filter((t=>!t.isDefault&&t.modelElements.includes("imageBlock")))};return (t,n,o)=>{if(!n.modelRange)return;const i=n.viewItem,r=Ai(n.modelRange.getItems());if(r&&o.schema.checkAttribute(r,"imageStyle"))for(const t of e[r.name])o.consumable.consume(i,{classes:t.className})&&o.writer.setAttribute("imageStyle",t.name,r);}}(this.normalizedStyles);n.editing.downcastDispatcher.on("attribute:imageStyle",i),n.data.downcastDispatcher.on("attribute:imageStyle",i),t&&(o.extend("imageBlock",{allowAttributes:"imageStyle"}),n.data.upcastDispatcher.on("element:figure",s,{priority:"low"})),e&&(o.extend("imageInline",{allowAttributes:"imageStyle"}),n.data.upcastDispatcher.on("element:img",s,{priority:"low"}));}_setupPostFixer(){const t=this.editor,e=t.model.document,n=t.plugins.get(Qf),o=new Map(this.normalizedStyles.map((t=>[t.name,t])));e.registerPostFixer((t=>{let i=!1;for(const r of e.differ.getChanges())if("insert"==r.type||"attribute"==r.type&&"imageStyle"==r.attributeKey){let e="insert"==r.type?r.position.nodeAfter:r.range.start.nodeAfter;if(e&&e.is("element","paragraph")&&e.childCount>0&&(e=e.getChild(0)),!n.isImage(e))continue;const s=e.getAttribute("imageStyle");if(!s)continue;const a=o.get(s);a&&a.modelElements.includes(e.name)||(t.removeAttribute("imageStyle",e),i=!0);}return i}));}}var Fk=n(5083),Vk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Fk.Z,Vk);Fk.Z.locals;class Uk extends Mi{static get requires(){return [jk]}static get pluginName(){return "ImageStyleUI"}get localizedDefaultStylesTitles(){const t=this.editor.t;return {"Wrap text":t("Wrap text"),"Break text":t("Break text"),"In line":t("In line"),"Full size image":t("Full size image"),"Side image":t("Side image"),"Left aligned image":t("Left aligned image"),"Centered image":t("Centered image"),"Right aligned image":t("Right aligned image")}}init(){const t=this.editor.plugins,e=this.editor.config.get("image.toolbar")||[],n=Hk(t.get("ImageStyleEditing").normalizedStyles,this.localizedDefaultStylesTitles);for(const t of n)this._createButton(t);const o=Hk([...e.filter(L),...Ok.getDefaultDropdownDefinitions(t)],this.localizedDefaultStylesTitles);for(const t of o)this._createDropdown(t,n);}_createDropdown(t,e){const n=this.editor.ui.componentFactory;n.add(t.name,(o=>{let i;const{defaultItem:r,items:s,title:a}=t,c=s.filter((t=>e.find((({name:e})=>Wk(e)===t)))).map((t=>{const e=n.create(t);return t===r&&(i=e),e}));s.length!==c.length&&Ok.warnInvalidStyle({dropdown:t});const l=Gu(o,bu),d=l.buttonView,h=d.arrowView;return qu(l,c,{enableActiveItemFocusOnDropdownOpen:!0}),d.set({label:Gk(a,i.label),class:null,tooltip:!0}),h.unbind("label"),h.set({label:a}),d.bind("icon").toMany(c,"isOn",((...t)=>{const e=t.findIndex(Nr);return e<0?i.icon:c[e].icon})),d.bind("label").toMany(c,"isOn",((...t)=>{const e=t.findIndex(Nr);return Gk(a,e<0?i.label:c[e].label)})),d.bind("isOn").toMany(c,"isOn",((...t)=>t.some(Nr))),d.bind("class").toMany(c,"isOn",((...t)=>t.some(Nr)?"ck-splitbutton_flatten":null)),d.on("execute",(()=>{c.some((({isOn:t})=>t))?l.isOpen=!l.isOpen:i.fire("execute");})),l.bind("isEnabled").toMany(c,"isEnabled",((...t)=>t.some(Nr))),this.listenTo(l,"execute",(()=>{this.editor.editing.view.focus();})),l}));}_createButton(t){const e=t.name;this.editor.ui.componentFactory.add(Wk(e),(n=>{const o=this.editor.commands.get("imageStyle"),i=new cu(n);return i.set({label:t.title,icon:t.icon,tooltip:!0,isToggleable:!0}),i.bind("isEnabled").to(o,"isEnabled"),i.bind("isOn").to(o,"value",(t=>t===e)),i.on("execute",this._executeCommand.bind(this,e)),i}));}_executeCommand(t){this.editor.execute("imageStyle",{value:t}),this.editor.editing.view.focus();}}function Hk(t,e){for(const n of t)e[n.title]&&(n.title=e[n.title]);return t}function Wk(t){return `imageStyle:${t}`}function Gk(t,e){return (t?t+": ":"")+e}function qk(t){const e=t.map((t=>t.replace("+","\\+")));return new RegExp(`^image\\/(${e.join("|")})$`)}function Yk(t){return new Promise(((e,n)=>{const o=t.getAttribute("src");fetch(o).then((t=>t.blob())).then((t=>{const n=$k(t,o),i=n.replace("image/",""),r=new File([t],`image.${i}`,{type:n});e(r);})).catch((t=>t&&"TypeError"===t.name?function(t){return function(t){return new Promise(((e,n)=>{const o=So.document.createElement("img");o.addEventListener("load",(()=>{const t=So.document.createElement("canvas");t.width=o.width,t.height=o.height;t.getContext("2d").drawImage(o,0,0),t.toBlob((t=>t?e(t):n()));})),o.addEventListener("error",(()=>n())),o.src=t;}))}(t).then((e=>{const n=$k(e,t),o=n.replace("image/","");return new File([e],`image.${o}`,{type:n})}))}(o).then(e).catch(n):n(t)));}))}function $k(t,e){return t.type?t.type:e.match(/data:(image\/\w+);base64/)?e.match(/data:(image\/\w+);base64/)[1].toLowerCase():"image/jpeg"}class Kk extends Mi{static get pluginName(){return "ImageUploadUI"}init(){const t=this.editor,e=t.t,n=n=>{const o=new Fp(n),i=t.commands.get("uploadImage"),r=t.config.get("image.upload.types"),s=qk(r);return o.set({acceptedType:r.map((t=>`image/${t}`)).join(","),allowMultipleFiles:!0}),o.buttonView.set({label:e("Insert image"),icon:Jh.image,tooltip:!0}),o.buttonView.bind("isEnabled").to(i),o.on("done",((e,n)=>{const o=Array.from(n).filter((t=>s.test(t.type)));o.length&&(t.execute("uploadImage",{file:o}),t.editing.view.focus());})),o};t.ui.componentFactory.add("uploadImage",n),t.ui.componentFactory.add("imageUpload",n);}}var Qk=n(3689),Zk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Qk.Z,Zk);Qk.Z.locals;var Jk=n(4036),Xk={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Jk.Z,Xk);Jk.Z.locals;var tb=n(3773),eb={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(tb.Z,eb);tb.Z.locals;class nb extends Mi{static get pluginName(){return "ImageUploadProgress"}constructor(t){super(t),this.placeholder="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";}init(){const t=this.editor;t.plugins.has("ImageBlockEditing")&&t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock",((...t)=>this.uploadStatusChange(...t))),t.plugins.has("ImageInlineEditing")&&t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline",((...t)=>this.uploadStatusChange(...t)));}uploadStatusChange(t,e,n){const o=this.editor,i=e.item,r=i.getAttribute("uploadId");if(!n.consumable.consume(e.item,t.name))return;const s=o.plugins.get("ImageUtils"),a=o.plugins.get(Rp),c=r?e.attributeNewValue:null,l=this.placeholder,d=o.editing.mapper.toViewElement(i),h=n.writer;if("reading"==c)return ob(d,h),void ib(s,l,d,h);if("uploading"==c){const t=a.loaders.get(r);return ob(d,h),void(t?(rb(d,h),function(t,e,n,o){const i=function(t){const e=t.createUIElement("div",{class:"ck-progress-bar"});return t.setCustomProperty("progressBar",!0,e),e}(e);e.insert(e.createPositionAt(t,"end"),i),n.on("change:uploadedPercent",((t,e,n)=>{o.change((t=>{t.setStyle("width",n+"%",i);}));}));}(d,h,t,o.editing.view),function(t,e,n,o){if(o.data){const i=t.findViewImgElement(e);n.setAttribute("src",o.data,i);}}(s,d,h,t)):ib(s,l,d,h))}"complete"==c&&a.loaders.get(r)&&function(t,e,n){const o=e.createUIElement("div",{class:"ck-image-upload-complete-icon"});e.insert(e.createPositionAt(t,"end"),o),setTimeout((()=>{n.change((t=>t.remove(t.createRangeOn(o))));}),3e3);}(d,h,o.editing.view),function(t,e){ab(t,e,"progressBar");}(d,h),rb(d,h),function(t,e){e.removeClass("ck-appear",t);}(d,h);}}function ob(t,e){t.hasClass("ck-appear")||e.addClass("ck-appear",t);}function ib(t,e,n,o){n.hasClass("ck-image-upload-placeholder")||o.addClass("ck-image-upload-placeholder",n);const i=t.findViewImgElement(n);i.getAttribute("src")!==e&&o.setAttribute("src",e,i),sb(n,"placeholder")||o.insert(o.createPositionAfter(i),function(t){const e=t.createUIElement("div",{class:"ck-upload-placeholder-loader"});return t.setCustomProperty("placeholder",!0,e),e}(o));}function rb(t,e){t.hasClass("ck-image-upload-placeholder")&&e.removeClass("ck-image-upload-placeholder",t),ab(t,e,"placeholder");}function sb(t,e){for(const n of t.getChildren())if(n.getCustomProperty(e))return n}function ab(t,e,n){const o=sb(t,n);o&&e.remove(e.createRangeOn(o));}class cb extends Si{refresh(){const t=this.editor,e=t.plugins.get("ImageUtils"),n=t.model.document.selection.getSelectedElement();this.isEnabled=e.isImageAllowed()||e.isImage(n);}execute(t){const e=pi(t.file),n=this.editor.model.document.selection,o=this.editor.plugins.get("ImageUtils"),i=Object.fromEntries(n.getAttributes());e.forEach(((t,e)=>{const r=n.getSelectedElement();if(e&&r&&o.isImage(r)){const e=this.editor.model.createPositionAfter(r);this._uploadImage(t,i,e);}else this._uploadImage(t,i);}));}_uploadImage(t,e,n){const o=this.editor,i=o.plugins.get(Rp).createLoader(t),r=o.plugins.get("ImageUtils");i&&r.insertImage({...e,uploadId:i.id},n);}}class lb extends Mi{static get requires(){return [Rp,gg,Og,Qf]}static get pluginName(){return "ImageUploadEditing"}constructor(t){super(t),t.config.define("image",{upload:{types:["jpeg","png","gif","bmp","webp","tiff"]}}),this._uploadImageElements=new Map;}init(){const t=this.editor,e=t.model.document,n=t.conversion,o=t.plugins.get(Rp),i=t.plugins.get("ImageUtils"),r=qk(t.config.get("image.upload.types")),s=new cb(t);t.commands.add("uploadImage",s),t.commands.add("imageUpload",s),n.for("upcast").attributeToAttribute({view:{name:"img",key:"uploadId"},model:"uploadId"}),this.listenTo(t.editing.view.document,"clipboardInput",((e,n)=>{if(o=n.dataTransfer,Array.from(o.types).includes("text/html")&&""!==o.getData("text/html"))return;var o;const i=Array.from(n.dataTransfer.files).filter((t=>!!t&&r.test(t.type)));i.length&&(e.stop(),t.model.change((e=>{n.targetRanges&&e.setSelection(n.targetRanges.map((e=>t.editing.mapper.toModelRange(e)))),t.model.enqueueChange((()=>{t.execute("uploadImage",{file:i});}));})));})),this.listenTo(t.plugins.get("ClipboardPipeline"),"inputTransformation",((e,n)=>{const r=Array.from(t.editing.view.createRangeIn(n.content)).filter((t=>function(t,e){return !(!t.isInlineImageView(e)||!e.getAttribute("src"))&&(e.getAttribute("src").match(/^data:image\/\w+;base64,/g)||e.getAttribute("src").match(/^blob:/g))}(i,t.item)&&!t.item.getAttribute("uploadProcessed"))).map((t=>({promise:Yk(t.item),imageElement:t.item})));if(!r.length)return;const s=new ih(t.editing.view.document);for(const t of r){s.setAttribute("uploadProcessed",!0,t.imageElement);const e=o.createLoader(t.promise);e&&(s.setAttribute("src","",t.imageElement),s.setAttribute("uploadId",e.id,t.imageElement));}})),t.editing.view.document.on("dragover",((t,e)=>{e.preventDefault();})),e.on("change",(()=>{const n=e.differ.getChanges({includeChangesInGraveyard:!0}).reverse(),i=new Set;for(const e of n)if("insert"==e.type&&"$text"!=e.name){const n=e.position.nodeAfter,r="$graveyard"==e.position.root.rootName;for(const e of db(t,n)){const t=e.getAttribute("uploadId");if(!t)continue;const n=o.loaders.get(t);n&&(r?i.has(t)||n.abort():(i.add(t),this._uploadImageElements.set(t,e),"idle"==n.status&&this._readAndUpload(n)));}}})),this.on("uploadComplete",((t,{imageElement:e,data:n})=>{const o=n.urls?n.urls:n;this.editor.model.change((t=>{t.setAttribute("src",o.default,e),this._parseAndSetSrcsetAttributeOnImage(o,e,t);}));}),{priority:"low"});}afterInit(){const t=this.editor.model.schema;this.editor.plugins.has("ImageBlockEditing")&&t.extend("imageBlock",{allowAttributes:["uploadId","uploadStatus"]}),this.editor.plugins.has("ImageInlineEditing")&&t.extend("imageInline",{allowAttributes:["uploadId","uploadStatus"]});}_readAndUpload(t){const e=this.editor,n=e.model,o=e.locale.t,r=e.plugins.get(Rp),s=e.plugins.get(gg),a=e.plugins.get("ImageUtils"),c=this._uploadImageElements;return n.enqueueChange({isUndoable:!1},(e=>{e.setAttribute("uploadStatus","reading",c.get(t.id));})),t.read().then((()=>{const o=t.upload(),r=c.get(t.id);if(i.isSafari){const t=e.editing.mapper.toViewElement(r),n=a.findViewImgElement(t);e.editing.view.once("render",(()=>{if(!n.parent)return;const t=e.editing.view.domConverter.mapViewToDom(n.parent);if(!t)return;const o=t.style.display;t.style.display="none",t._ckHack=t.offsetHeight,t.style.display=o;}));}return n.enqueueChange({isUndoable:!1},(t=>{t.setAttribute("uploadStatus","uploading",r);})),o})).then((e=>{n.enqueueChange({isUndoable:!1},(n=>{const o=c.get(t.id);n.setAttribute("uploadStatus","complete",o),this.fire("uploadComplete",{data:e,imageElement:o});})),l();})).catch((e=>{if("error"!==t.status&&"aborted"!==t.status)throw e;"error"==t.status&&e&&s.showWarning(e,{title:o("Upload failed"),namespace:"upload"}),n.enqueueChange({isUndoable:!1},(e=>{e.remove(c.get(t.id));})),l();}));function l(){n.enqueueChange({isUndoable:!1},(e=>{const n=c.get(t.id);e.removeAttribute("uploadId",n),e.removeAttribute("uploadStatus",n),c.delete(t.id);})),r.destroyLoader(t);}}_parseAndSetSrcsetAttributeOnImage(t,e,n){let o=0;const i=Object.keys(t).filter((t=>{const e=parseInt(t,10);if(!isNaN(e))return o=Math.max(o,e),!0})).map((e=>`${t[e]} ${e}w`)).join(", ");""!=i&&n.setAttribute("srcset",{data:i,width:o},e);}}function db(t,e){const n=t.plugins.get("ImageUtils");return Array.from(t.model.createRangeOn(e)).filter((t=>n.isImage(t.item))).map((t=>t.item))}class hb extends Mi{static get pluginName(){return "IndentEditing"}init(){const t=this.editor;t.commands.add("indent",new Bi(t)),t.commands.add("outdent",new Bi(t));}}const ub='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',gb='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';class mb extends Mi{static get pluginName(){return "IndentUI"}init(){const t=this.editor,e=t.locale,n=t.t,o="ltr"==e.uiLanguageDirection?ub:gb,i="ltr"==e.uiLanguageDirection?gb:ub;this._defineButton("indent",n("Increase indent"),o),this._defineButton("outdent",n("Decrease indent"),i);}_defineButton(t,e,n){const o=this.editor;o.ui.componentFactory.add(t,(i=>{const r=o.commands.get(t),s=new cu(i);return s.set({label:e,icon:n,tooltip:!0}),s.bind("isOn","isEnabled").to(r,"value","isEnabled"),this.listenTo(s,"execute",(()=>{o.execute(t),o.editing.view.focus();})),s}));}}class pb{constructor(){this._definitions=new Set;}get length(){return this._definitions.size}add(t){Array.isArray(t)?t.forEach((t=>this._definitions.add(t))):this._definitions.add(t);}getDispatcher(){return t=>{t.on("attribute:linkHref",((t,e,n)=>{if(!n.consumable.test(e.item,"attribute:linkHref"))return;if(!e.item.is("selection")&&!n.schema.isInline(e.item))return;const o=n.writer,i=o.document.selection;for(const t of this._definitions){const r=o.createAttributeElement("a",t.attributes,{priority:5});t.classes&&o.addClass(t.classes,r);for(const e in t.styles)o.setStyle(e,t.styles[e],r);o.setCustomProperty("link",!0,r),t.callback(e.attributeNewValue)?e.item.is("selection")?o.wrap(i.getFirstRange(),r):o.wrap(n.mapper.toViewRange(e.range),r):o.unwrap(n.mapper.toViewRange(e.range),r);}}),{priority:"high"});}}getDispatcherForLinkedImage(){return t=>{t.on("attribute:linkHref:imageBlock",((t,e,{writer:n,mapper:o})=>{const i=o.toViewElement(e.item),r=Array.from(i.getChildren()).find((t=>"a"===t.name));for(const t of this._definitions){const o=yi(t.attributes);if(t.callback(e.attributeNewValue)){for(const[t,e]of o)"class"===t?n.addClass(e,r):n.setAttribute(t,e,r);t.classes&&n.addClass(t.classes,r);for(const e in t.styles)n.setStyle(e,t.styles[e],r);}else {for(const[t,e]of o)"class"===t?n.removeClass(e,r):n.removeAttribute(t,r);t.classes&&n.removeClass(t.classes,r);for(const e in t.styles)n.removeStyle(e,r);}}}));}}}const fb=function(t,e,n){var o=t.length;return n=void 0===n?o:n,!e&&n>=o?t:_r(t,e,n)};var kb=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");const bb=function(t){return kb.test(t)};const wb=function(t){return t.split("")};var _b="\\ud800-\\udfff",Ab="["+_b+"]",Cb="[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",vb="\\ud83c[\\udffb-\\udfff]",yb="[^"+_b+"]",xb="(?:\\ud83c[\\udde6-\\uddff]){2}",Eb="[\\ud800-\\udbff][\\udc00-\\udfff]",Db="(?:"+Cb+"|"+vb+")"+"?",Ib="[\\ufe0e\\ufe0f]?",Mb=Ib+Db+("(?:\\u200d(?:"+[yb,xb,Eb].join("|")+")"+Ib+Db+")*"),Tb="(?:"+[yb+Cb+"?",Cb,xb,Eb,Ab].join("|")+")",Sb=RegExp(vb+"(?="+vb+")|"+Tb+Mb,"g");const Nb=function(t){return t.match(Sb)||[]};const Bb=function(t){return bb(t)?Nb(t):wb(t)};const Pb=function(t){return function(e){e=pr(e);var n=bb(e)?Bb(e):void 0,o=n?n[0]:e.charAt(0),i=n?fb(n,1).join(""):e.slice(1);return o[t]()+i}}("toUpperCase"),zb=/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,Lb=/^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,Ob=/^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,Rb=/^((\w+:(\/{2,})?)|(\W))/i,jb="Ctrl+K";function Fb(t,{writer:e}){const n=e.createAttributeElement("a",{href:t},{priority:5});return e.setCustomProperty("link",!0,n),n}function Vb(t){return function(t){const e=t.replace(zb,"");return e.match(Lb)}(t=String(t))?t:"#"}function Ub(t,e){return !!t&&e.checkAttribute(t.name,"linkHref")}function Hb(t,e){const n=(o=t,Ob.test(o)?"mailto:":e);var o;const i=!!n&&!Wb(t);return t&&i?n+t:t}function Wb(t){return Rb.test(t)}function Gb(t){window.open(t,"_blank","noopener");}class qb extends Si{constructor(t){super(t),this.manualDecorators=new _i,this.automaticDecorators=new pb;}restoreManualDecoratorStates(){for(const t of this.manualDecorators)t.value=this._getDecoratorStateFromModel(t.id);}refresh(){const t=this.editor.model,e=t.document.selection,n=e.getSelectedElement()||Ai(e.getSelectedBlocks());Ub(n,t.schema)?(this.value=n.getAttribute("linkHref"),this.isEnabled=t.schema.checkAttribute(n,"linkHref")):(this.value=e.getAttribute("linkHref"),this.isEnabled=t.schema.checkAttributeInSelection(e,"linkHref"));for(const t of this.manualDecorators)t.value=this._getDecoratorStateFromModel(t.id);}execute(t,e={}){const n=this.editor.model,o=n.document.selection,i=[],r=[];for(const t in e)e[t]?i.push(t):r.push(t);n.change((e=>{if(o.isCollapsed){const s=o.getFirstPosition();if(o.hasAttribute("linkHref")){const a=fm(s,"linkHref",o.getAttribute("linkHref"),n);e.setAttribute("linkHref",t,a),i.forEach((t=>{e.setAttribute(t,!0,a);})),r.forEach((t=>{e.removeAttribute(t,a);})),e.setSelection(e.createPositionAfter(a.end.nodeBefore));}else if(""!==t){const r=yi(o.getAttributes());r.set("linkHref",t),i.forEach((t=>{r.set(t,!0);}));const{end:a}=n.insertContent(e.createText(t,r),s);e.setSelection(a);}["linkHref",...i,...r].forEach((t=>{e.removeSelectionAttribute(t);}));}else {const s=n.schema.getValidRanges(o.getRanges(),"linkHref"),a=[];for(const t of o.getSelectedBlocks())n.schema.checkAttribute(t,"linkHref")&&a.push(e.createRangeOn(t));const c=a.slice();for(const t of s)this._isRangeToUpdate(t,a)&&c.push(t);for(const n of c)e.setAttribute("linkHref",t,n),i.forEach((t=>{e.setAttribute(t,!0,n);})),r.forEach((t=>{e.removeAttribute(t,n);}));}}));}_getDecoratorStateFromModel(t){const e=this.editor.model,n=e.document.selection,o=n.getSelectedElement();return Ub(o,e.schema)?o.getAttribute(t):n.getAttribute(t)}_isRangeToUpdate(t,e){for(const n of e)if(n.containsRange(t))return !1;return !0}}class Yb extends Si{refresh(){const t=this.editor.model,e=t.document.selection,n=e.getSelectedElement();Ub(n,t.schema)?this.isEnabled=t.schema.checkAttribute(n,"linkHref"):this.isEnabled=t.schema.checkAttributeInSelection(e,"linkHref");}execute(){const t=this.editor,e=this.editor.model,n=e.document.selection,o=t.commands.get("link");e.change((t=>{const i=n.isCollapsed?[fm(n.getFirstPosition(),"linkHref",n.getAttribute("linkHref"),e)]:e.schema.getValidRanges(n.getRanges(),"linkHref");for(const e of i)if(t.removeAttribute("linkHref",e),o)for(const n of o.manualDecorators)t.removeAttribute(n.id,e);}));}}class $b{constructor({id:t,label:e,attributes:n,classes:o,styles:i,defaultValue:r}){this.id=t,this.set("value"),this.defaultValue=r,this.label=e,this.attributes=n,this.classes=o,this.styles=i;}_createPattern(){return {attributes:this.attributes,classes:this.classes,styles:this.styles}}}d($b,H);var Kb=n(9773),Qb={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Kb.Z,Qb);Kb.Z.locals;const Zb="automatic",Jb=/^(https?:)?\/\//;class Xb extends Mi{static get pluginName(){return "LinkEditing"}static get requires(){return [em,Ug,Og]}constructor(t){super(t),t.config.define("link",{addTargetToExternalLinks:!1});}init(){const t=this.editor;t.model.schema.extend("$text",{allowAttributes:"linkHref"}),t.conversion.for("dataDowncast").attributeToElement({model:"linkHref",view:Fb}),t.conversion.for("editingDowncast").attributeToElement({model:"linkHref",view:(t,e)=>Fb(Vb(t),e)}),t.conversion.for("upcast").elementToAttribute({view:{name:"a",attributes:{href:!0}},model:{key:"linkHref",value:t=>t.getAttribute("href")}}),t.commands.add("link",new qb(t)),t.commands.add("unlink",new Yb(t));const e=function(t,e){const n={"Open in a new tab":t("Open in a new tab"),Downloadable:t("Downloadable")};return e.forEach((t=>(t.label&&n[t.label]&&(t.label=n[t.label]),t))),e}(t.t,function(t){const e=[];if(t)for(const[n,o]of Object.entries(t)){const t=Object.assign({},o,{id:`link${Pb(n)}`});e.push(t);}return e}(t.config.get("link.decorators")));this._enableAutomaticDecorators(e.filter((t=>t.mode===Zb))),this._enableManualDecorators(e.filter((t=>"manual"===t.mode)));t.plugins.get(em).registerAttribute("linkHref"),function(t,e,n,o){const i=t.editing.view,r=new Set;i.document.registerPostFixer((i=>{const s=t.model.document.selection;let a=!1;if(s.hasAttribute(e)){const c=fm(s.getFirstPosition(),e,s.getAttribute(e),t.model),l=t.editing.mapper.toViewRange(c);for(const t of l.getItems())t.is("element",n)&&!t.hasClass(o)&&(i.addClass(o,t),r.add(t),a=!0);}return a})),t.conversion.for("editingDowncast").add((t=>{function e(){i.change((t=>{for(const e of r.values())t.removeClass(o,e),r.delete(e);}));}t.on("insert",e,{priority:"highest"}),t.on("remove",e,{priority:"highest"}),t.on("attribute",e,{priority:"highest"}),t.on("selection",e,{priority:"highest"});}));}(t,"linkHref","a","ck-link_selected"),this._enableLinkOpen(),this._enableInsertContentSelectionAttributesFixer(),this._enableClickingAfterLink(),this._enableTypingOverLink(),this._handleDeleteContentAfterLink();}_enableAutomaticDecorators(t){const e=this.editor,n=e.commands.get("link").automaticDecorators;e.config.get("link.addTargetToExternalLinks")&&n.add({id:"linkIsExternal",mode:Zb,callback:t=>Jb.test(t),attributes:{target:"_blank",rel:"noopener noreferrer"}}),n.add(t),n.length&&e.conversion.for("downcast").add(n.getDispatcher());}_enableManualDecorators(t){if(!t.length)return;const e=this.editor,n=e.commands.get("link").manualDecorators;t.forEach((t=>{e.model.schema.extend("$text",{allowAttributes:t.id}),t=new $b(t),n.add(t),e.conversion.for("downcast").attributeToElement({model:t.id,view:(e,{writer:n,schema:o},{item:i})=>{if((i.is("selection")||o.isInline(i))&&e){const e=n.createAttributeElement("a",t.attributes,{priority:5});t.classes&&n.addClass(t.classes,e);for(const o in t.styles)n.setStyle(o,t.styles[o],e);return n.setCustomProperty("link",!0,e),e}}}),e.conversion.for("upcast").elementToAttribute({view:{name:"a",...t._createPattern()},model:{key:t.id}});}));}_enableLinkOpen(){const t=this.editor,e=t.editing.view.document;this.listenTo(e,"click",((t,e)=>{if(!(i.isMac?e.domEvent.metaKey:e.domEvent.ctrlKey))return;let n=e.domTarget;if("a"!=n.tagName.toLowerCase()&&(n=n.closest("a")),!n)return;const o=n.getAttribute("href");o&&(t.stop(),e.preventDefault(),Gb(o));}),{context:"$capture"}),this.listenTo(e,"keydown",((e,n)=>{const o=t.commands.get("link").value;o&&n.keyCode===li.enter&&n.altKey&&(e.stop(),Gb(o));}));}_enableInsertContentSelectionAttributesFixer(){const t=this.editor.model,e=t.document.selection;this.listenTo(t,"insertContent",(()=>{const n=e.anchor.nodeBefore,o=e.anchor.nodeAfter;e.hasAttribute("linkHref")&&n&&n.hasAttribute("linkHref")&&(o&&o.hasAttribute("linkHref")||t.change((e=>{tw(e,nw(t.schema));})));}),{priority:"low"});}_enableClickingAfterLink(){const t=this.editor,e=t.model;t.editing.view.addObserver(oh);let n=!1;this.listenTo(t.editing.view.document,"mousedown",(()=>{n=!0;})),this.listenTo(t.editing.view.document,"selectionChange",(()=>{if(!n)return;n=!1;const t=e.document.selection;if(!t.isCollapsed)return;if(!t.hasAttribute("linkHref"))return;const o=t.getFirstPosition(),i=fm(o,"linkHref",t.getAttribute("linkHref"),e);(o.isTouching(i.start)||o.isTouching(i.end))&&e.change((t=>{tw(t,nw(e.schema));}));}));}_enableTypingOverLink(){const t=this.editor,e=t.editing.view;let n,o;this.listenTo(e.document,"delete",(()=>{o=!0;}),{priority:"high"}),this.listenTo(t.model,"deleteContent",(()=>{const e=t.model.document.selection;e.isCollapsed||(o?o=!1:ew(t)&&function(t){const e=t.document.selection,n=e.getFirstPosition(),o=e.getLastPosition(),i=n.nodeAfter;if(!i)return !1;if(!i.is("$text"))return !1;if(!i.hasAttribute("linkHref"))return !1;const r=o.textNode||o.nodeBefore;if(i===r)return !0;return fm(n,"linkHref",i.getAttribute("linkHref"),t).containsRange(t.createRange(n,o),!0)}(t.model)&&(n=e.getAttributes()));}),{priority:"high"}),this.listenTo(t.model,"insertContent",((e,[i])=>{o=!1,ew(t)&&n&&(t.model.change((t=>{for(const[e,o]of n)t.setAttribute(e,o,i);})),n=null);}),{priority:"high"});}_handleDeleteContentAfterLink(){const t=this.editor,e=t.model,n=e.document.selection,o=t.editing.view;let i=!1,r=!1;this.listenTo(o.document,"delete",((t,e)=>{r="backward"===e.direction;}),{priority:"high"}),this.listenTo(e,"deleteContent",(()=>{i=!1;const t=n.getFirstPosition(),o=n.getAttribute("linkHref");if(!o)return;const r=fm(t,"linkHref",o,e);i=r.containsPosition(t)||r.end.isEqual(t);}),{priority:"high"}),this.listenTo(e,"deleteContent",(()=>{r&&(r=!1,i||t.model.enqueueChange((t=>{tw(t,nw(e.schema));})));}),{priority:"low"});}}function tw(t,e){t.removeSelectionAttribute("linkHref");for(const n of e)t.removeSelectionAttribute(n);}function ew(t){return t.model.change((t=>t.batch)).isTyping}function nw(t){return t.getDefinition("$text").allowAttributes.filter((t=>t.startsWith("link")))}var ow=n(7754),iw={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(ow.Z,iw);ow.Z.locals;class rw extends Ph{constructor(t,e){super(t);const n=t.t;this.focusTracker=new Ci,this.keystrokes=new vi,this.urlInputView=this._createUrlInput(),this.saveButtonView=this._createButton(n("Save"),Jh.check,"ck-button-save"),this.saveButtonView.type="submit",this.cancelButtonView=this._createButton(n("Cancel"),Jh.cancel,"ck-button-cancel","cancel"),this._manualDecoratorSwitches=this._createManualDecoratorSwitches(e),this.children=this._createFormChildren(e.manualDecorators),this._focusables=new dh,this._focusCycler=new vu({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:"shift + tab",focusNext:"tab"}});const o=["ck","ck-link-form","ck-responsive-form"];e.manualDecorators.length&&o.push("ck-link-form_layout-vertical","ck-vertical-form"),this.setTemplate({tag:"form",attributes:{class:o,tabindex:"-1"},children:this.children}),tu(this);}getDecoratorSwitchesState(){return Array.from(this._manualDecoratorSwitches).reduce(((t,e)=>(t[e.name]=e.isOn,t)),{})}render(){super.render(),eu({view:this});[this.urlInputView,...this._manualDecoratorSwitches,this.saveButtonView,this.cancelButtonView].forEach((t=>{this._focusables.add(t),this.focusTracker.add(t.element);})),this.keystrokes.listenTo(this.element);}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}focus(){this._focusCycler.focusFirst();}_createUrlInput(){const t=this.locale.t,e=new hg(this.locale,ug);return e.label=t("Link URL"),e}_createButton(t,e,n,o){const i=new cu(this.locale);return i.set({label:t,icon:e,tooltip:!0}),i.extendTemplate({attributes:{class:n}}),o&&i.delegate("execute").to(this,o),i}_createManualDecoratorSwitches(t){const e=this.createCollection();for(const n of t.manualDecorators){const o=new hu(this.locale);o.set({name:n.id,label:n.label,withText:!0}),o.bind("isOn").toMany([n,t],"value",((t,e)=>void 0===e&&void 0===t?n.defaultValue:t)),o.on("execute",(()=>{n.set("value",!o.isOn);})),e.add(o);}return e}_createFormChildren(t){const e=this.createCollection();if(e.add(this.urlInputView),t.length){const t=new Ph;t.setTemplate({tag:"ul",children:this._manualDecoratorSwitches.map((t=>({tag:"li",children:[t],attributes:{class:["ck","ck-list__item"]}}))),attributes:{class:["ck","ck-reset","ck-list"]}}),e.add(t);}return e.add(this.saveButtonView),e.add(this.cancelButtonView),e}}var sw=n(2347),aw={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(sw.Z,aw);sw.Z.locals;class cw extends Ph{constructor(t){super(t);const e=t.t;this.focusTracker=new Ci,this.keystrokes=new vi,this.previewButtonView=this._createPreviewButton(),this.unlinkButtonView=this._createButton(e("Unlink"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',"unlink"),this.editButtonView=this._createButton(e("Edit link"),Jh.pencil,"edit"),this.set("href"),this._focusables=new dh,this._focusCycler=new vu({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:"shift + tab",focusNext:"tab"}}),this.setTemplate({tag:"div",attributes:{class:["ck","ck-link-actions","ck-responsive-form"],tabindex:"-1"},children:[this.previewButtonView,this.editButtonView,this.unlinkButtonView]});}render(){super.render();[this.previewButtonView,this.editButtonView,this.unlinkButtonView].forEach((t=>{this._focusables.add(t),this.focusTracker.add(t.element);})),this.keystrokes.listenTo(this.element);}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}focus(){this._focusCycler.focusFirst();}_createButton(t,e,n){const o=new cu(this.locale);return o.set({label:t,icon:e,tooltip:!0}),o.delegate("execute").to(this,n),o}_createPreviewButton(){const t=new cu(this.locale),e=this.bindTemplate,n=this.t;return t.set({withText:!0,tooltip:n("Open link in new tab")}),t.extendTemplate({attributes:{class:["ck","ck-link-actions__preview"],href:e.to("href",(t=>t&&Vb(t))),target:"_blank",rel:"noopener noreferrer"}}),t.bind("label").to(this,"href",(t=>t||n("This link has no URL"))),t.bind("isEnabled").to(this,"href",(t=>!!t)),t.template.tag="a",t.template.eventListeners={},t}}const lw="link-ui";class dw extends Mi{static get requires(){return [_g]}static get pluginName(){return "LinkUI"}init(){const t=this.editor;t.editing.view.addObserver(nh),this.actionsView=this._createActionsView(),this.formView=this._createFormView(),this._balloon=t.plugins.get(_g),this._createToolbarLinkButton(),this._enableUserBalloonInteractions(),t.conversion.for("editingDowncast").markerToHighlight({model:lw,view:{classes:["ck-fake-link-selection"]}}),t.conversion.for("editingDowncast").markerToElement({model:lw,view:{name:"span",classes:["ck-fake-link-selection","ck-fake-link-selection_collapsed"]}});}destroy(){super.destroy(),this.formView.destroy();}_createActionsView(){const t=this.editor,e=new cw(t.locale),n=t.commands.get("link"),o=t.commands.get("unlink");return e.bind("href").to(n,"value"),e.editButtonView.bind("isEnabled").to(n),e.unlinkButtonView.bind("isEnabled").to(o),this.listenTo(e,"edit",(()=>{this._addFormView();})),this.listenTo(e,"unlink",(()=>{t.execute("unlink"),this._hideUI();})),e.keystrokes.set("Esc",((t,e)=>{this._hideUI(),e();})),e.keystrokes.set(jb,((t,e)=>{this._addFormView(),e();})),e}_createFormView(){const t=this.editor,e=t.commands.get("link"),n=t.config.get("link.defaultProtocol"),o=new rw(t.locale,e);return o.urlInputView.fieldView.bind("value").to(e,"value"),o.urlInputView.bind("isReadOnly").to(e,"isEnabled",(t=>!t)),o.saveButtonView.bind("isEnabled").to(e),this.listenTo(o,"submit",(()=>{const{value:e}=o.urlInputView.fieldView.element,i=Hb(e,n);t.execute("link",i,o.getDecoratorSwitchesState()),this._closeFormView();})),this.listenTo(o,"cancel",(()=>{this._closeFormView();})),o.keystrokes.set("Esc",((t,e)=>{this._closeFormView(),e();})),o}_createToolbarLinkButton(){const t=this.editor,e=t.commands.get("link"),n=t.t;t.keystrokes.set(jb,((t,n)=>{n(),e.isEnabled&&this._showUI(!0);})),t.ui.componentFactory.add("link",(t=>{const o=new cu(t);return o.isEnabled=!0,o.label=n("Link"),o.icon='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>',o.keystroke=jb,o.tooltip=!0,o.isToggleable=!0,o.bind("isEnabled").to(e,"isEnabled"),o.bind("isOn").to(e,"value",(t=>!!t)),this.listenTo(o,"execute",(()=>this._showUI(!0))),o}));}_enableUserBalloonInteractions(){const t=this.editor.editing.view.document;this.listenTo(t,"click",(()=>{this._getSelectedLinkElement()&&this._showUI();})),this.editor.keystrokes.set("Tab",((t,e)=>{this._areActionsVisible&&!this.actionsView.focusTracker.isFocused&&(this.actionsView.focus(),e());}),{priority:"high"}),this.editor.keystrokes.set("Esc",((t,e)=>{this._isUIVisible&&(this._hideUI(),e());})),Xh({emitter:this.formView,activator:()=>this._isUIInPanel,contextElements:[this._balloon.view.element],callback:()=>this._hideUI()});}_addActionsView(){this._areActionsInPanel||this._balloon.add({view:this.actionsView,position:this._getBalloonPositionData()});}_addFormView(){if(this._isFormInPanel)return;const t=this.editor.commands.get("link");this.formView.disableCssTransitions(),this._balloon.add({view:this.formView,position:this._getBalloonPositionData()}),this._balloon.visibleView===this.formView&&this.formView.urlInputView.fieldView.select(),this.formView.enableCssTransitions(),this.formView.urlInputView.fieldView.element.value=t.value||"";}_closeFormView(){const t=this.editor.commands.get("link");t.restoreManualDecoratorStates(),void 0!==t.value?this._removeFormView():this._hideUI();}_removeFormView(){this._isFormInPanel&&(this.formView.saveButtonView.focus(),this._balloon.remove(this.formView),this.editor.editing.view.focus(),this._hideFakeVisualSelection());}_showUI(t=!1){this._getSelectedLinkElement()?(this._areActionsVisible?this._addFormView():this._addActionsView(),t&&this._balloon.showStack("main")):(this._showFakeVisualSelection(),this._addActionsView(),t&&this._balloon.showStack("main"),this._addFormView()),this._startUpdatingUI();}_hideUI(){if(!this._isUIInPanel)return;const t=this.editor;this.stopListening(t.ui,"update"),this.stopListening(this._balloon,"change:visibleView"),t.editing.view.focus(),this._removeFormView(),this._balloon.remove(this.actionsView),this._hideFakeVisualSelection();}_startUpdatingUI(){const t=this.editor,e=t.editing.view.document;let n=this._getSelectedLinkElement(),o=r();const i=()=>{const t=this._getSelectedLinkElement(),e=r();n&&!t||!n&&e!==o?this._hideUI():this._isUIVisible&&this._balloon.updatePosition(this._getBalloonPositionData()),n=t,o=e;};function r(){return e.selection.focus.getAncestors().reverse().find((t=>t.is("element")))}this.listenTo(t.ui,"update",i),this.listenTo(this._balloon,"change:visibleView",i);}get _isFormInPanel(){return this._balloon.hasView(this.formView)}get _areActionsInPanel(){return this._balloon.hasView(this.actionsView)}get _areActionsVisible(){return this._balloon.visibleView===this.actionsView}get _isUIInPanel(){return this._isFormInPanel||this._areActionsInPanel}get _isUIVisible(){return this._balloon.visibleView==this.formView||this._areActionsVisible}_getBalloonPositionData(){const t=this.editor.editing.view,e=this.editor.model,n=t.document;let o=null;if(e.markers.has(lw)){const e=Array.from(this.editor.editing.mapper.markerNameToElements(lw)),n=t.createRange(t.createPositionBefore(e[0]),t.createPositionAfter(e[e.length-1]));o=t.domConverter.viewRangeToDom(n);}else o=()=>{const e=this._getSelectedLinkElement();return e?t.domConverter.mapViewToDom(e):t.domConverter.viewRangeToDom(n.selection.getFirstRange())};return {target:o}}_getSelectedLinkElement(){const t=this.editor.editing.view,e=t.document.selection,n=e.getSelectedElement();if(e.isCollapsed||n&&Pm(n))return hw(e.getFirstPosition());{const n=e.getFirstRange().getTrimmed(),o=hw(n.start),i=hw(n.end);return o&&o==i&&t.createRangeIn(o).getTrimmed().isEqual(n)?o:null}}_showFakeVisualSelection(){const t=this.editor.model;t.change((e=>{const n=t.document.selection.getFirstRange();if(t.markers.has(lw))e.updateMarker(lw,{range:n});else if(n.start.isAtEnd){const o=n.start.getLastMatchingPosition((({item:e})=>!t.schema.isContent(e)),{boundaries:n});e.addMarker(lw,{usingOperation:!1,affectsData:!1,range:e.createRange(o,n.end)});}else e.addMarker(lw,{usingOperation:!1,affectsData:!1,range:n});}));}_hideFakeVisualSelection(){const t=this.editor.model;t.markers.has(lw)&&t.change((t=>{t.removeMarker(lw);}));}}function hw(t){return t.getAncestors().find((t=>{return (e=t).is("attributeElement")&&!!e.getCustomProperty("link");var e;}))}const uw=new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$","i");class gw extends Mi{static get requires(){return [Zg]}static get pluginName(){return "AutoLink"}init(){const t=this.editor.model.document.selection;t.on("change:range",(()=>{this.isEnabled=!t.anchor.parent.is("element","codeBlock");})),this._enableTypingHandling();}afterInit(){this._enableEnterHandling(),this._enableShiftEnterHandling();}_enableTypingHandling(){const t=this.editor,e=new tm(t.model,(t=>{if(!function(t){return t.length>4&&" "===t[t.length-1]&&" "!==t[t.length-2]}(t))return;const e=mw(t.substr(0,t.length-1));return e?{url:e}:void 0}));e.on("matched:data",((e,n)=>{const{batch:o,range:i,url:r}=n;if(!o.isTyping)return;const s=i.end.getShiftedBy(-1),a=s.getShiftedBy(-r.length),c=t.model.createRange(a,s);this._applyAutoLink(r,c);})),e.bind("isEnabled").to(this);}_enableEnterHandling(){const t=this.editor,e=t.model,n=t.commands.get("enter");n&&n.on("execute",(()=>{const t=e.document.selection.getFirstPosition();if(!t.parent.previousSibling)return;const n=e.createRangeIn(t.parent.previousSibling);this._checkAndApplyAutoLinkOnRange(n);}));}_enableShiftEnterHandling(){const t=this.editor,e=t.model,n=t.commands.get("shiftEnter");n&&n.on("execute",(()=>{const t=e.document.selection.getFirstPosition(),n=e.createRange(e.createPositionAt(t.parent,0),t.getShiftedBy(-1));this._checkAndApplyAutoLinkOnRange(n);}));}_checkAndApplyAutoLinkOnRange(t){const e=this.editor.model,{text:n,range:o}=Xg(t,e),i=mw(n);if(i){const t=e.createRange(o.end.getShiftedBy(-i.length),o.end);this._applyAutoLink(i,t);}}_applyAutoLink(t,e){const n=this.editor.model,o=Hb(t,this.editor.config.get("link.defaultProtocol"));this.isEnabled&&function(t,e){return e.schema.checkAttributeInSelection(e.createSelection(t),"linkHref")}(e,n)&&Wb(o)&&!function(t){const e=t.start.nodeAfter;return e&&e.hasAttribute("linkHref")}(e)&&this._persistAutoLink(o,e);}_persistAutoLink(t,e){const n=this.editor.model,o=this.editor.plugins.get("Delete");n.enqueueChange((i=>{i.setAttribute("linkHref",t,e),n.enqueueChange((()=>{o.requestUndoOnBackspace();}));}));}}function mw(t){const e=uw.exec(t);return e?e[2]:null}class pw extends Si{constructor(t,e){super(t),this.type=e;}refresh(){this.value=this._getValue(),this.isEnabled=this._checkEnabled();}execute(t={}){const e=this.editor.model,n=e.document,o=Array.from(n.selection.getSelectedBlocks()).filter((t=>kw(t,e.schema))),i=void 0!==t.forceValue?!t.forceValue:this.value;e.change((t=>{if(i){let e=o[o.length-1].nextSibling,n=Number.POSITIVE_INFINITY,i=[];for(;e&&"listItem"==e.name&&0!==e.getAttribute("listIndent");){const t=e.getAttribute("listIndent");t<n&&(n=t);const o=t-n;i.push({element:e,listIndent:o}),e=e.nextSibling;}i=i.reverse();for(const e of i)t.setAttribute("listIndent",e.listIndent,e.element);}if(!i){let t=Number.POSITIVE_INFINITY;for(const e of o)e.is("element","listItem")&&e.getAttribute("listIndent")<t&&(t=e.getAttribute("listIndent"));t=0===t?1:t,fw(o,!0,t),fw(o,!1,t);}for(const e of o.reverse())i&&"listItem"==e.name?t.rename(e,"paragraph"):i||"listItem"==e.name?i||"listItem"!=e.name||e.getAttribute("listType")==this.type||t.setAttribute("listType",this.type,e):(t.setAttributes({listType:this.type,listIndent:0},e),t.rename(e,"listItem"));this.fire("_executeCleanup",o);}));}_getValue(){const t=Ai(this.editor.model.document.selection.getSelectedBlocks());return !!t&&t.is("element","listItem")&&t.getAttribute("listType")==this.type}_checkEnabled(){if(this.value)return !0;const t=this.editor.model.document.selection,e=this.editor.model.schema,n=Ai(t.getSelectedBlocks());return !!n&&kw(n,e)}}function fw(t,e,n){const o=e?t[0]:t[t.length-1];if(o.is("element","listItem")){let i=o[e?"previousSibling":"nextSibling"],r=o.getAttribute("listIndent");for(;i&&i.is("element","listItem")&&i.getAttribute("listIndent")>=n;)r>i.getAttribute("listIndent")&&(r=i.getAttribute("listIndent")),i.getAttribute("listIndent")==r&&t[e?"unshift":"push"](i),i=i[e?"previousSibling":"nextSibling"];}}function kw(t,e){return e.checkChild(t.parent,"listItem")&&!e.isObject(t)}class bw extends Si{constructor(t,e){super(t),this._indentBy="forward"==e?1:-1;}refresh(){this.isEnabled=this._checkEnabled();}execute(){const t=this.editor.model,e=t.document;let n=Array.from(e.selection.getSelectedBlocks());t.change((t=>{const e=n[n.length-1];let o=e.nextSibling;for(;o&&"listItem"==o.name&&o.getAttribute("listIndent")>e.getAttribute("listIndent");)n.push(o),o=o.nextSibling;this._indentBy<0&&(n=n.reverse());for(const e of n){const n=e.getAttribute("listIndent")+this._indentBy;n<0?t.rename(e,"paragraph"):t.setAttribute("listIndent",n,e);}this.fire("_executeCleanup",n);}));}_checkEnabled(){const t=Ai(this.editor.model.document.selection.getSelectedBlocks());if(!t||!t.is("element","listItem"))return !1;if(this._indentBy>0){const e=t.getAttribute("listIndent"),n=t.getAttribute("listType");let o=t.previousSibling;for(;o&&o.is("element","listItem")&&o.getAttribute("listIndent")>=e;){if(o.getAttribute("listIndent")==e)return o.getAttribute("listType")==n;o=o.previousSibling;}return !1}return !0}}function ww(t,e){const n=e.mapper,o=e.writer,i="numbered"==t.getAttribute("listType")?"ol":"ul",r=function(t){const e=t.createContainerElement("li");return e.getFillerOffset=Iw,e}(o),s=o.createContainerElement(i,null);return o.insert(o.createPositionAt(s,0),r),n.bindElements(t,r),r}function _w(t,e,n,o){const i=e.parent,r=n.mapper,s=n.writer;let a=r.toViewPosition(o.createPositionBefore(t));const c=vw(t.previousSibling,{sameIndent:!0,smallerIndent:!0,listIndent:t.getAttribute("listIndent")}),l=t.previousSibling;if(c&&c.getAttribute("listIndent")==t.getAttribute("listIndent")){const t=r.toViewElement(c);a=s.breakContainer(s.createPositionAfter(t));}else if(l&&"listItem"==l.name){a=r.toViewPosition(o.createPositionAt(l,"end"));const t=r.findMappedViewAncestor(a),e=function(t){for(const e of t.getChildren())if("ul"==e.name||"ol"==e.name)return e;return null}(t);a=e?s.createPositionBefore(e):s.createPositionAt(t,"end");}else a=r.toViewPosition(o.createPositionBefore(t));if(a=Cw(a),s.insert(a,i),l&&"listItem"==l.name){const t=r.toViewElement(l),n=s.createRange(s.createPositionAt(t,0),a).getWalker({ignoreElementEnd:!0});for(const t of n)if(t.item.is("element","li")){const o=s.breakContainer(s.createPositionBefore(t.item)),i=t.item.parent,r=s.createPositionAt(e,"end");Aw(s,r.nodeBefore,r.nodeAfter),s.move(s.createRangeOn(i),r),n.position=o;}}else {const n=i.nextSibling;if(n&&(n.is("element","ul")||n.is("element","ol"))){let o=null;for(const e of n.getChildren()){const n=r.toModelElement(e);if(!(n&&n.getAttribute("listIndent")>t.getAttribute("listIndent")))break;o=e;}o&&(s.breakContainer(s.createPositionAfter(o)),s.move(s.createRangeOn(o.parent),s.createPositionAt(e,"end")));}}Aw(s,i,i.nextSibling),Aw(s,i.previousSibling,i);}function Aw(t,e,n){return !e||!n||"ul"!=e.name&&"ol"!=e.name||e.name!=n.name||e.getAttribute("class")!==n.getAttribute("class")?null:t.mergeContainers(t.createPositionAfter(e))}function Cw(t){return t.getLastMatchingPosition((t=>t.item.is("uiElement")))}function vw(t,e){const n=!!e.sameIndent,o=!!e.smallerIndent,i=e.listIndent;let r=t;for(;r&&"listItem"==r.name;){const t=r.getAttribute("listIndent");if(n&&i==t||o&&i>t)return r;r="forward"===e.direction?r.nextSibling:r.previousSibling;}return null}function yw(t,e,n,o){t.ui.componentFactory.add(e,(i=>{const r=t.commands.get(e),s=new cu(i);return s.set({label:n,icon:o,tooltip:!0,isToggleable:!0}),s.bind("isOn","isEnabled").to(r,"value","isEnabled"),s.on("execute",(()=>{t.execute(e),t.editing.view.focus();})),s}));}function xw(t,e){const n=[],o=t.parent,i={ignoreElementEnd:!1,startPosition:t,shallow:!0,direction:e},r=o.getAttribute("listIndent"),s=[...new gc(i)].filter((t=>t.item.is("element"))).map((t=>t.item));for(const t of s){if(!t.is("element","listItem"))break;if(t.getAttribute("listIndent")<r)break;if(!(t.getAttribute("listIndent")>r)){if(t.getAttribute("listType")!==o.getAttribute("listType"))break;if(t.getAttribute("listStyle")!==o.getAttribute("listStyle"))break;if(t.getAttribute("listReversed")!==o.getAttribute("listReversed"))break;if(t.getAttribute("listStart")!==o.getAttribute("listStart"))break;"backward"===e?n.unshift(t):n.push(t);}}return n}const Ew=["disc","circle","square"],Dw=["decimal","decimal-leading-zero","lower-roman","upper-roman","lower-latin","upper-latin"];function Iw(){const t=!this.isEmpty&&("ul"==this.getChild(0).name||"ol"==this.getChild(0).name);return this.isEmpty||t?0:ts.call(this)}class Mw extends Mi{static get pluginName(){return "ListUtils"}getListTypeFromListStyleType(t){return function(t){return Ew.includes(t)?"bulleted":Dw.includes(t)?"numbered":null}(t)}getSelectedListItems(t){return function(t){let e=[...t.document.selection.getSelectedBlocks()].filter((t=>t.is("element","listItem"))).map((e=>{const n=t.change((t=>t.createPositionAt(e,0)));return [...xw(n,"backward"),...xw(n,"forward")]})).flat();return e=[...new Set(e)],e}(t)}getSiblingNodes(t,e){return xw(t,e)}}function Tw(t){return (e,n,o)=>{const i=o.consumable;if(!i.test(n.item,"insert")||!i.test(n.item,"attribute:listType")||!i.test(n.item,"attribute:listIndent"))return;i.consume(n.item,"insert"),i.consume(n.item,"attribute:listType"),i.consume(n.item,"attribute:listIndent");const r=n.item;_w(r,ww(r,o),o,t);}}function Sw(t,e,n){if(!n.consumable.test(e.item,t.name))return;const o=n.mapper.toViewElement(e.item),i=n.writer;i.breakContainer(i.createPositionBefore(o)),i.breakContainer(i.createPositionAfter(o));const r=o.parent,s="numbered"==e.attributeNewValue?"ol":"ul";i.rename(s,r);}function Nw(t,e,n){n.consumable.consume(e.item,t.name);const o=n.mapper.toViewElement(e.item).parent,i=n.writer;Aw(i,o,o.nextSibling),Aw(i,o.previousSibling,o);}function Bw(t,e,n){if(n.consumable.test(e.item,t.name)&&"listItem"!=e.item.name){let t=n.mapper.toViewPosition(e.range.start);const o=n.writer,i=[];for(;("ul"==t.parent.name||"ol"==t.parent.name)&&(t=o.breakContainer(t),"li"==t.parent.name);){const e=t,n=o.createPositionAt(t.parent,"end");if(!e.isEqual(n)){const t=o.remove(o.createRange(e,n));i.push(t);}t=o.createPositionAfter(t.parent);}if(i.length>0){for(let e=0;e<i.length;e++){const n=t.nodeBefore;if(t=o.insert(t,i[e]).end,e>0){const e=Aw(o,n,n.nextSibling);e&&e.parent==n&&t.offset--;}}Aw(o,t.nodeBefore,t.nodeAfter);}}}function Pw(t,e,n){const o=n.mapper.toViewPosition(e.position),i=o.nodeBefore,r=o.nodeAfter;Aw(n.writer,i,r);}function zw(t,e,n){if(n.consumable.consume(e.viewItem,{name:!0})){const t=n.writer,o=t.createElement("listItem"),i=function(t){let e=0,n=t.parent;for(;n;){if(n.is("element","li"))e++;else {const t=n.previousSibling;t&&t.is("element","li")&&e++;}n=n.parent;}return e}(e.viewItem);t.setAttribute("listIndent",i,o);const r=e.viewItem.parent&&"ol"==e.viewItem.parent.name?"numbered":"bulleted";if(t.setAttribute("listType",r,o),!n.safeInsert(o,e.modelCursor))return;const s=function(t,e,n){const{writer:o,schema:i}=n;let r=o.createPositionAfter(t);for(const s of e)if("ul"==s.name||"ol"==s.name)r=n.convertItem(s,r).modelCursor;else {const e=n.convertItem(s,o.createPositionAt(t,"end")),a=e.modelRange.start.nodeAfter;a&&a.is("element")&&!i.checkChild(t,a.name)&&(t=e.modelCursor.parent.is("element","listItem")?e.modelCursor.parent:Fw(e.modelCursor),r=o.createPositionAfter(t));}return r}(o,e.viewItem.getChildren(),n);e.modelRange=t.createRange(e.modelCursor,s),n.updateConversionResult(o,e);}}function Lw(t,e,n){if(n.consumable.test(e.viewItem,{name:!0})){const t=Array.from(e.viewItem.getChildren());for(const e of t){!(e.is("element","li")||Uw(e))&&e._remove();}}}function Ow(t,e,n){if(n.consumable.test(e.viewItem,{name:!0})){if(0===e.viewItem.childCount)return;const t=[...e.viewItem.getChildren()];let n=!1;for(const e of t)n&&!Uw(e)&&e._remove(),Uw(e)&&(n=!0);}}function Rw(t){return (e,n)=>{if(n.isPhantom)return;const o=n.modelPosition.nodeBefore;if(o&&o.is("element","listItem")){const e=n.mapper.toViewElement(o),i=e.getAncestors().find(Uw),r=t.createPositionAt(e,0).getWalker();for(const t of r){if("elementStart"==t.type&&t.item.is("element","li")){n.viewPosition=t.previousPosition;break}if("elementEnd"==t.type&&t.item==i){n.viewPosition=t.nextPosition;break}}}}}function jw(t,[e,n,o]){let i,r=e.is("documentFragment")?e.getChild(0):e;if(i=n?this.createSelection(n,o):this.document.selection,r&&r.is("element","listItem")){const t=i.getFirstPosition();let e=null;if(t.parent.is("element","listItem")?e=t.parent:t.nodeBefore&&t.nodeBefore.is("element","listItem")&&(e=t.nodeBefore),e){const t=e.getAttribute("listIndent");if(t>0)for(;r&&r.is("element","listItem");)r._setAttribute("listIndent",r.getAttribute("listIndent")+t),r=r.nextSibling;}}}function Fw(t){const e=new gc({startPosition:t});let n;do{n=e.next();}while(!n.value.item.is("element","listItem"));return n.value.item}function Vw(t,e,n,o,i,r){const s=vw(e.nodeBefore,{sameIndent:!0,smallerIndent:!0,listIndent:t,foo:"b"}),a=i.mapper,c=i.writer,l=s?s.getAttribute("listIndent"):null;let d;if(s)if(l==t){const t=a.toViewElement(s).parent;d=c.createPositionAfter(t);}else {const t=r.createPositionAt(s,"end");d=a.toViewPosition(t);}else d=n;d=Cw(d);for(const t of [...o.getChildren()])Uw(t)&&(d=c.move(c.createRangeOn(t),d).end,Aw(c,t,t.nextSibling),Aw(c,t.previousSibling,t));}function Uw(t){return t.is("element","ol")||t.is("element","ul")}class Hw extends Mi{static get pluginName(){return "ListEditing"}static get requires(){return [vm,Zg,Mw]}init(){const t=this.editor;t.model.schema.register("listItem",{inheritAllFrom:"$block",allowAttributes:["listType","listIndent"]});const e=t.data,n=t.editing;var o;t.model.document.registerPostFixer((e=>function(t,e){const n=t.document.differ.getChanges(),o=new Map;let i=!1;for(const o of n)if("insert"==o.type&&"listItem"==o.name)r(o.position);else if("insert"==o.type&&"listItem"!=o.name){if("$text"!=o.name){const n=o.position.nodeAfter;n.hasAttribute("listIndent")&&(e.removeAttribute("listIndent",n),i=!0),n.hasAttribute("listType")&&(e.removeAttribute("listType",n),i=!0),n.hasAttribute("listStyle")&&(e.removeAttribute("listStyle",n),i=!0),n.hasAttribute("listReversed")&&(e.removeAttribute("listReversed",n),i=!0),n.hasAttribute("listStart")&&(e.removeAttribute("listStart",n),i=!0);for(const e of Array.from(t.createRangeIn(n)).filter((t=>t.item.is("element","listItem"))))r(e.previousPosition);}r(o.position.getShiftedBy(o.length));}else "remove"==o.type&&"listItem"==o.name?r(o.position):("attribute"==o.type&&"listIndent"==o.attributeKey||"attribute"==o.type&&"listType"==o.attributeKey)&&r(o.range.start);for(const t of o.values())s(t),a(t);return i;function r(t){const e=t.nodeBefore;if(e&&e.is("element","listItem")){let t=e;if(o.has(t))return;for(let e=t.previousSibling;e&&e.is("element","listItem");e=t.previousSibling)if(t=e,o.has(t))return;o.set(e,t);}else {const e=t.nodeAfter;e&&e.is("element","listItem")&&o.set(e,e);}}function s(t){let n=0,o=null;for(;t&&t.is("element","listItem");){const r=t.getAttribute("listIndent");if(r>n){let s;null===o?(o=r-n,s=n):(o>r&&(o=r),s=r-o),e.setAttribute("listIndent",s,t),i=!0;}else o=null,n=t.getAttribute("listIndent")+1;t=t.nextSibling;}}function a(t){let n=[],o=null;for(;t&&t.is("element","listItem");){const r=t.getAttribute("listIndent");if(o&&o.getAttribute("listIndent")>r&&(n=n.slice(0,r+1)),0!=r)if(n[r]){const o=n[r];t.getAttribute("listType")!=o&&(e.setAttribute("listType",o,t),i=!0);}else n[r]=t.getAttribute("listType");o=t,t=t.nextSibling;}}}(t.model,e))),n.mapper.registerViewToModelLength("li",Ww),e.mapper.registerViewToModelLength("li",Ww),n.mapper.on("modelToViewPosition",Rw(n.view)),n.mapper.on("viewToModelPosition",(o=t.model,(t,e)=>{const n=e.viewPosition,i=n.parent,r=e.mapper;if("ul"==i.name||"ol"==i.name){if(n.isAtEnd){const t=r.toModelElement(n.nodeBefore),i=r.getModelLength(n.nodeBefore);e.modelPosition=o.createPositionBefore(t).getShiftedBy(i);}else {const t=r.toModelElement(n.nodeAfter);e.modelPosition=o.createPositionBefore(t);}t.stop();}else if("li"==i.name&&n.nodeBefore&&("ul"==n.nodeBefore.name||"ol"==n.nodeBefore.name)){const s=r.toModelElement(i);let a=1,c=n.nodeBefore;for(;c&&Uw(c);)a+=r.getModelLength(c),c=c.previousSibling;e.modelPosition=o.createPositionBefore(s).getShiftedBy(a),t.stop();}})),e.mapper.on("modelToViewPosition",Rw(n.view)),t.conversion.for("editingDowncast").add((e=>{e.on("insert",Bw,{priority:"high"}),e.on("insert:listItem",Tw(t.model)),e.on("attribute:listType:listItem",Sw,{priority:"high"}),e.on("attribute:listType:listItem",Nw,{priority:"low"}),e.on("attribute:listIndent:listItem",function(t){return (e,n,o)=>{if(!o.consumable.consume(n.item,"attribute:listIndent"))return;const i=o.mapper.toViewElement(n.item),r=o.writer;r.breakContainer(r.createPositionBefore(i)),r.breakContainer(r.createPositionAfter(i));const s=i.parent,a=s.previousSibling,c=r.createRangeOn(s);r.remove(c),a&&a.nextSibling&&Aw(r,a,a.nextSibling),Vw(n.attributeOldValue+1,n.range.start,c.start,i,o,t),_w(n.item,i,o,t);for(const t of n.item.getChildren())o.consumable.consume(t,"insert");}}(t.model)),e.on("remove:listItem",function(t){return (e,n,o)=>{const i=o.mapper.toViewPosition(n.position).getLastMatchingPosition((t=>!t.item.is("element","li"))).nodeAfter,r=o.writer;r.breakContainer(r.createPositionBefore(i)),r.breakContainer(r.createPositionAfter(i));const s=i.parent,a=s.previousSibling,c=r.createRangeOn(s),l=r.remove(c);a&&a.nextSibling&&Aw(r,a,a.nextSibling),Vw(o.mapper.toModelElement(i).getAttribute("listIndent")+1,n.position,c.start,i,o,t);for(const t of r.createRangeIn(l).getItems())o.mapper.unbindViewElement(t);e.stop();}}(t.model)),e.on("remove",Pw,{priority:"low"});})),t.conversion.for("dataDowncast").add((e=>{e.on("insert",Bw,{priority:"high"}),e.on("insert:listItem",Tw(t.model));})),t.conversion.for("upcast").add((t=>{t.on("element:ul",Lw,{priority:"high"}),t.on("element:ol",Lw,{priority:"high"}),t.on("element:li",Ow,{priority:"high"}),t.on("element:li",zw);})),t.model.on("insertContent",jw,{priority:"high"}),t.commands.add("numberedList",new pw(t,"numbered")),t.commands.add("bulletedList",new pw(t,"bulleted")),t.commands.add("indentList",new bw(t,"forward")),t.commands.add("outdentList",new bw(t,"backward"));const i=n.view.document;this.listenTo(i,"enter",((t,e)=>{const n=this.editor.model.document,o=n.selection.getLastPosition().parent;n.selection.isCollapsed&&"listItem"==o.name&&o.isEmpty&&(this.editor.execute("outdentList"),e.preventDefault(),t.stop());}),{context:"li"}),this.listenTo(i,"delete",((t,e)=>{if("backward"!==e.direction)return;const n=this.editor.model.document.selection;if(!n.isCollapsed)return;const o=n.getFirstPosition();if(!o.isAtStart)return;const i=o.parent;if("listItem"!==i.name)return;i.previousSibling&&"listItem"===i.previousSibling.name||(this.editor.execute("outdentList"),e.preventDefault(),t.stop());}),{context:"li"}),this.listenTo(t.editing.view.document,"tab",((e,n)=>{const o=n.shiftKey?"outdentList":"indentList";this.editor.commands.get(o).isEnabled&&(t.execute(o),n.stopPropagation(),n.preventDefault(),e.stop());}),{context:"li"});}afterInit(){const t=this.editor.commands,e=t.get("indent"),n=t.get("outdent");e&&e.registerChildCommand(t.get("indentList")),n&&n.registerChildCommand(t.get("outdentList"));}}function Ww(t){let e=1;for(const n of t.getChildren())if("ul"==n.name||"ol"==n.name)for(const t of n.getChildren())e+=Ww(t);return e}class Gw extends Mi{static get pluginName(){return "ListUI"}init(){const t=this.editor.t;yw(this.editor,"numberedList",t("Numbered List"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'),yw(this.editor,"bulletedList",t("Bulleted List"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');}}function qw(t,e){return t=>{t.on("attribute:url:media",n);};function n(n,o,i){if(!i.consumable.consume(o.item,n.name))return;const r=o.attributeNewValue,s=i.writer,a=i.mapper.toViewElement(o.item),c=[...a.getChildren()].find((t=>t.getCustomProperty("media-content")));s.remove(c);const l=t.getMediaViewElement(s,r,e);s.insert(s.createPositionAt(a,0),l);}}function Yw(t,e,n,o){return t.createContainerElement("figure",{class:"media"},[e.getMediaViewElement(t,n,o),t.createSlot()])}function $w(t){const e=t.getSelectedElement();return e&&e.is("element","media")?e:null}function Kw(t,e,n,o){t.change((i=>{const r=i.createElement("media",{url:e});t.insertObject(r,n,null,{setSelection:"on",findOptimalPosition:o});}));}class Qw extends Si{refresh(){const t=this.editor.model,e=t.document.selection,n=$w(e);this.value=n?n.getAttribute("url"):null,this.isEnabled=function(t){const e=t.getSelectedElement();return !!e&&"media"===e.name}(e)||function(t,e){const n=Fm(t,e);let o=n.start.parent;o.isEmpty&&!e.schema.isLimit(o)&&(o=o.parent);return e.schema.checkChild(o,"media")}(e,t);}execute(t){const e=this.editor.model,n=e.document.selection,o=$w(n);o?e.change((e=>{e.setAttribute("url",t,o);})):Kw(e,t,n,!0);}}class Zw{constructor(t,e){const n=e.providers,o=e.extraProviders||[],i=new Set(e.removeProviders),r=n.concat(o).filter((t=>{const e=t.name;return e?!i.has(e):(b("media-embed-no-provider-name",{provider:t}),!1)}));this.locale=t,this.providerDefinitions=r;}hasMedia(t){return !!this._getMedia(t)}getMediaViewElement(t,e,n){return this._getMedia(e).getViewElement(t,n)}_getMedia(t){if(!t)return new Jw(this.locale);t=t.trim();for(const e of this.providerDefinitions){const n=e.html,o=pi(e.url);for(const e of o){const o=this._getUrlMatches(t,e);if(o)return new Jw(this.locale,t,o,n)}}return null}_getUrlMatches(t,e){let n=t.match(e);if(n)return n;let o=t.replace(/^https?:\/\//,"");return n=o.match(e),n||(o=o.replace(/^www\./,""),n=o.match(e),n||null)}}class Jw{constructor(t,e,n,o){this.url=this._getValidUrl(e),this._locale=t,this._match=n,this._previewRenderer=o;}getViewElement(t,e){const n={};let o;if(e.renderForEditingView||e.renderMediaPreview&&this.url&&this._previewRenderer){this.url&&(n["data-oembed-url"]=this.url),e.renderForEditingView&&(n.class="ck-media__wrapper");const i=this._getPreviewHtml(e);o=t.createRawElement("div",n,((t,e)=>{e.setContentOf(t,i);}));}else this.url&&(n.url=this.url),o=t.createEmptyElement(e.elementName,n);return t.setCustomProperty("media-content",!0,o),o}_getPreviewHtml(t){return this._previewRenderer?this._previewRenderer(this._match):this.url&&t.renderForEditingView?this._getPlaceholderHtml():""}_getPlaceholderHtml(){const t=new ru,e=this._locale.t;t.content='<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>',t.viewBox="0 0 64 42";return new hh({tag:"div",attributes:{class:"ck ck-reset_all ck-media__placeholder"},children:[{tag:"div",attributes:{class:"ck-media__placeholder__icon"},children:[t]},{tag:"a",attributes:{class:"ck-media__placeholder__url",target:"_blank",rel:"noopener noreferrer",href:this.url,"data-cke-tooltip-text":e("Open media in new tab")},children:[{tag:"span",attributes:{class:"ck-media__placeholder__url__text"},children:[this.url]}]}]}).render().outerHTML}_getValidUrl(t){return t?t.match(/^https?/)?t:"https://"+t:null}}var Xw=n(7442),t_={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(Xw.Z,t_);Xw.Z.locals;class e_ extends Mi{static get pluginName(){return "MediaEmbedEditing"}constructor(t){super(t),t.config.define("mediaEmbed",{elementName:"oembed",providers:[{name:"dailymotion",url:/^dailymotion\.com\/video\/(\w+)/,html:t=>`<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`},{name:"spotify",url:[/^open\.spotify\.com\/(artist\/\w+)/,/^open\.spotify\.com\/(album\/\w+)/,/^open\.spotify\.com\/(track\/\w+)/],html:t=>`<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`},{name:"youtube",url:[/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,/^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,/^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,/^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/],html:t=>{const e=t[1],n=t[2];return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${e}${n?`?start=${n}`:""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`}},{name:"vimeo",url:[/^vimeo\.com\/(\d+)/,/^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,/^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,/^vimeo\.com\/channels\/[^/]+\/(\d+)/,/^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,/^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,/^player\.vimeo\.com\/video\/(\d+)/],html:t=>`<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`},{name:"instagram",url:/^instagram\.com\/p\/(\w+)/},{name:"twitter",url:/^twitter\.com/},{name:"googleMaps",url:[/^google\.com\/maps/,/^goo\.gl\/maps/,/^maps\.google\.com/,/^maps\.app\.goo\.gl/]},{name:"flickr",url:/^flickr\.com/},{name:"facebook",url:/^facebook\.com/}]}),this.registry=new Zw(t.locale,t.config.get("mediaEmbed"));}init(){const t=this.editor,e=t.model.schema,n=t.t,o=t.conversion,i=t.config.get("mediaEmbed.previewsInData"),r=t.config.get("mediaEmbed.elementName"),s=this.registry;t.commands.add("mediaEmbed",new Qw(t)),e.register("media",{inheritAllFrom:"$blockObject",allowAttributes:["url"]}),o.for("dataDowncast").elementToStructure({model:"media",view:(t,{writer:e})=>{const n=t.getAttribute("url");return Yw(e,s,n,{elementName:r,renderMediaPreview:n&&i})}}),o.for("dataDowncast").add(qw(s,{elementName:r,renderMediaPreview:i})),o.for("editingDowncast").elementToStructure({model:"media",view:(t,{writer:e})=>{const o=t.getAttribute("url");return function(t,e,n){return e.setCustomProperty("media",!0,t),zm(t,e,{label:n})}(Yw(e,s,o,{elementName:r,renderForEditingView:!0}),e,n("media widget"))}}),o.for("editingDowncast").add(qw(s,{elementName:r,renderForEditingView:!0})),o.for("upcast").elementToElement({view:t=>["oembed",r].includes(t.name)&&t.getAttribute("url")?{name:!0}:null,model:(t,{writer:e})=>{const n=t.getAttribute("url");if(s.hasMedia(n))return e.createElement("media",{url:n})}}).elementToElement({view:{name:"div",attributes:{"data-oembed-url":!0}},model:(t,{writer:e})=>{const n=t.getAttribute("data-oembed-url");if(s.hasMedia(n))return e.createElement("media",{url:n})}}).add((t=>{t.on("element:figure",(function(t,e,n){if(!n.consumable.consume(e.viewItem,{name:!0,classes:"media"}))return;const{modelRange:o,modelCursor:i}=n.convertChildren(e.viewItem,e.modelCursor);e.modelRange=o,e.modelCursor=i;Ai(o.getItems())||n.consumable.revert(e.viewItem,{name:!0,classes:"media"});}));}));}}const n_=/^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;class o_ extends Mi{static get requires(){return [_p,Zg,Lp]}static get pluginName(){return "AutoMediaEmbed"}constructor(t){super(t),this._timeoutId=null,this._positionToInsert=null;}init(){const t=this.editor,e=t.model.document;this.listenTo(t.plugins.get("ClipboardPipeline"),"inputTransformation",(()=>{const t=e.selection.getFirstRange(),n=md.fromPosition(t.start);n.stickiness="toPrevious";const o=md.fromPosition(t.end);o.stickiness="toNext",e.once("change:data",(()=>{this._embedMediaBetweenPositions(n,o),n.detach(),o.detach();}),{priority:"high"});})),t.commands.get("undo").on("execute",(()=>{this._timeoutId&&(So.window.clearTimeout(this._timeoutId),this._positionToInsert.detach(),this._timeoutId=null,this._positionToInsert=null);}),{priority:"high"});}_embedMediaBetweenPositions(t,e){const n=this.editor,o=n.plugins.get(e_).registry,i=new Bc(t,e),r=i.getWalker({ignoreElementEnd:!0});let s="";for(const t of r)t.item.is("$textProxy")&&(s+=t.item.data);if(s=s.trim(),!s.match(n_))return void i.detach();if(!o.hasMedia(s))return void i.detach();n.commands.get("mediaEmbed").isEnabled?(this._positionToInsert=md.fromPosition(t),this._timeoutId=So.window.setTimeout((()=>{n.model.change((t=>{let e;this._timeoutId=null,t.remove(i),i.detach(),"$graveyard"!==this._positionToInsert.root.rootName&&(e=this._positionToInsert),Kw(n.model,s,e,!1),this._positionToInsert.detach(),this._positionToInsert=null;})),n.plugins.get("Delete").requestUndoOnBackspace();}),100)):i.detach();}}var i_=n(9292),r_={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(i_.Z,r_);i_.Z.locals;class s_ extends Ph{constructor(t,e){super(e);const n=e.t;this.focusTracker=new Ci,this.keystrokes=new vi,this.set("mediaURLInputValue",""),this.urlInputView=this._createUrlInput(),this.saveButtonView=this._createButton(n("Save"),Jh.check,"ck-button-save"),this.saveButtonView.type="submit",this.saveButtonView.bind("isEnabled").to(this,"mediaURLInputValue",(t=>!!t)),this.cancelButtonView=this._createButton(n("Cancel"),Jh.cancel,"ck-button-cancel","cancel"),this._focusables=new dh,this._focusCycler=new vu({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:"shift + tab",focusNext:"tab"}}),this._validators=t,this.setTemplate({tag:"form",attributes:{class:["ck","ck-media-form","ck-responsive-form"],tabindex:"-1"},children:[this.urlInputView,this.saveButtonView,this.cancelButtonView]}),tu(this);}render(){super.render(),eu({view:this});[this.urlInputView,this.saveButtonView,this.cancelButtonView].forEach((t=>{this._focusables.add(t),this.focusTracker.add(t.element);})),this.keystrokes.listenTo(this.element);const t=t=>t.stopPropagation();this.keystrokes.set("arrowright",t),this.keystrokes.set("arrowleft",t),this.keystrokes.set("arrowup",t),this.keystrokes.set("arrowdown",t),this.listenTo(this.urlInputView.element,"selectstart",((t,e)=>{e.stopPropagation();}),{priority:"high"});}destroy(){super.destroy(),this.focusTracker.destroy(),this.keystrokes.destroy();}focus(){this._focusCycler.focusFirst();}get url(){return this.urlInputView.fieldView.element.value.trim()}set url(t){this.urlInputView.fieldView.element.value=t.trim();}isValid(){this.resetFormStatus();for(const t of this._validators){const e=t(this);if(e)return this.urlInputView.errorText=e,!1}return !0}resetFormStatus(){this.urlInputView.errorText=null,this.urlInputView.infoText=this._urlInputViewInfoDefault;}_createUrlInput(){const t=this.locale.t,e=new hg(this.locale,ug),n=e.fieldView;return this._urlInputViewInfoDefault=t("Paste the media URL in the input."),this._urlInputViewInfoTip=t("Tip: Paste the URL into the content to embed faster."),e.label=t("Media URL"),e.infoText=this._urlInputViewInfoDefault,n.on("input",(()=>{e.infoText=n.element.value?this._urlInputViewInfoTip:this._urlInputViewInfoDefault,this.mediaURLInputValue=n.element.value.trim();})),e}_createButton(t,e,n,o){const i=new cu(this.locale);return i.set({label:t,icon:e,tooltip:!0}),i.extendTemplate({attributes:{class:n}}),o&&i.delegate("execute").to(this,o),i}}class a_ extends Mi{static get requires(){return [e_]}static get pluginName(){return "MediaEmbedUI"}init(){const t=this.editor,e=t.commands.get("mediaEmbed"),n=t.plugins.get(e_).registry;t.ui.componentFactory.add("mediaEmbed",(o=>{const i=Gu(o),r=new s_(function(t,e){return [e=>{if(!e.url.length)return t("The URL must not be empty.")},n=>{if(!e.hasMedia(n.url))return t("This media URL is not supported.")}]}(t.t,n),t.locale);return this._setUpDropdown(i,r,e,t),this._setUpForm(i,r,e),i}));}_setUpDropdown(t,e,n){const o=this.editor,i=o.t,r=t.buttonView;t.bind("isEnabled").to(n),t.panelView.children.add(e),r.set({label:i("Insert media"),icon:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>',tooltip:!0}),r.on("open",(()=>{e.disableCssTransitions(),e.url=n.value||"",e.urlInputView.fieldView.select(),e.enableCssTransitions();}),{priority:"low"}),t.on("submit",(()=>{e.isValid()&&(o.execute("mediaEmbed",e.url),o.editing.view.focus());})),t.on("change:isOpen",(()=>e.resetFormStatus())),t.on("cancel",(()=>{o.editing.view.focus();}));}_setUpForm(t,e,n){e.delegate("submit","cancel").to(t),e.urlInputView.bind("value").to(n,"value"),e.urlInputView.bind("isReadOnly").to(n,"isEnabled",(t=>!t));}}var c_=n(4652),l_={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(c_.Z,l_);c_.Z.locals;function d_(t,e,n,{blockElements:o,inlineObjectElements:i}){let r=n.createPositionAt(t,"forward"==e?"after":"before");return r=r.getLastMatchingPosition((({item:t})=>t.is("element")&&!o.includes(t.name)&&!i.includes(t.name)),{direction:e}),"forward"==e?r.nodeAfter:r.nodeBefore}function h_(t,e){return !!t&&t.is("element")&&e.includes(t.name)}function u_(t,e){if(!t.childCount)return;const n=new ih(t.document),o=function(t,e){const n=e.createRangeIn(t),o=new Ji({name:/^p|h\d+$/,styles:{"mso-list":/.*/}}),i=[];for(const t of n)if("elementStart"===t.type&&o.match(t.item)){const e=p_(t.item);i.push({element:t.item,id:e.id,order:e.order,indent:e.indent});}return i}(t,n);if(!o.length)return;let i=null,r=1;o.forEach(((t,s)=>{const a=function(t,e){if(!t)return !0;if(t.id!==e.id)return e.indent-t.indent!=1;const n=e.element.previousSibling;if(!n)return !0;return o=n,!(o.is("element","ol")||o.is("element","ul"));var o;}(o[s-1],t),c=a?null:o[s-1],l=(h=t,(d=c)?h.indent-d.indent:h.indent-1);var d,h;if(a&&(i=null,r=1),!i||0!==l){const o=function(t,e){const n=new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`,"gi"),o=/mso-level-number-format:([^;]{0,100});/gi,i=/mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,r=n.exec(e);let s="decimal",a="ol",c=null;if(r&&r[1]){const e=o.exec(r[1]);if(e&&e[1]&&(s=e[1].trim(),a="bullet"!==s&&"image"!==s?"ol":"ul"),"bullet"===s){const e=function(t){const e=function(t){if(t.getChild(0).is("$text"))return null;for(const e of t.getChildren()){if(!e.is("element","span"))continue;const t=e.getChild(0);return t.is("$text")?t:t.getChild(0)}}(t);if(!e)return null;const n=e._data;if("o"===n)return "circle";if("·"===n)return "disc";if("§"===n)return "square";return null}(t.element);e&&(s=e);}else {const t=i.exec(r[1]);t&&t[1]&&(c=parseInt(t[1]));}}return {type:a,startIndex:c,style:g_(s)}}(t,e);if(i){if(t.indent>r){const t=i.getChild(i.childCount-1),e=t.getChild(t.childCount-1);i=m_(o,e,n),r+=1;}else if(t.indent<r){const e=r-t.indent;i=function(t,e){const n=t.getAncestors({parentFirst:!0});let o=null,i=0;for(const t of n)if("ul"!==t.name&&"ol"!==t.name||i++,i===e){o=t;break}return o}(i,e),r=parseInt(t.indent);}}else i=m_(o,t.element,n);t.indent<=r&&(i.is("element",o.type)||(i=n.rename(o.type,i)));}const u=function(t,e){return function(t,e){const n=new Ji({name:"span",styles:{"mso-list":"Ignore"}}),o=e.createRangeIn(t);for(const t of o)"elementStart"===t.type&&n.match(t.item)&&e.remove(t.item);}(t,e),e.rename("li",t)}(t.element,n);n.appendChild(u,i);}));}function g_(t){if(t.startsWith("arabic-leading-zero"))return "decimal-leading-zero";switch(t){case"alpha-upper":return "upper-alpha";case"alpha-lower":return "lower-alpha";case"roman-upper":return "upper-roman";case"roman-lower":return "lower-roman";case"circle":case"disc":case"square":return t;default:return null}}function m_(t,e,n){const o=e.parent,i=n.createElement(t.type),r=o.getChildIndex(e)+1;return n.insertChild(r,i,o),t.style&&n.setStyle("list-style-type",t.style,i),t.startIndex&&t.startIndex>1&&n.setAttribute("start",t.startIndex,i),i}function p_(t){const e={},n=t.getStyle("mso-list");if(n){const t=n.match(/(^|\s{1,100})l(\d+)/i),o=n.match(/\s{0,100}lfo(\d+)/i),i=n.match(/\s{0,100}level(\d+)/i);t&&o&&i&&(e.id=t[2],e.order=o[1],e.indent=i[1]);}return e}const f_=/id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;class k_{constructor(t){this.document=t;}isActive(t){return f_.test(t)}execute(t){const e=new ih(this.document),{body:n}=t._parsedData;!function(t,e){for(const n of t.getChildren())if(n.is("element","b")&&"normal"===n.getStyle("font-weight")){const o=t.getChildIndex(n);e.remove(n),e.insertChild(o,n.getChildren(),t);}}(n,e),function(t,e){for(const n of e.createRangeIn(t)){const t=n.item;if(t.is("element","li")){const n=t.getChild(0);n&&n.is("element","p")&&e.unwrapElement(n);}}}(n,e),function(t,e){const n=new ks(e.document.stylesProcessor),o=new aa(n,{renderingMode:"data"}),i=o.blockElements,r=o.inlineObjectElements,s=[];for(const n of e.createRangeIn(t)){const t=n.item;if(t.is("element","br")){const n=d_(t,"forward",e,{blockElements:i,inlineObjectElements:r}),o=d_(t,"backward",e,{blockElements:i,inlineObjectElements:r}),a=h_(n,i);(h_(o,i)||a)&&s.push(t);}}for(const t of s)t.hasClass("Apple-interchange-newline")?e.remove(t):e.replace(t,e.createElement("p"));}(n,e),t.content=n;}}function b_(t,e){if(!t.childCount)return;const n=new ih,o=function(t,e){const n=e.createRangeIn(t),o=new Ji({name:/v:(.+)/}),i=[];for(const t of n){if("elementStart"!=t.type)continue;const e=t.item,n=e.previousSibling&&e.previousSibling.name||null;o.match(e)&&e.getAttribute("o:gfxdata")&&"v:shapetype"!==n&&i.push(t.item.getAttribute("id"));}return i}(t,n);!function(t,e,n){const o=n.createRangeIn(e),i=new Ji({name:"img"}),r=[];for(const e of o)if(i.match(e.item)){const n=e.item,o=n.getAttribute("v:shapes")?n.getAttribute("v:shapes").split(" "):[];o.length&&o.every((e=>t.indexOf(e)>-1))?r.push(n):n.getAttribute("src")||r.push(n);}for(const t of r)n.remove(t);}(o,t,n),function(t,e){const n=e.createRangeIn(t),o=new Ji({name:/v:(.+)/}),i=[];for(const t of n)"elementStart"==t.type&&o.match(t.item)&&i.push(t.item);for(const t of i)e.remove(t);}(t,n);const i=function(t,e){const n=e.createRangeIn(t),o=new Ji({name:"img"}),i=[];for(const t of n)o.match(t.item)&&t.item.getAttribute("src").startsWith("file://")&&i.push(t.item);return i}(t,n);i.length&&function(t,e,n){if(t.length===e.length)for(let o=0;o<t.length;o++){const i=`data:${e[o].type};base64,${w_(e[o].hex)}`;n.setAttribute("src",i,t[o]);}}(i,function(t){if(!t)return [];const e=/{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,n=new RegExp("(?:("+e.source+"))([\\da-fA-F\\s]+)\\}","g"),o=t.match(n),i=[];if(o)for(const t of o){let n=!1;t.includes("\\pngblip")?n="image/png":t.includes("\\jpegblip")&&(n="image/jpeg"),n&&i.push({hex:t.replace(e,"").replace(/[^\da-fA-F]/g,""),type:n});}return i}(e),n);}function w_(t){return btoa(t.match(/\w{2}/g).map((t=>String.fromCharCode(parseInt(t,16)))).join(""))}const __=/<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,A_=/xmlns:o="urn:schemas-microsoft-com/i;class C_{constructor(t){this.document=t;}isActive(t){return __.test(t)||A_.test(t)}execute(t){const{body:e,stylesString:n}=t._parsedData;u_(e,n),b_(e,t.dataTransfer.getData("text/rtf")),t.content=e;}}function v_(t){return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,((t,e)=>1===e.length?" ":Array(e.length+1).join("  ").substr(0,e.length)))}function y_(t,e){const n=new DOMParser,o=function(t){return v_(v_(t)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g,"$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g,"").replace(/ <\//g," </").replace(/ <o:p><\/o:p>/g," <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g,"").replace(/>([^\S\r\n]*[\r\n]\s*)</g,"><")}(function(t){const e="</body>",n="</html>",o=t.indexOf(e);if(o<0)return t;const i=t.indexOf(n,o+e.length);return t.substring(0,o+e.length)+(i>=0?t.substring(i):"")}(t=t.replace(/<!--\[if gte vml 1]>/g,""))),i=n.parseFromString(o,"text/html");!function(t){t.querySelectorAll("span[style*=spacerun]").forEach((t=>{const e=t.innerText.length||0;t.innerText=Array(e+1).join("  ").substr(0,e);}));}(i);const r=i.body.innerHTML,s=function(t,e){const n=new ks(e),o=new aa(n,{renderingMode:"data"}),i=t.createDocumentFragment(),r=t.body.childNodes;for(;r.length>0;)i.appendChild(r[0]);return o.domToView(i,{skipComments:!0})}(i,e),a=function(t){const e=[],n=[],o=Array.from(t.getElementsByTagName("style"));for(const t of o)t.sheet&&t.sheet.cssRules&&t.sheet.cssRules.length&&(e.push(t.sheet),n.push(t.innerHTML));return {styles:e,stylesString:n.join(" ")}}(i);return {body:s,bodyString:r,styles:a.styles,stylesString:a.stylesString}}function x_(t,e,n,o,i=1){e>i?o.setAttribute(t,e,n):o.removeAttribute(t,n);}function E_(t,e,n={}){const o=t.createElement("tableCell",n);return t.insertElement("paragraph",o),t.insert(o,e),o}function D_(t,e){const n=e.parent.parent,o=parseInt(n.getAttribute("headingColumns")||0),{column:i}=t.getCellLocation(e);return !!o&&i<o}function I_(){return t=>{t.on("element:table",((t,e,n)=>{const o=e.viewItem;if(!n.consumable.test(o,{name:!0}))return;const{rows:i,headingRows:r,headingColumns:s}=function(t){const e={headingRows:0,headingColumns:0},n=[],o=[];let i;for(const r of Array.from(t.getChildren()))if("tbody"===r.name||"thead"===r.name||"tfoot"===r.name){"thead"!==r.name||i||(i=r);const t=Array.from(r.getChildren()).filter((t=>t.is("element","tr")));for(const r of t)if("thead"===r.parent.name&&r.parent===i)e.headingRows++,n.push(r);else {o.push(r);const t=T_(r);t>e.headingColumns&&(e.headingColumns=t);}}return e.rows=[...n,...o],e}(o),a={};s&&(a.headingColumns=s),r&&(a.headingRows=r);const c=n.writer.createElement("table",a);if(n.safeInsert(c,e.modelCursor)){if(n.consumable.consume(o,{name:!0}),i.forEach((t=>n.convertItem(t,n.writer.createPositionAt(c,"end")))),n.convertChildren(o,n.writer.createPositionAt(c,"end")),c.isEmpty){const t=n.writer.createElement("tableRow");n.writer.insert(t,n.writer.createPositionAt(c,"end")),E_(n.writer,n.writer.createPositionAt(t,"end"));}n.updateConversionResult(c,e);}}));}}function M_(t){return e=>{e.on(`element:${t}`,((t,e,n)=>{if(e.modelRange&&e.viewItem.isEmpty){const t=e.modelRange.start.nodeAfter,o=n.writer.createPositionAt(t,0);n.writer.insertElement("paragraph",o);}}),{priority:"low"});}}function T_(t){let e=0,n=0;const o=Array.from(t.getChildren()).filter((t=>"th"===t.name||"td"===t.name));for(;n<o.length&&"th"===o[n].name;){const t=o[n];e+=parseInt(t.getAttribute("colspan")||1),n++;}return e}class S_{constructor(t,e={}){this._table=t,this._startRow=void 0!==e.row?e.row:e.startRow||0,this._endRow=void 0!==e.row?e.row:e.endRow,this._startColumn=void 0!==e.column?e.column:e.startColumn||0,this._endColumn=void 0!==e.column?e.column:e.endColumn,this._includeAllSlots=!!e.includeAllSlots,this._skipRows=new Set,this._row=0,this._rowIndex=0,this._column=0,this._cellIndex=0,this._spannedCells=new Map,this._nextCellAtColumn=-1;}[Symbol.iterator](){return this}next(){const t=this._table.getChild(this._rowIndex);if(!t||this._isOverEndRow())return {done:!0};if(!t.is("element","tableRow"))return this._rowIndex++,this.next();if(this._isOverEndColumn())return this._advanceToNextRow();let e=null;const n=this._getSpanned();if(n)this._includeAllSlots&&!this._shouldSkipSlot()&&(e=this._formatOutValue(n.cell,n.row,n.column));else {const n=t.getChild(this._cellIndex);if(!n)return this._advanceToNextRow();const o=parseInt(n.getAttribute("colspan")||1),i=parseInt(n.getAttribute("rowspan")||1);(o>1||i>1)&&this._recordSpans(n,i,o),this._shouldSkipSlot()||(e=this._formatOutValue(n)),this._nextCellAtColumn=this._column+o;}return this._column++,this._column==this._nextCellAtColumn&&this._cellIndex++,e||this.next()}skipRow(t){this._skipRows.add(t);}_advanceToNextRow(){return this._row++,this._rowIndex++,this._column=0,this._cellIndex=0,this._nextCellAtColumn=-1,this.next()}_isOverEndRow(){return void 0!==this._endRow&&this._row>this._endRow}_isOverEndColumn(){return void 0!==this._endColumn&&this._column>this._endColumn}_formatOutValue(t,e=this._row,n=this._column){return {done:!1,value:new N_(this,t,e,n)}}_shouldSkipSlot(){const t=this._skipRows.has(this._row),e=this._row<this._startRow,n=this._column<this._startColumn,o=void 0!==this._endColumn&&this._column>this._endColumn;return t||e||n||o}_getSpanned(){const t=this._spannedCells.get(this._row);return t&&t.get(this._column)||null}_recordSpans(t,e,n){const o={cell:t,row:this._row,column:this._column};for(let t=this._row;t<this._row+e;t++)for(let e=this._column;e<this._column+n;e++)t==this._row&&e==this._column||this._markSpannedCell(t,e,o);}_markSpannedCell(t,e,n){this._spannedCells.has(t)||this._spannedCells.set(t,new Map);this._spannedCells.get(t).set(e,n);}}class N_{constructor(t,e,n,o){this.cell=e,this.row=t._row,this.column=t._column,this.cellAnchorRow=n,this.cellAnchorColumn=o,this._cellIndex=t._cellIndex,this._rowIndex=t._rowIndex,this._table=t._table;}get isAnchor(){return this.row===this.cellAnchorRow&&this.column===this.cellAnchorColumn}get cellWidth(){return parseInt(this.cell.getAttribute("colspan")||1)}get cellHeight(){return parseInt(this.cell.getAttribute("rowspan")||1)}get rowIndex(){return this._rowIndex}getPositionBefore(){return this._table.root.document.model.createPositionAt(this._table.getChild(this.row),this._cellIndex)}}function B_(t,e={}){return (n,{writer:o})=>{const i=n.getAttribute("headingRows")||0,r=[];i>0&&r.push(o.createContainerElement("thead",null,o.createSlot((t=>t.is("element","tableRow")&&t.index<i)))),i<t.getRows(n)&&r.push(o.createContainerElement("tbody",null,o.createSlot((t=>t.is("element","tableRow")&&t.index>=i))));const s=o.createContainerElement("figure",{class:"table"},[o.createContainerElement("table",null,r),o.createSlot((t=>!t.is("element","tableRow")))]);return e.asWidget?function(t,e){return e.setCustomProperty("table",!0,t),zm(t,e,{hasSelectionHandle:!0})}(s,o):s}}function P_(t={}){return (e,{writer:n})=>{const o=e.parent,i=o.parent,r=i.getChildIndex(o),s=new S_(i,{row:r}),a=i.getAttribute("headingRows")||0,c=i.getAttribute("headingColumns")||0;for(const o of s)if(o.cell==e){const e=o.row<a||o.column<c?"th":"td";return t.asWidget?jm(n.createEditableElement(e),n):n.createContainerElement(e)}}}function z_(t={}){return (e,{writer:n,consumable:o,mapper:i})=>{if(e.parent.is("element","tableCell")&&L_(e))return t.asWidget?n.createContainerElement("span",{class:"ck-table-bogus-paragraph"}):(o.consume(e,"insert"),void i.bindElements(e,i.toViewElement(e.parent)))}}function L_(t){return 1==t.parent.childCount&&![...t.getAttributeKeys()].length}class O_ extends Si{refresh(){const t=this.editor.model,e=t.document.selection,n=t.schema;this.isEnabled=function(t,e){const n=t.getFirstPosition().parent,o=n===n.root?n:n.parent;return e.checkChild(o,"table")}(e,n);}execute(t={}){const e=this.editor.model,n=this.editor.plugins.get("TableUtils"),o=this.editor.config.get("table"),i=o.defaultHeadings.rows,r=o.defaultHeadings.columns;void 0===t.headingRows&&i&&(t.headingRows=i),void 0===t.headingColumns&&r&&(t.headingColumns=r),e.change((o=>{const i=n.createTable(o,t);e.insertObject(i,null,null,{findOptimalPosition:"auto"}),o.setSelection(o.createPositionAt(i.getNodeByPath([0,0,0]),0));}));}}class R_ extends Si{constructor(t,e={}){super(t),this.order=e.order||"below";}refresh(){const t=this.editor.model.document.selection,e=!!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;this.isEnabled=e;}execute(){const t=this.editor,e=t.model.document.selection,n=t.plugins.get("TableUtils"),o="above"===this.order,i=n.getSelectionAffectedTableCells(e),r=n.getRowIndexes(i),s=o?r.first:r.last,a=i[0].findAncestor("table");n.insertRows(a,{at:o?s:s+1,copyStructureFromAbove:!o});}}class j_ extends Si{constructor(t,e={}){super(t),this.order=e.order||"right";}refresh(){const t=this.editor.model.document.selection,e=!!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;this.isEnabled=e;}execute(){const t=this.editor,e=t.model.document.selection,n=t.plugins.get("TableUtils"),o="left"===this.order,i=n.getSelectionAffectedTableCells(e),r=n.getColumnIndexes(i),s=o?r.first:r.last,a=i[0].findAncestor("table");n.insertColumns(a,{columns:1,at:o?s:s+1});}}class F_ extends Si{constructor(t,e={}){super(t),this.direction=e.direction||"horizontally";}refresh(){const t=this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);this.isEnabled=1===t.length;}execute(){const t=this.editor.plugins.get("TableUtils"),e=t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];"horizontally"===this.direction?t.splitCellHorizontally(e,2):t.splitCellVertically(e,2);}}function V_(t,e,n){const{startRow:o,startColumn:i,endRow:r,endColumn:s}=e,a=n.createElement("table"),c=r-o+1;for(let t=0;t<c;t++)n.insertElement("tableRow",a,"end");const l=[...new S_(t,{startRow:o,endRow:r,startColumn:i,endColumn:s,includeAllSlots:!0})];for(const{row:t,column:e,cell:c,isAnchor:d,cellAnchorRow:h,cellAnchorColumn:u}of l){const l=t-o,g=a.getChild(l);if(d){const o=n.cloneElement(c);n.append(o,g),q_(o,t,e,r,s,n);}else (h<o||u<i)&&E_(n,n.createPositionAt(g,"end"));}return function(t,e,n,o,i){const r=parseInt(e.getAttribute("headingRows")||0);if(r>0){x_("headingRows",r-n,t,i,0);}const s=parseInt(e.getAttribute("headingColumns")||0);if(s>0){x_("headingColumns",s-o,t,i,0);}}(a,t,o,i,n),a}function U_(t,e,n=0){const o=[],i=new S_(t,{startRow:n,endRow:e-1});for(const t of i){const{row:n,cellHeight:i}=t;n<e&&e<=n+i-1&&o.push(t);}return o}function H_(t,e,n){const o=t.parent,i=o.parent,r=o.index,s=e-r,a={},c=parseInt(t.getAttribute("rowspan"))-s;c>1&&(a.rowspan=c);const l=parseInt(t.getAttribute("colspan")||1);l>1&&(a.colspan=l);const d=r+s,h=[...new S_(i,{startRow:r,endRow:d,includeAllSlots:!0})];let u,g=null;for(const e of h){const{row:o,column:i,cell:r}=e;r===t&&void 0===u&&(u=i),void 0!==u&&u===i&&o===d&&(g=E_(n,e.getPositionBefore(),a));}return x_("rowspan",s,t,n),g}function W_(t,e){const n=[],o=new S_(t);for(const t of o){const{column:o,cellWidth:i}=t;o<e&&e<=o+i-1&&n.push(t);}return n}function G_(t,e,n,o){const i=n-e,r={},s=parseInt(t.getAttribute("colspan"))-i;s>1&&(r.colspan=s);const a=parseInt(t.getAttribute("rowspan")||1);a>1&&(r.rowspan=a);const c=E_(o,o.createPositionAfter(t),r);return x_("colspan",i,t,o),c}function q_(t,e,n,o,i,r){const s=parseInt(t.getAttribute("colspan")||1),a=parseInt(t.getAttribute("rowspan")||1);if(n+s-1>i){x_("colspan",i-n+1,t,r,1);}if(e+a-1>o){x_("rowspan",o-e+1,t,r,1);}}function Y_(t,e){const n=e.getColumns(t),o=new Array(n).fill(0);for(const{column:e}of new S_(t))o[e]++;const i=o.reduce(((t,e,n)=>e?t:[...t,n]),[]);if(i.length>0){const n=i[i.length-1];return e.removeColumns(t,{at:n}),!0}return !1}function $_(t,e){const n=[],o=e.getRows(t);for(let e=0;e<o;e++){t.getChild(e).isEmpty&&n.push(e);}if(n.length>0){const o=n[n.length-1];return e.removeRows(t,{at:o}),!0}return !1}function K_(t,e){Y_(t,e)||$_(t,e);}function Q_(t,e){const n=Array.from(new S_(t,{startColumn:e.firstColumn,endColumn:e.lastColumn,row:e.lastRow}));if(n.every((({cellHeight:t})=>1===t)))return e.lastRow;const o=n[0].cellHeight-1;return e.lastRow+o}function Z_(t,e){const n=Array.from(new S_(t,{startRow:e.firstRow,endRow:e.lastRow,column:e.lastColumn}));if(n.every((({cellWidth:t})=>1===t)))return e.lastColumn;const o=n[0].cellWidth-1;return e.lastColumn+o}class J_ extends Si{constructor(t,e){super(t),this.direction=e.direction,this.isHorizontal="right"==this.direction||"left"==this.direction;}refresh(){const t=this._getMergeableCell();this.value=t,this.isEnabled=!!t;}execute(){const t=this.editor.model,e=t.document,n=this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e.selection)[0],o=this.value,i=this.direction;t.change((t=>{const e="right"==i||"down"==i,r=e?n:o,s=e?o:n,a=s.parent;!function(t,e,n){X_(t)||(X_(e)&&n.remove(n.createRangeIn(e)),n.move(n.createRangeIn(t),n.createPositionAt(e,"end")));n.remove(t);}(s,r,t);const c=this.isHorizontal?"colspan":"rowspan",l=parseInt(n.getAttribute(c)||1),d=parseInt(o.getAttribute(c)||1);t.setAttribute(c,l+d,r),t.setSelection(t.createRangeIn(r));const h=this.editor.plugins.get("TableUtils");K_(a.findAncestor("table"),h);}));}_getMergeableCell(){const t=this.editor.model.document,e=this.editor.plugins.get("TableUtils"),n=e.getTableCellsContainingSelection(t.selection)[0];if(!n)return;const o=this.isHorizontal?function(t,e,n){const o=t.parent,i=o.parent,r="right"==e?t.nextSibling:t.previousSibling,s=(i.getAttribute("headingColumns")||0)>0;if(!r)return;const a="right"==e?t:r,c="right"==e?r:t,{column:l}=n.getCellLocation(a),{column:d}=n.getCellLocation(c),h=parseInt(a.getAttribute("colspan")||1),u=D_(n,a),g=D_(n,c);if(s&&u!=g)return;return l+h===d?r:void 0}(n,this.direction,e):function(t,e,n){const o=t.parent,i=o.parent,r=i.getChildIndex(o);if("down"==e&&r===n.getRows(i)-1||"up"==e&&0===r)return;const s=parseInt(t.getAttribute("rowspan")||1),a=i.getAttribute("headingRows")||0,c="down"==e&&r+s===a,l="up"==e&&r===a;if(a&&(c||l))return;const d=parseInt(t.getAttribute("rowspan")||1),h="down"==e?r+d:r,u=[...new S_(i,{endRow:h})],g=u.find((e=>e.cell===t)),m=g.column,p=u.find((({row:t,cellHeight:n,column:o})=>o===m&&("down"==e?t===h:h===t+n)));return p&&p.cell}(n,this.direction,e);if(!o)return;const i=this.isHorizontal?"rowspan":"colspan",r=parseInt(n.getAttribute(i)||1);return parseInt(o.getAttribute(i)||1)===r?o:void 0}}function X_(t){return 1==t.childCount&&t.getChild(0).is("element","paragraph")&&t.getChild(0).isEmpty}class tA extends Si{refresh(){const t=this.editor.plugins.get("TableUtils"),e=t.getSelectionAffectedTableCells(this.editor.model.document.selection),n=e[0];if(n){const o=n.findAncestor("table"),i=this.editor.plugins.get("TableUtils").getRows(o)-1,r=t.getRowIndexes(e),s=0===r.first&&r.last===i;this.isEnabled=!s;}else this.isEnabled=!1;}execute(){const t=this.editor.model,e=this.editor.plugins.get("TableUtils"),n=e.getSelectionAffectedTableCells(t.document.selection),o=e.getRowIndexes(n),i=n[0],r=i.findAncestor("table"),s=e.getCellLocation(i).column;t.change((t=>{const n=o.last-o.first+1;e.removeRows(r,{at:o.first,rows:n});const i=function(t,e,n,o){const i=t.getChild(Math.min(e,o-1));let r=i.getChild(0),s=0;for(const t of i.getChildren()){if(s>n)return r;r=t,s+=parseInt(t.getAttribute("colspan")||1);}return r}(r,o.first,s,e.getRows(r));t.setSelection(t.createPositionAt(i,0));}));}}class eA extends Si{refresh(){const t=this.editor.plugins.get("TableUtils"),e=t.getSelectionAffectedTableCells(this.editor.model.document.selection),n=e[0];if(n){const o=n.findAncestor("table"),i=t.getColumns(o),{first:r,last:s}=t.getColumnIndexes(e);this.isEnabled=s-r<i-1;}else this.isEnabled=!1;}execute(){const t=this.editor.plugins.get("TableUtils"),[e,n]=function(t,e){const n=e.getSelectionAffectedTableCells(t),o=n[0],i=n.pop(),r=[o,i];return o.isBefore(i)?r:r.reverse()}(this.editor.model.document.selection,t),o=e.parent.parent,i=[...new S_(o)],r={first:i.find((t=>t.cell===e)).column,last:i.find((t=>t.cell===n)).column},s=function(t,e,n,o){const i=parseInt(n.getAttribute("colspan")||1);return i>1?n:e.previousSibling||n.nextSibling?n.nextSibling||e.previousSibling:o.first?t.reverse().find((({column:t})=>t<o.first)).cell:t.reverse().find((({column:t})=>t>o.last)).cell}(i,e,n,r);this.editor.model.change((t=>{const e=r.last-r.first+1;this.editor.plugins.get("TableUtils").removeColumns(o,{at:r.first,columns:e}),t.setSelection(t.createPositionAt(s,0));}));}}class nA extends Si{refresh(){const t=this.editor.plugins.get("TableUtils"),e=this.editor.model,n=t.getSelectionAffectedTableCells(e.document.selection),o=n.length>0;this.isEnabled=o,this.value=o&&n.every((t=>this._isInHeading(t,t.parent.parent)));}execute(t={}){if(t.forceValue===this.value)return;const e=this.editor.plugins.get("TableUtils"),n=this.editor.model,o=e.getSelectionAffectedTableCells(n.document.selection),i=o[0].findAncestor("table"),{first:r,last:s}=e.getRowIndexes(o),a=this.value?r:s+1,c=i.getAttribute("headingRows")||0;n.change((t=>{if(a){const e=U_(i,a,a>c?c:0);for(const{cell:n}of e)H_(n,a,t);}x_("headingRows",a,i,t,0);}));}_isInHeading(t,e){const n=parseInt(e.getAttribute("headingRows")||0);return !!n&&t.parent.index<n}}class oA extends Si{refresh(){const t=this.editor.model,e=this.editor.plugins.get("TableUtils"),n=e.getSelectionAffectedTableCells(t.document.selection),o=n.length>0;this.isEnabled=o,this.value=o&&n.every((t=>D_(e,t)));}execute(t={}){if(t.forceValue===this.value)return;const e=this.editor.plugins.get("TableUtils"),n=this.editor.model,o=e.getSelectionAffectedTableCells(n.document.selection),i=o[0].findAncestor("table"),{first:r,last:s}=e.getColumnIndexes(o),a=this.value?r:s+1;n.change((t=>{if(a){const e=W_(i,a);for(const{cell:n,column:o}of e)G_(n,o,a,t);}x_("headingColumns",a,i,t,0);}));}}class iA extends Mi{static get pluginName(){return "TableUtils"}init(){this.decorate("insertColumns"),this.decorate("insertRows");}getCellLocation(t){const e=t.parent,n=e.parent,o=n.getChildIndex(e),i=new S_(n,{row:o});for(const{cell:e,row:n,column:o}of i)if(e===t)return {row:n,column:o}}createTable(t,e){const n=t.createElement("table"),o=parseInt(e.rows)||2,i=parseInt(e.columns)||2;return rA(t,n,0,o,i),e.headingRows&&x_("headingRows",Math.min(e.headingRows,o),n,t,0),e.headingColumns&&x_("headingColumns",Math.min(e.headingColumns,i),n,t,0),n}insertRows(t,e={}){const n=this.editor.model,o=e.at||0,i=e.rows||1,r=void 0!==e.copyStructureFromAbove,s=e.copyStructureFromAbove?o-1:o,a=this.getRows(t),c=this.getColumns(t);if(o>a)throw new k("tableutils-insertrows-insert-out-of-range",this,{options:e});n.change((e=>{const n=t.getAttribute("headingRows")||0;if(n>o&&x_("headingRows",n+i,t,e,0),!r&&(0===o||o===a))return void rA(e,t,o,i,c);const l=r?Math.max(o,s):o,d=new S_(t,{endRow:l}),h=new Array(c).fill(1);for(const{row:t,column:n,cellHeight:a,cellWidth:c,cell:l}of d){const d=t+a-1,u=t<=s&&s<=d;t<o&&o<=d?(e.setAttribute("rowspan",a+i,l),h[n]=-c):r&&u&&(h[n]=c);}for(let n=0;n<i;n++){const n=e.createElement("tableRow");e.insert(n,t,o);for(let t=0;t<h.length;t++){const o=h[t],i=e.createPositionAt(n,"end");o>0&&E_(e,i,o>1?{colspan:o}:null),t+=Math.abs(o)-1;}}}));}insertColumns(t,e={}){const n=this.editor.model,o=e.at||0,i=e.columns||1;n.change((e=>{const n=t.getAttribute("headingColumns");o<n&&e.setAttribute("headingColumns",n+i,t);const r=this.getColumns(t);if(0===o||r===o){for(const n of t.getChildren())n.is("element","tableRow")&&sA(i,e,e.createPositionAt(n,o?"end":0));return}const s=new S_(t,{column:o,includeAllSlots:!0});for(const t of s){const{row:n,cell:r,cellAnchorColumn:a,cellAnchorRow:c,cellWidth:l,cellHeight:d}=t;if(a<o){e.setAttribute("colspan",l+i,r);const t=c+d-1;for(let e=n;e<=t;e++)s.skipRow(e);}else sA(i,e,t.getPositionBefore());}}));}removeRows(t,e){const n=this.editor.model,o=e.rows||1,i=this.getRows(t),r=e.at,s=r+o-1;if(s>i-1)throw new k("tableutils-removerows-row-index-out-of-range",this,{table:t,options:e});n.change((e=>{const{cellsToMove:n,cellsToTrim:o}=function(t,e,n){const o=new Map,i=[];for(const{row:r,column:s,cellHeight:a,cell:c}of new S_(t,{endRow:n})){const t=r+a-1;if(r>=e&&r<=n&&t>n){const t=a-(n-r+1);o.set(s,{cell:c,rowspan:t});}if(r<e&&t>=e){let o;o=t>=n?n-e+1:t-e+1,i.push({cell:c,rowspan:a-o});}}return {cellsToMove:o,cellsToTrim:i}}(t,r,s);if(n.size){!function(t,e,n,o){const i=new S_(t,{includeAllSlots:!0,row:e}),r=[...i],s=t.getChild(e);let a;for(const{column:t,cell:e,isAnchor:i}of r)if(n.has(t)){const{cell:e,rowspan:i}=n.get(t),r=a?o.createPositionAfter(a):o.createPositionAt(s,0);o.move(o.createRangeOn(e),r),x_("rowspan",i,e,o),a=e;}else i&&(a=e);}(t,s+1,n,e);}for(let n=s;n>=r;n--)e.remove(t.getChild(n));for(const{rowspan:t,cell:n}of o)x_("rowspan",t,n,e);!function(t,e,n,o){const i=t.getAttribute("headingRows")||0;if(e<i){x_("headingRows",n<i?i-(n-e+1):e,t,o,0);}}(t,r,s,e),Y_(t,this)||$_(t,this);}));}removeColumns(t,e){const n=this.editor.model,o=e.at,i=e.columns||1,r=e.at+i-1;n.change((e=>{!function(t,e,n){const o=t.getAttribute("headingColumns")||0;if(o&&e.first<o){const i=Math.min(o-1,e.last)-e.first+1;n.setAttribute("headingColumns",o-i,t);}}(t,{first:o,last:r},e);for(let n=r;n>=o;n--)for(const{cell:o,column:i,cellWidth:r}of [...new S_(t)])i<=n&&r>1&&i+r>n?x_("colspan",r-1,o,e):i===n&&e.remove(o);$_(t,this)||Y_(t,this);}));}splitCellVertically(t,e=2){const n=this.editor.model,o=t.parent.parent,i=parseInt(t.getAttribute("rowspan")||1),r=parseInt(t.getAttribute("colspan")||1);n.change((n=>{if(r>1){const{newCellsSpan:o,updatedSpan:s}=aA(r,e);x_("colspan",s,t,n);const a={};o>1&&(a.colspan=o),i>1&&(a.rowspan=i);sA(r>e?e-1:r-1,n,n.createPositionAfter(t),a);}if(r<e){const s=e-r,a=[...new S_(o)],{column:c}=a.find((({cell:e})=>e===t)),l=a.filter((({cell:e,cellWidth:n,column:o})=>e!==t&&o===c||o<c&&o+n>c));for(const{cell:t,cellWidth:e}of l)n.setAttribute("colspan",e+s,t);const d={};i>1&&(d.rowspan=i),sA(s,n,n.createPositionAfter(t),d);const h=o.getAttribute("headingColumns")||0;h>c&&x_("headingColumns",h+s,o,n);}}));}splitCellHorizontally(t,e=2){const n=this.editor.model,o=t.parent,i=o.parent,r=i.getChildIndex(o),s=parseInt(t.getAttribute("rowspan")||1),a=parseInt(t.getAttribute("colspan")||1);n.change((n=>{if(s>1){const o=[...new S_(i,{startRow:r,endRow:r+s-1,includeAllSlots:!0})],{newCellsSpan:c,updatedSpan:l}=aA(s,e);x_("rowspan",l,t,n);const{column:d}=o.find((({cell:e})=>e===t)),h={};c>1&&(h.rowspan=c),a>1&&(h.colspan=a);for(const t of o){const{column:e,row:o}=t;o>=r+l&&e===d&&(o+r+l)%c==0&&sA(1,n,t.getPositionBefore(),h);}}if(s<e){const o=e-s,c=[...new S_(i,{startRow:0,endRow:r})];for(const{cell:e,cellHeight:i,row:s}of c)if(e!==t&&s+i>r){const t=i+o;n.setAttribute("rowspan",t,e);}const l={};a>1&&(l.colspan=a),rA(n,i,r+1,o,1,l);const d=i.getAttribute("headingRows")||0;d>r&&x_("headingRows",d+o,i,n);}}));}getColumns(t){return [...t.getChild(0).getChildren()].reduce(((t,e)=>t+parseInt(e.getAttribute("colspan")||1)),0)}getRows(t){return Array.from(t.getChildren()).reduce(((t,e)=>e.is("element","tableRow")?t+1:t),0)}createTableWalker(t,e={}){return new S_(t,e)}getSelectedTableCells(t){const e=[];for(const n of this.sortRanges(t.getRanges())){const t=n.getContainedElement();t&&t.is("element","tableCell")&&e.push(t);}return e}getTableCellsContainingSelection(t){const e=[];for(const n of t.getRanges()){const t=n.start.findAncestor("tableCell");t&&e.push(t);}return e}getSelectionAffectedTableCells(t){const e=this.getSelectedTableCells(t);return e.length?e:this.getTableCellsContainingSelection(t)}getRowIndexes(t){const e=t.map((t=>t.parent.index));return this._getFirstLastIndexesObject(e)}getColumnIndexes(t){const e=t[0].findAncestor("table"),n=[...new S_(e)].filter((e=>t.includes(e.cell))).map((t=>t.column));return this._getFirstLastIndexesObject(n)}isSelectionRectangular(t){if(t.length<2||!this._areCellInTheSameTableSection(t))return !1;const e=new Set,n=new Set;let o=0;for(const i of t){const{row:t,column:r}=this.getCellLocation(i),s=parseInt(i.getAttribute("rowspan")||1),a=parseInt(i.getAttribute("colspan")||1);e.add(t),n.add(r),s>1&&e.add(t+s-1),a>1&&n.add(r+a-1),o+=s*a;}const i=function(t,e){const n=Array.from(t.values()),o=Array.from(e.values()),i=Math.max(...n),r=Math.min(...n),s=Math.max(...o),a=Math.min(...o);return (i-r+1)*(s-a+1)}(e,n);return i==o}sortRanges(t){return Array.from(t).sort(cA)}_getFirstLastIndexesObject(t){const e=t.sort(((t,e)=>t-e));return {first:e[0],last:e[e.length-1]}}_areCellInTheSameTableSection(t){const e=t[0].findAncestor("table"),n=this.getRowIndexes(t),o=parseInt(e.getAttribute("headingRows")||0);if(!this._areIndexesInSameSection(n,o))return !1;const i=parseInt(e.getAttribute("headingColumns")||0),r=this.getColumnIndexes(t);return this._areIndexesInSameSection(r,i)}_areIndexesInSameSection({first:t,last:e},n){return t<n===e<n}}function rA(t,e,n,o,i,r={}){for(let s=0;s<o;s++){const o=t.createElement("tableRow");t.insert(o,e,n),sA(i,t,t.createPositionAt(o,"end"),r);}}function sA(t,e,n,o={}){for(let i=0;i<t;i++)E_(e,n,o);}function aA(t,e){if(t<e)return {newCellsSpan:1,updatedSpan:1};const n=Math.floor(t/e);return {newCellsSpan:n,updatedSpan:t-n*e+n}}function cA(t,e){const n=t.start,o=e.start;return n.isBefore(o)?-1:1}class lA extends Si{refresh(){const t=this.editor.plugins.get(iA),e=t.getSelectedTableCells(this.editor.model.document.selection);this.isEnabled=t.isSelectionRectangular(e,this.editor.plugins.get(iA));}execute(){const t=this.editor.model,e=this.editor.plugins.get(iA);t.change((n=>{const o=e.getSelectedTableCells(t.document.selection),i=o.shift(),{mergeWidth:r,mergeHeight:s}=function(t,e,n){let o=0,i=0;for(const t of e){const{row:e,column:r}=n.getCellLocation(t);o=uA(t,r,o,"colspan"),i=uA(t,e,i,"rowspan");}const{row:r,column:s}=n.getCellLocation(t),a=o-s,c=i-r;return {mergeWidth:a,mergeHeight:c}}(i,o,e);x_("colspan",r,i,n),x_("rowspan",s,i,n);for(const t of o)dA(t,i,n);K_(i.findAncestor("table"),e),n.setSelection(i,"in");}));}}function dA(t,e,n){hA(t)||(hA(e)&&n.remove(n.createRangeIn(e)),n.move(n.createRangeIn(t),n.createPositionAt(e,"end"))),n.remove(t);}function hA(t){return 1==t.childCount&&t.getChild(0).is("element","paragraph")&&t.getChild(0).isEmpty}function uA(t,e,n,o){const i=parseInt(t.getAttribute(o)||1);return Math.max(n,e+i)}class gA extends Si{constructor(t){super(t),this.affectsData=!1;}refresh(){const t=this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);this.isEnabled=t.length>0;}execute(){const t=this.editor.model,e=this.editor.plugins.get("TableUtils"),n=e.getSelectionAffectedTableCells(t.document.selection),o=e.getRowIndexes(n),i=n[0].findAncestor("table"),r=[];for(let e=o.first;e<=o.last;e++)for(const n of i.getChild(e).getChildren())r.push(t.createRangeOn(n));t.change((t=>{t.setSelection(r);}));}}class mA extends Si{constructor(t){super(t),this.affectsData=!1;}refresh(){const t=this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);this.isEnabled=t.length>0;}execute(){const t=this.editor.plugins.get("TableUtils"),e=this.editor.model,n=t.getSelectionAffectedTableCells(e.document.selection),o=n[0],i=n.pop(),r=o.findAncestor("table"),s=t.getCellLocation(o),a=t.getCellLocation(i),c=Math.min(s.column,a.column),l=Math.max(s.column,a.column),d=[];for(const t of new S_(r,{startColumn:c,endColumn:l}))d.push(e.createRangeOn(t.cell));e.change((t=>{t.setSelection(d);}));}}function pA(t){t.document.registerPostFixer((e=>function(t,e){const n=e.document.differ.getChanges();let o=!1;const i=new Set;for(const e of n){let n;"table"==e.name&&"insert"==e.type&&(n=e.position.nodeAfter),"tableRow"!=e.name&&"tableCell"!=e.name||(n=e.position.findAncestor("table")),bA(e)&&(n=e.range.start.findAncestor("table")),n&&!i.has(n)&&(o=fA(n,t)||o,o=kA(n,t)||o,i.add(n));}return o}(e,t)));}function fA(t,e){let n=!1;const o=function(t){const e=parseInt(t.getAttribute("headingRows")||0),n=Array.from(t.getChildren()).reduce(((t,e)=>e.is("element","tableRow")?t+1:t),0),o=[];for(const{row:i,cell:r,cellHeight:s}of new S_(t)){if(s<2)continue;const t=i<e?e:n;if(i+s>t){const e=t-i;o.push({cell:r,rowspan:e});}}return o}(t);if(o.length){n=!0;for(const t of o)x_("rowspan",t.rowspan,t.cell,e,1);}return n}function kA(t,e){let n=!1;const o=function(t){const e=new Array(t.childCount).fill(0);for(const{rowIndex:n}of new S_(t,{includeAllSlots:!0}))e[n]++;return e}(t),i=[];for(const[e,n]of o.entries())!n&&t.getChild(e).is("element","tableRow")&&i.push(e);if(i.length){n=!0;for(const n of i.reverse())e.remove(t.getChild(n)),o.splice(n,1);}const r=o.filter(((e,n)=>t.getChild(n).is("element","tableRow"))),s=r[0];if(!r.every((t=>t===s))){const o=r.reduce(((t,e)=>e>t?e:t),0);for(const[i,s]of r.entries()){const r=o-s;if(r){for(let n=0;n<r;n++)E_(e,e.createPositionAt(t.getChild(i),"end"));n=!0;}}}return n}function bA(t){const e="attribute"===t.type,n=t.attributeKey;return e&&("headingRows"===n||"colspan"===n||"rowspan"===n)}function wA(t){t.document.registerPostFixer((e=>function(t,e){const n=e.document.differ.getChanges();let o=!1;for(const e of n)"insert"==e.type&&"table"==e.name&&(o=_A(e.position.nodeAfter,t)||o),"insert"==e.type&&"tableRow"==e.name&&(o=AA(e.position.nodeAfter,t)||o),"insert"==e.type&&"tableCell"==e.name&&(o=CA(e.position.nodeAfter,t)||o),vA(e)&&(o=CA(e.position.parent,t)||o);return o}(e,t)));}function _A(t,e){let n=!1;for(const o of t.getChildren())o.is("element","tableRow")&&(n=AA(o,e)||n);return n}function AA(t,e){let n=!1;for(const o of t.getChildren())n=CA(o,e)||n;return n}function CA(t,e){if(0==t.childCount)return e.insertElement("paragraph",t),!0;const n=Array.from(t.getChildren()).filter((t=>t.is("$text")));for(const t of n)e.wrap(e.createRangeOn(t),"paragraph");return !!n.length}function vA(t){return !(!t.position||!t.position.parent.is("element","tableCell"))&&("insert"==t.type&&"$text"==t.name||"remove"==t.type)}function yA(t,e){if(!t.is("element","paragraph"))return !1;const n=e.toViewElement(t);return !!n&&L_(t)!==n.is("element","span")}var xA=n(3881),EA={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(xA.Z,EA);xA.Z.locals;class DA extends Mi{static get pluginName(){return "TableEditing"}static get requires(){return [iA]}init(){const t=this.editor,e=t.model,n=e.schema,o=t.conversion,i=t.plugins.get(iA);n.register("table",{inheritAllFrom:"$blockObject",allowAttributes:["headingRows","headingColumns"]}),n.register("tableRow",{allowIn:"table",isLimit:!0}),n.register("tableCell",{allowContentOf:"$container",allowIn:"tableRow",allowAttributes:["colspan","rowspan"],isLimit:!0,isSelectable:!0}),o.for("upcast").add((t=>{t.on("element:figure",((t,e,n)=>{if(!n.consumable.test(e.viewItem,{name:!0,classes:"table"}))return;const o=function(t){for(const e of t.getChildren())if(e.is("element","table"))return e}(e.viewItem);if(!o||!n.consumable.test(o,{name:!0}))return;n.consumable.consume(e.viewItem,{name:!0,classes:"table"});const i=Ai(n.convertItem(o,e.modelCursor).modelRange.getItems());i?(n.convertChildren(e.viewItem,n.writer.createPositionAt(i,"end")),n.updateConversionResult(i,e)):n.consumable.revert(e.viewItem,{name:!0,classes:"table"});}));})),o.for("upcast").add(I_()),o.for("editingDowncast").elementToStructure({model:{name:"table",attributes:["headingRows"]},view:B_(i,{asWidget:!0})}),o.for("dataDowncast").elementToStructure({model:{name:"table",attributes:["headingRows"]},view:B_(i)}),o.for("upcast").elementToElement({model:"tableRow",view:"tr"}),o.for("upcast").add((t=>{t.on("element:tr",((t,e)=>{e.viewItem.isEmpty&&0==e.modelCursor.index&&t.stop();}),{priority:"high"});})),o.for("downcast").elementToElement({model:"tableRow",view:(t,{writer:e})=>t.isEmpty?e.createEmptyElement("tr"):e.createContainerElement("tr")}),o.for("upcast").elementToElement({model:"tableCell",view:"td"}),o.for("upcast").elementToElement({model:"tableCell",view:"th"}),o.for("upcast").add(M_("td")),o.for("upcast").add(M_("th")),o.for("editingDowncast").elementToElement({model:"tableCell",view:P_({asWidget:!0})}),o.for("dataDowncast").elementToElement({model:"tableCell",view:P_()}),o.for("editingDowncast").elementToElement({model:"paragraph",view:z_({asWidget:!0}),converterPriority:"high"}),o.for("dataDowncast").elementToElement({model:"paragraph",view:z_(),converterPriority:"high"}),o.for("downcast").attributeToAttribute({model:"colspan",view:"colspan"}),o.for("upcast").attributeToAttribute({model:{key:"colspan",value:IA("colspan")},view:"colspan"}),o.for("downcast").attributeToAttribute({model:"rowspan",view:"rowspan"}),o.for("upcast").attributeToAttribute({model:{key:"rowspan",value:IA("rowspan")},view:"rowspan"}),t.data.mapper.on("modelToViewPosition",((t,e)=>{const n=e.modelPosition.parent,o=e.modelPosition.nodeBefore;if(!n.is("element","tableCell"))return;if(!o||!o.is("element","paragraph"))return;const i=e.mapper.toViewElement(o),r=e.mapper.toViewElement(n);i===r&&(e.viewPosition=e.mapper.findPositionIn(r,o.maxOffset));})),t.config.define("table.defaultHeadings.rows",0),t.config.define("table.defaultHeadings.columns",0),t.commands.add("insertTable",new O_(t)),t.commands.add("insertTableRowAbove",new R_(t,{order:"above"})),t.commands.add("insertTableRowBelow",new R_(t,{order:"below"})),t.commands.add("insertTableColumnLeft",new j_(t,{order:"left"})),t.commands.add("insertTableColumnRight",new j_(t,{order:"right"})),t.commands.add("removeTableRow",new tA(t)),t.commands.add("removeTableColumn",new eA(t)),t.commands.add("splitTableCellVertically",new F_(t,{direction:"vertically"})),t.commands.add("splitTableCellHorizontally",new F_(t,{direction:"horizontally"})),t.commands.add("mergeTableCells",new lA(t)),t.commands.add("mergeTableCellRight",new J_(t,{direction:"right"})),t.commands.add("mergeTableCellLeft",new J_(t,{direction:"left"})),t.commands.add("mergeTableCellDown",new J_(t,{direction:"down"})),t.commands.add("mergeTableCellUp",new J_(t,{direction:"up"})),t.commands.add("setTableColumnHeader",new oA(t)),t.commands.add("setTableRowHeader",new nA(t)),t.commands.add("selectTableRow",new gA(t)),t.commands.add("selectTableColumn",new mA(t)),pA(e),wA(e),this.listenTo(e.document,"change:data",(()=>{!function(t,e){const n=t.document.differ;for(const t of n.getChanges()){let n,o=!1;if("attribute"==t.type){const e=t.range.start.nodeAfter;if(!e||!e.is("element","table"))continue;if("headingRows"!=t.attributeKey&&"headingColumns"!=t.attributeKey)continue;n=e,o="headingRows"==t.attributeKey;}else "tableRow"!=t.name&&"tableCell"!=t.name||(n=t.position.findAncestor("table"),o="tableRow"==t.name);if(!n)continue;const i=n.getAttribute("headingRows")||0,r=n.getAttribute("headingColumns")||0,s=new S_(n);for(const t of s){const n=t.row<i||t.column<r?"th":"td",s=e.mapper.toViewElement(t.cell);s&&s.is("element")&&s.name!=n&&e.reconvertItem(o?t.cell.parent:t.cell);}}}(e,t.editing),function(t,e){const n=t.document.differ,o=new Set;for(const t of n.getChanges()){const e="attribute"==t.type?t.range.start.parent:t.position.parent;e.is("element","tableCell")&&o.add(e);}for(const t of o.values()){const n=Array.from(t.getChildren()).filter((t=>yA(t,e.mapper)));for(const t of n)e.reconvertItem(t);}}(e,t.editing);}));}}function IA(t){return e=>{const n=parseInt(e.getAttribute(t));return Number.isNaN(n)||n<=0?null:n}}var MA=n(1613),TA={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(MA.Z,TA);MA.Z.locals;class SA extends Ph{constructor(t){super(t);const e=this.bindTemplate;this.items=this._createGridCollection(),this.keystrokes=new vi,this.focusTracker=new Ci,this.set("rows",0),this.set("columns",0),this.bind("label").to(this,"columns",this,"rows",((t,e)=>`${e} × ${t}`)),this.setTemplate({tag:"div",attributes:{class:["ck"]},children:[{tag:"div",attributes:{class:["ck-insert-table-dropdown__grid"]},on:{"mouseover@.ck-insert-table-dropdown-grid-box":e.to("boxover")},children:this.items},{tag:"div",attributes:{class:["ck","ck-insert-table-dropdown__label"],"aria-hidden":!0},children:[{text:e.to("label")}]}],on:{mousedown:e.to((t=>{t.preventDefault();})),click:e.to((()=>{this.fire("execute");}))}}),this.on("boxover",((t,e)=>{const{row:n,column:o}=e.target.dataset;this.items.get(10*(parseInt(n,10)-1)+(parseInt(o,10)-1)).focus();})),this.focusTracker.on("change:focusedElement",((t,e,n)=>{if(!n)return;const{row:o,column:i}=n.dataset;this.set({rows:parseInt(o),columns:parseInt(i)});})),this.on("change:columns",(()=>this._highlightGridBoxes())),this.on("change:rows",(()=>this._highlightGridBoxes()));}render(){super.render(),function({keystrokeHandler:t,focusTracker:e,gridItems:n,numberOfColumns:o,uiLanguageDirection:i}){const r="number"==typeof o?()=>o:o;function s(t){return o=>{const i=n.find((t=>t.element===e.focusedElement)),r=n.getIndex(i),s=t(r,n);n.get(s).focus(),o.stopPropagation(),o.preventDefault();}}function a(t,e){return t===e-1?0:t+1}function c(t,e){return 0===t?e-1:t-1}t.set("arrowright",s(((t,e)=>"rtl"===i?c(t,e.length):a(t,e.length)))),t.set("arrowleft",s(((t,e)=>"rtl"===i?a(t,e.length):c(t,e.length)))),t.set("arrowup",s(((t,e)=>{let n=t-r();return n<0&&(n=t+r()*Math.floor(e.length/r()),n>e.length-1&&(n-=r())),n}))),t.set("arrowdown",s(((t,e)=>{let n=t+r();return n>e.length-1&&(n=t%r()),n})));}({keystrokeHandler:this.keystrokes,focusTracker:this.focusTracker,gridItems:this.items,numberOfColumns:10,uiLanguageDirection:this.locale&&this.locale.uiLanguageDirection});for(const t of this.items)this.focusTracker.add(t.element);this.keystrokes.listenTo(this.element);}focus(){this.items.get(0).focus();}focusLast(){this.items.get(0).focus();}_highlightGridBoxes(){const t=this.rows,e=this.columns;this.items.map(((n,o)=>{const i=Math.floor(o/10)<t&&o%10<e;n.set("isOn",i);}));}_createGridButton(t,e,n,o){const i=new cu(t);return i.set({label:o,class:"ck-insert-table-dropdown-grid-box"}),i.extendTemplate({attributes:{"data-row":e,"data-column":n}}),i}_createGridCollection(){const t=[];for(let e=0;e<100;e++){const n=Math.floor(e/10),o=e%10,i=`${n+1} × ${o+1}`;t.push(this._createGridButton(this.locale,n+1,o+1,i));}return this.createCollection(t)}}class NA extends Mi{static get pluginName(){return "TableUI"}init(){const t=this.editor,e=this.editor.t,n="ltr"===t.locale.contentLanguageDirection;t.ui.componentFactory.add("insertTable",(n=>{const o=t.commands.get("insertTable"),i=Gu(n);let r;return i.bind("isEnabled").to(o),i.buttonView.set({icon:'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',label:e("Insert table"),tooltip:!0}),i.on("change:isOpen",(()=>{r||(r=new SA(n),i.panelView.children.add(r),r.delegate("execute").to(i),i.on("execute",(()=>{t.execute("insertTable",{rows:r.rows,columns:r.columns}),t.editing.view.focus();})));})),i})),t.ui.componentFactory.add("tableColumn",(t=>{const o=[{type:"switchbutton",model:{commandName:"setTableColumnHeader",label:e("Header column"),bindIsOn:!0}},{type:"separator"},{type:"button",model:{commandName:n?"insertTableColumnLeft":"insertTableColumnRight",label:e("Insert column left")}},{type:"button",model:{commandName:n?"insertTableColumnRight":"insertTableColumnLeft",label:e("Insert column right")}},{type:"button",model:{commandName:"removeTableColumn",label:e("Delete column")}},{type:"button",model:{commandName:"selectTableColumn",label:e("Select column")}}];return this._prepareDropdown(e("Column"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>',o,t)})),t.ui.componentFactory.add("tableRow",(t=>{const n=[{type:"switchbutton",model:{commandName:"setTableRowHeader",label:e("Header row"),bindIsOn:!0}},{type:"separator"},{type:"button",model:{commandName:"insertTableRowAbove",label:e("Insert row above")}},{type:"button",model:{commandName:"insertTableRowBelow",label:e("Insert row below")}},{type:"button",model:{commandName:"removeTableRow",label:e("Delete row")}},{type:"button",model:{commandName:"selectTableRow",label:e("Select row")}}];return this._prepareDropdown(e("Row"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>',n,t)})),t.ui.componentFactory.add("mergeTableCells",(t=>{const o=[{type:"button",model:{commandName:"mergeTableCellUp",label:e("Merge cell up")}},{type:"button",model:{commandName:n?"mergeTableCellRight":"mergeTableCellLeft",label:e("Merge cell right")}},{type:"button",model:{commandName:"mergeTableCellDown",label:e("Merge cell down")}},{type:"button",model:{commandName:n?"mergeTableCellLeft":"mergeTableCellRight",label:e("Merge cell left")}},{type:"separator"},{type:"button",model:{commandName:"splitTableCellVertically",label:e("Split cell vertically")}},{type:"button",model:{commandName:"splitTableCellHorizontally",label:e("Split cell horizontally")}}];return this._prepareMergeSplitButtonDropdown(e("Merge cells"),'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>',o,t)}));}_prepareDropdown(t,e,n,o){const i=this.editor,r=Gu(o),s=this._fillDropdownWithListOptions(r,n);return r.buttonView.set({label:t,icon:e,tooltip:!0}),r.bind("isEnabled").toMany(s,"isEnabled",((...t)=>t.some((t=>t)))),this.listenTo(r,"execute",(t=>{i.execute(t.source.commandName),t.source instanceof hu||i.editing.view.focus();})),r}_prepareMergeSplitButtonDropdown(t,e,n,o){const i=this.editor,r=Gu(o,bu),s="mergeTableCells",a=i.commands.get(s),c=this._fillDropdownWithListOptions(r,n);return r.buttonView.set({label:t,icon:e,tooltip:!0,isEnabled:!0}),r.bind("isEnabled").toMany([a,...c],"isEnabled",((...t)=>t.some((t=>t)))),this.listenTo(r.buttonView,"execute",(()=>{i.execute(s),i.editing.view.focus();})),this.listenTo(r,"execute",(t=>{i.execute(t.source.commandName),i.editing.view.focus();})),r}_fillDropdownWithListOptions(t,e){const n=this.editor,o=[],i=new _i;for(const t of e)BA(t,n,o,i);return Yu(t,i,n.ui.componentFactory),o}}function BA(t,e,n,o){const i=t.model=new mg(t.model),{commandName:r,bindIsOn:s}=t.model;if("button"===t.type||"switchbutton"===t.type){const t=e.commands.get(r);n.push(t),i.set({commandName:r}),i.bind("isEnabled").to(t),s&&i.bind("isOn").to(t,"value");}i.set({withText:!0}),o.add(t);}var PA=n(6945),zA={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(PA.Z,zA);PA.Z.locals;class LA extends Mi{static get pluginName(){return "TableSelection"}static get requires(){return [iA,iA]}init(){const t=this.editor,e=t.model,n=t.editing.view;this.listenTo(e,"deleteContent",((t,e)=>this._handleDeleteContent(t,e)),{priority:"high"}),this.listenTo(n.document,"insertText",((t,e)=>this._handleInsertTextEvent(t,e)),{priority:"high"}),this._defineSelectionConverter(),this._enablePluginDisabling();}getSelectedTableCells(){const t=this.editor.plugins.get(iA),e=this.editor.model.document.selection,n=t.getSelectedTableCells(e);return 0==n.length?null:n}getSelectionAsFragment(){const t=this.editor.plugins.get(iA),e=this.getSelectedTableCells();return e?this.editor.model.change((n=>{const o=n.createDocumentFragment(),{first:i,last:r}=t.getColumnIndexes(e),{first:s,last:a}=t.getRowIndexes(e),c=e[0].findAncestor("table");let l=a,d=r;if(t.isSelectionRectangular(e)){const t={firstColumn:i,lastColumn:r,firstRow:s,lastRow:a};l=Q_(c,t),d=Z_(c,t);}const h=V_(c,{startRow:s,startColumn:i,endRow:l,endColumn:d},n);return n.insert(h,o,0),o})):null}setCellSelection(t,e){const n=this._getCellsToSelect(t,e);this.editor.model.change((t=>{t.setSelection(n.cells.map((e=>t.createRangeOn(e))),{backward:n.backward});}));}getFocusCell(){const t=[...this.editor.model.document.selection.getRanges()].pop().getContainedElement();return t&&t.is("element","tableCell")?t:null}getAnchorCell(){const t=Ai(this.editor.model.document.selection.getRanges()).getContainedElement();return t&&t.is("element","tableCell")?t:null}_defineSelectionConverter(){const t=this.editor,e=new Set;t.conversion.for("editingDowncast").add((t=>t.on("selection",((t,n,o)=>{const i=o.writer;!function(t){for(const n of e)t.removeClass("ck-editor__editable_selected",n);e.clear();}(i);const r=this.getSelectedTableCells();if(!r)return;for(const t of r){const n=o.mapper.toViewElement(t);i.addClass("ck-editor__editable_selected",n),e.add(n);}const s=o.mapper.toViewElement(r[r.length-1]);i.setSelection(s,0);}),{priority:"lowest"})));}_enablePluginDisabling(){const t=this.editor;this.on("change:isEnabled",(()=>{if(!this.isEnabled){const e=this.getSelectedTableCells();if(!e)return;t.model.change((n=>{const o=n.createPositionAt(e[0],0),i=t.model.schema.getNearestSelectionRange(o);n.setSelection(i);}));}}));}_handleDeleteContent(t,e){const n=this.editor.plugins.get(iA),[o,i]=e,r=this.editor.model,s=!i||"backward"==i.direction,a=n.getSelectedTableCells(o);a.length&&(t.stop(),r.change((t=>{const e=a[s?a.length-1:0];r.change((t=>{for(const e of a)r.deleteContent(t.createSelection(e,"in"));}));const n=r.schema.getNearestSelectionRange(t.createPositionAt(e,0));o.is("documentSelection")?t.setSelection(n):o.setTo(n);})));}_handleInsertTextEvent(t,e){const n=this.editor,o=n.model.document.selection,i=this.getSelectedTableCells(o);if(!i)return;const r=n.editing.view,s=n.editing.mapper,a=i.map((t=>r.createRangeOn(s.toViewElement(t))));e.selection=r.createSelection(a);}_getCellsToSelect(t,e){const n=this.editor.plugins.get("TableUtils"),o=n.getCellLocation(t),i=n.getCellLocation(e),r=Math.min(o.row,i.row),s=Math.max(o.row,i.row),a=Math.min(o.column,i.column),c=Math.max(o.column,i.column),l=new Array(s-r+1).fill(null).map((()=>[])),d={startRow:r,endRow:s,startColumn:a,endColumn:c};for(const{row:e,cell:n}of new S_(t.findAncestor("table"),d))l[e-r].push(n);const h=i.row<o.row,u=i.column<o.column;return h&&l.reverse(),u&&l.forEach((t=>t.reverse())),{cells:l.flat(),backward:h||u}}}class OA extends Mi{static get pluginName(){return "TableClipboard"}static get requires(){return [LA,iA]}init(){const t=this.editor,e=t.editing.view.document;this.listenTo(e,"copy",((t,e)=>this._onCopyCut(t,e))),this.listenTo(e,"cut",((t,e)=>this._onCopyCut(t,e))),this.listenTo(t.model,"insertContent",((t,e)=>this._onInsertContent(t,...e)),{priority:"high"}),this.decorate("_replaceTableSlotCell");}_onCopyCut(t,e){const n=this.editor.plugins.get(LA);if(!n.getSelectedTableCells())return;if("cut"==t.name&&this.editor.isReadOnly)return;e.preventDefault(),t.stop();const o=this.editor.data,i=this.editor.editing.view.document,r=o.toView(n.getSelectionAsFragment());i.fire("clipboardOutput",{dataTransfer:e.dataTransfer,content:r,method:t.name});}_onInsertContent(t,e,n){if(n&&!n.is("documentSelection"))return;const o=this.editor.model,i=this.editor.plugins.get(iA);let r=RA(e,o);if(!r)return;const s=i.getSelectionAffectedTableCells(o.document.selection);s.length?(t.stop(),o.change((t=>{const e={width:i.getColumns(r),height:i.getRows(r)},n=function(t,e,n,o){const i=t[0].findAncestor("table"),r=o.getColumnIndexes(t),s=o.getRowIndexes(t),a={firstColumn:r.first,lastColumn:r.last,firstRow:s.first,lastRow:s.last},c=1===t.length;c&&(a.lastRow+=e.height-1,a.lastColumn+=e.width-1,function(t,e,n,o){const i=o.getColumns(t),r=o.getRows(t);n>i&&o.insertColumns(t,{at:i,columns:n-i});e>r&&o.insertRows(t,{at:r,rows:e-r});}(i,a.lastRow+1,a.lastColumn+1,o));c||!o.isSelectionRectangular(t)?function(t,e,n){const{firstRow:o,lastRow:i,firstColumn:r,lastColumn:s}=e,a={first:o,last:i},c={first:r,last:s};FA(t,r,a,n),FA(t,s+1,a,n),jA(t,o,c,n),jA(t,i+1,c,n,o);}(i,a,n):(a.lastRow=Q_(i,a),a.lastColumn=Z_(i,a));return a}(s,e,t,i),o=n.lastRow-n.firstRow+1,a=n.lastColumn-n.firstColumn+1,c={startRow:0,startColumn:0,endRow:Math.min(o,e.height)-1,endColumn:Math.min(a,e.width)-1};r=V_(r,c,t);const l=s[0].findAncestor("table"),d=this._replaceSelectedCellsWithPasted(r,e,l,n,t);if(this.editor.plugins.get("TableSelection").isEnabled){const e=i.sortRanges(d.map((e=>t.createRangeOn(e))));t.setSelection(e);}else t.setSelection(d[0],0);}))):K_(r,i);}_replaceSelectedCellsWithPasted(t,e,n,o,i){const{width:r,height:s}=e,a=function(t,e,n){const o=new Array(n).fill(null).map((()=>new Array(e).fill(null)));for(const{column:e,row:n,cell:i}of new S_(t))o[n][e]=i;return o}(t,r,s),c=[...new S_(n,{startRow:o.firstRow,endRow:o.lastRow,startColumn:o.firstColumn,endColumn:o.lastColumn,includeAllSlots:!0})],l=[];let d;for(const t of c){const{row:e,column:n}=t;n===o.firstColumn&&(d=t.getPositionBefore());const c=e-o.firstRow,h=n-o.firstColumn,u=a[c%s][h%r],g=u?i.cloneElement(u):null,m=this._replaceTableSlotCell(t,g,d,i);m&&(q_(m,e,n,o.lastRow,o.lastColumn,i),l.push(m),d=i.createPositionAfter(m));}const h=parseInt(n.getAttribute("headingRows")||0),u=parseInt(n.getAttribute("headingColumns")||0),g=o.firstRow<h&&h<=o.lastRow,m=o.firstColumn<u&&u<=o.lastColumn;if(g){const t=jA(n,h,{first:o.firstColumn,last:o.lastColumn},i,o.firstRow);l.push(...t);}if(m){const t=FA(n,u,{first:o.firstRow,last:o.lastRow},i);l.push(...t);}return l}_replaceTableSlotCell(t,e,n,o){const{cell:i,isAnchor:r}=t;return r&&o.remove(i),e?(o.insert(e,n),e):null}getTableIfOnlyTableInContent(t,e){return RA(t,e)}}function RA(t,e){if(!t.is("documentFragment")&&!t.is("element"))return null;if(t.is("element","table"))return t;if(1==t.childCount&&t.getChild(0).is("element","table"))return t.getChild(0);const n=e.createRangeIn(t);for(const t of n.getItems())if(t.is("element","table")){const o=e.createRange(n.start,e.createPositionBefore(t));if(e.hasContent(o,{ignoreWhitespaces:!0}))return null;const i=e.createRange(e.createPositionAfter(t),n.end);return e.hasContent(i,{ignoreWhitespaces:!0})?null:t}return null}function jA(t,e,n,o,i=0){if(e<1)return;return U_(t,e,i).filter((({column:t,cellWidth:e})=>VA(t,e,n))).map((({cell:t})=>H_(t,e,o)))}function FA(t,e,n,o){if(e<1)return;return W_(t,e).filter((({row:t,cellHeight:e})=>VA(t,e,n))).map((({cell:t,column:n})=>G_(t,n,e,o)))}function VA(t,e,n){const o=t+e-1,{first:i,last:r}=n;return t>=i&&t<=r||t<i&&o>=i}class UA extends Mi{static get pluginName(){return "TableKeyboard"}static get requires(){return [LA,iA]}init(){const t=this.editor.editing.view.document;this.listenTo(t,"arrowKey",((...t)=>this._onArrowKey(...t)),{context:"table"}),this.listenTo(t,"tab",((...t)=>this._handleTabOnSelectedTable(...t)),{context:"figure"}),this.listenTo(t,"tab",((...t)=>this._handleTab(...t)),{context:["th","td"]});}_handleTabOnSelectedTable(t,e){const n=this.editor,o=n.model.document.selection.getSelectedElement();o&&o.is("element","table")&&(e.preventDefault(),e.stopPropagation(),t.stop(),n.model.change((t=>{t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)));})));}_handleTab(t,e){const n=this.editor,o=this.editor.plugins.get(iA),i=n.model.document.selection,r=!e.shiftKey;let s=o.getTableCellsContainingSelection(i)[0];if(s||(s=this.editor.plugins.get("TableSelection").getFocusCell()),!s)return;e.preventDefault(),e.stopPropagation(),t.stop();const a=s.parent,c=a.parent,l=c.getChildIndex(a),d=a.getChildIndex(s),h=0===d;if(!r&&h&&0===l)return void n.model.change((t=>{t.setSelection(t.createRangeOn(c));}));const u=d===a.childCount-1,g=l===o.getRows(c)-1;if(r&&g&&u&&(n.execute("insertTableRowBelow"),l===o.getRows(c)-1))return void n.model.change((t=>{t.setSelection(t.createRangeOn(c));}));let m;if(r&&u){const t=c.getChild(l+1);m=t.getChild(0);}else if(!r&&h){const t=c.getChild(l-1);m=t.getChild(t.childCount-1);}else m=a.getChild(d+(r?1:-1));n.model.change((t=>{t.setSelection(t.createRangeIn(m));}));}_onArrowKey(t,e){const n=this.editor,o=mi(e.keyCode,n.locale.contentLanguageDirection);this._handleArrowKeys(o,e.shiftKey)&&(e.preventDefault(),e.stopPropagation(),t.stop());}_handleArrowKeys(t,e){const n=this.editor.plugins.get(iA),o=this.editor.model,i=o.document.selection,r=["right","down"].includes(t),s=n.getSelectedTableCells(i);if(s.length){let n;return n=e?this.editor.plugins.get("TableSelection").getFocusCell():r?s[s.length-1]:s[0],this._navigateFromCellInDirection(n,t,e),!0}const a=i.focus.findAncestor("tableCell");if(!a)return !1;if(!i.isCollapsed)if(e){if(i.isBackward==r&&!i.containsEntireContent(a))return !1}else {const t=i.getSelectedElement();if(!t||!o.schema.isObject(t))return !1}return !!this._isSelectionAtCellEdge(i,a,r)&&(this._navigateFromCellInDirection(a,t,e),!0)}_isSelectionAtCellEdge(t,e,n){const o=this.editor.model,i=this.editor.model.schema,r=n?t.getLastPosition():t.getFirstPosition();if(!i.getLimitElement(r).is("element","tableCell")){return o.createPositionAt(e,n?"end":0).isTouching(r)}const s=o.createSelection(r);return o.modifySelection(s,{direction:n?"forward":"backward"}),r.isEqual(s.focus)}_navigateFromCellInDirection(t,e,n=!1){const o=this.editor.model,i=t.findAncestor("table"),r=[...new S_(i,{includeAllSlots:!0})],{row:s,column:a}=r[r.length-1],c=r.find((({cell:e})=>e==t));let{row:l,column:d}=c;switch(e){case"left":d--;break;case"up":l--;break;case"right":d+=c.cellWidth;break;case"down":l+=c.cellHeight;}if(l<0||l>s||d<0&&l<=0||d>a&&l>=s)return void o.change((t=>{t.setSelection(t.createRangeOn(i));}));d<0?(d=n?0:a,l--):d>a&&(d=n?a:0,l++);const h=r.find((t=>t.row==l&&t.column==d)).cell,u=["right","down"].includes(e),g=this.editor.plugins.get("TableSelection");if(n&&g.isEnabled){const e=g.getAnchorCell()||t;g.setCellSelection(e,h);}else {const t=o.createPositionAt(h,u?0:"end");o.change((e=>{e.setSelection(t);}));}}}class HA extends ma{constructor(t){super(t),this.domEventType=["mousemove","mouseleave"];}onDomEvent(t){this.fire(t.type,t);}}class WA extends Mi{static get pluginName(){return "TableMouse"}static get requires(){return [LA,iA]}init(){this.editor.editing.view.addObserver(HA),this._enableShiftClickSelection(),this._enableMouseDragSelection();}_enableShiftClickSelection(){const t=this.editor,e=t.plugins.get(iA);let n=!1;const o=t.plugins.get(LA);this.listenTo(t.editing.view.document,"mousedown",((i,r)=>{const s=t.model.document.selection;if(!this.isEnabled||!o.isEnabled)return;if(!r.domEvent.shiftKey)return;const a=o.getAnchorCell()||e.getTableCellsContainingSelection(s)[0];if(!a)return;const c=this._getModelTableCellFromDomEvent(r);c&&GA(a,c)&&(n=!0,o.setCellSelection(a,c),r.preventDefault());})),this.listenTo(t.editing.view.document,"mouseup",(()=>{n=!1;})),this.listenTo(t.editing.view.document,"selectionChange",(t=>{n&&t.stop();}),{priority:"highest"});}_enableMouseDragSelection(){const t=this.editor;let e,n,o=!1,i=!1;const r=t.plugins.get(LA);this.listenTo(t.editing.view.document,"mousedown",((t,n)=>{this.isEnabled&&r.isEnabled&&(n.domEvent.shiftKey||n.domEvent.ctrlKey||n.domEvent.altKey||(e=this._getModelTableCellFromDomEvent(n)));})),this.listenTo(t.editing.view.document,"mousemove",((t,s)=>{if(!s.domEvent.buttons)return;if(!e)return;const a=this._getModelTableCellFromDomEvent(s);a&&GA(e,a)&&(n=a,o||n==e||(o=!0)),o&&(i=!0,r.setCellSelection(e,n),s.preventDefault());})),this.listenTo(t.editing.view.document,"mouseup",(()=>{o=!1,i=!1,e=null,n=null;})),this.listenTo(t.editing.view.document,"selectionChange",(t=>{i&&t.stop();}),{priority:"highest"});}_getModelTableCellFromDomEvent(t){const e=t.target,n=this.editor.editing.view.createPositionAt(e,0);return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell",{includeSelf:!0})}}function GA(t,e){return t.parent.parent==e.parent.parent}var qA=n(6306),YA={injectType:"singletonStyleTag",attributes:{"data-cke":!0},insert:"head",singleton:!0};Ri()(qA.Z,YA);qA.Z.locals;function $A(t){const e=t.getSelectedElement();return e&&QA(e)?e:null}function KA(t){const e=t.getFirstPosition();if(!e)return null;let n=e.parent;for(;n;){if(n.is("element")&&QA(n))return n;n=n.parent;}return null}function QA(t){return !!t.getCustomProperty("table")&&Pm(t)}const ZA={autoRefresh:!0},JA=36e5;class XA{constructor(t,e=ZA){if(!t)throw new k("token-missing-token-url",this);e.initValue&&this._validateTokenValue(e.initValue),this.set("value",e.initValue),this._refresh="function"==typeof t?t:()=>{return e=t,new Promise(((t,n)=>{const o=new XMLHttpRequest;o.open("GET",e),o.addEventListener("load",(()=>{const e=o.status,i=o.response;return e<200||e>299?n(new k("token-cannot-download-new-token",null)):t(i)})),o.addEventListener("error",(()=>n(new Error("Network Error")))),o.addEventListener("abort",(()=>n(new Error("Abort")))),o.send();}));var e;},this._options=Object.assign({},ZA,e);}init(){return new Promise(((t,e)=>{this.value?(this._options.autoRefresh&&this._registerRefreshTokenTimeout(),t(this)):this.refreshToken().then(t).catch(e);}))}refreshToken(){return this._refresh().then((t=>{this._validateTokenValue(t),this.set("value",t),this._options.autoRefresh&&this._registerRefreshTokenTimeout();})).then((()=>this))}destroy(){clearTimeout(this._tokenRefreshTimeout);}_validateTokenValue(t){const e="string"==typeof t,n=!/^".*"$/.test(t),o=e&&3===t.split(".").length;if(!n||!o)throw new k("token-not-in-jwt-format",this)}_registerRefreshTokenTimeout(){const t=this._getTokenRefreshTimeoutTime();clearTimeout(this._tokenRefreshTimeout),this._tokenRefreshTimeout=setTimeout((()=>{this.refreshToken();}),t);}_getTokenRefreshTimeoutTime(){try{const[,t]=this.value.split("."),{exp:e}=JSON.parse(atob(t));if(!e)return JA;return Math.floor((1e3*e-Date.now())/2)}catch(t){return JA}}static create(t,e=ZA){return new XA(t,e).init()}}d(XA,H);const tC=XA,eC=/^data:(\S*?);base64,/;class nC{constructor(t,e,n){if(!t)throw new k("fileuploader-missing-file",null);if(!e)throw new k("fileuploader-missing-token",null);if(!n)throw new k("fileuploader-missing-api-address",null);this.file=function(t){if("string"!=typeof t)return !1;const e=t.match(eC);return !(!e||!e.length)}(t)?function(t,e=512){try{const n=t.match(eC)[1],o=atob(t.replace(eC,"")),i=[];for(let t=0;t<o.length;t+=e){const n=o.slice(t,t+e),r=new Array(n.length);for(let t=0;t<n.length;t++)r[t]=n.charCodeAt(t);i.push(new Uint8Array(r));}return new Blob(i,{type:n})}catch(t){throw new k("fileuploader-decoding-image-data-error",null)}}(t):t,this._token=e,this._apiAddress=n;}onProgress(t){return this.on("progress",((e,n)=>t(n))),this}onError(t){return this.once("error",((e,n)=>t(n))),this}abort(){this.xhr.abort();}send(){return this._prepareRequest(),this._attachXHRListeners(),this._sendRequest()}_prepareRequest(){const t=new XMLHttpRequest;t.open("POST",this._apiAddress),t.setRequestHeader("Authorization",this._token.value),t.responseType="json",this.xhr=t;}_attachXHRListeners(){const t=this,e=this.xhr;function n(e){return ()=>t.fire("error",e)}e.addEventListener("error",n("Network Error")),e.addEventListener("abort",n("Abort")),e.upload&&e.upload.addEventListener("progress",(t=>{t.lengthComputable&&this.fire("progress",{total:t.total,uploaded:t.loaded});})),e.addEventListener("load",(()=>{const t=e.status,n=e.response;if(t<200||t>299)return this.fire("error",n.message||n.error)}));}_sendRequest(){const t=new FormData,e=this.xhr;return t.append("file",this.file),new Promise(((n,o)=>{e.addEventListener("load",(()=>{const t=e.status,i=e.response;return t<200||t>299?i.message?o(new k("fileuploader-uploading-data-failed",this,{message:i.message})):o(i.error):n(i)})),e.addEventListener("error",(()=>o(new Error("Network Error")))),e.addEventListener("abort",(()=>o(new Error("Abort")))),e.send(t);}))}}d(nC,I);class oC{constructor(t,e){if(!t)throw new k("uploadgateway-missing-token",null);if(!e)throw new k("uploadgateway-missing-api-address",null);this._token=t,this._apiAddress=e;}upload(t){return new nC(t,this._token,this._apiAddress)}}class iC extends Li{static get pluginName(){return "CloudServicesCore"}createToken(t,e){return new tC(t,e)}createUploadGateway(t,e){return new oC(t,e)}}class rC extends Ng{}rC.builtinPlugins=[class extends Mi{static get requires(){return [_p,vm,Ep,Dm,Jg,Lp]}static get pluginName(){return "Essentials"}},class extends Mi{static get requires(){return [Rp]}static get pluginName(){return "CKFinderUploadAdapter"}init(){const t=this.editor.config.get("ckfinder.uploadUrl");t&&(this.editor.plugins.get(Rp).createUploadAdapter=e=>new Gp(e,t,this.editor.t));}},class extends Mi{static get requires(){return [Zg]}static get pluginName(){return "Autoformat"}afterInit(){this._addListAutoformats(),this._addBasicStylesAutoformats(),this._addHeadingAutoformats(),this._addBlockQuoteAutoformats(),this._addCodeBlockAutoformats(),this._addHorizontalLineAutoformats();}_addListAutoformats(){const t=this.editor.commands;t.get("bulletedList")&&qp(this.editor,this,/^[*-]\s$/,"bulletedList"),t.get("numberedList")&&qp(this.editor,this,/^1[.|)]\s$/,"numberedList"),t.get("todoList")&&qp(this.editor,this,/^\[\s?\]\s$/,"todoList"),t.get("checkTodoList")&&qp(this.editor,this,/^\[\s?x\s?\]\s$/,(()=>{this.editor.execute("todoList"),this.editor.execute("checkTodoList");}));}_addBasicStylesAutoformats(){const t=this.editor.commands;if(t.get("bold")){const t=Kp(this.editor,"bold");Yp(this.editor,this,/(?:^|\s)(\*\*)([^*]+)(\*\*)$/g,t),Yp(this.editor,this,/(?:^|\s)(__)([^_]+)(__)$/g,t);}if(t.get("italic")){const t=Kp(this.editor,"italic");Yp(this.editor,this,/(?:^|\s)(\*)([^*_]+)(\*)$/g,t),Yp(this.editor,this,/(?:^|\s)(_)([^_]+)(_)$/g,t);}if(t.get("code")){const t=Kp(this.editor,"code");Yp(this.editor,this,/(`)([^`]+)(`)$/g,t);}if(t.get("strikethrough")){const t=Kp(this.editor,"strikethrough");Yp(this.editor,this,/(~~)([^~]+)(~~)$/g,t);}}_addHeadingAutoformats(){const t=this.editor.commands.get("heading");t&&t.modelElements.filter((t=>t.match(/^heading[1-6]$/))).forEach((e=>{const n=e[7],o=new RegExp(`^(#{${n}})\\s$`);qp(this.editor,this,o,(()=>{if(!t.isEnabled||t.value===e)return !1;this.editor.execute("heading",{value:e});}));}));}_addBlockQuoteAutoformats(){this.editor.commands.get("blockQuote")&&qp(this.editor,this,/^>\s$/,"blockQuote");}_addCodeBlockAutoformats(){const t=this.editor,e=t.model.document.selection;t.commands.get("codeBlock")&&qp(t,this,/^```$/,(()=>{if(e.getFirstPosition().parent.is("element","listItem"))return !1;this.editor.execute("codeBlock",{usePreviousLanguageChoice:!0});}));}_addHorizontalLineAutoformats(){this.editor.commands.get("horizontalLine")&&qp(this.editor,this,/^---$/,"horizontalLine");}},class extends Mi{static get requires(){return [Jp,tf]}static get pluginName(){return "Bold"}},class extends Mi{static get requires(){return [nf,rf]}static get pluginName(){return "Italic"}},class extends Mi{static get requires(){return [df,gf]}static get pluginName(){return "BlockQuote"}},class extends Mi{static get pluginName(){return "CKBox"}static get requires(){return [xf,mf]}},class extends Mi{static get pluginName(){return "CKFinder"}static get requires(){return ["Link","CKFinderUploadAdapter",Nf,Mf]}},class extends Li{static get pluginName(){return "CloudServices"}static get requires(){return [iC]}init(){const t=this.context.config.get("cloudServices")||{};for(const e in t)this[e]=t[e];if(this._tokens=new Map,this.tokenUrl)return this.token=this.context.plugins.get("CloudServicesCore").createToken(this.tokenUrl),this._tokens.set(this.tokenUrl,this.token),this.token.init();this.token=null;}registerTokenUrl(t){if(this._tokens.has(t))return Promise.resolve(this.getTokenFor(t));const e=this.context.plugins.get("CloudServicesCore").createToken(t);return this._tokens.set(t,e),e.init()}getTokenFor(t){const e=this._tokens.get(t);if(!e)throw new k("cloudservices-token-not-registered",this);return e}destroy(){super.destroy();for(const t of this._tokens.values())t.destroy();}},class extends Mi{static get requires(){return [Bf,"ImageUpload"]}init(){const t=this.editor;t.plugins.has("ImageBlockEditing")||t.plugins.has("ImageInlineEditing")||b("easy-image-image-feature-missing",t);}static get pluginName(){return "EasyImage"}},class extends Mi{static get requires(){return [Uf,Gf]}static get pluginName(){return "Heading"}},class extends Mi{static get requires(){return [fk,bk]}static get pluginName(){return "Image"}},class extends Mi{static get requires(){return [Ak,Ck]}static get pluginName(){return "ImageCaption"}},class extends Mi{static get requires(){return [jk,Uk]}static get pluginName(){return "ImageStyle"}},class extends Mi{static get requires(){return [ip,Qf]}static get pluginName(){return "ImageToolbar"}afterInit(){const t=this.editor,e=t.t,n=t.plugins.get(ip),o=t.plugins.get("ImageUtils");var i;n.register("image",{ariaLabel:e("Image toolbar"),items:(i=t.config.get("image.toolbar")||[],i.map((t=>L(t)?t.name:t))),getRelatedElement:t=>o.getClosestSelectedImageWidget(t)});}},class extends Mi{static get pluginName(){return "ImageUpload"}static get requires(){return [lb,Kk,nb]}},class extends Mi{static get pluginName(){return "Indent"}static get requires(){return [hb,mb]}},class extends Mi{static get requires(){return [Xb,dw,gw]}static get pluginName(){return "Link"}},class extends Mi{static get requires(){return [Hw,Gw]}static get pluginName(){return "List"}},class extends Mi{static get requires(){return [e_,a_,o_,np]}static get pluginName(){return "MediaEmbed"}},Rf,class extends Mi{static get pluginName(){return "PasteFromOffice"}static get requires(){return [Og]}init(){const t=this.editor,e=t.editing.view.document,n=[];n.push(new C_(e)),n.push(new k_(e)),t.plugins.get("ClipboardPipeline").on("inputTransformation",((o,i)=>{if(i._isTransformedWithPasteFromOffice)return;if(t.model.document.selection.getFirstPosition().parent.is("element","codeBlock"))return;const r=i.dataTransfer.getData("text/html"),s=n.find((t=>t.isActive(r)));s&&(i._parsedData=y_(r,e.stylesProcessor),s.execute(i),i._isTransformedWithPasteFromOffice=!0);}),{priority:"high"});}},class extends Mi{static get requires(){return [hk,Qf]}static get pluginName(){return "PictureEditing"}afterInit(){const t=this.editor;t.plugins.has("ImageBlockEditing")&&t.model.schema.extend("imageBlock",{allowAttributes:["sources"]}),t.plugins.has("ImageInlineEditing")&&t.model.schema.extend("imageInline",{allowAttributes:["sources"]}),this._setupConversion(),this._setupImageUploadEditingIntegration();}_setupConversion(){const t=this.editor,e=t.conversion,n=t.plugins.get("ImageUtils");e.for("upcast").add(function(t){const e=["srcset","media","type","sizes"];return t=>{t.on("element:picture",n);};function n(n,o,i){const r=o.viewItem;if(!i.consumable.test(r,{name:!0}))return;const s=new Map;for(const t of r.getChildren())if(t.is("element","source")){const n={};for(const o of e)t.hasAttribute(o)&&i.consumable.test(t,{attributes:o})&&(n[o]=t.getAttribute(o));Object.keys(n).length&&s.set(t,n);}const a=t.findViewImgElement(r);if(!a)return;let c=o.modelCursor.parent;if(!c.is("element","imageBlock")){const t=i.convertItem(a,o.modelCursor);o.modelRange=t.modelRange,o.modelCursor=t.modelCursor,c=Ai(t.modelRange.getItems());}i.consumable.consume(r,{name:!0});for(const[t,e]of s)i.consumable.consume(t,{attributes:Object.keys(e)});s.size&&i.writer.setAttribute("sources",Array.from(s.values()),c),i.convertChildren(r,c);}}(n)),e.for("downcast").add(function(t){return t=>{t.on("attribute:sources:imageBlock",e),t.on("attribute:sources:imageInline",e);};function e(e,n,o){if(!o.consumable.consume(n.item,e.name))return;const i=o.writer,r=o.mapper.toViewElement(n.item),s=t.findViewImgElement(r);if(n.attributeNewValue&&n.attributeNewValue.length){const t=i.createContainerElement("picture",null,n.attributeNewValue.map((t=>i.createEmptyElement("source",t)))),e=[];let o=s.parent;for(;o&&o.is("attributeElement");){const t=o.parent;i.unwrap(i.createRangeOn(s),o),e.unshift(o),o=t;}i.insert(i.createPositionBefore(s),t),i.move(i.createRangeOn(s),i.createPositionAt(t,"end"));for(const n of e)i.wrap(i.createRangeOn(t),n);}else if(s.parent.is("element","picture")){const t=s.parent;i.move(i.createRangeOn(s),i.createPositionBefore(t)),i.remove(t);}}}(n));}_setupImageUploadEditingIntegration(){const t=this.editor;t.plugins.has("ImageUploadEditing")&&this.listenTo(t.plugins.get("ImageUploadEditing"),"uploadComplete",((e,{imageElement:n,data:o})=>{const i=o.sources;i&&t.model.change((t=>{t.setAttributes({sources:i},n);}));}));}},class extends Mi{static get requires(){return [DA,NA,LA,WA,UA,OA,np]}static get pluginName(){return "Table"}},class extends Mi{static get requires(){return [ip]}static get pluginName(){return "TableToolbar"}afterInit(){const t=this.editor,e=t.t,n=t.plugins.get(ip),o=t.config.get("table.contentToolbar"),i=t.config.get("table.tableToolbar");o&&n.register("tableContent",{ariaLabel:e("Table toolbar"),items:o,getRelatedElement:KA}),i&&n.register("table",{ariaLabel:e("Table toolbar"),items:i,getRelatedElement:$A});}},class extends Mi{static get requires(){return ["Delete","Input"]}static get pluginName(){return "TextTransformation"}constructor(t){super(t),t.config.define("typing",{transformations:{include:hm}});}init(){const t=this.editor.model.document.selection;t.on("change:range",(()=>{this.isEnabled=!t.anchor.parent.is("element","codeBlock");})),this._enableTransformationWatchers();}_enableTransformationWatchers(){const t=this.editor,e=t.model,n=t.plugins.get("Delete"),o=function(t){const e=t.extra||[],n=t.remove||[],o=t=>!n.includes(t);return function(t){const e=new Set;for(const n of t)if("string"==typeof n&&dm[n])for(const t of dm[n])e.add(t);else e.add(n);return Array.from(e)}(t.include.concat(e).filter(o)).filter(o).map((t=>"string"==typeof t&&lm[t]?lm[t]:t)).filter((t=>"object"==typeof t)).map((t=>({from:um(t.from),to:gm(t.to)})))}(t.config.get("typing.transformations")),i=new tm(t.model,(t=>{for(const e of o){if(e.from.test(t))return {normalizedTransformation:e}}}));i.on("matched:data",((t,o)=>{if(!o.batch.isTyping)return;const{from:i,to:r}=o.normalizedTransformation,s=i.exec(o.text),a=r(s.slice(1)),c=o.range;let l=s.index;e.enqueueChange((t=>{for(let n=1;n<s.length;n++){const o=s[n],i=a[n-1];if(null==i){l+=o.length;continue}const r=c.start.getShiftedBy(l),d=e.createRange(r,r.getShiftedBy(o.length)),h=mm(r);e.insertContent(t.createText(i,h),d),l+=i.length;}e.enqueueChange((()=>{n.requestUndoOnBackspace();}));}));})),i.bind("isEnabled").to(this);}}],rC.defaultConfig={toolbar:{items:["heading","|","bold","italic","link","bulletedList","numberedList","|","outdent","indent","|","uploadImage","blockQuote","insertTable","mediaEmbed","undo","redo"]},image:{toolbar:["imageStyle:inline","imageStyle:block","imageStyle:side","|","toggleImageCaption","imageTextAlternative"]},table:{contentToolbar:["tableColumn","tableRow","mergeTableCells"]},language:"en"};})(),o=o.default})()));

    });

    var BalloonEditor = /*@__PURE__*/getDefaultExportFromCjs(ckeditor);

    /* src\apps\Mdw\components\MdwCard.svelte generated by Svelte v3.59.2 */

    const file$C = "src\\apps\\Mdw\\components\\MdwCard.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    function get_each_context_1$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (10:20) {#each Texts as Value}
    function create_each_block_1$b(ctx) {
    	let p;
    	let t_value = /*Value*/ ctx[6] + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "svelte-17qhg7n");
    			add_location(p, file$C, 10, 24, 383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Information*/ 1 && t_value !== (t_value = /*Value*/ ctx[6] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$b.name,
    		type: "each",
    		source: "(10:20) {#each Texts as Value}",
    		ctx
    	});

    	return block;
    }

    // (8:12) {#each Information as Texts, Key}
    function create_each_block$l(ctx) {
    	let div;
    	let t;
    	let each_value_1 = /*Texts*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div, "class", "mdw-card-row svelte-17qhg7n");
    			add_location(div, file$C, 8, 16, 287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Information*/ 1) {
    				each_value_1 = /*Texts*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$b(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(8:12) {#each Information as Texts, Key}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let mounted;
    	let dispose;
    	let each_value = /*Information*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div0, "width", "100%");
    			set_style(div0, "height", "100%");
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "column");
    			add_location(div0, file$C, 6, 8, 143);
    			attr_dev(div1, "class", "mdw-card svelte-17qhg7n");
    			add_location(div1, file$C, 5, 4, 111);
    			attr_dev(div2, "class", "mdw-card-wrapper svelte-17qhg7n");
    			add_location(div2, file$C, 4, 0, 57);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(div2, "keyup", /*keyup_handler*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Information*/ 1) {
    				each_value = /*Information*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwCard', slots, []);
    	let { Information = [] } = $$props;
    	const writable_props = ['Information'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwCard> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('Information' in $$props) $$invalidate(0, Information = $$props.Information);
    	};

    	$$self.$capture_state = () => ({ Information });

    	$$self.$inject_state = $$props => {
    		if ('Information' in $$props) $$invalidate(0, Information = $$props.Information);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [Information, click_handler, keyup_handler];
    }

    class MdwCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$D, create_fragment$D, safe_not_equal, { Information: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwCard",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get Information() {
    		throw new Error("<MdwCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Information(value) {
    		throw new Error("<MdwCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\components\MdwChip.svelte generated by Svelte v3.59.2 */

    const file$B = "src\\apps\\Mdw\\components\\MdwChip.svelte";

    // (42:0) {:else}
    function create_else_block$c(ctx) {
    	let div;
    	let t0;
    	let span1;
    	let span0;
    	let t1;
    	let t2;
    	let if_block0 = /*PrefixIcon*/ ctx[1] && create_if_block_3$b(ctx);
    	let if_block1 = /*SuffixIcon*/ ctx[2] && create_if_block_2$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			span1 = element("span");
    			span0 = element("span");
    			t1 = text(/*Text*/ ctx[0]);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			set_style(span0, "margin", "0px");
    			set_style(span0, "white-space", "nowrap");
    			add_location(span0, file$B, 49, 12, 1757);
    			attr_dev(span1, "class", "chip-cell");
    			set_style(span1, "margin", "0px");
    			add_location(span1, file$B, 48, 8, 1698);
    			attr_dev(div, "class", "chip-container svelte-aofty2");
    			set_style(div, "background-color", /*Color*/ ctx[3] || "#ffffff");
    			set_style(div, "color", /*GetTextColor*/ ctx[4]());
    			add_location(div, file$B, 42, 4, 1386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, span1);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*PrefixIcon*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$b(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*Text*/ 1) set_data_dev(t1, /*Text*/ ctx[0]);

    			if (/*SuffixIcon*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$d(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*Color*/ 8) {
    				set_style(div, "background-color", /*Color*/ ctx[3] || "#ffffff");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(42:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (31:0) {#if !SuffixIcon}
    function create_if_block$s(ctx) {
    	let div;
    	let t0;
    	let span1;
    	let span0;
    	let t1;
    	let mounted;
    	let dispose;
    	let if_block = /*PrefixIcon*/ ctx[1] && create_if_block_1$g(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			span1 = element("span");
    			span0 = element("span");
    			t1 = text(/*Text*/ ctx[0]);
    			set_style(span0, "margin", "0px");
    			set_style(span0, "white-space", "nowrap");
    			add_location(span0, file$B, 38, 12, 1281);
    			attr_dev(span1, "class", "chip-cell");
    			set_style(span1, "margin", "0px");
    			add_location(span1, file$B, 37, 8, 1222);
    			attr_dev(div, "class", "chip-container svelte-aofty2");
    			set_style(div, "background-color", /*Color*/ ctx[3] || "#ffffff");
    			set_style(div, "color", /*GetTextColor*/ ctx[4]());
    			add_location(div, file$B, 31, 4, 892);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, span1);
    			append_dev(span1, span0);
    			append_dev(span0, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler*/ ctx[5], false, false, false, false),
    					listen_dev(div, "click", /*click_handler*/ ctx[6], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*PrefixIcon*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$g(ctx);
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*Text*/ 1) set_data_dev(t1, /*Text*/ ctx[0]);

    			if (dirty & /*Color*/ 8) {
    				set_style(div, "background-color", /*Color*/ ctx[3] || "#ffffff");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(31:0) {#if !SuffixIcon}",
    		ctx
    	});

    	return block;
    }

    // (44:8) {#if PrefixIcon}
    function create_if_block_3$b(ctx) {
    	let span;
    	let i;
    	let i_class_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "fas fa-" + /*PrefixIcon*/ ctx[1] + " svelte-aofty2");
    			set_style(i, "margin-left", "0px");
    			set_style(i, "margin-right", "0.37vh");
    			add_location(i, file$B, 45, 16, 1569);
    			attr_dev(span, "class", "chip-cell");
    			add_location(span, file$B, 44, 12, 1527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*PrefixIcon*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*PrefixIcon*/ ctx[1] + " svelte-aofty2")) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$b.name,
    		type: "if",
    		source: "(44:8) {#if PrefixIcon}",
    		ctx
    	});

    	return block;
    }

    // (52:8) {#if SuffixIcon}
    function create_if_block_2$d(ctx) {
    	let span;
    	let i;
    	let i_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "fas fa-" + /*SuffixIcon*/ ctx[2] + " svelte-aofty2");
    			add_location(i, file$B, 53, 16, 1935);
    			attr_dev(span, "class", "chip-cell");
    			add_location(span, file$B, 52, 12, 1875);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "keyup", /*keyup_handler_1*/ ctx[7], false, false, false, false),
    					listen_dev(span, "click", /*click_handler_1*/ ctx[8], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*SuffixIcon*/ 4 && i_class_value !== (i_class_value = "fas fa-" + /*SuffixIcon*/ ctx[2] + " svelte-aofty2")) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(52:8) {#if SuffixIcon}",
    		ctx
    	});

    	return block;
    }

    // (33:8) {#if PrefixIcon}
    function create_if_block_1$g(ctx) {
    	let span;
    	let i;
    	let i_class_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "fas fa-" + /*PrefixIcon*/ ctx[1] + " svelte-aofty2");
    			set_style(i, "margin-left", "0px");
    			set_style(i, "margin-right", "0.37vh");
    			add_location(i, file$B, 34, 16, 1093);
    			attr_dev(span, "class", "chip-cell");
    			add_location(span, file$B, 33, 12, 1051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*PrefixIcon*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*PrefixIcon*/ ctx[1] + " svelte-aofty2")) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(33:8) {#if PrefixIcon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*SuffixIcon*/ ctx[2]) return create_if_block$s;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwChip', slots, []);
    	let { Text = '' } = $$props;
    	let { PrefixIcon = false } = $$props;
    	let { SuffixIcon = false } = $$props;
    	let { Color = '#ffffff' } = $$props;

    	const HexToRgb = Hex => {
    		var ShorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

    		Hex = Hex.replace(ShorthandRegex, function (m, r, g, b) {
    			return r + r + g + g + b + b;
    		});

    		var Result = (/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i).exec(Hex);

    		return Result
    		? [parseInt(Result[1], 16), parseInt(Result[2], 16), parseInt(Result[3], 16)]
    		: [255, 255, 255];
    	};

    	const GetTextColor = () => {
    		let [R, G, B] = HexToRgb(Color);

    		if (R * 0.299 + G * 0.587 + B * 0.114 > 150) {
    			return "#000000";
    		} else {
    			return "#FFFFFF";
    		}
    	};

    	const writable_props = ['Text', 'PrefixIcon', 'SuffixIcon', 'Color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwChip> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('Text' in $$props) $$invalidate(0, Text = $$props.Text);
    		if ('PrefixIcon' in $$props) $$invalidate(1, PrefixIcon = $$props.PrefixIcon);
    		if ('SuffixIcon' in $$props) $$invalidate(2, SuffixIcon = $$props.SuffixIcon);
    		if ('Color' in $$props) $$invalidate(3, Color = $$props.Color);
    	};

    	$$self.$capture_state = () => ({
    		Text,
    		PrefixIcon,
    		SuffixIcon,
    		Color,
    		HexToRgb,
    		GetTextColor
    	});

    	$$self.$inject_state = $$props => {
    		if ('Text' in $$props) $$invalidate(0, Text = $$props.Text);
    		if ('PrefixIcon' in $$props) $$invalidate(1, PrefixIcon = $$props.PrefixIcon);
    		if ('SuffixIcon' in $$props) $$invalidate(2, SuffixIcon = $$props.SuffixIcon);
    		if ('Color' in $$props) $$invalidate(3, Color = $$props.Color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Text,
    		PrefixIcon,
    		SuffixIcon,
    		Color,
    		GetTextColor,
    		keyup_handler,
    		click_handler,
    		keyup_handler_1,
    		click_handler_1
    	];
    }

    class MdwChip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			Text: 0,
    			PrefixIcon: 1,
    			SuffixIcon: 2,
    			Color: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwChip",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get Text() {
    		throw new Error("<MdwChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Text(value) {
    		throw new Error("<MdwChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get PrefixIcon() {
    		throw new Error("<MdwChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set PrefixIcon(value) {
    		throw new Error("<MdwChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get SuffixIcon() {
    		throw new Error("<MdwChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set SuffixIcon(value) {
    		throw new Error("<MdwChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Color() {
    		throw new Error("<MdwChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Color(value) {
    		throw new Error("<MdwChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to
     * detect CSS custom variable support.
     */
    var supportsCssVariables_;
    function supportsCssVariables(windowObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        var CSS = windowObj.CSS;
        var supportsCssVars = supportsCssVariables_;
        if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
            return supportsCssVariables_;
        }
        var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
        if (!supportsFunctionPresent) {
            return false;
        }
        var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
        // See: https://bugs.webkit.org/show_bug.cgi?id=154669
        // See: README section on Safari
        var weAreFeatureDetectingSafari10plus = (CSS.supports('(--css-vars: yes)') &&
            CSS.supports('color', '#00000000'));
        supportsCssVars =
            explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
        if (!forceRefresh) {
            supportsCssVariables_ = supportsCssVars;
        }
        return supportsCssVars;
    }
    function getNormalizedEventCoords(evt, pageOffset, clientRect) {
        if (!evt) {
            return { x: 0, y: 0 };
        }
        var x = pageOffset.x, y = pageOffset.y;
        var documentX = x + clientRect.left;
        var documentY = y + clientRect.top;
        var normalizedX;
        var normalizedY;
        // Determine touch point relative to the ripple container.
        if (evt.type === 'touchstart') {
            var touchEvent = evt;
            normalizedX = touchEvent.changedTouches[0].pageX - documentX;
            normalizedY = touchEvent.changedTouches[0].pageY - documentY;
        }
        else {
            var mouseEvent = evt;
            normalizedX = mouseEvent.pageX - documentX;
            normalizedY = mouseEvent.pageY - documentY;
        }
        return { x: normalizedX, y: normalizedY };
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
    };

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFoundation = /** @class */ (function () {
        function MDCFoundation(adapter) {
            if (adapter === void 0) { adapter = {}; }
            this.adapter = adapter;
        }
        Object.defineProperty(MDCFoundation, "cssClasses", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports every
                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "strings", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "numbers", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "defaultAdapter", {
            get: function () {
                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
                // validation.
                return {};
            },
            enumerable: false,
            configurable: true
        });
        MDCFoundation.prototype.init = function () {
            // Subclasses should override this method to perform initialization routines (registering events, etc.)
        };
        MDCFoundation.prototype.destroy = function () {
            // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        };
        return MDCFoundation;
    }());

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Determine whether the current browser supports passive event listeners, and
     * if so, use them.
     */
    function applyPassive$1(globalObj) {
        if (globalObj === void 0) { globalObj = window; }
        return supportsPassiveOption(globalObj) ?
            { passive: true } :
            false;
    }
    function supportsPassiveOption(globalObj) {
        if (globalObj === void 0) { globalObj = window; }
        // See
        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
        var passiveSupported = false;
        try {
            var options = {
                // This function will be called when the browser
                // attempts to access the passive property.
                get passive() {
                    passiveSupported = true;
                    return false;
                }
            };
            var handler = function () { };
            globalObj.document.addEventListener('test', handler, options);
            globalObj.document.removeEventListener('test', handler, options);
        }
        catch (err) {
            passiveSupported = false;
        }
        return passiveSupported;
    }

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        applyPassive: applyPassive$1
    });

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */
    function closest(element, selector) {
        if (element.closest) {
            return element.closest(selector);
        }
        var el = element;
        while (el) {
            if (matches$1(el, selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    function matches$1(element, selector) {
        var nativeMatches = element.matches
            || element.webkitMatchesSelector
            || element.msMatchesSelector;
        return nativeMatches.call(element, selector);
    }
    /**
     * Used to compute the estimated scroll width of elements. When an element is
     * hidden due to display: none; being applied to a parent element, the width is
     * returned as 0. However, the element will have a true width once no longer
     * inside a display: none context. This method computes an estimated width when
     * the element is hidden or returns the true width when the element is visble.
     * @param {Element} element the element whose width to estimate
     */
    function estimateScrollWidth(element) {
        // Check the offsetParent. If the element inherits display: none from any
        // parent, the offsetParent property will be null (see
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
        // This check ensures we only clone the node when necessary.
        var htmlEl = element;
        if (htmlEl.offsetParent !== null) {
            return htmlEl.scrollWidth;
        }
        var clone = htmlEl.cloneNode(true);
        clone.style.setProperty('position', 'absolute');
        clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
        document.documentElement.appendChild(clone);
        var scrollWidth = clone.scrollWidth;
        document.documentElement.removeChild(clone);
        return scrollWidth;
    }

    var ponyfill = /*#__PURE__*/Object.freeze({
        __proto__: null,
        closest: closest,
        matches: matches$1,
        estimateScrollWidth: estimateScrollWidth
    });

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses = {
        // Ripple is a special case where the "root" component is really a "mixin" of sorts,
        // given that it's an 'upgrade' to an existing component. That being said it is the root
        // CSS class that all other CSS classes derive from.
        BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
        FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
        FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
        ROOT: 'mdc-ripple-upgraded',
        UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    };
    var strings = {
        VAR_FG_SCALE: '--mdc-ripple-fg-scale',
        VAR_FG_SIZE: '--mdc-ripple-fg-size',
        VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
        VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
        VAR_LEFT: '--mdc-ripple-left',
        VAR_TOP: '--mdc-ripple-top',
    };
    var numbers = {
        DEACTIVATION_TIMEOUT_MS: 225,
        FG_DEACTIVATION_MS: 150,
        INITIAL_ORIGIN_SCALE: 0.6,
        PADDING: 10,
        TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = [
        'touchstart', 'pointerdown', 'mousedown', 'keydown',
    ];
    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = [
        'touchend', 'pointerup', 'mouseup', 'contextmenu',
    ];
    // simultaneous nested activations
    var activatedTargets = [];
    var MDCRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCRippleFoundation, _super);
        function MDCRippleFoundation(adapter) {
            var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;
            _this.activationAnimationHasEnded = false;
            _this.activationTimer = 0;
            _this.fgDeactivationRemovalTimer = 0;
            _this.fgScale = '0';
            _this.frame = { width: 0, height: 0 };
            _this.initialSize = 0;
            _this.layoutFrame = 0;
            _this.maxRadius = 0;
            _this.unboundedCoords = { left: 0, top: 0 };
            _this.activationState = _this.defaultActivationState();
            _this.activationTimerCallback = function () {
                _this.activationAnimationHasEnded = true;
                _this.runDeactivationUXLogicIfReady();
            };
            _this.activateHandler = function (e) {
                _this.activateImpl(e);
            };
            _this.deactivateHandler = function () {
                _this.deactivateImpl();
            };
            _this.focusHandler = function () {
                _this.handleFocus();
            };
            _this.blurHandler = function () {
                _this.handleBlur();
            };
            _this.resizeHandler = function () {
                _this.layout();
            };
            return _this;
        }
        Object.defineProperty(MDCRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "strings", {
            get: function () {
                return strings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "numbers", {
            get: function () {
                return numbers;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    browserSupportsCssVars: function () { return true; },
                    computeBoundingRect: function () {
                        return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });
                    },
                    containsEventTarget: function () { return true; },
                    deregisterDocumentInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    deregisterResizeHandler: function () { return undefined; },
                    getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },
                    isSurfaceActive: function () { return true; },
                    isSurfaceDisabled: function () { return true; },
                    isUnbounded: function () { return true; },
                    registerDocumentInteractionHandler: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    registerResizeHandler: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    updateCssVariable: function () { return undefined; },
                };
            },
            enumerable: false,
            configurable: true
        });
        MDCRippleFoundation.prototype.init = function () {
            var _this = this;
            var supportsPressRipple = this.supportsPressRipple();
            this.registerRootHandlers(supportsPressRipple);
            if (supportsPressRipple) {
                var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter.addClass(ROOT_1);
                    if (_this.adapter.isUnbounded()) {
                        _this.adapter.addClass(UNBOUNDED_1);
                        // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                        _this.layoutInternal();
                    }
                });
            }
        };
        MDCRippleFoundation.prototype.destroy = function () {
            var _this = this;
            if (this.supportsPressRipple()) {
                if (this.activationTimer) {
                    clearTimeout(this.activationTimer);
                    this.activationTimer = 0;
                    this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
                }
                if (this.fgDeactivationRemovalTimer) {
                    clearTimeout(this.fgDeactivationRemovalTimer);
                    this.fgDeactivationRemovalTimer = 0;
                    this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
                }
                var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter.removeClass(ROOT_2);
                    _this.adapter.removeClass(UNBOUNDED_2);
                    _this.removeCssVars();
                });
            }
            this.deregisterRootHandlers();
            this.deregisterDeactivationHandlers();
        };
        /**
         * @param evt Optional event containing position information.
         */
        MDCRippleFoundation.prototype.activate = function (evt) {
            this.activateImpl(evt);
        };
        MDCRippleFoundation.prototype.deactivate = function () {
            this.deactivateImpl();
        };
        MDCRippleFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame) {
                cancelAnimationFrame(this.layoutFrame);
            }
            this.layoutFrame = requestAnimationFrame(function () {
                _this.layoutInternal();
                _this.layoutFrame = 0;
            });
        };
        MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
            var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
            if (unbounded) {
                this.adapter.addClass(UNBOUNDED);
            }
            else {
                this.adapter.removeClass(UNBOUNDED);
            }
        };
        MDCRippleFoundation.prototype.handleFocus = function () {
            var _this = this;
            requestAnimationFrame(function () { return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });
        };
        MDCRippleFoundation.prototype.handleBlur = function () {
            var _this = this;
            requestAnimationFrame(function () { return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });
        };
        /**
         * We compute this property so that we are not querying information about the client
         * until the point in time where the foundation requests it. This prevents scenarios where
         * client-side feature-detection may happen too early, such as when components are rendered on the server
         * and then initialized at mount time on the client.
         */
        MDCRippleFoundation.prototype.supportsPressRipple = function () {
            return this.adapter.browserSupportsCssVars();
        };
        MDCRippleFoundation.prototype.defaultActivationState = function () {
            return {
                activationEvent: undefined,
                hasDeactivationUXRun: false,
                isActivated: false,
                isProgrammatic: false,
                wasActivatedByPointer: false,
                wasElementMadeActive: false,
            };
        };
        /**
         * supportsPressRipple Passed from init to save a redundant function call
         */
        MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {
            var e_1, _a;
            if (supportsPressRipple) {
                try {
                    for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
                        var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
                        this.adapter.registerInteractionHandler(evtType, this.activateHandler);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (this.adapter.isUnbounded()) {
                    this.adapter.registerResizeHandler(this.resizeHandler);
                }
            }
            this.adapter.registerInteractionHandler('focus', this.focusHandler);
            this.adapter.registerInteractionHandler('blur', this.blurHandler);
        };
        MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {
            var e_2, _a;
            if (evt.type === 'keydown') {
                this.adapter.registerInteractionHandler('keyup', this.deactivateHandler);
            }
            else {
                try {
                    for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
                        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
                        this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        MDCRippleFoundation.prototype.deregisterRootHandlers = function () {
            var e_3, _a;
            try {
                for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
                    var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
                    this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.adapter.deregisterInteractionHandler('focus', this.focusHandler);
            this.adapter.deregisterInteractionHandler('blur', this.blurHandler);
            if (this.adapter.isUnbounded()) {
                this.adapter.deregisterResizeHandler(this.resizeHandler);
            }
        };
        MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {
            var e_4, _a;
            this.adapter.deregisterInteractionHandler('keyup', this.deactivateHandler);
            try {
                for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
                    var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
                    this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        MDCRippleFoundation.prototype.removeCssVars = function () {
            var _this = this;
            var rippleStrings = MDCRippleFoundation.strings;
            var keys = Object.keys(rippleStrings);
            keys.forEach(function (key) {
                if (key.indexOf('VAR_') === 0) {
                    _this.adapter.updateCssVariable(rippleStrings[key], null);
                }
            });
        };
        MDCRippleFoundation.prototype.activateImpl = function (evt) {
            var _this = this;
            if (this.adapter.isSurfaceDisabled()) {
                return;
            }
            var activationState = this.activationState;
            if (activationState.isActivated) {
                return;
            }
            // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
            var previousActivationEvent = this.previousActivationEvent;
            var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
            if (isSameInteraction) {
                return;
            }
            activationState.isActivated = true;
            activationState.isProgrammatic = evt === undefined;
            activationState.activationEvent = evt;
            activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
            var hasActivatedChild = evt !== undefined &&
                activatedTargets.length > 0 &&
                activatedTargets.some(function (target) { return _this.adapter.containsEventTarget(target); });
            if (hasActivatedChild) {
                // Immediately reset activation state, while preserving logic that prevents touch follow-on events
                this.resetActivationState();
                return;
            }
            if (evt !== undefined) {
                activatedTargets.push(evt.target);
                this.registerDeactivationHandlers(evt);
            }
            activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
            if (activationState.wasElementMadeActive) {
                this.animateActivation();
            }
            requestAnimationFrame(function () {
                // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
                activatedTargets = [];
                if (!activationState.wasElementMadeActive
                    && evt !== undefined
                    && (evt.key === ' ' || evt.keyCode === 32)) {
                    // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                    // active states inconsistently when they're called within event handling code:
                    // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                    // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                    // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                    // variable is set within a rAF callback for a submit button interaction (#2241).
                    activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
                    if (activationState.wasElementMadeActive) {
                        _this.animateActivation();
                    }
                }
                if (!activationState.wasElementMadeActive) {
                    // Reset activation state immediately if element was not made active.
                    _this.activationState = _this.defaultActivationState();
                }
            });
        };
        MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {
            return (evt !== undefined && evt.type === 'keydown') ?
                this.adapter.isSurfaceActive() :
                true;
        };
        MDCRippleFoundation.prototype.animateActivation = function () {
            var _this = this;
            var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
            var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
            var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
            this.layoutInternal();
            var translateStart = '';
            var translateEnd = '';
            if (!this.adapter.isUnbounded()) {
                var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
                translateStart = startPoint.x + "px, " + startPoint.y + "px";
                translateEnd = endPoint.x + "px, " + endPoint.y + "px";
            }
            this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
            this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
            // Cancel any ongoing activation/deactivation animations
            clearTimeout(this.activationTimer);
            clearTimeout(this.fgDeactivationRemovalTimer);
            this.rmBoundedActivationClasses();
            this.adapter.removeClass(FG_DEACTIVATION);
            // Force layout in order to re-trigger the animation.
            this.adapter.computeBoundingRect();
            this.adapter.addClass(FG_ACTIVATION);
            this.activationTimer = setTimeout(function () {
                _this.activationTimerCallback();
            }, DEACTIVATION_TIMEOUT_MS);
        };
        MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {
            var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
            var startPoint;
            if (wasActivatedByPointer) {
                startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
            }
            else {
                startPoint = {
                    x: this.frame.width / 2,
                    y: this.frame.height / 2,
                };
            }
            // Center the element around the start point.
            startPoint = {
                x: startPoint.x - (this.initialSize / 2),
                y: startPoint.y - (this.initialSize / 2),
            };
            var endPoint = {
                x: (this.frame.width / 2) - (this.initialSize / 2),
                y: (this.frame.height / 2) - (this.initialSize / 2),
            };
            return { startPoint: startPoint, endPoint: endPoint };
        };
        MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {
            var _this = this;
            // This method is called both when a pointing device is released, and when the activation animation ends.
            // The deactivation animation should only run after both of those occur.
            var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
            var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
            var activationHasEnded = hasDeactivationUXRun || !isActivated;
            if (activationHasEnded && this.activationAnimationHasEnded) {
                this.rmBoundedActivationClasses();
                this.adapter.addClass(FG_DEACTIVATION);
                this.fgDeactivationRemovalTimer = setTimeout(function () {
                    _this.adapter.removeClass(FG_DEACTIVATION);
                }, numbers.FG_DEACTIVATION_MS);
            }
        };
        MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter.removeClass(FG_ACTIVATION);
            this.activationAnimationHasEnded = false;
            this.adapter.computeBoundingRect();
        };
        MDCRippleFoundation.prototype.resetActivationState = function () {
            var _this = this;
            this.previousActivationEvent = this.activationState.activationEvent;
            this.activationState = this.defaultActivationState();
            // Touch devices may fire additional events for the same interaction within a short time.
            // Store the previous event until it's safe to assume that subsequent events are for new interactions.
            setTimeout(function () { return _this.previousActivationEvent = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        };
        MDCRippleFoundation.prototype.deactivateImpl = function () {
            var _this = this;
            var activationState = this.activationState;
            // This can happen in scenarios such as when you have a keyup event that blurs the element.
            if (!activationState.isActivated) {
                return;
            }
            var state = __assign({}, activationState);
            if (activationState.isProgrammatic) {
                requestAnimationFrame(function () {
                    _this.animateDeactivation(state);
                });
                this.resetActivationState();
            }
            else {
                this.deregisterDeactivationHandlers();
                requestAnimationFrame(function () {
                    _this.activationState.hasDeactivationUXRun = true;
                    _this.animateDeactivation(state);
                    _this.resetActivationState();
                });
            }
        };
        MDCRippleFoundation.prototype.animateDeactivation = function (_a) {
            var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
            if (wasActivatedByPointer || wasElementMadeActive) {
                this.runDeactivationUXLogicIfReady();
            }
        };
        MDCRippleFoundation.prototype.layoutInternal = function () {
            var _this = this;
            this.frame = this.adapter.computeBoundingRect();
            var maxDim = Math.max(this.frame.height, this.frame.width);
            // Surface diameter is treated differently for unbounded vs. bounded ripples.
            // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
            // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
            // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
            // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
            // `overflow: hidden`.
            var getBoundedRadius = function () {
                var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
                return hypotenuse + MDCRippleFoundation.numbers.PADDING;
            };
            this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
            // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
            var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
            // Unbounded ripple size should always be even number to equally center align.
            if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
                this.initialSize = initialSize - 1;
            }
            else {
                this.initialSize = initialSize;
            }
            this.fgScale = "" + this.maxRadius / this.initialSize;
            this.updateLayoutCssVars();
        };
        MDCRippleFoundation.prototype.updateLayoutCssVars = function () {
            var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
            this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
            this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
            if (this.adapter.isUnbounded()) {
                this.unboundedCoords = {
                    left: Math.round((this.frame.width / 2) - (this.initialSize / 2)),
                    top: Math.round((this.frame.height / 2) - (this.initialSize / 2)),
                };
                this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
                this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
            }
        };
        return MDCRippleFoundation;
    }(MDCFoundation));

    const { applyPassive } = events;
    const { matches } = ponyfill;
    function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name, value) => node.style.setProperty(name, value), initPromise = Promise.resolve(), } = {}) {
        let instance;
        let addLayoutListener = getContext('SMUI:addLayoutListener');
        let removeLayoutListener;
        let oldActive = active;
        let oldEventTarget = eventTarget;
        let oldActiveTarget = activeTarget;
        function handleProps() {
            if (surface) {
                addClass('mdc-ripple-surface');
                if (color === 'primary') {
                    addClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
                else if (color === 'secondary') {
                    removeClass('smui-ripple-surface--primary');
                    addClass('smui-ripple-surface--secondary');
                }
                else {
                    removeClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
            }
            else {
                removeClass('mdc-ripple-surface');
                removeClass('smui-ripple-surface--primary');
                removeClass('smui-ripple-surface--secondary');
            }
            // Handle activation first.
            if (instance && oldActive !== active) {
                oldActive = active;
                if (active) {
                    instance.activate();
                }
                else if (active === false) {
                    instance.deactivate();
                }
            }
            // Then create/destroy an instance.
            if (ripple && !instance) {
                instance = new MDCRippleFoundation({
                    addClass,
                    browserSupportsCssVars: () => supportsCssVariables(window),
                    computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
                    containsEventTarget: (target) => node.contains(target),
                    deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
                    deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
                    deregisterResizeHandler: (handler) => window.removeEventListener('resize', handler),
                    getWindowPageOffset: () => ({
                        x: window.pageXOffset,
                        y: window.pageYOffset,
                    }),
                    isSurfaceActive: () => active == null ? matches(activeTarget || node, ':active') : active,
                    isSurfaceDisabled: () => !!disabled,
                    isUnbounded: () => !!unbounded,
                    registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
                    registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
                    registerResizeHandler: (handler) => window.addEventListener('resize', handler),
                    removeClass,
                    updateCssVariable: addStyle,
                });
                initPromise.then(() => {
                    if (instance) {
                        instance.init();
                        instance.setUnbounded(unbounded);
                    }
                });
            }
            else if (instance && !ripple) {
                initPromise.then(() => {
                    if (instance) {
                        instance.destroy();
                        instance = undefined;
                    }
                });
            }
            // Now handle event/active targets
            if (instance &&
                (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
                oldEventTarget = eventTarget;
                oldActiveTarget = activeTarget;
                instance.destroy();
                requestAnimationFrame(() => {
                    if (instance) {
                        instance.init();
                        instance.setUnbounded(unbounded);
                    }
                });
            }
            if (!ripple && unbounded) {
                addClass('mdc-ripple-upgraded--unbounded');
            }
        }
        handleProps();
        if (addLayoutListener) {
            removeLayoutListener = addLayoutListener(layout);
        }
        function layout() {
            if (instance) {
                instance.layout();
            }
        }
        return {
            update(props) {
                ({
                    ripple,
                    surface,
                    unbounded,
                    disabled,
                    color,
                    active,
                    rippleElement,
                    eventTarget,
                    activeTarget,
                    addClass,
                    removeClass,
                    addStyle,
                    initPromise,
                } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: undefined, active: undefined, rippleElement: undefined, eventTarget: undefined, activeTarget: undefined, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name, value) => node.style.setProperty(name, value), initPromise: Promise.resolve() }, props));
                handleProps();
            },
            destroy() {
                if (instance) {
                    instance.destroy();
                    instance = undefined;
                    removeClass('mdc-ripple-surface');
                    removeClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
                if (removeLayoutListener) {
                    removeLayoutListener();
                }
            },
        };
    }

    /* src\components\Button\Button.svelte generated by Svelte v3.59.2 */
    const file$A = "src\\components\\Button\\Button.svelte";

    function create_fragment$B(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[2],
    		{
    			class: div_class_value = "ui-button " + /*Color*/ ctx[1] + " " + /*$$restProps*/ ctx[2]?.class
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$A, 9, 0, 164);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler*/ ctx[5], false, false, false, false),
    					listen_dev(
    						div,
    						"click",
    						function () {
    							if (is_function(/*click*/ ctx[0])) /*click*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false,
    						false
    					),
    					action_destroyer(Ripple.call(null, div, { surface: true, active: true }))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*Color, $$restProps*/ 6 && div_class_value !== (div_class_value = "ui-button " + /*Color*/ ctx[1] + " " + /*$$restProps*/ ctx[2]?.class)) && { class: div_class_value }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	const omit_props_names = ["click","Color"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);

    	let { click = () => {
    		
    	} } = $$props;

    	let { Color = 'primary' } = $$props;

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('click' in $$new_props) $$invalidate(0, click = $$new_props.click);
    		if ('Color' in $$new_props) $$invalidate(1, Color = $$new_props.Color);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Ripple, click, Color });

    	$$self.$inject_state = $$new_props => {
    		if ('click' in $$props) $$invalidate(0, click = $$new_props.click);
    		if ('Color' in $$props) $$invalidate(1, Color = $$new_props.Color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [click, Color, $$restProps, $$scope, slots, keyup_handler];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$B, create_fragment$B, safe_not_equal, { click: 0, Color: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get click() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set click(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Checkbox\Checkbox.svelte generated by Svelte v3.59.2 */
    const file$z = "src\\components\\Checkbox\\Checkbox.svelte";

    // (20:16) {:else}
    function create_else_block$b(ctx) {
    	let input;
    	let t;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = space();
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(input, "class", "ui-checkbox-input");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "data-indeterminate", "false");
    			input.value = "";
    			add_location(input, file$z, 20, 20, 981);
    			attr_dev(path, "d", "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
    			add_location(path, file$z, 21, 107, 1175);
    			attr_dev(svg, "class", "ui-checkbox-icon");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "aria-hidden", "true");
    			add_location(svg, file$z, 21, 20, 1088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(20:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:16) {#if Checked}
    function create_if_block$r(ctx) {
    	let input;
    	let t;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = space();
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(input, "class", "ui-checkbox-input");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "data-indeterminate", "false");
    			input.value = "";
    			input.checked = true;
    			add_location(input, file$z, 17, 20, 577);
    			attr_dev(path, "d", "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
    			add_location(path, file$z, 18, 107, 779);
    			attr_dev(svg, "class", "ui-checkbox-icon");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "aria-hidden", "true");
    			add_location(svg, file$z, 18, 20, 692);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(17:16) {#if Checked}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div;
    	let label;
    	let span1;
    	let span0;
    	let span1_class_value;
    	let t0;
    	let span2;
    	let t1;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*Checked*/ ctx[0]) return create_if_block$r;
    		return create_else_block$b;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			span1 = element("span");
    			span0 = element("span");
    			if_block.c();
    			t0 = space();
    			span2 = element("span");
    			t1 = text(/*Title*/ ctx[1]);
    			attr_dev(span0, "class", "ui-checkbox-label");
    			add_location(span0, file$z, 15, 12, 492);
    			attr_dev(span1, "class", span1_class_value = "ui-checkbox-root " + (/*Checked*/ ctx[0] ? 'ui-checkbox-active' : ''));
    			attr_dev(span1, "aria-disabled", "false");
    			add_location(span1, file$z, 14, 8, 388);
    			attr_dev(span2, "class", "ui-checkbox-text");
    			add_location(span2, file$z, 25, 8, 1360);
    			attr_dev(label, "for", "");
    			attr_dev(label, "class", "ui-checkbox");
    			set_style(label, "width", "auto");
    			set_style(label, "max-width", "max-content");
    			add_location(label, file$z, 13, 4, 273);
    			attr_dev(div, "class", div_class_value = "ui-checkbox-container " + /*className*/ ctx[2]);
    			add_location(div, file$z, 12, 0, 220);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, span1);
    			append_dev(span1, span0);
    			if_block.m(span0, null);
    			append_dev(label, t0);
    			append_dev(label, span2);
    			append_dev(span2, t1);

    			if (!mounted) {
    				dispose = listen_dev(label, "click", /*ChangeCheckbox*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span0, null);
    				}
    			}

    			if (dirty & /*Checked*/ 1 && span1_class_value !== (span1_class_value = "ui-checkbox-root " + (/*Checked*/ ctx[0] ? 'ui-checkbox-active' : ''))) {
    				attr_dev(span1, "class", span1_class_value);
    			}

    			if (dirty & /*Title*/ 2) set_data_dev(t1, /*Title*/ ctx[1]);

    			if (dirty & /*className*/ 4 && div_class_value !== (div_class_value = "ui-checkbox-container " + /*className*/ ctx[2])) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	let { Title = '' } = $$props;
    	let { Checked = false } = $$props;
    	let { className = '' } = $$props;

    	var ChangeCheckbox = () => {
    		$$invalidate(0, Checked = !Checked);
    	};

    	const writable_props = ['Title', 'Checked', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('Title' in $$props) $$invalidate(1, Title = $$props.Title);
    		if ('Checked' in $$props) $$invalidate(0, Checked = $$props.Checked);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		Title,
    		Checked,
    		className,
    		ChangeCheckbox
    	});

    	$$self.$inject_state = $$props => {
    		if ('Title' in $$props) $$invalidate(1, Title = $$props.Title);
    		if ('Checked' in $$props) $$invalidate(0, Checked = $$props.Checked);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('ChangeCheckbox' in $$props) $$invalidate(3, ChangeCheckbox = $$props.ChangeCheckbox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [Checked, Title, className, ChangeCheckbox];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$A, create_fragment$A, safe_not_equal, { Title: 1, Checked: 0, className: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get Title() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Title(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Checked() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Checked(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\components\ImageHover.svelte generated by Svelte v3.59.2 */
    const file$y = "src\\apps\\Mdw\\components\\ImageHover.svelte";

    function create_fragment$z(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[8]);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div, file$y, 56, 0, 1875);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[9](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "resize", /*onwindowresize*/ ctx[8]),
    					listen_dev(div, "mouseenter", /*MouseEnter*/ ctx[3], false, false, false, false),
    					listen_dev(div, "mouseleave", /*MouseLeave*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[9](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageHover', slots, ['default']);
    	let { Source = "https://media.tenor.com/FawYo00tBekAAAAC/loading-thinking.gif" } = $$props;
    	let innerWidth = 0, innerHeight = 0;
    	let HoverElement;

    	const GetImageDimensions = () => {
    		return new Promise(Res => {
    				var img = new Image();

    				img.addEventListener("load", function () {
    					Res([this.naturalWidth, this.naturalHeight]);
    				});

    				img.src = Source;
    			});
    	};

    	const MouseEnter = async () => {
    		let [Width, Height] = await GetImageDimensions();
    		let elemRect = HoverElement.getBoundingClientRect();
    		let MaxWidth = 100;

    		if (Width > innerWidth * 0.8) {
    			const Reduction = innerWidth * 0.8 / Width;
    			MaxWidth = Reduction * 100;

    			// Reduce twice, first is to 'fit to screen', then reduce it to MaxWidth of img.
    			Width = Width * Reduction * Reduction;

    			Height = Height * Reduction * Reduction;
    		}
    		let TopPosition = elemRect.top - Height - elemRect.height;
    		let LeftPosition = elemRect.left - Width / 2 + elemRect.width / 2;
    		if (TopPosition < 21) TopPosition = 21;
    		if (TopPosition > innerHeight) TopPosition = innerHeight - Height - 21;
    		if (LeftPosition < 21) LeftPosition = 21;
    		if (LeftPosition > innerWidth) LeftPosition = innerWidth - Width - 21;

    		ImageHoverData.set({
    			Show: true,
    			Source,
    			Top: TopPosition,
    			Left: LeftPosition,
    			MaxWidth
    		});
    	};

    	const MouseLeave = () => {
    		ImageHoverData.set({ Show: false, Source: "", Top: 0, Left: 0 });
    	};

    	const writable_props = ['Source'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImageHover> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		$$invalidate(0, innerWidth = window.innerWidth);
    		$$invalidate(1, innerHeight = window.innerHeight);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			HoverElement = $$value;
    			$$invalidate(2, HoverElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('Source' in $$props) $$invalidate(5, Source = $$props.Source);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ImageHoverData,
    		Source,
    		innerWidth,
    		innerHeight,
    		HoverElement,
    		GetImageDimensions,
    		MouseEnter,
    		MouseLeave
    	});

    	$$self.$inject_state = $$props => {
    		if ('Source' in $$props) $$invalidate(5, Source = $$props.Source);
    		if ('innerWidth' in $$props) $$invalidate(0, innerWidth = $$props.innerWidth);
    		if ('innerHeight' in $$props) $$invalidate(1, innerHeight = $$props.innerHeight);
    		if ('HoverElement' in $$props) $$invalidate(2, HoverElement = $$props.HoverElement);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		innerWidth,
    		innerHeight,
    		HoverElement,
    		MouseEnter,
    		MouseLeave,
    		Source,
    		$$scope,
    		slots,
    		onwindowresize,
    		div_binding
    	];
    }

    class ImageHover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$z, create_fragment$z, safe_not_equal, { Source: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageHover",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get Source() {
    		throw new Error("<ImageHover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Source(value) {
    		throw new Error("<ImageHover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\apps\Reports.svelte generated by Svelte v3.59.2 */

    const { console: console_1$3 } = globals;

    const file$x = "src\\apps\\Mdw\\apps\\Reports.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[71] = list;
    	child_ctx[72] = i;
    	return child_ctx;
    }

    function get_each_context_1$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[73] = list[i];
    	child_ctx[75] = i;
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[72] = i;
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[72] = i;
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[72] = i;
    	return child_ctx;
    }

    function get_each_context_5$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[72] = i;
    	return child_ctx;
    }

    function get_each_context_6$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	child_ctx[72] = i;
    	return child_ctx;
    }

    // (562:4) <MdwPanelHeader>
    function create_default_slot_22(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterReports*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Reports";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$x, 562, 8, 23296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(562:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (573:12) {#if (CurrentCategory == 'All' || CurrentCategory == Data.category) && (Data.category != 'Investigation Report' || ($MdwProfile.certs.includes(10) || $MdwProfile.certs.includes(11)))}
    function create_if_block_24(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[42](/*Data*/ ctx[70]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[/*Data*/ ctx[70].title, /*Data*/ ctx[70].category],
    					[
    						`ID: ${/*Data*/ ctx[70].id}`,
    						`${/*Data*/ ctx[70].author} - ${GetTimeLabel(/*Data*/ ctx[70].created)}`
    					]
    				]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};

    			if (dirty[0] & /*FilteredReports, MaxReports*/ 3) mdwcard_changes.Information = [
    				[/*Data*/ ctx[70].title, /*Data*/ ctx[70].category],
    				[
    					`ID: ${/*Data*/ ctx[70].id}`,
    					`${/*Data*/ ctx[70].author} - ${GetTimeLabel(/*Data*/ ctx[70].created)}`
    				]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_24.name,
    		type: "if",
    		source: "(573:12) {#if (CurrentCategory == 'All' || CurrentCategory == Data.category) && (Data.category != 'Investigation Report' || ($MdwProfile.certs.includes(10) || $MdwProfile.certs.includes(11)))}",
    		ctx
    	});

    	return block;
    }

    // (572:8) {#each FilteredReports.slice(0, MaxReports) as Data, Key}
    function create_each_block_6$1(ctx) {
    	let show_if = (/*CurrentCategory*/ ctx[2] == 'All' || /*CurrentCategory*/ ctx[2] == /*Data*/ ctx[70].category) && (/*Data*/ ctx[70].category != 'Investigation Report' || (/*$MdwProfile*/ ctx[5].certs.includes(10) || /*$MdwProfile*/ ctx[5].certs.includes(11)));
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block_24(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*CurrentCategory, FilteredReports, MaxReports, $MdwProfile*/ 39) show_if = (/*CurrentCategory*/ ctx[2] == 'All' || /*CurrentCategory*/ ctx[2] == /*Data*/ ctx[70].category) && (/*Data*/ ctx[70].category != 'Investigation Report' || (/*$MdwProfile*/ ctx[5].certs.includes(10) || /*$MdwProfile*/ ctx[5].certs.includes(11)));

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*CurrentCategory, FilteredReports, MaxReports, $MdwProfile*/ 39) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_24(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6$1.name,
    		type: "each",
    		source: "(572:8) {#each FilteredReports.slice(0, MaxReports) as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (581:8) {#if FilteredReports.length > 5}
    function create_if_block_23(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				Color: "success",
    				click: /*LoadMore*/ ctx[8],
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			set_style(div, "display", "flex");
    			set_style(div, "justify-content", "center");
    			set_style(div, "width", "100%");
    			add_location(div, file$x, 581, 12, 24275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 524288) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(581:8) {#if FilteredReports.length > 5}",
    		ctx
    	});

    	return block;
    }

    // (583:16) <Button Color="success" click={LoadMore}>
    function create_default_slot_21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Load More");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(583:16) <Button Color=\\\"success\\\" click={LoadMore}>",
    		ctx
    	});

    	return block;
    }

    // (571:4) <MdwPanelList style="height: 86%">
    function create_default_slot_20(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;
    	let each_value_6 = /*FilteredReports*/ ctx[0].slice(0, /*MaxReports*/ ctx[1]);
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6$1(get_each_context_6$1(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*FilteredReports*/ ctx[0].length > 5 && create_if_block_23(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*FilteredReports, MaxReports, FetchById, CurrentCategory, $MdwProfile*/ 2087) {
    				each_value_6 = /*FilteredReports*/ ctx[0].slice(0, /*MaxReports*/ ctx[1]);
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6$1(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*FilteredReports*/ ctx[0].length > 5) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*FilteredReports*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_23(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(571:4) <MdwPanelList style=\\\"height: 86%\\\">",
    		ctx
    	});

    	return block;
    }

    // (561:0) <MdwPanel class="filled">
    function create_default_slot_19(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let textfield;
    	let updating_RealValue;
    	let t1;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield_RealValue_binding(value) {
    		/*textfield_RealValue_binding*/ ctx[41](value);
    	}

    	let textfield_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Category",
    		Select: /*GetReportsCategories*/ ctx[13](true)
    	};

    	if (/*CurrentCategory*/ ctx[2] !== void 0) {
    		textfield_props.RealValue = /*CurrentCategory*/ ctx[2];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'RealValue', textfield_RealValue_binding));

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				style: "height: 86%",
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(textfield.$$.fragment);
    			t1 = space();
    			create_component(mdwpanellist.$$.fragment);
    			set_style(div, "width", "97%");
    			set_style(div, "margin-left", "auto");
    			set_style(div, "margin-right", "auto");
    			add_location(div, file$x, 566, 4, 23418);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(textfield, div, null);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const textfield_changes = {};

    			if (!updating_RealValue && dirty[0] & /*CurrentCategory*/ 4) {
    				updating_RealValue = true;
    				textfield_changes.RealValue = /*CurrentCategory*/ ctx[2];
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield.$set(textfield_changes);
    			const mdwpanellist_changes = {};

    			if (dirty[0] & /*FilteredReports, MaxReports, CurrentCategory, $MdwProfile*/ 39 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(textfield);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(561:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (594:12) {:else}
    function create_else_block_3$2(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Add Report";
    			add_location(h6, file$x, 594, 16, 24780);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$2.name,
    		type: "else",
    		source: "(594:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (592:12) {#if $CurrentReport.id}
    function create_if_block_22$1(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*$CurrentReport*/ ctx[4].id + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Edit Report (#");
    			t1 = text(t1_value);
    			t2 = text(")");
    			add_location(h6, file$x, 592, 16, 24698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16 && t1_value !== (t1_value = /*$CurrentReport*/ ctx[4].id + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22$1.name,
    		type: "if",
    		source: "(592:12) {#if $CurrentReport.id}",
    		ctx
    	});

    	return block;
    }

    // (598:12) {#if !$IsPublic}
    function create_if_block_15$1(ctx) {
    	let div;
    	let show_if;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$CurrentReport*/ ctx[4].id) return create_if_block_16$1;
    		if (show_if == null) show_if = !!HasCidPermission("Reports.Create");
    		if (show_if) return create_if_block_21$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 598, 16, 24872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$1.name,
    		type: "if",
    		source: "(598:12) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (606:24) {#if HasCidPermission("Reports.Create")}
    function create_if_block_21$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$x, 605, 65, 25752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_4*/ ctx[40], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_5*/ ctx[47], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21$1.name,
    		type: "if",
    		source: "(606:24) {#if HasCidPermission(\\\"Reports.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (600:20) {#if $CurrentReport.id}
    function create_if_block_16$1(ctx) {
    	let show_if_3 = HasCidPermission("Reports.Create");
    	let t0;
    	let show_if_2 = HasCidPermission("Reports.Export");
    	let t1;
    	let show_if_1 = HasCidPermission("Reports.Delete");
    	let t2;
    	let show_if = HasCidPermission("Reports.Edit");
    	let if_block3_anchor;
    	let if_block0 = show_if_3 && create_if_block_20$1(ctx);
    	let if_block1 = show_if_2 && create_if_block_19$1(ctx);
    	let if_block2 = show_if_1 && create_if_block_18$1(ctx);
    	let if_block3 = show_if && create_if_block_17$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if_3) if_block0.p(ctx, dirty);
    			if (show_if_2) if_block1.p(ctx, dirty);
    			if (show_if_1) if_block2.p(ctx, dirty);
    			if (show_if) if_block3.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$1.name,
    		type: "if",
    		source: "(600:20) {#if $CurrentReport.id}",
    		ctx
    	});

    	return block;
    }

    // (601:24) {#if HasCidPermission("Reports.Create")}
    function create_if_block_20$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "New");
    			attr_dev(i, "class", "fas fa-sync");
    			add_location(i, file$x, 600, 65, 25017);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[39], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_1*/ ctx[43], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20$1.name,
    		type: "if",
    		source: "(601:24) {#if HasCidPermission(\\\"Reports.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (602:24) {#if HasCidPermission("Reports.Export")}
    function create_if_block_19$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Export");
    			attr_dev(i, "class", "fas fa-file-export");
    			add_location(i, file$x, 601, 65, 25190);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[38], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_2*/ ctx[44], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19$1.name,
    		type: "if",
    		source: "(602:24) {#if HasCidPermission(\\\"Reports.Export\\\")}",
    		ctx
    	});

    	return block;
    }

    // (603:24) {#if HasCidPermission("Reports.Delete")}
    function create_if_block_18$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Delete");
    			attr_dev(i, "class", "fas fa-trash");
    			add_location(i, file$x, 602, 65, 25374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_2*/ ctx[37], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_3*/ ctx[45], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$1.name,
    		type: "if",
    		source: "(603:24) {#if HasCidPermission(\\\"Reports.Delete\\\")}",
    		ctx
    	});

    	return block;
    }

    // (604:24) {#if HasCidPermission("Reports.Edit")}
    function create_if_block_17$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$x, 603, 63, 25550);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_3*/ ctx[36], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_4*/ ctx[46], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$1.name,
    		type: "if",
    		source: "(604:24) {#if HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (591:8) <MdwPanelHeader>
    function create_default_slot_18$2(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$CurrentReport*/ ctx[4].id) return create_if_block_22$1;
    		return create_else_block_3$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*$IsPublic*/ ctx[7] && create_if_block_15$1(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (!/*$IsPublic*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_15$1(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$2.name,
    		type: "slot",
    		source: "(591:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (590:4) <MdwPanel class="filled" style="width: 100%; height: max-content; padding-bottom: 1vh; margin-bottom: 0.5vh;">
    function create_default_slot_17$2(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div0;
    	let textfield0;
    	let updating_RealValue;
    	let t1;
    	let div1;
    	let textfield1;
    	let updating_RealValue_1;
    	let t2;
    	let div2;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_18$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[48](value);
    	}

    	let textfield0_props = {
    		style: "margin-bottom: 0px;",
    		SubSet: /*OnReportCategoryUpdate*/ ctx[9],
    		Title: "Category",
    		Select: /*GetReportsCategories*/ ctx[13]()
    	};

    	if (/*$CurrentReport*/ ctx[4].category !== void 0) {
    		textfield0_props.RealValue = /*$CurrentReport*/ ctx[4].category;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[49](value);
    	}

    	let textfield1_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Title",
    		Icon: "pencil-alt"
    	};

    	if (/*$CurrentReport*/ ctx[4].title !== void 0) {
    		textfield1_props.RealValue = /*$CurrentReport*/ ctx[4].title;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			set_style(div0, "width", "97%");
    			set_style(div0, "margin-left", "auto");
    			set_style(div0, "margin-right", "auto");
    			add_location(div0, file$x, 611, 8, 25971);
    			set_style(div1, "width", "97%");
    			set_style(div1, "margin-left", "auto");
    			set_style(div1, "margin-right", "auto");
    			add_location(div1, file$x, 615, 8, 26248);
    			attr_dev(div2, "class", "mdw-reports-editor svelte-v5wmf8");
    			add_location(div2, file$x, 619, 8, 26469);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(textfield0, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(textfield1, div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			/*div2_binding*/ ctx[50](div2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsPublic*/ 144 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*$CurrentReport*/ ctx[4].category;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_RealValue_1 && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$CurrentReport*/ ctx[4].title;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(textfield1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			/*div2_binding*/ ctx[50](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$2.name,
    		type: "slot",
    		source: "(590:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; padding-bottom: 1vh; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (629:16) {#if $CurrentReport.id && HasCidPermission("Reports.Edit")}
    function create_if_block_14$1(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$x, 629, 20, 26903);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_5*/ ctx[35], false, false, false, false),
    					listen_dev(i, "click", /*AddEvidence*/ ctx[14], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$1.name,
    		type: "if",
    		source: "(629:16) {#if $CurrentReport.id && HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (625:8) <MdwPanelHeader>
    function create_default_slot_16$2(ctx) {
    	let h6;
    	let t0_value = (/*$IsEms*/ ctx[6] ? "Photos" : "Evidence") + "";
    	let t0;
    	let t1;
    	let div;
    	let show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_14$1(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 625, 12, 26710);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 627, 12, 26771);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$IsEms*/ 64 && t0_value !== (t0_value = (/*$IsEms*/ ctx[6] ? "Photos" : "Evidence") + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*$CurrentReport*/ 16) show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_14$1(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(625:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (635:8) {#if $CurrentReport.id && $CurrentReport.formattedEvidence}
    function create_if_block_12$2(ctx) {
    	let div;
    	let current;
    	let each_value_5 = /*$CurrentReport*/ ctx[4].formattedEvidence;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$x, 635, 12, 27117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport, RemoveEvidence*/ 32784) {
    				each_value_5 = /*$CurrentReport*/ ctx[4].formattedEvidence;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$2.name,
    		type: "if",
    		source: "(635:8) {#if $CurrentReport.id && $CurrentReport.formattedEvidence}",
    		ctx
    	});

    	return block;
    }

    // (642:20) {:else}
    function create_else_block_2$3(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_7() {
    		return /*click_handler_7*/ ctx[52](/*Data*/ ctx[70]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[70].Text,
    				Color: /*Data*/ ctx[70]?.Color || "#ffffff",
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_7);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = /*Data*/ ctx[70].Text;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = /*Data*/ ctx[70]?.Color || "#ffffff";
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(642:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (638:20) {#if Data.Image}
    function create_if_block_13$2(ctx) {
    	let imagehover;
    	let current;

    	imagehover = new ImageHover({
    			props: {
    				Source: /*Data*/ ctx[70].Image,
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imagehover.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imagehover, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagehover_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) imagehover_changes.Source = /*Data*/ ctx[70].Image;

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				imagehover_changes.$$scope = { dirty, ctx };
    			}

    			imagehover.$set(imagehover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagehover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagehover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imagehover, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$2.name,
    		type: "if",
    		source: "(638:20) {#if Data.Image}",
    		ctx
    	});

    	return block;
    }

    // (639:24) <ImageHover Source={Data.Image}>
    function create_default_slot_15$2(ctx) {
    	let mdwchip;
    	let t;
    	let current;

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[51](/*Data*/ ctx[70]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[70].Text,
    				Color: /*Data*/ ctx[70]?.Color || "#ffffff",
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_6);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = /*Data*/ ctx[70].Text;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = /*Data*/ ctx[70]?.Color || "#ffffff";
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(639:24) <ImageHover Source={Data.Image}>",
    		ctx
    	});

    	return block;
    }

    // (637:16) {#each $CurrentReport.formattedEvidence as Data, Key}
    function create_each_block_5$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_13$2, create_else_block_2$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*Data*/ ctx[70].Image) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$1.name,
    		type: "each",
    		source: "(637:16) {#each $CurrentReport.formattedEvidence as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (624:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_14$2(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedEvidence && create_if_block_12$2(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedEvidence) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_12$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(624:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (656:16) {#if $CurrentReport.id && HasCidPermission("Reports.Edit")}
    function create_if_block_11$3(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$x, 656, 20, 28264);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_6*/ ctx[34], false, false, false, false),
    					listen_dev(i, "click", /*AddUnit*/ ctx[16], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$3.name,
    		type: "if",
    		source: "(656:16) {#if $CurrentReport.id && HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (652:8) <MdwPanelHeader>
    function create_default_slot_13$2(ctx) {
    	let h6;

    	let t0_value = (/*$IsEms*/ ctx[6]
    	? "Involved Colleagues"
    	: "Involved Officers") + "";

    	let t0;
    	let t1;
    	let div;
    	let show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_11$3(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 652, 12, 28049);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 654, 12, 28132);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$IsEms*/ 64 && t0_value !== (t0_value = (/*$IsEms*/ ctx[6]
    			? "Involved Colleagues"
    			: "Involved Officers") + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$CurrentReport*/ 16) show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_11$3(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(652:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (662:8) {#if $CurrentReport.id && $CurrentReport.formattedOfficers}
    function create_if_block_10$5(ctx) {
    	let div;
    	let current;
    	let each_value_4 = /*$CurrentReport*/ ctx[4].formattedOfficers;
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$x, 662, 12, 28474);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport, RemoveUnit*/ 131088) {
    				each_value_4 = /*$CurrentReport*/ ctx[4].formattedOfficers;
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$5.name,
    		type: "if",
    		source: "(662:8) {#if $CurrentReport.id && $CurrentReport.formattedOfficers}",
    		ctx
    	});

    	return block;
    }

    // (664:16) {#each $CurrentReport.formattedOfficers as Data, Key}
    function create_each_block_4$1(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_8() {
    		return /*click_handler_8*/ ctx[53](/*Data*/ ctx[70]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[70].Text,
    				Color: /*Data*/ ctx[70]?.Color || "#ffffff",
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_8);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = /*Data*/ ctx[70].Text;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = /*Data*/ ctx[70]?.Color || "#ffffff";
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(664:16) {#each $CurrentReport.formattedOfficers as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (651:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_12$3(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedOfficers && create_if_block_10$5(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedOfficers) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_10$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$3.name,
    		type: "slot",
    		source: "(651:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (677:16) {#if $CurrentReport.id && HasCidPermission("Reports.Edit")}
    function create_if_block_9$6(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$x, 677, 20, 29220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_7*/ ctx[33], false, false, false, false),
    					listen_dev(i, "click", /*AddPerson*/ ctx[18], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$6.name,
    		type: "if",
    		source: "(677:16) {#if $CurrentReport.id && HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (673:8) <MdwPanelHeader>
    function create_default_slot_11$4(ctx) {
    	let h6;
    	let t1;
    	let div;
    	let show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_9$6(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Involved Persons";
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 673, 12, 29043);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 675, 12, 29088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16) show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_9$6(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$4.name,
    		type: "slot",
    		source: "(673:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (683:8) {#if $CurrentReport.id && $CurrentReport.formattedPersons}
    function create_if_block_8$7(ctx) {
    	let div;
    	let current;
    	let each_value_3 = /*$CurrentReport*/ ctx[4].formattedPersons;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$x, 683, 12, 29431);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport, RemovePerson*/ 524304) {
    				each_value_3 = /*$CurrentReport*/ ctx[4].formattedPersons;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$7.name,
    		type: "if",
    		source: "(683:8) {#if $CurrentReport.id && $CurrentReport.formattedPersons}",
    		ctx
    	});

    	return block;
    }

    // (685:16) {#each $CurrentReport.formattedPersons as Data, Key}
    function create_each_block_3$2(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_9() {
    		return /*click_handler_9*/ ctx[54](/*Data*/ ctx[70]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[70].Text,
    				Color: /*Data*/ ctx[70]?.Color || "#ffffff",
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_9);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = /*Data*/ ctx[70].Text;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = /*Data*/ ctx[70]?.Color || "#ffffff";
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(685:16) {#each $CurrentReport.formattedPersons as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (672:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_10$4(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_11$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedPersons && create_if_block_8$7(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].formattedPersons) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_8$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$4.name,
    		type: "slot",
    		source: "(672:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (698:16) {#if $CurrentReport.id && HasCidPermission("Reports.Edit")}
    function create_if_block_7$7(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$x, 698, 20, 30154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_8*/ ctx[32], false, false, false, false),
    					listen_dev(i, "click", /*AddTag*/ ctx[20], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$7.name,
    		type: "if",
    		source: "(698:16) {#if $CurrentReport.id && HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (694:8) <MdwPanelHeader>
    function create_default_slot_9$4(ctx) {
    	let h6;
    	let t1;
    	let div;
    	let show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_7$7(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Tags";
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 694, 12, 29989);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 696, 12, 30022);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16) show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_7$7(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$4.name,
    		type: "slot",
    		source: "(694:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (704:8) {#if $CurrentReport.id && $CurrentReport.tags}
    function create_if_block_5$9(ctx) {
    	let div;
    	let current;
    	let each_value_2 = /*$CurrentReport*/ ctx[4].tags;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$x, 704, 12, 30350);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport, RemoveTag*/ 2097168) {
    				each_value_2 = /*$CurrentReport*/ ctx[4].tags;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$9.name,
    		type: "if",
    		source: "(704:8) {#if $CurrentReport.id && $CurrentReport.tags}",
    		ctx
    	});

    	return block;
    }

    // (709:20) {:else}
    function create_else_block_1$7(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[70]).tag,
    				Color: GetTagById(/*Data*/ ctx[70])?.color || "#ffffff",
    				PrefixIcon: GetTagById(/*Data*/ ctx[70]).icon
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[70]).tag;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[70])?.color || "#ffffff";
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[70]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$7.name,
    		type: "else",
    		source: "(709:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (707:20) {#if HasCidPermission("Reports.Edit")}
    function create_if_block_6$7(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_10() {
    		return /*click_handler_10*/ ctx[55](/*Key*/ ctx[72]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[70]).tag,
    				Color: GetTagById(/*Data*/ ctx[70])?.color || "#ffffff",
    				PrefixIcon: GetTagById(/*Data*/ ctx[70]).icon,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_10);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[70]).tag;
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[70])?.color || "#ffffff";
    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[70]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$7.name,
    		type: "if",
    		source: "(707:20) {#if HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (706:16) {#each $CurrentReport.tags as Data, Key}
    function create_each_block_2$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_6$7, create_else_block_1$7];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (HasCidPermission("Reports.Edit")) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(706:16) {#each $CurrentReport.tags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (693:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_8$4(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_9$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].tags && create_if_block_5$9(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].tags) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$4.name,
    		type: "slot",
    		source: "(693:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (589:0) <MdwPanel>
    function create_default_slot_7$6(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let t2;
    	let mdwpanel3;
    	let t3;
    	let mdwpanel4;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; padding-bottom: 1vh; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_17$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_12$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel3 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_10$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel4 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_8$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    			t2 = space();
    			create_component(mdwpanel3.$$.fragment);
    			t3 = space();
    			create_component(mdwpanel4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(mdwpanel3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(mdwpanel4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*ReportsEditor, $CurrentReport, $IsPublic*/ 152 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    			const mdwpanel3_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel3_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel3.$set(mdwpanel3_changes);
    			const mdwpanel4_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel4_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel4.$set(mdwpanel4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			transition_in(mdwpanel3.$$.fragment, local);
    			transition_in(mdwpanel4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			transition_out(mdwpanel3.$$.fragment, local);
    			transition_out(mdwpanel4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(mdwpanel3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(mdwpanel4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$6.name,
    		type: "slot",
    		source: "(589:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    // (725:16) {#if $CurrentReport.id && HasCidPermission("Reports.Edit")}
    function create_if_block_4$9(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$x, 725, 20, 31432);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_9*/ ctx[31], false, false, false, false),
    					listen_dev(i, "click", /*AddSuspect*/ ctx[22], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$9.name,
    		type: "if",
    		source: "(725:16) {#if $CurrentReport.id && HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (721:8) <MdwPanelHeader>
    function create_default_slot_6$8(ctx) {
    	let h6;
    	let t0_value = (/*$IsEms*/ ctx[6] ? "Add Victim" : "Add Suspect") + "";
    	let t0;
    	let t1;
    	let div;
    	let show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_4$9(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 721, 12, 31232);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 723, 12, 31300);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$IsEms*/ 64 && t0_value !== (t0_value = (/*$IsEms*/ ctx[6] ? "Add Victim" : "Add Suspect") + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*$CurrentReport*/ 16) show_if = /*$CurrentReport*/ ctx[4].id && HasCidPermission("Reports.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$9(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$8.name,
    		type: "slot",
    		source: "(721:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (720:4) <MdwPanel class="filled" style="width: 100%; height: 4.3vh; margin-bottom: 0.5vh;">
    function create_default_slot_5$b(ctx) {
    	let mdwpanelheader;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_6$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$b.name,
    		type: "slot",
    		source: "(720:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: 4.3vh; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (732:4) {#if $CurrentReport.id && $CurrentReport.scums}
    function create_if_block$q(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$CurrentReport*/ ctx[4].scums;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport, GetFinalString, GetReductionDropdown, $IsEms, GetMedicalBill, OpenChargesModal, SaveScum, RemoveSuspect*/ 528482384) {
    				each_value = /*$CurrentReport*/ ctx[4].scums;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(732:4) {#if $CurrentReport.id && $CurrentReport.scums}",
    		ctx
    	});

    	return block;
    }

    // (739:24) {#if HasCidPermission("Reports.Edit")}
    function create_if_block_3$a(ctx) {
    	let i0;
    	let t;
    	let i1;
    	let mounted;
    	let dispose;

    	function click_handler_11() {
    		return /*click_handler_11*/ ctx[56](/*Key*/ ctx[72]);
    	}

    	function click_handler_12() {
    		return /*click_handler_12*/ ctx[57](/*Key*/ ctx[72]);
    	}

    	const block = {
    		c: function create() {
    			i0 = element("i");
    			t = space();
    			i1 = element("i");
    			attr_dev(i0, "data-tooltip", "Delete");
    			attr_dev(i0, "class", "fas fa-trash");
    			add_location(i0, file$x, 739, 28, 32047);
    			attr_dev(i1, "data-tooltip", "Save");
    			attr_dev(i1, "class", "fas fa-save");
    			add_location(i1, file$x, 740, 28, 32176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, i1, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i0, "keyup", /*keyup_handler_10*/ ctx[30], false, false, false, false),
    					listen_dev(i0, "click", click_handler_11, false, false, false, false),
    					listen_dev(i1, "keyup", /*keyup_handler_11*/ ctx[29], false, false, false, false),
    					listen_dev(i1, "click", click_handler_12, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(i1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$a.name,
    		type: "if",
    		source: "(739:24) {#if HasCidPermission(\\\"Reports.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (735:16) <MdwPanelHeader>
    function create_default_slot_4$c(ctx) {
    	let h6;
    	let t0_value = /*Data*/ ctx[70].Name + "";
    	let t0;
    	let t1;
    	let t2_value = /*Data*/ ctx[70].Cid + "";
    	let t2;
    	let t3;
    	let t4;
    	let div;
    	let show_if = HasCidPermission("Reports.Edit");
    	let if_block = show_if && create_if_block_3$a(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = text(" (#");
    			t2 = text(t2_value);
    			t3 = text(")");
    			t4 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$x, 735, 20, 31842);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$x, 737, 20, 31920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    			append_dev(h6, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16 && t0_value !== (t0_value = /*Data*/ ctx[70].Name + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*$CurrentReport*/ 16 && t2_value !== (t2_value = /*Data*/ ctx[70].Cid + "")) set_data_dev(t2, t2_value);
    			if (show_if) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$c.name,
    		type: "slot",
    		source: "(735:16) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (748:20) {#each Data.Charges as Charge, CKey}
    function create_each_block_1$a(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: (/*Charge*/ ctx[73].Type != "Principal"
    				? /*Charge*/ ctx[73].Type == "Accomplice"
    					? "(Accomplice) "
    					: "(Attempted) "
    				: "") + GetChargeById(/*Charge*/ ctx[73].Id)?.name || "Unknown Charge.",
    				Color: "#000000"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16) mdwchip_changes.Text = (/*Charge*/ ctx[73].Type != "Principal"
    			? /*Charge*/ ctx[73].Type == "Accomplice"
    				? "(Accomplice) "
    				: "(Attempted) "
    			: "") + GetChargeById(/*Charge*/ ctx[73].Id)?.name || "Unknown Charge.";

    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$a.name,
    		type: "each",
    		source: "(748:20) {#each Data.Charges as Charge, CKey}",
    		ctx
    	});

    	return block;
    }

    // (775:16) {:else}
    function create_else_block$a(ctx) {
    	let mdwpanelheader;
    	let t;
    	let div;
    	let checkbox;
    	let updating_Checked;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "flex-direction: column; height: max-content; padding-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_3$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function checkbox_Checked_binding(value) {
    		/*checkbox_Checked_binding*/ ctx[65](value, /*Data*/ ctx[70]);
    	}

    	let checkbox_props = { Title: "Processed" };

    	if (/*Data*/ ctx[70].Processed !== void 0) {
    		checkbox_props.Checked = /*Data*/ ctx[70].Processed;
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'Checked', checkbox_Checked_binding));

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			div = element("div");
    			create_component(checkbox.$$.fragment);
    			set_style(div, "display", "flex");
    			set_style(div, "flex-direction", "row");
    			set_style(div, "justify-content", "space-between");
    			set_style(div, "width", "96.8%");
    			set_style(div, "margin", "0 auto");
    			add_location(div, file$x, 780, 20, 34901);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(checkbox, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const checkbox_changes = {};

    			if (!updating_Checked && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_Checked = true;
    				checkbox_changes.Checked = /*Data*/ ctx[70].Processed;
    				add_flush_callback(() => updating_Checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(775:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (754:16) {#if !$IsEms}
    function create_if_block_1$f(ctx) {
    	let div0;
    	let checkbox0;
    	let updating_Checked;
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let textfield;
    	let updating_Value;
    	let updating_RealValue;
    	let t3;
    	let mdwpanelheader;
    	let t4;
    	let div1;
    	let checkbox1;
    	let updating_Checked_1;
    	let t5;
    	let checkbox2;
    	let updating_Checked_2;
    	let current;

    	function checkbox0_Checked_binding(value) {
    		/*checkbox0_Checked_binding*/ ctx[59](value, /*Data*/ ctx[70]);
    	}

    	let checkbox0_props = { Title: "Arrest Warrant" };

    	if (/*Data*/ ctx[70].Warrent !== void 0) {
    		checkbox0_props.Checked = /*Data*/ ctx[70].Warrent;
    	}

    	checkbox0 = new Checkbox({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, 'Checked', checkbox0_Checked_binding));
    	let if_block = /*Data*/ ctx[70].Warrent && create_if_block_2$c(ctx);

    	function textfield_Value_binding(value) {
    		/*textfield_Value_binding*/ ctx[61](value, /*Data*/ ctx[70]);
    	}

    	function textfield_RealValue_binding_2(value) {
    		/*textfield_RealValue_binding_2*/ ctx[62](value, /*Data*/ ctx[70]);
    	}

    	let textfield_props = {
    		style: "width: 96.8%; margin: 0 auto;",
    		Title: "Sentence Reduction",
    		Select: /*GetReductionDropdown*/ ctx[28](/*Data*/ ctx[70].Charges)
    	};

    	if (/*Data*/ ctx[70].Reduction !== void 0) {
    		textfield_props.Value = /*Data*/ ctx[70].Reduction;
    	}

    	if (/*Data*/ ctx[70].ReductionString !== void 0) {
    		textfield_props.RealValue = /*Data*/ ctx[70].ReductionString;
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'Value', textfield_Value_binding));
    	binding_callbacks.push(() => bind(textfield, 'RealValue', textfield_RealValue_binding_2));

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "flex-direction: column; height: max-content; padding-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function checkbox1_Checked_binding(value) {
    		/*checkbox1_Checked_binding*/ ctx[63](value, /*Data*/ ctx[70]);
    	}

    	let checkbox1_props = { Title: "Pleaded Guilty" };

    	if (/*Data*/ ctx[70].PleadedGuilty !== void 0) {
    		checkbox1_props.Checked = /*Data*/ ctx[70].PleadedGuilty;
    	}

    	checkbox1 = new Checkbox({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, 'Checked', checkbox1_Checked_binding));

    	function checkbox2_Checked_binding(value) {
    		/*checkbox2_Checked_binding*/ ctx[64](value, /*Data*/ ctx[70]);
    	}

    	let checkbox2_props = { Title: "Processed" };

    	if (/*Data*/ ctx[70].Processed !== void 0) {
    		checkbox2_props.Checked = /*Data*/ ctx[70].Processed;
    	}

    	checkbox2 = new Checkbox({ props: checkbox2_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox2, 'Checked', checkbox2_Checked_binding));

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(checkbox0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			create_component(textfield.$$.fragment);
    			t3 = space();
    			create_component(mdwpanelheader.$$.fragment);
    			t4 = space();
    			div1 = element("div");
    			create_component(checkbox1.$$.fragment);
    			t5 = space();
    			create_component(checkbox2.$$.fragment);
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			set_style(div0, "justify-content", "space-between");
    			set_style(div0, "width", "96.8%");
    			set_style(div0, "margin", "0 auto");
    			add_location(div0, file$x, 754, 20, 33130);
    			set_style(hr, "margin", "1vh auto");
    			set_style(hr, "width", "96.8%");
    			set_style(hr, "border", "none");
    			set_style(hr, "height", "0.2vh");
    			set_style(hr, "background-color", "rgb(34, 40, 49)");
    			add_location(hr, file$x, 761, 20, 33575);
    			set_style(div1, "display", "flex");
    			set_style(div1, "flex-direction", "row");
    			set_style(div1, "justify-content", "space-between");
    			set_style(div1, "width", "96.8%");
    			set_style(div1, "margin", "0 auto");
    			add_location(div1, file$x, 770, 20, 34235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(checkbox0, div0, null);
    			append_dev(div0, t0);
    			if (if_block) if_block.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(textfield, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(checkbox1, div1, null);
    			append_dev(div1, t5);
    			mount_component(checkbox2, div1, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const checkbox0_changes = {};

    			if (!updating_Checked && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_Checked = true;
    				checkbox0_changes.Checked = /*Data*/ ctx[70].Warrent;
    				add_flush_callback(() => updating_Checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);

    			if (/*Data*/ ctx[70].Warrent) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const textfield_changes = {};
    			if (dirty[0] & /*$CurrentReport*/ 16) textfield_changes.Select = /*GetReductionDropdown*/ ctx[28](/*Data*/ ctx[70].Charges);

    			if (!updating_Value && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_Value = true;
    				textfield_changes.Value = /*Data*/ ctx[70].Reduction;
    				add_flush_callback(() => updating_Value = false);
    			}

    			if (!updating_RealValue && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_RealValue = true;
    				textfield_changes.RealValue = /*Data*/ ctx[70].ReductionString;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield.$set(textfield_changes);
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const checkbox1_changes = {};

    			if (!updating_Checked_1 && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_Checked_1 = true;
    				checkbox1_changes.Checked = /*Data*/ ctx[70].PleadedGuilty;
    				add_flush_callback(() => updating_Checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);
    			const checkbox2_changes = {};

    			if (!updating_Checked_2 && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_Checked_2 = true;
    				checkbox2_changes.Checked = /*Data*/ ctx[70].Processed;
    				add_flush_callback(() => updating_Checked_2 = false);
    			}

    			checkbox2.$set(checkbox2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			transition_in(checkbox2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			transition_out(checkbox2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(checkbox0);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t2);
    			destroy_component(textfield, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div1);
    			destroy_component(checkbox1);
    			destroy_component(checkbox2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(754:16) {#if !$IsEms}",
    		ctx
    	});

    	return block;
    }

    // (776:20) <MdwPanelHeader style="flex-direction: column; height: max-content; padding-bottom: 0.5vh;">
    function create_default_slot_3$c(ctx) {
    	let h60;
    	let t1;
    	let h61;
    	let t2_value = /*GetMedicalBill*/ ctx[27](/*Data*/ ctx[70].Charges) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h60 = element("h6");
    			h60.textContent = "Final";
    			t1 = space();
    			h61 = element("h6");
    			t2 = text(t2_value);
    			set_style(h60, "font-size", "2.4vh");
    			set_style(h60, "height", "2.5vh");
    			add_location(h60, file$x, 776, 24, 34718);
    			add_location(h61, file$x, 777, 24, 34799);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h60, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h61, anchor);
    			append_dev(h61, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16 && t2_value !== (t2_value = /*GetMedicalBill*/ ctx[27](/*Data*/ ctx[70].Charges) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h60);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h61);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(776:20) <MdwPanelHeader style=\\\"flex-direction: column; height: max-content; padding-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (757:24) {#if Data.Warrent}
    function create_if_block_2$c(ctx) {
    	let textfield;
    	let updating_RealValue;
    	let current;

    	function textfield_RealValue_binding_1(value) {
    		/*textfield_RealValue_binding_1*/ ctx[60](value, /*Data*/ ctx[70]);
    	}

    	let textfield_props = { Title: "Expiration Date", Type: "date" };

    	if (/*Data*/ ctx[70].WarrentExpiration !== void 0) {
    		textfield_props.RealValue = /*Data*/ ctx[70].WarrentExpiration;
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'RealValue', textfield_RealValue_binding_1));

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};

    			if (!updating_RealValue && dirty[0] & /*$CurrentReport*/ 16) {
    				updating_RealValue = true;
    				textfield_changes.RealValue = /*Data*/ ctx[70].WarrentExpiration;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(757:24) {#if Data.Warrent}",
    		ctx
    	});

    	return block;
    }

    // (766:20) <MdwPanelHeader style="flex-direction: column; height: max-content; padding-bottom: 0.5vh;">
    function create_default_slot_2$d(ctx) {
    	let h60;
    	let t1;
    	let h61;
    	let t2_value = /*GetFinalString*/ ctx[26](/*Data*/ ctx[70].Reduction, /*Data*/ ctx[70].Charges) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h60 = element("h6");
    			h60.textContent = "Final";
    			t1 = space();
    			h61 = element("h6");
    			t2 = text(t2_value);
    			set_style(h60, "font-size", "2.4vh");
    			set_style(h60, "height", "2.5vh");
    			add_location(h60, file$x, 766, 24, 34036);
    			add_location(h61, file$x, 767, 24, 34117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h60, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h61, anchor);
    			append_dev(h61, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentReport*/ 16 && t2_value !== (t2_value = /*GetFinalString*/ ctx[26](/*Data*/ ctx[70].Reduction, /*Data*/ ctx[70].Charges) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h60);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h61);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(766:20) <MdwPanelHeader style=\\\"flex-direction: column; height: max-content; padding-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (734:12) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_1$g(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let mdwchip;
    	let t1;
    	let t2;
    	let hr;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let t4;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_4$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function click_handler_13() {
    		return /*click_handler_13*/ ctx[58](/*Data*/ ctx[70]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*$IsEms*/ ctx[6] ? "Edit Invoices" : "Edit Charges",
    				Color: "#ffffff"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_13);
    	let each_value_1 = /*Data*/ ctx[70].Charges;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block_1$f, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (!/*$IsEms*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(mdwchip.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			hr = element("hr");
    			t3 = space();
    			if_block.c();
    			t4 = space();
    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$x, 745, 16, 32381);
    			set_style(hr, "margin", "1vh auto");
    			set_style(hr, "width", "96.8%");
    			set_style(hr, "border", "none");
    			set_style(hr, "height", "0.2vh");
    			set_style(hr, "background-color", "rgb(34, 40, 49)");
    			add_location(hr, file$x, 752, 16, 32969);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(mdwchip, div, null);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			insert_dev(target, t2, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t4, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentReport*/ 16 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$IsEms*/ 64) mdwchip_changes.Text = /*$IsEms*/ ctx[6] ? "Edit Invoices" : "Edit Charges";
    			mdwchip.$set(mdwchip_changes);

    			if (dirty[0] & /*$CurrentReport*/ 16) {
    				each_value_1 = /*Data*/ ctx[70].Charges;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$a(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t4.parentNode, t4);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwchip.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwchip.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(mdwchip);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(734:12) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (733:8) {#each $CurrentReport.scums as Data, Key}
    function create_each_block$k(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(733:8) {#each $CurrentReport.scums as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (719:0) <MdwPanel>
    function create_default_slot$p(ctx) {
    	let mdwpanel;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: 4.3vh; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_5$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].scums && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);

    			if (/*$CurrentReport*/ ctx[4].id && /*$CurrentReport*/ ctx[4].scums) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentReport*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(719:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot_7$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*FilteredReports, MaxReports, CurrentCategory, $MdwProfile*/ 39 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms, ReportsEditor, $IsPublic*/ 216 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentReport, $IsEms*/ 80 | dirty[2] & /*$$scope*/ 524288) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $CurrentReport;
    	let $MdwModalsEvidence;
    	let $MdwProfile;
    	let $IsEms;
    	let $IsPublic;
    	validate_store(CurrentReport, 'CurrentReport');
    	component_subscribe($$self, CurrentReport, $$value => $$invalidate(4, $CurrentReport = $$value));
    	validate_store(MdwModalsEvidence, 'MdwModalsEvidence');
    	component_subscribe($$self, MdwModalsEvidence, $$value => $$invalidate(67, $MdwModalsEvidence = $$value));
    	validate_store(MdwProfile, 'MdwProfile');
    	component_subscribe($$self, MdwProfile, $$value => $$invalidate(5, $MdwProfile = $$value));
    	validate_store(IsEms, 'IsEms');
    	component_subscribe($$self, IsEms, $$value => $$invalidate(6, $IsEms = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(7, $IsPublic = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reports', slots, []);
    	let Reports = [];
    	let FilteredReports = [];
    	let MaxReports = 15;
    	let CurrentCategory = 'All';
    	let ReportsEditor;

    	const LoadMore = () => {
    		$$invalidate(1, MaxReports = MaxReports + 50);
    	};

    	const GenerateDefaultReport = () => {
    		let Template = $IsEms ? DefaultMedicalReport : DefaultReport;

    		switch ($CurrentReport.category) {
    			case "MCU Investigation Report":
    				Template = MCUReport;
    				break;
    			case "Civilian Report":
    				Template = CivilianReport;
    				break;
    			case "Vehicle Accident Report":
    				Template = VehicleReport;
    				break;
    			case "Mental Status Report":
    				Template = MentalReport;
    				break;
    			case "Physio Report":
    				Template = FysioReport;
    				break;
    			case "Burn Report":
    				Template = BurnReport;
    				break;
    			case "Gunshot Wound Report":
    				Template = GunshotReport;
    				break;
    			case "Prescription Report":
    				Template = ReceiptReport;
    				break;
    		}

    		// const Template = $IsEms ? DefaultMedicalReport : ($CurrentReport && $CurrentReport.category == "MCU Onderzoek Rapport" ? MCUReport : DefaultReport);
    		return Template.replace("[DEPARTMENT]", $MdwProfile.department == "RANGER"
    		? "SAPR"
    		: $MdwProfile.department).replace("[DATE_TIMESTAMP]", new Date().toLocaleString('en-US', {
    			timeZone: 'Europe/Amsterdam',
    			hour12: false,
    			year: 'numeric',
    			month: '2-digit',
    			day: '2-digit',
    			hour: '2-digit',
    			minute: '2-digit',
    			timeZoneName: 'short'
    		})).replace("[REPORTING_OFFICER]", `@${$MdwProfile.callsign} ${$MdwProfile.name}`);
    	};

    	const OnReportCategoryUpdate = () => {
    		if ($CurrentReport.id) return "";

    		setTimeout(
    			() => {
    				window.editor.setData(GenerateDefaultReport());
    			},
    			100
    		);

    		return "";
    	};

    	onMount(() => {
    		SendEvent("Reports/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Reports = Data;
    			FilterReports("");
    		});

    		if (ReportsEditor) {
    			BalloonEditor.create(ReportsEditor, {
    				supportAllValues: true,
    				toolbar: {
    					items: [
    						'heading',
    						'|',
    						'bold',
    						'italic',
    						'|',
    						'blockQuote',
    						'|',
    						'undo',
    						'redo',
    						'|',
    						'numberedList',
    						'bulletedList',
    						'|',
    						'insertTable'
    					],
    					shouldNotGroupWhenFull: true
    				},
    				placeholder: "Begin met typen..."
    			}).then(Editor => {
    				window.editor = Editor;

    				if ($CurrentReport.report) {
    					window.editor.setData($CurrentReport.report);
    				} else {
    					window.editor.setData(GenerateDefaultReport());
    					set_store_value(CurrentReport, $CurrentReport.category = GetReportTypes($MdwProfile.certs)[0].Value, $CurrentReport);
    				}
    			}).catch(Error => {
    				console.error(Error);
    			});
    		}
    	});

    	const DoesReportContainTag = (Tags, Query) => {
    		for (let i = 0; i < Tags.length; i++) {
    			const TagData = GetTagById(Tags[i]);

    			if (TagData && TagData.tag.toLowerCase().includes(Query)) {
    				return true;
    			}
    		}
    		return false;
    	};

    	const FilterReports = Value => {
    		const Search = Value.toLowerCase();

    		// Get report types user is allowed to see
    		const ReportTypes = GetReportTypes($MdwProfile.certs, true);

    		// Get reports by report allowed types
    		let CategorizedReports = Reports.filter(Val => {
    			return ReportTypes.includes(Val.category);
    		});

    		// Get reports by current category if not 'Alles'
    		if (CurrentCategory != 'All') CategorizedReports = CategorizedReports.filter(Val => Val.category == CurrentCategory);

    		// Filter them by search query.
    		$$invalidate(0, FilteredReports = CategorizedReports.filter(Val => {
    			return Val.title.toLowerCase().includes(Search) || Val.author.toLowerCase().includes(Search) || String(Val.id).toLowerCase().includes(Search) || Val.scums.toLowerCase().includes(Search) || DoesReportContainTag(Val.tags, Search);
    		}));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Reports/FetchById", { Id }, async (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentReport.set(Data);
    			window.editor.setData($CurrentReport.report);
    			let formattedScums = Data.scums;

    			for (let i = 0; i < formattedScums.length; i++) {
    				if (!formattedScums[i].ReductionString) {
    					formattedScums[i].ReductionString = "0% / 0 maanden / $ 0,00";
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.scums = formattedScums, $CurrentReport);
    			let formattedEvidence = [];

    			for (let i = 0; i < Data.evidence.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Evidence/FetchById", { Id: Data.evidence[i] });

    				if (Success) {
    					const EvidenceData = GetEvidenceById(Result.type);
    					let EvidenceText = Result.description;

    					if (Result.type == "Foto") {
    						EvidenceText = `Foto (${EvidenceText})`;
    					} else {
    						EvidenceText = `${Result.identifier} - (${EvidenceText})`;
    					}

    					formattedEvidence.push({
    						Color: EvidenceData?.Color || "#ffffff",
    						Text: EvidenceText,
    						Image: Result.type == "Foto" ? Result.identifier : false,
    						Id: formattedEvidence.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedEvidence = formattedEvidence, $CurrentReport);
    			let formattedOfficers = [];

    			for (let i = 0; i < Data.officers.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Staff/FetchById", { Id: Data.officers[i] });

    				if (Success) {
    					formattedOfficers.push({
    						Color: "#ffffff",
    						Text: `(${Result.callsign}) ${Result.name}`,
    						Id: formattedOfficers.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedOfficers = formattedOfficers, $CurrentReport);
    			let formattedPersons = [];

    			for (let i = 0; i < Data.persons.length; i++) {
    				const [Success, Result] = await AsyncSendEvent("Profiles/FetchById", { Id: Data.persons[i] });

    				if (Success) {
    					formattedPersons.push({
    						Color: "#ffffff",
    						Text: `${Result.name} (#${Result.citizenid})`,
    						Id: formattedPersons.length
    					});
    				}
    			}
    			set_store_value(CurrentReport, $CurrentReport.formattedPersons = formattedPersons, $CurrentReport);
    		});
    	};

    	const OnReportAction = Type => {
    		if (Type == "Reset") {
    			CurrentReport.set({
    				category: GetReportTypes($MdwProfile.certs)[0].Value,
    				title: '',
    				report: '',
    				evidence: [],
    				tags: [],
    				officers: [],
    				persons: [],
    				vehicles: [],
    				scums: []
    			});

    			window.editor.setData(GenerateDefaultReport());
    		} else if (Type == "Export") {
    			ShowLoader.set(true);

    			SendEvent("Reports/Export", { id: $CurrentReport.id }, (Success, Data) => {
    				ShowLoader.set(false);
    				if (!Success) return;
    				MdwModalsExport$1.set({ Show: true, Msg: Data.Msg });
    				if (Data.Url) CopyToClipboard(Data.Url);
    			});
    		} else if (Type == "Save") {
    			ShowLoader.set(true);

    			SendEvent(
    				"Reports/SaveReport",
    				{
    					report: window.editor.getData(),
    					title: $CurrentReport.title,
    					category: $CurrentReport.category,
    					id: $CurrentReport.id
    				},
    				(Success, Data) => {
    					ShowLoader.set(false);
    					if (!Success) return;

    					if (Data) {
    						let ReportsIndex = Reports.findIndex(Val => Val.id == $CurrentReport.id);

    						if (ReportsIndex > -1) {
    							Reports[ReportsIndex] = Data;
    						} else {
    							Reports = [Data, ...Reports];
    						}
    						FetchById(Data.id);
    						FilterReports("");
    					}
    				}
    			);
    		} else if (Type == "Delete") {
    			ShowLoader.set(true);

    			SendEvent("Reports/RemoveReport", { Id: $CurrentReport.id }, () => {
    				let ReportsIndex = Reports.findIndex(Val => Val.id == $CurrentReport.id);
    				if (ReportsIndex > -1) Reports.splice(ReportsIndex, 1);
    				FilterReports("");
    				ShowLoader.set(false);
    				OnReportAction("Reset");
    			});
    		}
    	};

    	// Reports
    	const GetReportsCategories = WithAll => {
    		let Retval = [];
    		if (WithAll) Retval.push({ Text: "All" });
    		const Types = GetReportTypes($MdwProfile.certs);
    		Retval = [...Retval, ...Types];
    		return Retval;
    	};

    	// Reports - Evidence
    	const AddEvidence = () => {
    		MdwModalsEvidence.set({
    			Show: true,
    			Form: $MdwModalsEvidence.Form,
    			Cb: (Create, Form) => {
    				ShowLoader.set(true);

    				SendEvent(
    					"Reports/AddEvidence",
    					{
    						ReportId: $CurrentReport.id,
    						Create,
    						Form
    					},
    					async (Success, Data) => {
    						ShowLoader.set(false);
    						if (!Success) return;
    						const [_Success, Result] = await AsyncSendEvent("Evidence/FetchById", { Id: Data });
    						const EvidenceData = GetEvidenceById(Result.type);
    						let EvidenceText = Result.description;

    						if (Result.type == "Foto") {
    							EvidenceText = `Foto (${EvidenceText})`;
    						} else {
    							EvidenceText = `${Result.identifier} - (${EvidenceText})`;
    						}

    						set_store_value(
    							CurrentReport,
    							$CurrentReport.formattedEvidence = [
    								...$CurrentReport.formattedEvidence,
    								{
    									Color: EvidenceData?.Color || "#ffffff",
    									Text: EvidenceText,
    									Image: Result.type == "Foto" ? Result.identifier : false,
    									Id: $CurrentReport.formattedEvidence.length
    								}
    							],
    							$CurrentReport
    						);
    					}
    				);
    			}
    		});
    	};

    	const RemoveEvidence = EvidenceId => {
    		if (!HasCidPermission("Reports.Edit")) return;

    		SendEvent("Reports/RemoveEvidence", { ReportId: $CurrentReport.id, EvidenceId }, (Success, Data) => {
    			if (!Success) return;
    			let NewReport = { ...$CurrentReport };
    			NewReport.evidence.splice(EvidenceId, 1);
    			NewReport.formattedEvidence.splice(EvidenceId, 1);
    			CurrentReport.set(NewReport);
    		});
    	};

    	// Reports - Involved Officers
    	const AddUnit = () => {
    		MdwModalsUnits.set({
    			Show: true,
    			IgnoreFilter: $CurrentReport.officers,
    			Cb: OfficerId => {
    				SendEvent("Reports/AddOfficer", { ReportId: $CurrentReport.id, OfficerId }, async (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentReport, $CurrentReport.officers = [...$CurrentReport.officers, OfficerId], $CurrentReport);
    					const [_Success, Result] = await AsyncSendEvent("Staff/FetchById", { Id: OfficerId });

    					set_store_value(
    						CurrentReport,
    						$CurrentReport.formattedOfficers = [
    							...$CurrentReport.formattedOfficers,
    							{
    								Color: "#ffffff",
    								Text: `(${Result.callsign}) ${Result.name}`,
    								Id: $CurrentReport.formattedOfficers.length
    							}
    						],
    						$CurrentReport
    					);
    				});
    			}
    		});
    	};

    	const RemoveUnit = OfficerId => {
    		if (!HasCidPermission("Reports.Edit")) return;

    		SendEvent("Reports/RemoveOfficer", { ReportId: $CurrentReport.id, OfficerId }, (Success, Data) => {
    			if (!Success) return;
    			let NewReport = { ...$CurrentReport };
    			NewReport.officers.splice(OfficerId, 1);
    			NewReport.formattedOfficers.splice(OfficerId, 1);
    			CurrentReport.set(NewReport);
    		});
    	};

    	// Reports - Involved Persons
    	const AddPerson = () => {
    		MdwModalsPerson.set({
    			Show: true,
    			IgnoreFilter: $CurrentReport.persons,
    			Cb: PersonId => {
    				SendEvent("Reports/AddPerson", { ReportId: $CurrentReport.id, PersonId }, async (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentReport, $CurrentReport.persons = [...$CurrentReport.persons, PersonId], $CurrentReport);
    					const [_Success, Result] = await AsyncSendEvent("Profiles/FetchById", { Id: PersonId });

    					set_store_value(
    						CurrentReport,
    						$CurrentReport.formattedPersons = [
    							...$CurrentReport.formattedPersons,
    							{
    								Color: "#ffffff",
    								Text: `${Result.name} (#${Result.citizenid})`,
    								Id: $CurrentReport.formattedPersons.length
    							}
    						],
    						$CurrentReport
    					);
    				});
    			}
    		});
    	};

    	const RemovePerson = PersonId => {
    		if (!HasCidPermission("Reports.Edit")) return;

    		SendEvent("Reports/RemovePerson", { ReportId: $CurrentReport.id, PersonId }, (Success, Data) => {
    			if (!Success) return;
    			let NewReport = { ...$CurrentReport };
    			NewReport.persons.splice(PersonId, 1);
    			NewReport.formattedPersons.splice(PersonId, 1);
    			CurrentReport.set(NewReport);
    		});
    	};

    	// Reports - Tags
    	const AddTag = () => {
    		MdwModalsTags.set({
    			Show: true,
    			IgnoreFilter: $CurrentReport.tags,
    			Cb: TagId => {
    				SendEvent("Reports/AddTag", { ReportId: $CurrentReport.id, TagId }, (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentReport, $CurrentReport.tags = [...$CurrentReport.tags, TagId], $CurrentReport);
    				});
    			}
    		});
    	};

    	const RemoveTag = TagId => {
    		SendEvent("Reports/RemoveTag", { ReportId: $CurrentReport.id, TagId }, (Success, Data) => {
    			if (!Success) return;
    			let NewReport = { ...$CurrentReport };
    			NewReport.tags.splice(TagId, 1);
    			CurrentReport.set(NewReport);
    		});
    	};

    	const AddSuspect = () => {
    		MdwModalsProfiles.set({
    			Show: true,
    			IgnoreFilter: $CurrentReport.scums.map(Value => Value.Cid),
    			Cb: Data => {
    				const ScumData = {
    					Charges: [],
    					Reduction: 0,
    					ReductionString: "0% / 0 maanden / $ 0,00",
    					PleadedGuilty: false,
    					Processed: false,
    					Warrent: false,
    					WarrentExpiration: false,
    					Cid: Data.citizenid,
    					Name: Data.name,
    					Id: Data.id
    				};

    				ShowLoader.set(true);

    				SendEvent("Reports/AddCriminalScum", { ReportId: $CurrentReport.id, ScumData }, (Success, Data) => {
    					ShowLoader.set(false);
    					if (!Success) return;
    					set_store_value(CurrentReport, $CurrentReport.scums = [...$CurrentReport.scums, ScumData], $CurrentReport);
    				});
    			}
    		});
    	};

    	const SaveScum = ScumId => {
    		ShowLoader.set(true);
    		let ScumData = $CurrentReport.scums[ScumId];

    		if (ScumData.Warrent) {
    			let NowDate = new Date().getTime();
    			let WarrentDate = new Date(ScumData.WarrentExpiration).getTime();

    			if (Number.isNaN(WarrentDate) || NowDate >= WarrentDate) {
    				ScumData.Warrent = false;
    				set_store_value(CurrentReport, $CurrentReport.scums[ScumId] = ScumData, $CurrentReport);
    			}
    		}

    		SendEvent(
    			"Reports/SaveScum",
    			{
    				ReportId: $CurrentReport.id,
    				ScumId,
    				ScumData
    			},
    			(Success, Data) => {
    				if (!Success) return;
    				ShowLoader.set(false);
    			}
    		);
    	};

    	const RemoveSuspect = ScumId => {
    		SendEvent("Reports/DeleteScum", { ReportId: $CurrentReport.id, ScumId }, (Success, Data) => {
    			if (!Success) return;
    			let NewReport = { ...$CurrentReport };
    			NewReport.scums.splice(ScumId, 1);
    			CurrentReport.set(NewReport);
    		});
    	};

    	const OpenChargesModal = ScumData => {
    		MdwModalsCharges.set({
    			Show: true,
    			Charges: ScumData.Charges,
    			Cb: Charges => {
    				let ScumId = $CurrentReport.scums.findIndex(Val => Val.Cid == ScumData.Cid);
    				if (ScumId > -1) set_store_value(CurrentReport, $CurrentReport.scums[ScumId].Charges = Charges, $CurrentReport);
    			}
    		});
    	};

    	const GetFinalString = (Reduction, Charges) => {
    		let TotalJail = 0;
    		let TotalFine = 0;
    		let TotalPoints = 0;
    		let TotalParole = 0;
    		let Charged = [];

    		for (let i = 0; i < Charges.length; i++) {
    			const Type = Charges[i].Type;
    			const Data = GetChargeById(Charges[i].Id);

    			if (Data) {
    				if (Type == "Principal") {
    					if (!Charged.includes(Charges[i].Id)) {
    						TotalJail += Number(Data.jail);
    						TotalFine += Number(Data.fine);
    						TotalPoints += Number(Data.points);
    					} else {
    						TotalParole += Data.jail;
    					}
    				} else if (Type == "Accomplice") {
    					if (!Charged.includes(Charges[i].Id)) {
    						TotalJail += Number(Data?.accomplice?.jail || 0);
    						TotalFine += Number(Data?.accomplice?.fine || 0);
    						TotalPoints += Number(Data?.accomplice?.points || 0);
    					} else {
    						TotalParole += Data?.accomplice?.jail || 0;
    					}
    				} else if (Type == "Attempted") {
    					if (!Charged.includes(Charges[i].Id)) {
    						TotalJail += Number(Data?.attempted?.jail || 0);
    						TotalFine += Number(Data?.attempted?.fine || 0);
    						TotalPoints += Number(Data?.attempted?.points || 0);
    					} else {
    						TotalParole += Number(Data?.attempted?.jail || 0);
    					}
    				}
    				Charged.push(Charges[i].Id);
    			}
    		}
    		let _Reduction = (100 - Number(Reduction)) / 100;

    		if (_Reduction < 1.0) {
    			const ReductedJail = 1.0 - _Reduction;
    			TotalParole += Math.ceil(TotalJail * ReductedJail);
    		}

    		if (TotalParole > 0) {
    			return `${Math.ceil(TotalJail * _Reduction)} maanden (+${TotalParole} voorwaardelijk) / ${FormatCurrency.format(TotalFine * _Reduction)} boete / ${TotalPoints} punt(en)`;
    		}
    		return `${Math.ceil(TotalJail * _Reduction)} maanden / ${FormatCurrency.format(TotalFine * _Reduction)} boete / ${TotalPoints} punt(en)`;
    	};

    	const GetMedicalBill = Charges => {
    		let TotalFine = 0;

    		for (let i = 0; i < Charges.length; i++) {
    			const Data = GetChargeById(Charges[i].Id);

    			if (Data) {
    				TotalFine += Data.fine;
    			}
    		}
    		return `${FormatCurrency.format(TotalFine)} factuur`;
    	};

    	const GetReductionDropdown = Charges => {
    		let TotalJail = 0;
    		let TotalFine = 0;
    		let Charged = [];

    		for (let i = 0; i < Charges.length; i++) {
    			const Type = Charges[i].Type;
    			const Data = GetChargeById(Charges[i].Id);

    			if (Data) {
    				if (Type == "Principal") {
    					TotalJail += Number(Data.jail);
    					if (!Charged.includes(Charges[i].Id)) TotalFine += Number(Data.fine);
    				} else if (Type == "Accomplice") {
    					TotalJail += Number(Data?.accomplice?.jail || 0);
    					if (!Charged.includes(Charges[i].Id)) TotalFine += Number(Data?.accomplice?.fine || 0);
    				} else if (Type == "Attempted") {
    					TotalJail += Number(Data?.attempted?.jail || 0);
    					if (!Charged.includes(Charges[i].Id)) TotalFine += Number(Data?.attempted?.fine || 0);
    				}
    				Charged = [...Charged, Charges[i].Id];
    			}
    		}

    		return [
    			{
    				Text: `0% / ${TotalJail} maanden / ${FormatCurrency.format(TotalFine)}`,
    				Value: "0"
    			},
    			{
    				Text: `20% / ${Math.ceil(TotalJail * 0.8)} maanden / ${FormatCurrency.format(TotalFine * 0.8)}`,
    				Value: "20"
    			},
    			{
    				Text: `40% / ${Math.ceil(TotalJail * 0.6)} maanden / ${FormatCurrency.format(TotalFine * 0.6)}`,
    				Value: "40"
    			},
    			{
    				Text: `60% / ${Math.ceil(TotalJail * 0.4)} maanden / ${FormatCurrency.format(TotalFine * 0.4)}`,
    				Value: "60"
    			}
    		];
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Reports> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function textfield_RealValue_binding(value) {
    		CurrentCategory = value;
    		$$invalidate(2, CurrentCategory);
    	}

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	const click_handler_1 = () => {
    		OnReportAction("Reset");
    	};

    	const click_handler_2 = () => {
    		OnReportAction("Export");
    	};

    	const click_handler_3 = () => {
    		OnReportAction("Delete");
    	};

    	const click_handler_4 = () => {
    		OnReportAction("Save");
    	};

    	const click_handler_5 = () => {
    		OnReportAction("Save");
    	};

    	function textfield0_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentReport.category, value)) {
    			$CurrentReport.category = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentReport.title, value)) {
    			$CurrentReport.title = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			ReportsEditor = $$value;
    			$$invalidate(3, ReportsEditor);
    		});
    	}

    	const click_handler_6 = Data => {
    		RemoveEvidence(Data.Id);
    	};

    	const click_handler_7 = Data => {
    		RemoveEvidence(Data.Id);
    	};

    	const click_handler_8 = Data => {
    		RemoveUnit(Data.Id);
    	};

    	const click_handler_9 = Data => {
    		RemovePerson(Data.Id);
    	};

    	const click_handler_10 = Key => {
    		RemoveTag(Key);
    	};

    	const click_handler_11 = Key => {
    		RemoveSuspect(Key);
    	};

    	const click_handler_12 = Key => {
    		SaveScum(Key);
    	};

    	const click_handler_13 = Data => {
    		OpenChargesModal(Data);
    	};

    	function checkbox0_Checked_binding(value, Data) {
    		if ($$self.$$.not_equal(Data.Warrent, value)) {
    			Data.Warrent = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function textfield_RealValue_binding_1(value, Data) {
    		if ($$self.$$.not_equal(Data.WarrentExpiration, value)) {
    			Data.WarrentExpiration = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function textfield_Value_binding(value, Data) {
    		if ($$self.$$.not_equal(Data.Reduction, value)) {
    			Data.Reduction = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function textfield_RealValue_binding_2(value, Data) {
    		if ($$self.$$.not_equal(Data.ReductionString, value)) {
    			Data.ReductionString = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function checkbox1_Checked_binding(value, Data) {
    		if ($$self.$$.not_equal(Data.PleadedGuilty, value)) {
    			Data.PleadedGuilty = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function checkbox2_Checked_binding(value, Data) {
    		if ($$self.$$.not_equal(Data.Processed, value)) {
    			Data.Processed = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	function checkbox_Checked_binding(value, Data) {
    		if ($$self.$$.not_equal(Data.Processed, value)) {
    			Data.Processed = value;
    			CurrentReport.set($CurrentReport);
    		}
    	}

    	$$self.$capture_state = () => ({
    		DefaultReport,
    		MCUReport,
    		DefaultMedicalReport,
    		GetReportTypes,
    		CivilianReport,
    		BalloonEditor,
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		MdwCard,
    		MdwChip,
    		Button,
    		TextField,
    		Checkbox,
    		ImageHover,
    		onMount,
    		AsyncSendEvent,
    		CopyToClipboard,
    		Delay,
    		FormatCurrency,
    		GetChargeById,
    		GetEvidenceById,
    		GetTagById,
    		GetTimeLabel,
    		HasCidPermission,
    		SendEvent,
    		CurrentReport,
    		IsPublic,
    		IsEms,
    		MdwModalsCharges,
    		MdwModalsEvidence,
    		MdwModalsPerson,
    		MdwModalsProfiles,
    		MdwModalsTags,
    		MdwModalsUnits,
    		MdwModalsExport: MdwModalsExport$1,
    		MdwProfile,
    		ShowLoader,
    		Reports,
    		FilteredReports,
    		MaxReports,
    		CurrentCategory,
    		ReportsEditor,
    		LoadMore,
    		GenerateDefaultReport,
    		OnReportCategoryUpdate,
    		DoesReportContainTag,
    		FilterReports,
    		FetchById,
    		OnReportAction,
    		GetReportsCategories,
    		AddEvidence,
    		RemoveEvidence,
    		AddUnit,
    		RemoveUnit,
    		AddPerson,
    		RemovePerson,
    		AddTag,
    		RemoveTag,
    		AddSuspect,
    		SaveScum,
    		RemoveSuspect,
    		OpenChargesModal,
    		GetFinalString,
    		GetMedicalBill,
    		GetReductionDropdown,
    		$CurrentReport,
    		$MdwModalsEvidence,
    		$MdwProfile,
    		$IsEms,
    		$IsPublic
    	});

    	$$self.$inject_state = $$props => {
    		if ('Reports' in $$props) Reports = $$props.Reports;
    		if ('FilteredReports' in $$props) $$invalidate(0, FilteredReports = $$props.FilteredReports);
    		if ('MaxReports' in $$props) $$invalidate(1, MaxReports = $$props.MaxReports);
    		if ('CurrentCategory' in $$props) $$invalidate(2, CurrentCategory = $$props.CurrentCategory);
    		if ('ReportsEditor' in $$props) $$invalidate(3, ReportsEditor = $$props.ReportsEditor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredReports,
    		MaxReports,
    		CurrentCategory,
    		ReportsEditor,
    		$CurrentReport,
    		$MdwProfile,
    		$IsEms,
    		$IsPublic,
    		LoadMore,
    		OnReportCategoryUpdate,
    		FilterReports,
    		FetchById,
    		OnReportAction,
    		GetReportsCategories,
    		AddEvidence,
    		RemoveEvidence,
    		AddUnit,
    		RemoveUnit,
    		AddPerson,
    		RemovePerson,
    		AddTag,
    		RemoveTag,
    		AddSuspect,
    		SaveScum,
    		RemoveSuspect,
    		OpenChargesModal,
    		GetFinalString,
    		GetMedicalBill,
    		GetReductionDropdown,
    		keyup_handler_11,
    		keyup_handler_10,
    		keyup_handler_9,
    		keyup_handler_8,
    		keyup_handler_7,
    		keyup_handler_6,
    		keyup_handler_5,
    		keyup_handler_3,
    		keyup_handler_2,
    		keyup_handler_1,
    		keyup_handler,
    		keyup_handler_4,
    		textfield_RealValue_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		textfield0_RealValue_binding,
    		textfield1_RealValue_binding,
    		div2_binding,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9,
    		click_handler_10,
    		click_handler_11,
    		click_handler_12,
    		click_handler_13,
    		checkbox0_Checked_binding,
    		textfield_RealValue_binding_1,
    		textfield_Value_binding,
    		textfield_RealValue_binding_2,
    		checkbox1_Checked_binding,
    		checkbox2_Checked_binding,
    		checkbox_Checked_binding
    	];
    }

    class Reports_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$y, create_fragment$y, safe_not_equal, {}, null, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reports_1",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Profiles.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1$3, console: console_1$2 } = globals;
    const file$w = "src\\apps\\Mdw\\apps\\Profiles.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	const constants_0 = GetChargeById(/*Data*/ child_ctx[34].Id);
    	child_ctx[35] = constants_0;
    	return child_ctx;
    }

    function get_each_context_1$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i][0];
    	child_ctx[43] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    // (180:4) <MdwPanelHeader>
    function create_default_slot_18$1(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterProfiles*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Profiles";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$w, 180, 8, 6403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$1.name,
    		type: "slot",
    		source: "(180:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (186:8) {#each FilteredProfiles.slice(0, MaxProfiles) as Data, Key}
    function create_each_block_6(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[20](/*Data*/ ctx[34]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [[/*Data*/ ctx[34].name], [`ID: ${/*Data*/ ctx[34].citizenid}`]]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};
    			if (dirty[0] & /*FilteredProfiles, MaxProfiles*/ 3) mdwcard_changes.Information = [[/*Data*/ ctx[34].name], [`ID: ${/*Data*/ ctx[34].citizenid}`]];
    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(186:8) {#each FilteredProfiles.slice(0, MaxProfiles) as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (193:8) {#if FilteredProfiles.length > 5}
    function create_if_block_22(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				Color: "success",
    				click: /*LoadMore*/ ctx[7],
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			set_style(div, "display", "flex");
    			set_style(div, "justify-content", "center");
    			set_style(div, "width", "100%");
    			add_location(div, file$w, 193, 12, 6855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(193:8) {#if FilteredProfiles.length > 5}",
    		ctx
    	});

    	return block;
    }

    // (195:16) <Button Color="success" click={LoadMore}>
    function create_default_slot_17$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Load More");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(195:16) <Button Color=\\\"success\\\" click={LoadMore}>",
    		ctx
    	});

    	return block;
    }

    // (185:4) <MdwPanelList>
    function create_default_slot_16$1(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;
    	let each_value_6 = /*FilteredProfiles*/ ctx[0].slice(0, /*MaxProfiles*/ ctx[1]);
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*FilteredProfiles*/ ctx[0].length > 5 && create_if_block_22(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*FilteredProfiles, MaxProfiles, FetchById*/ 515) {
    				each_value_6 = /*FilteredProfiles*/ ctx[0].slice(0, /*MaxProfiles*/ ctx[1]);
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*FilteredProfiles*/ ctx[0].length > 5) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*FilteredProfiles*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_22(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(185:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (179:0) <MdwPanel class="filled">
    function create_default_slot_15$1(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_18$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty[0] & /*FilteredProfiles, MaxProfiles*/ 3 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(179:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (205:8) {:else}
    function create_else_block_2$2(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Add Profile";
    			add_location(h6, file$w, 205, 12, 7249);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(205:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (203:8) {#if $CurrentProfile.id}
    function create_if_block_21(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*$CurrentProfile*/ ctx[3].citizenid + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Edit Profile (#");
    			t1 = text(t1_value);
    			t2 = text(")");
    			add_location(h6, file$w, 203, 12, 7166);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8 && t1_value !== (t1_value = /*$CurrentProfile*/ ctx[3].citizenid + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(203:8) {#if $CurrentProfile.id}",
    		ctx
    	});

    	return block;
    }

    // (209:8) {#if !$IsPublic}
    function create_if_block_15(ctx) {
    	let div;
    	let show_if;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$CurrentProfile*/ ctx[3].id) return create_if_block_16;
    		if (show_if == null) show_if = !!HasCidPermission("Profiles.Create");
    		if (show_if) return create_if_block_20;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$w, 209, 12, 7326);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(209:8) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (216:20) {#if HasCidPermission("Profiles.Create")}
    function create_if_block_20(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$w, 215, 62, 8006);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_3*/ ctx[19], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_4*/ ctx[24], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(216:20) {#if HasCidPermission(\\\"Profiles.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (211:16) {#if $CurrentProfile.id}
    function create_if_block_16(ctx) {
    	let show_if_2 = HasCidPermission("Profiles.Create");
    	let t0;
    	let show_if_1 = HasCidPermission("Profiles.Delete");
    	let t1;
    	let show_if = HasCidPermission("Profiles.Edit");
    	let if_block2_anchor;
    	let if_block0 = show_if_2 && create_if_block_19(ctx);
    	let if_block1 = show_if_1 && create_if_block_18(ctx);
    	let if_block2 = show_if && create_if_block_17(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if_2) if_block0.p(ctx, dirty);
    			if (show_if_1) if_block1.p(ctx, dirty);
    			if (show_if) if_block2.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(211:16) {#if $CurrentProfile.id}",
    		ctx
    	});

    	return block;
    }

    // (212:20) {#if HasCidPermission("Profiles.Create")}
    function create_if_block_19(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "New");
    			attr_dev(i, "class", "fas fa-sync");
    			add_location(i, file$w, 211, 62, 7465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[18], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_1*/ ctx[21], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(212:20) {#if HasCidPermission(\\\"Profiles.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (213:20) {#if HasCidPermission("Profiles.Delete")}
    function create_if_block_18(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Delete");
    			attr_dev(i, "class", "fas fa-trash");
    			add_location(i, file$w, 212, 62, 7636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[17], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_2*/ ctx[22], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(213:20) {#if HasCidPermission(\\\"Profiles.Delete\\\")}",
    		ctx
    	});

    	return block;
    }

    // (214:20) {#if HasCidPermission("Profiles.Edit")}
    function create_if_block_17(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$w, 213, 60, 7810);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_2*/ ctx[16], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_3*/ ctx[23], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(214:20) {#if HasCidPermission(\\\"Profiles.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (202:4) <MdwPanelHeader>
    function create_default_slot_14$1(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$CurrentProfile*/ ctx[3].id) return create_if_block_21;
    		return create_else_block_2$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*$IsPublic*/ ctx[4] && create_if_block_15(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (!/*$IsPublic*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_15(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(202:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (224:12) {#if $CurrentProfile.wanted}
    function create_if_block_14(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "position", "absolute");
    			set_style(div, "width", "19vh");
    			set_style(div, "height", "19vh");
    			set_style(div, "transform", "rotate(-45deg)");
    			set_style(div, "background-image", "url(./images/wanted.png)");
    			set_style(div, "background-position", "center center");
    			set_style(div, "background-repeat", "no-repeat");
    			set_style(div, "background-size", "100% 80%");
    			add_location(div, file$w, 224, 16, 8432);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(224:12) {#if $CurrentProfile.wanted}",
    		ctx
    	});

    	return block;
    }

    // (237:4) {#if HasCidPermission("Profiles.ShowNotes")}
    function create_if_block_13$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "mdw-profile-editor svelte-1pf96ol");
    			add_location(div, file$w, 237, 8, 9372);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[28](div);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[28](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(237:4) {#if HasCidPermission(\\\"Profiles.ShowNotes\\\")}",
    		ctx
    	});

    	return block;
    }

    // (201:0) <MdwPanel class="filled">
    function create_default_slot_13$1(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div2;
    	let div0;
    	let t1;
    	let img;
    	let img_src_value;
    	let t2;
    	let div1;
    	let textfield0;
    	let updating_RealValue;
    	let t3;
    	let textfield1;
    	let updating_RealValue_1;
    	let t4;
    	let textfield2;
    	let updating_RealValue_2;
    	let t5;
    	let show_if = HasCidPermission("Profiles.ShowNotes");
    	let if_block1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = /*$CurrentProfile*/ ctx[3].wanted && create_if_block_14(ctx);

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[25](value);
    	}

    	let textfield0_props = {
    		style: "margin-bottom: 0px;",
    		Title: "SSN",
    		Icon: "id-card"
    	};

    	if (/*$CurrentProfile*/ ctx[3].citizenid !== void 0) {
    		textfield0_props.RealValue = /*$CurrentProfile*/ ctx[3].citizenid;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[26](value);
    	}

    	let textfield1_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Name",
    		Icon: "user"
    	};

    	if (/*$CurrentProfile*/ ctx[3].name !== void 0) {
    		textfield1_props.RealValue = /*$CurrentProfile*/ ctx[3].name;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	function textfield2_RealValue_binding(value) {
    		/*textfield2_RealValue_binding*/ ctx[27](value);
    	}

    	let textfield2_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Profile Photo URL",
    		Icon: "clipboard"
    	};

    	if (/*$CurrentProfile*/ ctx[3].image !== void 0) {
    		textfield2_props.RealValue = /*$CurrentProfile*/ ctx[3].image;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'RealValue', textfield2_RealValue_binding));
    	let if_block1 = show_if && create_if_block_13$1(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			img = element("img");
    			t2 = space();
    			div1 = element("div");
    			create_component(textfield0.$$.fragment);
    			t3 = space();
    			create_component(textfield1.$$.fragment);
    			t4 = space();
    			create_component(textfield2.$$.fragment);
    			t5 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (!src_url_equal(img.src, img_src_value = /*$CurrentProfile*/ ctx[3].image || "./images/mugshot.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			set_style(img, "width", "19vh");
    			set_style(img, "height", "19vh");
    			set_style(img, "border", "0.15vh solid black");
    			add_location(img, file$w, 226, 12, 8695);
    			set_style(div0, "height", "19.3vh");
    			set_style(div0, "width", "19.3vh");
    			add_location(div0, file$w, 222, 8, 8328);
    			set_style(div1, "margin-left", "0.7vh");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$w, 229, 8, 8856);
    			set_style(div2, "display", "flex");
    			set_style(div2, "flex-direction", "row");
    			set_style(div2, "width", "97%");
    			set_style(div2, "height", "19.4vh");
    			set_style(div2, "margin-left", "auto");
    			set_style(div2, "margin-right", "auto");
    			add_location(div2, file$w, 221, 4, 8202);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t1);
    			append_dev(div0, img);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t3);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t4);
    			mount_component(textfield2, div1, null);
    			insert_dev(target, t5, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentProfile, $IsPublic*/ 24 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].wanted) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_14(ctx);
    					if_block0.c();
    					if_block0.m(div0, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*$CurrentProfile*/ 8 && !src_url_equal(img.src, img_src_value = /*$CurrentProfile*/ ctx[3].image || "./images/mugshot.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty[0] & /*$CurrentProfile*/ 8) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*$CurrentProfile*/ ctx[3].citizenid;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_RealValue_1 && dirty[0] & /*$CurrentProfile*/ 8) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$CurrentProfile*/ ctx[3].name;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_RealValue_2 && dirty[0] & /*$CurrentProfile*/ 8) {
    				updating_RealValue_2 = true;
    				textfield2_changes.RealValue = /*$CurrentProfile*/ ctx[3].image;
    				add_flush_callback(() => updating_RealValue_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			if (show_if) if_block1.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			if (detaching) detach_dev(t5);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(201:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (244:8) <MdwPanelHeader>
    function create_default_slot_12$2(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*GetPriorPoints*/ ctx[14](/*$CurrentProfile*/ ctx[3].priors) + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Licenses (");
    			t1 = text(t1_value);
    			t2 = text(" points)");
    			add_location(h6, file$w, 244, 12, 9609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8 && t1_value !== (t1_value = /*GetPriorPoints*/ ctx[14](/*$CurrentProfile*/ ctx[3].priors) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(244:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (248:8) {#if $CurrentProfile.id && $CurrentProfile.licenses}
    function create_if_block_10$4(ctx) {
    	let div;
    	let current;
    	let each_value_5 = Object.entries(/*$CurrentProfile*/ ctx[3].licenses);
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 248, 12, 9781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile, RevokeLicense, $IsGov, $IsJudge*/ 2152) {
    				each_value_5 = Object.entries(/*$CurrentProfile*/ ctx[3].licenses);
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$4.name,
    		type: "if",
    		source: "(248:8) {#if $CurrentProfile.id && $CurrentProfile.licenses}",
    		ctx
    	});

    	return block;
    }

    // (251:20) {#if Value}
    function create_if_block_11$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_12$1, create_else_block_1$6];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$IsGov*/ ctx[5] || /*$IsJudge*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$2.name,
    		type: "if",
    		source: "(251:20) {#if Value}",
    		ctx
    	});

    	return block;
    }

    // (254:24) {:else}
    function create_else_block_1$6(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: LicensesLocale[/*License*/ ctx[42]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = LicensesLocale[/*License*/ ctx[42]];
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(254:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (252:24) {#if $IsGov || $IsJudge}
    function create_if_block_12$1(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[29](/*License*/ ctx[42]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: LicensesLocale[/*License*/ ctx[42]],
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_5);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = LicensesLocale[/*License*/ ctx[42]];
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(252:24) {#if $IsGov || $IsJudge}",
    		ctx
    	});

    	return block;
    }

    // (250:16) {#each Object.entries($CurrentProfile.licenses) as [License, Value]}
    function create_each_block_5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*Value*/ ctx[43] && create_if_block_11$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*Value*/ ctx[43]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_11$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(250:16) {#each Object.entries($CurrentProfile.licenses) as [License, Value]}",
    		ctx
    	});

    	return block;
    }

    // (243:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_11$3(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].licenses && create_if_block_10$4(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].licenses) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_10$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(243:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (263:4) {#if !$IsPublic}
    function create_if_block_6$6(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$6.name,
    		type: "if",
    		source: "(263:4) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (269:20) {#if $CurrentProfile.id && HasCidPermission("Profiles.Edit")}
    function create_if_block_9$5(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$w, 269, 24, 10786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_4*/ ctx[15], false, false, false, false),
    					listen_dev(i, "click", /*AddTag*/ ctx[12], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$5.name,
    		type: "if",
    		source: "(269:20) {#if $CurrentProfile.id && HasCidPermission(\\\"Profiles.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (265:12) <MdwPanelHeader>
    function create_default_slot_10$3(ctx) {
    	let h6;
    	let t1;
    	let div;
    	let show_if = /*$CurrentProfile*/ ctx[3].id && HasCidPermission("Profiles.Edit");
    	let if_block = show_if && create_if_block_9$5(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Tags";
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$w, 265, 16, 10603);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$w, 267, 16, 10644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8) show_if = /*$CurrentProfile*/ ctx[3].id && HasCidPermission("Profiles.Edit");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_9$5(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(265:12) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (275:12) {#if $CurrentProfile.id && $CurrentProfile.tags}
    function create_if_block_7$6(ctx) {
    	let div;
    	let current;
    	let each_value_4 = /*$CurrentProfile*/ ctx[3].tags;
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 275, 16, 11004);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile, RemoveTag*/ 8200) {
    				each_value_4 = /*$CurrentProfile*/ ctx[3].tags;
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$6.name,
    		type: "if",
    		source: "(275:12) {#if $CurrentProfile.id && $CurrentProfile.tags}",
    		ctx
    	});

    	return block;
    }

    // (280:24) {:else}
    function create_else_block$9(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[34]).tag,
    				Color: GetTagById(/*Data*/ ctx[34]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[34]).icon
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[34]).tag;
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[34]).color;
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[34]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(280:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (278:24) {#if HasCidPermission("Profiles.Edit")}
    function create_if_block_8$6(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[30](/*Key*/ ctx[37]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[34]).tag,
    				Color: GetTagById(/*Data*/ ctx[34]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[34]).icon,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_6);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[34]).tag;
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[34]).color;
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[34]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$6.name,
    		type: "if",
    		source: "(278:24) {#if HasCidPermission(\\\"Profiles.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (277:20) {#each $CurrentProfile.tags as Data, Key}
    function create_each_block_4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_8$6, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (HasCidPermission("Profiles.Edit")) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(277:20) {#each $CurrentProfile.tags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (264:8) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_9$3(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].tags && create_if_block_7$6(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].tags) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_7$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(264:8) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (290:8) <MdwPanelHeader>
    function create_default_slot_8$3(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Vehicles";
    			add_location(h6, file$w, 290, 12, 11869);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(290:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (294:8) {#if $CurrentProfile.id && $CurrentProfile.vehicles}
    function create_if_block_5$8(ctx) {
    	let div;
    	let current;
    	let each_value_3 = /*$CurrentProfile*/ ctx[3].vehicles;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 294, 12, 11991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8) {
    				each_value_3 = /*$CurrentProfile*/ ctx[3].vehicles;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$8.name,
    		type: "if",
    		source: "(294:8) {#if $CurrentProfile.id && $CurrentProfile.vehicles}",
    		ctx
    	});

    	return block;
    }

    // (296:16) {#each $CurrentProfile.vehicles as Data, Key}
    function create_each_block_3$1(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_7() {
    		return /*click_handler_7*/ ctx[31](/*Data*/ ctx[34]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: "" + (/*Data*/ ctx[34].Plate + " - " + /*Data*/ ctx[34].Vehicle)
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_7);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = "" + (/*Data*/ ctx[34].Plate + " - " + /*Data*/ ctx[34].Vehicle);
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(296:16) {#each $CurrentProfile.vehicles as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (289:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_7$5(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].vehicles && create_if_block_5$8(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].vehicles) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$5.name,
    		type: "slot",
    		source: "(289:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (303:4) {#if HasCidPermission("Profiles.ShowHousing")}
    function create_if_block_3$9(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_5$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$9.name,
    		type: "if",
    		source: "(303:4) {#if HasCidPermission(\\\"Profiles.ShowHousing\\\")}",
    		ctx
    	});

    	return block;
    }

    // (305:12) <MdwPanelHeader>
    function create_default_slot_6$7(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Housing";
    			add_location(h6, file$w, 305, 16, 12584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$7.name,
    		type: "slot",
    		source: "(305:12) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (308:12) {#if $CurrentProfile.id && $CurrentProfile.housing}
    function create_if_block_4$8(ctx) {
    	let div;
    	let current;
    	let each_value_2 = /*$CurrentProfile*/ ctx[3].housing;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 308, 16, 12714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8) {
    				each_value_2 = /*$CurrentProfile*/ ctx[3].housing;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$8.name,
    		type: "if",
    		source: "(308:12) {#if $CurrentProfile.id && $CurrentProfile.housing}",
    		ctx
    	});

    	return block;
    }

    // (310:20) {#each $CurrentProfile.housing as Data, Key}
    function create_each_block_2$3(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: "" + (/*Data*/ ctx[34].Adress + " (" + (/*Data*/ ctx[34].Owner ? "Owner" : "Keyholder") + ")")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = "" + (/*Data*/ ctx[34].Adress + " (" + (/*Data*/ ctx[34].Owner ? "Owner" : "Keyholder") + ")");
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(310:20) {#each $CurrentProfile.housing as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (304:8) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_5$a(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_6$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].housing && create_if_block_4$8(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].housing) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$a.name,
    		type: "slot",
    		source: "(304:8) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (319:8) <MdwPanelHeader>
    function create_default_slot_4$b(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Employment";
    			add_location(h6, file$w, 319, 12, 13219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$b.name,
    		type: "slot",
    		source: "(319:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (323:8) {#if $CurrentProfile.id && $CurrentProfile.employment}
    function create_if_block_2$b(ctx) {
    	let div;
    	let current;
    	let each_value_1 = /*$CurrentProfile*/ ctx[3].employment;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 323, 12, 13345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8) {
    				each_value_1 = /*$CurrentProfile*/ ctx[3].employment;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$9(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(323:8) {#if $CurrentProfile.id && $CurrentProfile.employment}",
    		ctx
    	});

    	return block;
    }

    // (325:16) {#each $CurrentProfile.employment as Data, Key}
    function create_each_block_1$9(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: "" + (/*Data*/ ctx[34].Business + " (" + /*Data*/ ctx[34].Role + ")")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = "" + (/*Data*/ ctx[34].Business + " (" + /*Data*/ ctx[34].Role + ")");
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$9.name,
    		type: "each",
    		source: "(325:16) {#each $CurrentProfile.employment as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (318:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_3$b(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_4$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].employment && create_if_block_2$b(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].employment) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(318:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (333:8) <MdwPanelHeader>
    function create_default_slot_2$c(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "History";
    			add_location(h6, file$w, 333, 12, 13795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(333:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (337:8) {#if $CurrentProfile.id && $CurrentProfile.priors}
    function create_if_block$p(ctx) {
    	let div;
    	let current;
    	let each_value = /*$CurrentProfile*/ ctx[3].priors;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$w, 337, 12, 13914);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentProfile*/ 8) {
    				each_value = /*$CurrentProfile*/ ctx[3].priors;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(337:8) {#if $CurrentProfile.id && $CurrentProfile.priors}",
    		ctx
    	});

    	return block;
    }

    // (341:20) {#if Charge}
    function create_if_block_1$e(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: "" + ((/*Data*/ ctx[34].Amount > 1
    				? `(${/*Data*/ ctx[34].Amount}x) `
    				: "") + /*Charge*/ ctx[35].name)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8) mdwchip_changes.Text = "" + ((/*Data*/ ctx[34].Amount > 1
    			? `(${/*Data*/ ctx[34].Amount}x) `
    			: "") + /*Charge*/ ctx[35].name);

    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(341:20) {#if Charge}",
    		ctx
    	});

    	return block;
    }

    // (339:16) {#each $CurrentProfile.priors as Data, Key}
    function create_each_block$j(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*Charge*/ ctx[35] && create_if_block_1$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*Charge*/ ctx[35]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(339:16) {#each $CurrentProfile.priors as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (332:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_1$f(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].priors && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentProfile*/ ctx[3].id && /*$CurrentProfile*/ ctx[3].priors) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentProfile*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(332:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (242:0) <MdwPanel>
    function create_default_slot$o(ctx) {
    	let mdwpanel0;
    	let t0;
    	let t1;
    	let mdwpanel1;
    	let t2;
    	let show_if = HasCidPermission("Profiles.ShowHousing");
    	let t3;
    	let mdwpanel2;
    	let t4;
    	let mdwpanel3;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = !/*$IsPublic*/ ctx[4] && create_if_block_6$6(ctx);

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_7$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = show_if && create_if_block_3$9(ctx);

    	mdwpanel2 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_3$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel3 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			create_component(mdwpanel2.$$.fragment);
    			t4 = space();
    			create_component(mdwpanel3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(mdwpanel3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*$CurrentProfile, $IsGov, $IsJudge*/ 104 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);

    			if (!/*$IsPublic*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*$IsPublic*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			if (show_if) if_block1.p(ctx, dirty);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    			const mdwpanel3_changes = {};

    			if (dirty[0] & /*$CurrentProfile*/ 8 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel3_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel3.$set(mdwpanel3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(mdwpanel2.$$.fragment, local);
    			transition_in(mdwpanel3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(mdwpanel2.$$.fragment, local);
    			transition_out(mdwpanel3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(mdwpanel2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(mdwpanel3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(242:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*FilteredProfiles, MaxProfiles*/ 3 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*ProfileEditor, $CurrentProfile, $IsPublic*/ 28 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentProfile, $IsPublic, $IsGov, $IsJudge*/ 120 | dirty[1] & /*$$scope*/ 65536) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $CurrentProfile;
    	let $IsPublic;
    	let $IsGov;
    	let $IsJudge;
    	validate_store(CurrentProfile, 'CurrentProfile');
    	component_subscribe($$self, CurrentProfile, $$value => $$invalidate(3, $CurrentProfile = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(4, $IsPublic = $$value));
    	validate_store(IsGov, 'IsGov');
    	component_subscribe($$self, IsGov, $$value => $$invalidate(5, $IsGov = $$value));
    	validate_store(IsJudge, 'IsJudge');
    	component_subscribe($$self, IsJudge, $$value => $$invalidate(6, $IsJudge = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Profiles', slots, []);
    	let Profiles = [];
    	let FilteredProfiles = [];
    	let MaxProfiles = 15;
    	let ProfileEditor;

    	const LoadMore = () => {
    		$$invalidate(1, MaxProfiles = MaxProfiles + 50);
    	};

    	onMount(() => {
    		SendEvent("Profiles/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Profiles = Data;
    			$$invalidate(0, FilteredProfiles = Data);
    		});

    		if (ProfileEditor) {
    			BalloonEditor.create(ProfileEditor, {
    				supportAllValues: true,
    				toolbar: {
    					items: [
    						'heading',
    						'|',
    						'bold',
    						'italic',
    						'|',
    						'blockQuote',
    						'|',
    						'undo',
    						'redo',
    						'|',
    						'numberedList',
    						'bulletedList',
    						'|',
    						'insertTable'
    					],
    					shouldNotGroupWhenFull: true
    				},
    				placeholder: "Begin met typen..."
    			}).then(Editor => {
    				window.editor = Editor;
    				if ($CurrentProfile.notes) window.editor.setData($CurrentProfile.notes);
    			}).catch(Error => {
    				console.error(Error);
    			});
    		}
    	});

    	onDestroy(() => {
    		if (window.editor) window.editor.destroy();
    	});

    	const DoesProfileContainTag = (Tags, Query) => {
    		for (let i = 0; i < Tags.length; i++) {
    			const TagData = GetTagById(Tags[i]);

    			if (TagData && TagData.tag.toLowerCase().includes(Query)) {
    				return true;
    			}
    		}
    		return false;
    	};

    	const FilterProfiles = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredProfiles = Profiles.filter(Val => {
    			return Val.citizenid.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search) || Val.notes.toLowerCase().includes(Search) || DoesProfileContainTag(Val.tags, Search);
    		}));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Profiles/FetchById", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentProfile.set(Data);
    			window.editor.setData(Data.notes);
    		});
    	};

    	const OnProfileAction = Type => {
    		if (Type == "Reset") {
    			CurrentProfile.set({
    				citizenid: "",
    				name: "",
    				image: "",
    				notes: ""
    			});

    			window.editor.setData("");
    		} else if (Type == "Save") {
    			ShowLoader.set(true);

    			SendEvent(
    				"Profiles/SaveProfile",
    				{
    					citizenid: $CurrentProfile.citizenid,
    					name: $CurrentProfile.name,
    					image: $CurrentProfile.image,
    					notes: window.editor.getData(),
    					id: $CurrentProfile.id
    				},
    				(Success, Data) => {
    					ShowLoader.set(false);
    					if (!Success) return;

    					if (Data) {
    						let ProfileIndex = Profiles.findIndex(Val => Val.id == $CurrentProfile.id);
    						console.log(ProfileIndex);

    						if (ProfileIndex > -1) {
    							Profiles[ProfileIndex] = Data;
    						} else {
    							Profiles = [Data, ...Profiles];
    						}

    						FetchById(Data.id);
    						$$invalidate(0, FilteredProfiles = Profiles);
    					}
    				}
    			);
    		} else if (Type == "Delete") {
    			ShowLoader.set(true);

    			SendEvent("Profiles/DeleteProfile", { Id: $CurrentProfile.id }, () => {
    				let ProfilesIndex = Profiles.findIndex(Val => Val.id == $CurrentProfile.id);
    				if (ProfilesIndex > -1) Profiles.splice(ProfilesIndex, 1);
    				$$invalidate(0, FilteredProfiles = Profiles);
    				ShowLoader.set(false);
    				OnProfileAction("Reset");
    			});
    		}
    	};

    	const RevokeLicense = License => {
    		if (!License) return;
    		ShowLoader.set(true);
    		set_store_value(CurrentProfile, $CurrentProfile.licenses[License] = false, $CurrentProfile);

    		SendEvent(
    			"Profiles/RevokeLicense",
    			{
    				citizenid: $CurrentProfile.citizenid,
    				license: License
    			},
    			() => {
    				ShowLoader.set(false);
    			}
    		);
    	};

    	const AddTag = () => {
    		MdwModalsTags.set({
    			Show: true,
    			IgnoreFilter: $CurrentProfile.tags,
    			Cb: TagId => {
    				SendEvent("Profiles/AddTag", { ProfileId: $CurrentProfile.id, TagId }, (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentProfile, $CurrentProfile.tags = [...$CurrentProfile.tags, TagId], $CurrentProfile);
    				});
    			}
    		});
    	};

    	const RemoveTag = TagId => {
    		SendEvent("Profiles/RemoveTag", { ProfileId: $CurrentProfile.id, TagId }, (Success, Data) => {
    			if (!Success) return;
    			let NewProfile = { ...$CurrentProfile };
    			NewProfile.tags.splice(TagId, 1);
    			CurrentProfile.set(NewProfile);
    		});
    	};

    	const GetPriorPoints = Priors => {
    		if (!Priors) return 0;
    		let TotalPoints = 0;

    		for (let i = 0; i < Priors.length; i++) {
    			const Prior = GetChargeById(Priors[i].Id);
    			if (Prior && Number(Prior.points) > 0) TotalPoints += Number(Prior.points);
    		}
    		return TotalPoints;
    	};

    	const writable_props = [];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Profiles> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	const click_handler_1 = () => {
    		OnProfileAction("Reset");
    	};

    	const click_handler_2 = () => {
    		OnProfileAction("Delete");
    	};

    	const click_handler_3 = () => {
    		OnProfileAction("Save");
    	};

    	const click_handler_4 = () => {
    		OnProfileAction("Save");
    	};

    	function textfield0_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProfile.citizenid, value)) {
    			$CurrentProfile.citizenid = value;
    			CurrentProfile.set($CurrentProfile);
    		}
    	}

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProfile.name, value)) {
    			$CurrentProfile.name = value;
    			CurrentProfile.set($CurrentProfile);
    		}
    	}

    	function textfield2_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProfile.image, value)) {
    			$CurrentProfile.image = value;
    			CurrentProfile.set($CurrentProfile);
    		}
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			ProfileEditor = $$value;
    			$$invalidate(2, ProfileEditor);
    		});
    	}

    	const click_handler_5 = License => {
    		RevokeLicense(License);
    	};

    	const click_handler_6 = Key => {
    		RemoveTag(Key);
    	};

    	const click_handler_7 = Data => MdwModalsVehicleHistory.set({ Show: true, Plate: Data.Plate });

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		MdwCard,
    		MdwChip,
    		Button,
    		TextField,
    		onMount,
    		onDestroy,
    		GetChargeById,
    		GetTagById,
    		HasCidPermission,
    		SendEvent,
    		CurrentProfile,
    		IsGov,
    		IsJudge,
    		IsPublic,
    		MdwModalsTags,
    		MdwModalsVehicleHistory,
    		ShowLoader,
    		LicensesLocale,
    		BalloonEditor,
    		Profiles,
    		FilteredProfiles,
    		MaxProfiles,
    		ProfileEditor,
    		LoadMore,
    		DoesProfileContainTag,
    		FilterProfiles,
    		FetchById,
    		OnProfileAction,
    		RevokeLicense,
    		AddTag,
    		RemoveTag,
    		GetPriorPoints,
    		$CurrentProfile,
    		$IsPublic,
    		$IsGov,
    		$IsJudge
    	});

    	$$self.$inject_state = $$props => {
    		if ('Profiles' in $$props) Profiles = $$props.Profiles;
    		if ('FilteredProfiles' in $$props) $$invalidate(0, FilteredProfiles = $$props.FilteredProfiles);
    		if ('MaxProfiles' in $$props) $$invalidate(1, MaxProfiles = $$props.MaxProfiles);
    		if ('ProfileEditor' in $$props) $$invalidate(2, ProfileEditor = $$props.ProfileEditor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredProfiles,
    		MaxProfiles,
    		ProfileEditor,
    		$CurrentProfile,
    		$IsPublic,
    		$IsGov,
    		$IsJudge,
    		LoadMore,
    		FilterProfiles,
    		FetchById,
    		OnProfileAction,
    		RevokeLicense,
    		AddTag,
    		RemoveTag,
    		GetPriorPoints,
    		keyup_handler_4,
    		keyup_handler_2,
    		keyup_handler_1,
    		keyup_handler,
    		keyup_handler_3,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		textfield0_RealValue_binding,
    		textfield1_RealValue_binding,
    		textfield2_RealValue_binding,
    		div_binding,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7
    	];
    }

    class Profiles_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$x, create_fragment$x, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Profiles_1",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Evidence.svelte generated by Svelte v3.59.2 */
    const file$v = "src\\apps\\Mdw\\apps\\Evidence.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    // (123:4) <MdwPanelHeader>
    function create_default_slot_7$4(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterEvidence*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Evidence";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$v, 123, 8, 4554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$4.name,
    		type: "slot",
    		source: "(123:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (129:8) {#each FilteredEvidence as Data, Key}
    function create_each_block_1$8(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[15](/*Data*/ ctx[27]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[`${/*Data*/ ctx[27].type} - ${/*Data*/ ctx[27].description}`],
    					[`ID: ${/*Data*/ ctx[27].id}`]
    				]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};

    			if (dirty[0] & /*FilteredEvidence*/ 1) mdwcard_changes.Information = [
    				[`${/*Data*/ ctx[27].type} - ${/*Data*/ ctx[27].description}`],
    				[`ID: ${/*Data*/ ctx[27].id}`]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(129:8) {#each FilteredEvidence as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (128:4) <MdwPanelList>
    function create_default_slot_6$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*FilteredEvidence*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*FilteredEvidence, FetchById*/ 33) {
    				each_value_1 = /*FilteredEvidence*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$6.name,
    		type: "slot",
    		source: "(128:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (122:0) <MdwPanel class="filled">
    function create_default_slot_5$9(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_7$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_6$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 1) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty[0] & /*FilteredEvidence*/ 1 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$9.name,
    		type: "slot",
    		source: "(122:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:8) {:else}
    function create_else_block_1$5(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Add Evidence";
    			add_location(h6, file$v, 142, 12, 5157);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(142:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (140:8) {#if $CurrentEvidence.id}
    function create_if_block_9$4(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*$CurrentEvidence*/ ctx[1].id + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Edit Evidence (#");
    			t1 = text(t1_value);
    			t2 = text(")");
    			add_location(h6, file$v, 140, 12, 5079);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentEvidence*/ 2 && t1_value !== (t1_value = /*$CurrentEvidence*/ ctx[1].id + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$4.name,
    		type: "if",
    		source: "(140:8) {#if $CurrentEvidence.id}",
    		ctx
    	});

    	return block;
    }

    // (146:8) {#if !$IsPublic}
    function create_if_block_3$8(ctx) {
    	let div;
    	let show_if;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$CurrentEvidence*/ ctx[1].id) return create_if_block_4$7;
    		if (show_if == null) show_if = !!HasCidPermission("Evidence.Create");
    		if (show_if) return create_if_block_8$5;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$v, 146, 12, 5235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(146:8) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (153:20) {#if HasCidPermission("Evidence.Create")}
    function create_if_block_8$5(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$v, 152, 62, 5919);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_3*/ ctx[14], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_4*/ ctx[19], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$5.name,
    		type: "if",
    		source: "(153:20) {#if HasCidPermission(\\\"Evidence.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (148:16) {#if $CurrentEvidence.id}
    function create_if_block_4$7(ctx) {
    	let show_if_2 = HasCidPermission("Evidence.Create");
    	let t0;
    	let show_if_1 = HasCidPermission("Evidence.Delete");
    	let t1;
    	let show_if = HasCidPermission("Evidence.Edit");
    	let if_block2_anchor;
    	let if_block0 = show_if_2 && create_if_block_7$5(ctx);
    	let if_block1 = show_if_1 && create_if_block_6$5(ctx);
    	let if_block2 = show_if && create_if_block_5$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if_2) if_block0.p(ctx, dirty);
    			if (show_if_1) if_block1.p(ctx, dirty);
    			if (show_if) if_block2.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(148:16) {#if $CurrentEvidence.id}",
    		ctx
    	});

    	return block;
    }

    // (149:20) {#if HasCidPermission("Evidence.Create")}
    function create_if_block_7$5(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "New");
    			attr_dev(i, "class", "fas fa-sync");
    			add_location(i, file$v, 148, 62, 5375);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[13], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_1*/ ctx[16], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$5.name,
    		type: "if",
    		source: "(149:20) {#if HasCidPermission(\\\"Evidence.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (150:20) {#if HasCidPermission("Evidence.Delete")}
    function create_if_block_6$5(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Delete");
    			attr_dev(i, "class", "fas fa-trash");
    			add_location(i, file$v, 149, 62, 5547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[12], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_2*/ ctx[17], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$5.name,
    		type: "if",
    		source: "(150:20) {#if HasCidPermission(\\\"Evidence.Delete\\\")}",
    		ctx
    	});

    	return block;
    }

    // (151:20) {#if HasCidPermission("Evidence.Edit")}
    function create_if_block_5$7(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$v, 150, 60, 5722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_2*/ ctx[11], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_3*/ ctx[18], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$7.name,
    		type: "if",
    		source: "(151:20) {#if HasCidPermission(\\\"Evidence.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (139:4) <MdwPanelHeader>
    function create_default_slot_4$a(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$CurrentEvidence*/ ctx[1].id) return create_if_block_9$4;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*$IsPublic*/ ctx[2] && create_if_block_3$8(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (!/*$IsPublic*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$8(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$a.name,
    		type: "slot",
    		source: "(139:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (138:0) <MdwPanel class="filled">
    function create_default_slot_3$a(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let textfield0;
    	let updating_RealValue;
    	let t1;
    	let textfield1;
    	let updating_RealValue_1;
    	let t2;
    	let textfield2;
    	let updating_RealValue_2;
    	let t3;
    	let textfield3;
    	let updating_RealValue_3;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_4$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[20](value);
    	}

    	let textfield0_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Type",
    		Select: /*GetEvidenceTypes*/ ctx[9]()
    	};

    	if (/*$CurrentEvidence*/ ctx[1].type !== void 0) {
    		textfield0_props.RealValue = /*$CurrentEvidence*/ ctx[1].type;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[21](value);
    	}

    	let textfield1_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Identifier",
    		Icon: "fingerprint"
    	};

    	if (/*$CurrentEvidence*/ ctx[1].identifier !== void 0) {
    		textfield1_props.RealValue = /*$CurrentEvidence*/ ctx[1].identifier;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	function textfield2_RealValue_binding(value) {
    		/*textfield2_RealValue_binding*/ ctx[22](value);
    	}

    	let textfield2_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Description",
    		Icon: "clipboard"
    	};

    	if (/*$CurrentEvidence*/ ctx[1].description !== void 0) {
    		textfield2_props.RealValue = /*$CurrentEvidence*/ ctx[1].description;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'RealValue', textfield2_RealValue_binding));

    	function textfield3_RealValue_binding(value) {
    		/*textfield3_RealValue_binding*/ ctx[23](value);
    	}

    	let textfield3_props = {
    		style: "margin-bottom: 0px;",
    		Title: "SSN",
    		Icon: "user"
    	};

    	if (/*$CurrentEvidence*/ ctx[1].citizenid !== void 0) {
    		textfield3_props.RealValue = /*$CurrentEvidence*/ ctx[1].citizenid;
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'RealValue', textfield3_RealValue_binding));

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(textfield2.$$.fragment);
    			t3 = space();
    			create_component(textfield3.$$.fragment);
    			set_style(div, "width", "97%");
    			set_style(div, "margin-left", "auto");
    			set_style(div, "margin-right", "auto");
    			add_location(div, file$v, 158, 4, 6116);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t1);
    			mount_component(textfield1, div, null);
    			append_dev(div, t2);
    			mount_component(textfield2, div, null);
    			append_dev(div, t3);
    			mount_component(textfield3, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentEvidence, $IsPublic*/ 6 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty[0] & /*$CurrentEvidence*/ 2) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*$CurrentEvidence*/ ctx[1].type;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_RealValue_1 && dirty[0] & /*$CurrentEvidence*/ 2) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$CurrentEvidence*/ ctx[1].identifier;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_RealValue_2 && dirty[0] & /*$CurrentEvidence*/ 2) {
    				updating_RealValue_2 = true;
    				textfield2_changes.RealValue = /*$CurrentEvidence*/ ctx[1].description;
    				add_flush_callback(() => updating_RealValue_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_RealValue_3 && dirty[0] & /*$CurrentEvidence*/ 2) {
    				updating_RealValue_3 = true;
    				textfield3_changes.RealValue = /*$CurrentEvidence*/ ctx[1].citizenid;
    				add_flush_callback(() => updating_RealValue_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(138:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (173:16) {#if $CurrentEvidence.id}
    function create_if_block_2$a(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$v, 173, 20, 7003);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_4*/ ctx[10], false, false, false, false),
    					listen_dev(i, "click", /*AddTag*/ ctx[7], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(173:16) {#if $CurrentEvidence.id}",
    		ctx
    	});

    	return block;
    }

    // (169:8) <MdwPanelHeader>
    function create_default_slot_2$b(ctx) {
    	let h6;
    	let t1;
    	let div;
    	let if_block = /*$CurrentEvidence*/ ctx[1].id && create_if_block_2$a(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Tags";
    			t1 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(h6, file$v, 169, 12, 6872);
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$v, 171, 12, 6905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$CurrentEvidence*/ ctx[1].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$a(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(169:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (179:8) {#if $CurrentEvidence.id && $CurrentEvidence.tags}
    function create_if_block$o(ctx) {
    	let div;
    	let current;
    	let each_value = /*$CurrentEvidence*/ ctx[1].tags;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$v, 179, 12, 7203);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentEvidence, RemoveTag, $IsGov*/ 266) {
    				each_value = /*$CurrentEvidence*/ ctx[1].tags;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(179:8) {#if $CurrentEvidence.id && $CurrentEvidence.tags}",
    		ctx
    	});

    	return block;
    }

    // (184:20) {:else}
    function create_else_block$8(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[27]).tag,
    				Color: GetTagById(/*Data*/ ctx[27]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[27]).icon
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[27]).tag;
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[27]).color;
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[27]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(184:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (182:20) {#if $IsGov}
    function create_if_block_1$d(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[24](/*Key*/ ctx[29]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[27]).tag,
    				Color: GetTagById(/*Data*/ ctx[27]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[27]).icon,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_5);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[27]).tag;
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[27]).color;
    			if (dirty[0] & /*$CurrentEvidence*/ 2) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[27]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(182:20) {#if $IsGov}",
    		ctx
    	});

    	return block;
    }

    // (181:16) {#each $CurrentEvidence.tags as Data, Key}
    function create_each_block$i(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$d, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$IsGov*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(181:16) {#each $CurrentEvidence.tags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (168:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_1$e(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentEvidence*/ ctx[1].id && /*$CurrentEvidence*/ ctx[1].tags && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentEvidence*/ 2 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentEvidence*/ ctx[1].id && /*$CurrentEvidence*/ ctx[1].tags) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentEvidence*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(168:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (167:0) <MdwPanel>
    function create_default_slot$n(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentEvidence, $IsGov*/ 10 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(167:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_5$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*FilteredEvidence*/ 1 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*$CurrentEvidence, $IsPublic*/ 6 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentEvidence, $IsGov*/ 10 | dirty[1] & /*$$scope*/ 1) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $MdwEvidence;
    	let $CurrentEvidence;
    	let $IsPublic;
    	let $IsGov;
    	validate_store(MdwEvidence, 'MdwEvidence');
    	component_subscribe($$self, MdwEvidence, $$value => $$invalidate(26, $MdwEvidence = $$value));
    	validate_store(CurrentEvidence, 'CurrentEvidence');
    	component_subscribe($$self, CurrentEvidence, $$value => $$invalidate(1, $CurrentEvidence = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(2, $IsPublic = $$value));
    	validate_store(IsGov, 'IsGov');
    	component_subscribe($$self, IsGov, $$value => $$invalidate(3, $IsGov = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Evidence', slots, []);
    	let Evidence = [];
    	let FilteredEvidence = [];

    	onMount(() => {
    		SendEvent("Evidence/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Evidence = Data;
    			$$invalidate(0, FilteredEvidence = Data);
    		});
    	});

    	const FilterEvidence = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredEvidence = Evidence.filter(Val => {
    			return String(Val.id).toLowerCase().includes(Search) || Val.identifier.toLowerCase().includes(Search) || Val.description.toLowerCase().includes(Search) || Val.citizenid.toLowerCase().includes(Search);
    		}));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Evidence/FetchById", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentEvidence.set(Data);
    		});
    	};

    	const OnEvidenceAction = Type => {
    		if (Type == "Reset") {
    			CurrentEvidence.set({
    				type: "",
    				identifier: "",
    				description: "",
    				citizenid: ""
    			});
    		} else if (Type == "Save") {
    			if ($CurrentEvidence.identifier.includes(".discordapp.")) {
    				MdwModalsExport.set({
    					Show: true,
    					Msg: `cdn.discordapp.com cannot be used as an identifier.`
    				});

    				return;
    			}

    			ShowLoader.set(true);

    			SendEvent(
    				"Evidence/SaveEvidence",
    				{
    					type: $CurrentEvidence.type,
    					identifier: $CurrentEvidence.identifier,
    					description: $CurrentEvidence.description,
    					citizenid: $CurrentEvidence.citizenid,
    					id: $CurrentEvidence.id
    				},
    				(Success, Data) => {
    					ShowLoader.set(false);
    					if (!Success) return;

    					if (Data) {
    						let EvidenceIndex = Evidence.findIndex(Val => Val.id == $CurrentEvidence.id);

    						if (EvidenceIndex > -1) {
    							Evidence[EvidenceIndex] = Data;
    						} else {
    							Evidence = [Data, ...Evidence];
    						}

    						FetchById(Data.id);
    						$$invalidate(0, FilteredEvidence = Evidence);
    					}
    				}
    			);
    		} else if (Type == "Delete") {
    			ShowLoader.set(true);

    			SendEvent("Evidence/DeleteEvidence", { Id: $CurrentEvidence.id }, () => {
    				let EvidenceIndex = Evidence.findIndex(Val => Val.id == $CurrentEvidence.id);
    				if (EvidenceIndex > -1) Evidence.splice(EvidenceIndex, 1);
    				$$invalidate(0, FilteredEvidence = Profiles);
    				ShowLoader.set(false);
    				OnEvidenceAction("Reset");
    			});
    		}
    	};

    	const AddTag = () => {
    		MdwModalsTags.set({
    			Show: true,
    			IgnoreFilter: $CurrentEvidence.tags,
    			Cb: TagId => {
    				SendEvent("Evidence/AddTag", { EvidenceId: $CurrentEvidence.id, TagId }, (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentEvidence, $CurrentEvidence.tags = [...$CurrentEvidence.tags, TagId], $CurrentEvidence);
    				});
    			}
    		});
    	};

    	const RemoveTag = TagId => {
    		SendEvent("Evidence/RemoveTag", { EvidenceId: $CurrentEvidence.id, TagId }, (Success, Data) => {
    			if (!Success) return;
    			let NewEvidence = { ...$CurrentEvidence };
    			NewEvidence.tags.splice(TagId, 1);
    			CurrentEvidence.set(NewEvidence);
    		});
    	};

    	const GetEvidenceTypes = () => {
    		return $MdwEvidence.filter(Val => !Val.deleted);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Evidence> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	const click_handler_1 = () => {
    		OnEvidenceAction("Reset");
    	};

    	const click_handler_2 = () => {
    		OnEvidenceAction("Delete");
    	};

    	const click_handler_3 = () => {
    		OnEvidenceAction("Save");
    	};

    	const click_handler_4 = () => {
    		OnEvidenceAction("Save");
    	};

    	function textfield0_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentEvidence.type, value)) {
    			$CurrentEvidence.type = value;
    			CurrentEvidence.set($CurrentEvidence);
    		}
    	}

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentEvidence.identifier, value)) {
    			$CurrentEvidence.identifier = value;
    			CurrentEvidence.set($CurrentEvidence);
    		}
    	}

    	function textfield2_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentEvidence.description, value)) {
    			$CurrentEvidence.description = value;
    			CurrentEvidence.set($CurrentEvidence);
    		}
    	}

    	function textfield3_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentEvidence.citizenid, value)) {
    			$CurrentEvidence.citizenid = value;
    			CurrentEvidence.set($CurrentEvidence);
    		}
    	}

    	const click_handler_5 = Key => {
    		RemoveTag(Key);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		MdwCard,
    		onMount,
    		GetTagById,
    		HasCidPermission,
    		SendEvent,
    		CurrentEvidence,
    		IsGov,
    		IsHighcommand,
    		IsPublic,
    		MdwEvidence,
    		MdwModalsTags,
    		ShowLoader,
    		MdwChip,
    		Evidence,
    		FilteredEvidence,
    		FilterEvidence,
    		FetchById,
    		OnEvidenceAction,
    		AddTag,
    		RemoveTag,
    		GetEvidenceTypes,
    		$MdwEvidence,
    		$CurrentEvidence,
    		$IsPublic,
    		$IsGov
    	});

    	$$self.$inject_state = $$props => {
    		if ('Evidence' in $$props) Evidence = $$props.Evidence;
    		if ('FilteredEvidence' in $$props) $$invalidate(0, FilteredEvidence = $$props.FilteredEvidence);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredEvidence,
    		$CurrentEvidence,
    		$IsPublic,
    		$IsGov,
    		FilterEvidence,
    		FetchById,
    		OnEvidenceAction,
    		AddTag,
    		RemoveTag,
    		GetEvidenceTypes,
    		keyup_handler_4,
    		keyup_handler_2,
    		keyup_handler_1,
    		keyup_handler,
    		keyup_handler_3,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		textfield0_RealValue_binding,
    		textfield1_RealValue_binding,
    		textfield2_RealValue_binding,
    		textfield3_RealValue_binding,
    		click_handler_5
    	];
    }

    class Evidence_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$w, create_fragment$w, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Evidence_1",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Properties.svelte generated by Svelte v3.59.2 */
    const file$u = "src\\apps\\Mdw\\apps\\Properties.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (51:4) <MdwPanelHeader>
    function create_default_slot_5$8(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterProperties*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Properties";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$u, 51, 8, 1759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$8.name,
    		type: "slot",
    		source: "(51:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (57:8) {#each FilteredProperties as Data, Key}
    function create_each_block$h(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*Data*/ ctx[12]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [[/*Data*/ ctx[12].adress], [`ID: ${/*Data*/ ctx[12].id}`]]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};
    			if (dirty & /*FilteredProperties*/ 1) mdwcard_changes.Information = [[/*Data*/ ctx[12].adress], [`ID: ${/*Data*/ ctx[12].id}`]];
    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(57:8) {#each FilteredProperties as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (56:4) <MdwPanelList>
    function create_default_slot_4$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*FilteredProperties*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredProperties, FetchProfileById*/ 33) {
    				each_value = /*FilteredProperties*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(56:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (50:0) <MdwPanel class="filled" style="width: 50%">
    function create_default_slot_3$9(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_5$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredProperties*/ 32769) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(50:0) <MdwPanel class=\\\"filled\\\" style=\\\"width: 50%\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:4) <MdwPanelHeader>
    function create_default_slot_2$a(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Property";
    			add_location(h6, file$u, 67, 8, 2252);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(67:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#if $IsGov || $IsJudge}
    function create_if_block$n(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				Color: /*$CurrentProperty*/ ctx[1].id ? "default" : "disabled",
    				click: /*SetHousingGps*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*$CurrentProperty*/ 2) button_changes.Color = /*$CurrentProperty*/ ctx[1].id ? "default" : "disabled";

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(75:8) {#if $IsGov || $IsJudge}",
    		ctx
    	});

    	return block;
    }

    // (76:12) <Button Color={$CurrentProperty.id ? "default" : "disabled"} click={SetHousingGps}>
    function create_default_slot_1$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Locate");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(76:12) <Button Color={$CurrentProperty.id ? \\\"default\\\" : \\\"disabled\\\"} click={SetHousingGps}>",
    		ctx
    	});

    	return block;
    }

    // (66:0) <MdwPanel class="filled" style="width: 50%">
    function create_default_slot$m(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let textfield0;
    	let updating_RealValue;
    	let t1;
    	let textfield1;
    	let updating_RealValue_1;
    	let t2;
    	let textfield2;
    	let updating_RealValue_2;
    	let t3;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[8](value);
    	}

    	let textfield0_props = {
    		ReadOnly: true,
    		Title: "Property ID",
    		Icon: "user"
    	};

    	if (/*$CurrentProperty*/ ctx[1].id !== void 0) {
    		textfield0_props.RealValue = /*$CurrentProperty*/ ctx[1].id;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[9](value);
    	}

    	let textfield1_props = {
    		ReadOnly: true,
    		Title: "Street Name & House Number",
    		Icon: "user"
    	};

    	if (/*$CurrentProperty*/ ctx[1].adress !== void 0) {
    		textfield1_props.RealValue = /*$CurrentProperty*/ ctx[1].adress;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	function textfield2_RealValue_binding(value) {
    		/*textfield2_RealValue_binding*/ ctx[10](value);
    	}

    	let textfield2_props = {
    		ReadOnly: true,
    		Title: "Sold",
    		Icon: "user"
    	};

    	if (/*$CurrentProperty*/ ctx[1].owned !== void 0) {
    		textfield2_props.RealValue = /*$CurrentProperty*/ ctx[1].owned;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'RealValue', textfield2_RealValue_binding));
    	let if_block = (/*$IsGov*/ ctx[2] || /*$IsJudge*/ ctx[3]) && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(textfield2.$$.fragment);
    			t3 = space();
    			if (if_block) if_block.c();
    			set_style(div, "width", "97%");
    			set_style(div, "margin-left", "auto");
    			set_style(div, "margin-right", "auto");
    			add_location(div, file$u, 70, 4, 2300);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t1);
    			mount_component(textfield1, div, null);
    			append_dev(div, t2);
    			mount_component(textfield2, div, null);
    			append_dev(div, t3);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty & /*$CurrentProperty*/ 2) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*$CurrentProperty*/ ctx[1].id;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_RealValue_1 && dirty & /*$CurrentProperty*/ 2) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$CurrentProperty*/ ctx[1].adress;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_RealValue_2 && dirty & /*$CurrentProperty*/ 2) {
    				updating_RealValue_2 = true;
    				textfield2_changes.RealValue = /*$CurrentProperty*/ ctx[1].owned;
    				add_flush_callback(() => updating_RealValue_2 = false);
    			}

    			textfield2.$set(textfield2_changes);

    			if (/*$IsGov*/ ctx[2] || /*$IsJudge*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$IsGov, $IsJudge*/ 12) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(66:0) <MdwPanel class=\\\"filled\\\" style=\\\"width: 50%\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let mdwpanel0;
    	let t;
    	let mdwpanel1;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 50%",
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 50%",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t = space();
    			create_component(mdwpanel1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel0_changes = {};

    			if (dirty & /*$$scope, FilteredProperties*/ 32769) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty & /*$$scope, $CurrentProperty, $IsGov, $IsJudge*/ 32782) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanel1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $CurrentProperty;
    	let $IsGov;
    	let $IsJudge;
    	validate_store(CurrentProperty, 'CurrentProperty');
    	component_subscribe($$self, CurrentProperty, $$value => $$invalidate(1, $CurrentProperty = $$value));
    	validate_store(IsGov, 'IsGov');
    	component_subscribe($$self, IsGov, $$value => $$invalidate(2, $IsGov = $$value));
    	validate_store(IsJudge, 'IsJudge');
    	component_subscribe($$self, IsJudge, $$value => $$invalidate(3, $IsJudge = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Properties', slots, []);
    	let Properties = [];
    	let FilteredProperties = [];

    	onMount(() => {
    		SendEvent("Properties/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Properties = Data;
    			$$invalidate(0, FilteredProperties = Data);
    		});
    	});

    	const FilterProperties = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredProperties = Properties.filter(Val => {
    			return String(Val.id).toLowerCase().includes(Search) || Val.adress.toLowerCase().includes(Search);
    		}));
    	};

    	const FetchProfileById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Properties/FetchProperty", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentProperty.set(Data);
    		});
    	};

    	const SetHousingGps = () => {
    		if (!$CurrentProperty.id) return;

    		SendEvent("Dispatch/SetGPS", {
    			x: $CurrentProperty.coords.x,
    			y: $CurrentProperty.coords.y
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Properties> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		FetchProfileById(Data.id);
    	};

    	function textfield0_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProperty.id, value)) {
    			$CurrentProperty.id = value;
    			CurrentProperty.set($CurrentProperty);
    		}
    	}

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProperty.adress, value)) {
    			$CurrentProperty.adress = value;
    			CurrentProperty.set($CurrentProperty);
    		}
    	}

    	function textfield2_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentProperty.owned, value)) {
    			$CurrentProperty.owned = value;
    			CurrentProperty.set($CurrentProperty);
    		}
    	}

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		MdwCard,
    		onMount,
    		SendEvent,
    		CurrentProperty,
    		IsGov,
    		IsJudge,
    		ShowLoader,
    		Button,
    		Properties,
    		FilteredProperties,
    		FilterProperties,
    		FetchProfileById,
    		SetHousingGps,
    		$CurrentProperty,
    		$IsGov,
    		$IsJudge
    	});

    	$$self.$inject_state = $$props => {
    		if ('Properties' in $$props) Properties = $$props.Properties;
    		if ('FilteredProperties' in $$props) $$invalidate(0, FilteredProperties = $$props.FilteredProperties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredProperties,
    		$CurrentProperty,
    		$IsGov,
    		$IsJudge,
    		FilterProperties,
    		FetchProfileById,
    		SetHousingGps,
    		click_handler,
    		textfield0_RealValue_binding,
    		textfield1_RealValue_binding,
    		textfield2_RealValue_binding
    	];
    }

    class Properties_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Properties_1",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\apps\Mdw\components\MdwChargeCard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$1 } = globals;
    const file$t = "src\\apps\\Mdw\\components\\MdwChargeCard.svelte";

    // (34:4) {#if IsChargeValid(accomplice)}
    function create_if_block_1$c(ctx) {
    	let hr;
    	let t0;
    	let p0;
    	let t2;
    	let div;
    	let p1;
    	let t3_value = /*accomplice*/ ctx[6].jail + "";
    	let t3;
    	let t4;
    	let t5;
    	let p2;
    	let t6_value = FormatCurrency.format(/*accomplice*/ ctx[6].fine) + "";
    	let t6;
    	let t7;
    	let p3;
    	let t8_value = /*accomplice*/ ctx[6].points + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			p0 = element("p");
    			p0.textContent = "Accomplice";
    			t2 = space();
    			div = element("div");
    			p1 = element("p");
    			t3 = text(t3_value);
    			t4 = text(" month(s)");
    			t5 = space();
    			p2 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			p3 = element("p");
    			t8 = text(t8_value);
    			t9 = text(" point(s)");
    			set_style(hr, "border-top", "none");
    			set_style(hr, "border-right", "none");
    			set_style(hr, "border-bottom", "0.1vh solid black");
    			set_style(hr, "border-left", "none");
    			set_style(hr, "border-image", "initial");
    			add_location(hr, file$t, 34, 8, 1149);
    			attr_dev(p0, "class", "mdw-charge-subheader svelte-1viajd4");
    			add_location(p0, file$t, 35, 8, 1285);
    			add_location(p1, file$t, 37, 12, 1384);
    			add_location(p2, file$t, 38, 12, 1431);
    			add_location(p3, file$t, 39, 12, 1492);
    			attr_dev(div, "class", "mdw-charge-info svelte-1viajd4");
    			add_location(div, file$t, 36, 8, 1341);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p1);
    			append_dev(p1, t3);
    			append_dev(p1, t4);
    			append_dev(div, t5);
    			append_dev(div, p2);
    			append_dev(p2, t6);
    			append_dev(div, t7);
    			append_dev(div, p3);
    			append_dev(p3, t8);
    			append_dev(p3, t9);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*accomplice*/ 64 && t3_value !== (t3_value = /*accomplice*/ ctx[6].jail + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*accomplice*/ 64 && t6_value !== (t6_value = FormatCurrency.format(/*accomplice*/ ctx[6].fine) + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*accomplice*/ 64 && t8_value !== (t8_value = /*accomplice*/ ctx[6].points + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(34:4) {#if IsChargeValid(accomplice)}",
    		ctx
    	});

    	return block;
    }

    // (43:4) {#if IsChargeValid(attempted)}
    function create_if_block$m(ctx) {
    	let hr;
    	let t0;
    	let p0;
    	let t2;
    	let div;
    	let p1;
    	let t3_value = /*attempted*/ ctx[7].jail + "";
    	let t3;
    	let t4;
    	let t5;
    	let p2;
    	let t6_value = FormatCurrency.format(/*attempted*/ ctx[7].fine) + "";
    	let t6;
    	let t7;
    	let p3;
    	let t8_value = /*attempted*/ ctx[7].points + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			p0 = element("p");
    			p0.textContent = "Attempted";
    			t2 = space();
    			div = element("div");
    			p1 = element("p");
    			t3 = text(t3_value);
    			t4 = text(" month(s)");
    			t5 = space();
    			p2 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			p3 = element("p");
    			t8 = text(t8_value);
    			t9 = text(" point(s)");
    			set_style(hr, "border-top", "none");
    			set_style(hr, "border-right", "none");
    			set_style(hr, "border-bottom", "0.1vh solid black");
    			set_style(hr, "border-left", "none");
    			set_style(hr, "border-image", "initial");
    			add_location(hr, file$t, 43, 8, 1600);
    			attr_dev(p0, "class", "mdw-charge-subheader svelte-1viajd4");
    			add_location(p0, file$t, 44, 8, 1736);
    			add_location(p1, file$t, 46, 12, 1834);
    			add_location(p2, file$t, 47, 12, 1880);
    			add_location(p3, file$t, 48, 12, 1940);
    			attr_dev(div, "class", "mdw-charge-info svelte-1viajd4");
    			add_location(div, file$t, 45, 8, 1791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p1);
    			append_dev(p1, t3);
    			append_dev(p1, t4);
    			append_dev(div, t5);
    			append_dev(div, p2);
    			append_dev(p2, t6);
    			append_dev(div, t7);
    			append_dev(div, p3);
    			append_dev(p3, t8);
    			append_dev(p3, t9);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*attempted*/ 128 && t3_value !== (t3_value = /*attempted*/ ctx[7].jail + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*attempted*/ 128 && t6_value !== (t6_value = FormatCurrency.format(/*attempted*/ ctx[7].fine) + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*attempted*/ 128 && t8_value !== (t8_value = /*attempted*/ ctx[7].points + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(43:4) {#if IsChargeValid(attempted)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div1;
    	let p0;
    	let t0;
    	let t1;
    	let div0;
    	let p1;
    	let t2;
    	let t3;
    	let t4;
    	let p2;
    	let t5_value = FormatCurrency.format(/*fine*/ ctx[3]) + "";
    	let t5;
    	let t6;
    	let p3;
    	let t7;
    	let t8;
    	let t9;
    	let show_if_1 = /*IsChargeValid*/ ctx[8](/*accomplice*/ ctx[6]);
    	let t10;
    	let show_if = /*IsChargeValid*/ ctx[8](/*attempted*/ ctx[7]);
    	let div1_data_tooltip_value;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if_1 && create_if_block_1$c(ctx);
    	let if_block1 = show_if && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			p0 = element("p");
    			t0 = text(/*name*/ ctx[0]);
    			t1 = space();
    			div0 = element("div");
    			p1 = element("p");
    			t2 = text(/*jail*/ ctx[4]);
    			t3 = text(" month(s)");
    			t4 = space();
    			p2 = element("p");
    			t5 = text(t5_value);
    			t6 = space();
    			p3 = element("p");
    			t7 = text(/*points*/ ctx[5]);
    			t8 = text(" point(s)");
    			t9 = space();
    			if (if_block0) if_block0.c();
    			t10 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(p0, "class", "mdw-charge-header svelte-1viajd4");
    			add_location(p0, file$t, 27, 4, 904);
    			add_location(p1, file$t, 29, 8, 988);
    			add_location(p2, file$t, 30, 8, 1020);
    			add_location(p3, file$t, 31, 8, 1066);
    			attr_dev(div0, "class", "mdw-charge-info svelte-1viajd4");
    			add_location(div0, file$t, 28, 4, 949);
    			attr_dev(div1, "data-tooltip", div1_data_tooltip_value = /*description*/ ctx[2] || ' ');
    			attr_dev(div1, "class", div1_class_value = "mdw-charge-container charge-" + /*type*/ ctx[1].toLowerCase() + " svelte-1viajd4");
    			add_location(div1, file$t, 26, 0, 784);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p0);
    			append_dev(p0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, p1);
    			append_dev(p1, t2);
    			append_dev(p1, t3);
    			append_dev(div0, t4);
    			append_dev(div0, p2);
    			append_dev(p2, t5);
    			append_dev(div0, t6);
    			append_dev(div0, p3);
    			append_dev(p3, t7);
    			append_dev(p3, t8);
    			append_dev(div1, t9);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t10);
    			if (if_block1) if_block1.m(div1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*click_handler*/ ctx[9], false, false, false, false),
    					listen_dev(div1, "keyup", /*keyup_handler*/ ctx[10], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 1) set_data_dev(t0, /*name*/ ctx[0]);
    			if (dirty & /*jail*/ 16) set_data_dev(t2, /*jail*/ ctx[4]);
    			if (dirty & /*fine*/ 8 && t5_value !== (t5_value = FormatCurrency.format(/*fine*/ ctx[3]) + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*points*/ 32) set_data_dev(t7, /*points*/ ctx[5]);
    			if (dirty & /*accomplice*/ 64) show_if_1 = /*IsChargeValid*/ ctx[8](/*accomplice*/ ctx[6]);

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$c(ctx);
    					if_block0.c();
    					if_block0.m(div1, t10);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*attempted*/ 128) show_if = /*IsChargeValid*/ ctx[8](/*attempted*/ ctx[7]);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$m(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*description*/ 4 && div1_data_tooltip_value !== (div1_data_tooltip_value = /*description*/ ctx[2] || ' ')) {
    				attr_dev(div1, "data-tooltip", div1_data_tooltip_value);
    			}

    			if (dirty & /*type*/ 2 && div1_class_value !== (div1_class_value = "mdw-charge-container charge-" + /*type*/ ctx[1].toLowerCase() + " svelte-1viajd4")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwChargeCard', slots, []);
    	let { name = '' } = $$props;
    	let { type = 'Normal' } = $$props;
    	let { description = '' } = $$props;
    	let { fine = 0 } = $$props;
    	let { jail = 0 } = $$props;
    	let { points = 0 } = $$props;
    	let { accomplice = [] } = $$props;
    	let { attempted = [] } = $$props;

    	const IsChargeValid = Data => {
    		console.log(JSON.stringify(Data));
    		if (!Data || Data == "" || (!Data.jail || Data.jail == "" || Data.jail == "0" || Data.jail <= 0) && (!Data.fine || Data.fine == "" || Data.fine == "0" || Data.fine <= 0) && (!Data.points || Data.points == "" || Data.points == "0" || Data.points <= 0)) return false;
    		return true;
    	};

    	const writable_props = [
    		'name',
    		'type',
    		'description',
    		'fine',
    		'jail',
    		'points',
    		'accomplice',
    		'attempted'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<MdwChargeCard> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('description' in $$props) $$invalidate(2, description = $$props.description);
    		if ('fine' in $$props) $$invalidate(3, fine = $$props.fine);
    		if ('jail' in $$props) $$invalidate(4, jail = $$props.jail);
    		if ('points' in $$props) $$invalidate(5, points = $$props.points);
    		if ('accomplice' in $$props) $$invalidate(6, accomplice = $$props.accomplice);
    		if ('attempted' in $$props) $$invalidate(7, attempted = $$props.attempted);
    	};

    	$$self.$capture_state = () => ({
    		FormatCurrency,
    		name,
    		type,
    		description,
    		fine,
    		jail,
    		points,
    		accomplice,
    		attempted,
    		IsChargeValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('description' in $$props) $$invalidate(2, description = $$props.description);
    		if ('fine' in $$props) $$invalidate(3, fine = $$props.fine);
    		if ('jail' in $$props) $$invalidate(4, jail = $$props.jail);
    		if ('points' in $$props) $$invalidate(5, points = $$props.points);
    		if ('accomplice' in $$props) $$invalidate(6, accomplice = $$props.accomplice);
    		if ('attempted' in $$props) $$invalidate(7, attempted = $$props.attempted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		name,
    		type,
    		description,
    		fine,
    		jail,
    		points,
    		accomplice,
    		attempted,
    		IsChargeValid,
    		click_handler,
    		keyup_handler
    	];
    }

    class MdwChargeCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			name: 0,
    			type: 1,
    			description: 2,
    			fine: 3,
    			jail: 4,
    			points: 5,
    			accomplice: 6,
    			attempted: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwChargeCard",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get name() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fine() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fine(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get jail() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set jail(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get points() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set points(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accomplice() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accomplice(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get attempted() {
    		throw new Error("<MdwChargeCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attempted(value) {
    		throw new Error("<MdwChargeCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\apps\Charges.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1$2 } = globals;
    const file$s = "src\\apps\\Mdw\\apps\\Charges.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i][0];
    	child_ctx[4] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (39:8) <MdwPanelHeader style="width: 98.6%;">
    function create_default_slot_4$8(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterCharges*/ ctx[1],
    				style: "width: 20%;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Charges";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$s, 39, 12, 1399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(39:8) <MdwPanelHeader style=\\\"width: 98.6%;\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:4) <MdwPanel class="filled" style="width: 98.6%; margin: 0.5vh auto 0px; height: 6vh;">
    function create_default_slot_3$8(ctx) {
    	let mdwpanelheader;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "width: 98.6%;",
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(38:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 98.6%; margin: 0.5vh auto 0px; height: 6vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:12) <MdwPanelHeader style="width: 98.6%;">
    function create_default_slot_2$9(ctx) {
    	let h6;
    	let t_value = /*Category*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t = text(t_value);
    			add_location(h6, file$s, 47, 16, 1800);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredCharges*/ 1 && t_value !== (t_value = /*Category*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(47:12) <MdwPanelHeader style=\\\"width: 98.6%;\\\">",
    		ctx
    	});

    	return block;
    }

    // (52:16) {#each Charges as Data, Key}
    function create_each_block_1$7(ctx) {
    	let mdwchargecard;
    	let current;
    	const mdwchargecard_spread_levels = [/*Data*/ ctx[7]];
    	let mdwchargecard_props = {};

    	for (let i = 0; i < mdwchargecard_spread_levels.length; i += 1) {
    		mdwchargecard_props = assign(mdwchargecard_props, mdwchargecard_spread_levels[i]);
    	}

    	mdwchargecard = new MdwChargeCard({
    			props: mdwchargecard_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchargecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchargecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchargecard_changes = (dirty & /*Object, FilteredCharges*/ 1)
    			? get_spread_update(mdwchargecard_spread_levels, [get_spread_object(/*Data*/ ctx[7])])
    			: {};

    			mdwchargecard.$set(mdwchargecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchargecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchargecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchargecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(52:16) {#each Charges as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (46:8) <MdwPanel class="filled" style="width: 98.6%; margin: 0.5vh auto 0px; height: max-content;">
    function create_default_slot_1$c(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let t1;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "width: 98.6%;",
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*Charges*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			attr_dev(div, "class", "mdw-charges svelte-u1kpi7");
    			add_location(div, file$s, 50, 12, 1866);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 1025) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (dirty & /*Object, FilteredCharges*/ 1) {
    				each_value_1 = /*Charges*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(46:8) <MdwPanel class=\\\"filled\\\" style=\\\"width: 98.6%; margin: 0.5vh auto 0px; height: max-content;\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#each Object.entries(FilteredCharges) as [Category, Charges]}
    function create_each_block$g(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 98.6%; margin: 0.5vh auto 0px; height: max-content;",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 1025) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(45:4) {#each Object.entries(FilteredCharges) as [Category, Charges]}",
    		ctx
    	});

    	return block;
    }

    // (37:0) <MdwPanel style="width: 100%; background-color: rgb(46, 70, 94);">
    function create_default_slot$l(ctx) {
    	let mdwpanel;
    	let t;
    	let each_1_anchor;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 98.6%; margin: 0.5vh auto 0px; height: 6vh;",
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = Object.entries(/*FilteredCharges*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);

    			if (dirty & /*Object, FilteredCharges*/ 1) {
    				each_value = Object.entries(/*FilteredCharges*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(37:0) <MdwPanel style=\\\"width: 100%; background-color: rgb(46, 70, 94);\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				style: "width: 100%; background-color: rgb(46, 70, 94);",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 1025) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $MdwCharges;
    	validate_store(MdwCharges, 'MdwCharges');
    	component_subscribe($$self, MdwCharges, $$value => $$invalidate(2, $MdwCharges = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Charges', slots, []);
    	let FilteredCharges = {};

    	onMount(() => {
    		FilterCharges("");
    	});

    	const FilterCharges = Value => {
    		const Search = Value.toLowerCase();

    		const FilteredResult = $MdwCharges.filter(Val => {
    			return (Val.name.toLowerCase().includes(Search) || Val.category.toLowerCase().includes(Search)) && Val.deleted == 0;
    		});

    		let NewCharges = {};

    		for (let i = 0; i < FilteredResult.length; i++) {
    			const Charge = FilteredResult[i];

    			if (NewCharges[Charge.category] == undefined) {
    				NewCharges[Charge.category] = [];
    			}

    			NewCharges[Charge.category].push(Charge);
    		}
    		$$invalidate(0, FilteredCharges = NewCharges);
    	};

    	const writable_props = [];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Charges> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		TextField,
    		MdwCharges,
    		MdwChargeCard,
    		onMount,
    		FilteredCharges,
    		FilterCharges,
    		$MdwCharges
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredCharges' in $$props) $$invalidate(0, FilteredCharges = $$props.FilteredCharges);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredCharges, FilterCharges];
    }

    class Charges extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Charges",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Staff.svelte generated by Svelte v3.59.2 */
    const file$r = "src\\apps\\Mdw\\apps\\Staff.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    // (105:4) <MdwPanelHeader>
    function create_default_slot_12$1(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterStaff*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Staff";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$r, 105, 8, 3739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(105:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (112:12) {#if (!$IsPublic && $IsEms && Data.department.toLowerCase() == 'los santos medical group') || (!$IsEms && Data.department.toLowerCase() != 'los santos medical group')}
    function create_if_block_11$1(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[15](/*Data*/ ctx[27]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[
    						/*Data*/ ctx[27].callsign
    						? `(${/*Data*/ ctx[27].callsign}) ${/*Data*/ ctx[27].name}`
    						: /*Data*/ ctx[27].name
    					],
    					[`ID: ${/*Data*/ ctx[27].id}`]
    				]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};

    			if (dirty[0] & /*FilteredStaff*/ 1) mdwcard_changes.Information = [
    				[
    					/*Data*/ ctx[27].callsign
    					? `(${/*Data*/ ctx[27].callsign}) ${/*Data*/ ctx[27].name}`
    					: /*Data*/ ctx[27].name
    				],
    				[`ID: ${/*Data*/ ctx[27].id}`]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(112:12) {#if (!$IsPublic && $IsEms && Data.department.toLowerCase() == 'los santos medical group') || (!$IsEms && Data.department.toLowerCase() != 'los santos medical group')}",
    		ctx
    	});

    	return block;
    }

    // (111:8) {#each FilteredStaff as Data, Key}
    function create_each_block_3(ctx) {
    	let show_if = !/*$IsPublic*/ ctx[4] && /*$IsEms*/ ctx[5] && /*Data*/ ctx[27].department.toLowerCase() == 'los santos medical group' || !/*$IsEms*/ ctx[5] && /*Data*/ ctx[27].department.toLowerCase() != 'los santos medical group';
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block_11$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$IsPublic, $IsEms, FilteredStaff*/ 49) show_if = !/*$IsPublic*/ ctx[4] && /*$IsEms*/ ctx[5] && /*Data*/ ctx[27].department.toLowerCase() == 'los santos medical group' || !/*$IsEms*/ ctx[5] && /*Data*/ ctx[27].department.toLowerCase() != 'los santos medical group';

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$IsPublic, $IsEms, FilteredStaff*/ 49) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_11$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(111:8) {#each FilteredStaff as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (110:4) <MdwPanelList>
    function create_default_slot_11$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*FilteredStaff*/ ctx[0];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*FilteredStaff, FetchById, $IsPublic, $IsEms*/ 305) {
    				each_value_3 = /*FilteredStaff*/ ctx[0];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(110:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (104:0) <MdwPanel class="filled">
    function create_default_slot_10$2(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty[0] & /*FilteredStaff, $IsPublic, $IsEms*/ 49 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(104:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:4) <MdwPanelHeader>
    function create_default_slot_9$2(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Profile";
    			add_location(h6, file$r, 123, 8, 4457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(123:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (122:0) <MdwPanel class="filled">
    function create_default_slot_8$2(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t1;
    	let div1;
    	let textfield0;
    	let updating_RealValue;
    	let t2;
    	let textfield1;
    	let updating_RealValue_1;
    	let t3;
    	let textfield2;
    	let updating_RealValue_2;
    	let t4;
    	let textfield3;
    	let updating_RealValue_3;
    	let t5;
    	let textfield4;
    	let updating_RealValue_4;
    	let t6;
    	let textfield5;
    	let updating_RealValue_5;
    	let t7;
    	let textfield6;
    	let updating_RealValue_6;
    	let t8;
    	let textfield7;
    	let updating_RealValue_7;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[16](value);
    	}

    	let textfield0_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "SSN",
    		Icon: "id-card"
    	};

    	if (/*$CurrentStaff*/ ctx[3].citizenid !== void 0) {
    		textfield0_props.RealValue = /*$CurrentStaff*/ ctx[3].citizenid;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[17](value);
    	}

    	let textfield1_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Name",
    		Icon: "user"
    	};

    	if (/*$CurrentStaff*/ ctx[3].name !== void 0) {
    		textfield1_props.RealValue = /*$CurrentStaff*/ ctx[3].name;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	function textfield2_RealValue_binding(value) {
    		/*textfield2_RealValue_binding*/ ctx[18](value);
    	}

    	let textfield2_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Callsign",
    		Icon: "tag"
    	};

    	if (/*$CurrentStaff*/ ctx[3].callsign !== void 0) {
    		textfield2_props.RealValue = /*$CurrentStaff*/ ctx[3].callsign;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'RealValue', textfield2_RealValue_binding));

    	function textfield3_RealValue_binding(value) {
    		/*textfield3_RealValue_binding*/ ctx[19](value);
    	}

    	let textfield3_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Alias",
    		Icon: "mask"
    	};

    	if (/*$CurrentStaff*/ ctx[3].alias !== void 0) {
    		textfield3_props.RealValue = /*$CurrentStaff*/ ctx[3].alias;
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'RealValue', textfield3_RealValue_binding));

    	function textfield4_RealValue_binding(value) {
    		/*textfield4_RealValue_binding*/ ctx[20](value);
    	}

    	let textfield4_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Phone Number",
    		Icon: "mobile-alt"
    	};

    	if (/*$CurrentStaff*/ ctx[3].phonenumber !== void 0) {
    		textfield4_props.RealValue = /*$CurrentStaff*/ ctx[3].phonenumber;
    	}

    	textfield4 = new TextField({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'RealValue', textfield4_RealValue_binding));

    	function textfield5_RealValue_binding(value) {
    		/*textfield5_RealValue_binding*/ ctx[21](value);
    	}

    	let textfield5_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Unit",
    		Icon: "house-user"
    	};

    	if (/*$CurrentStaff*/ ctx[3].department !== void 0) {
    		textfield5_props.RealValue = /*$CurrentStaff*/ ctx[3].department;
    	}

    	textfield5 = new TextField({ props: textfield5_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield5, 'RealValue', textfield5_RealValue_binding));

    	function textfield6_RealValue_binding(value) {
    		/*textfield6_RealValue_binding*/ ctx[22](value);
    	}

    	let textfield6_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Rank",
    		Icon: "certificate"
    	};

    	if (/*CurrentRank*/ ctx[2] !== void 0) {
    		textfield6_props.RealValue = /*CurrentRank*/ ctx[2];
    	}

    	textfield6 = new TextField({ props: textfield6_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield6, 'RealValue', textfield6_RealValue_binding));

    	function textfield7_RealValue_binding(value) {
    		/*textfield7_RealValue_binding*/ ctx[23](value);
    	}

    	let textfield7_props = {
    		ReadOnly: true,
    		style: "margin-bottom: 0px;",
    		Title: "Strikes",
    		Icon: "times-circle"
    	};

    	if (/*AmountOfStrikes*/ ctx[1] !== void 0) {
    		textfield7_props.RealValue = /*AmountOfStrikes*/ ctx[1];
    	}

    	textfield7 = new TextField({ props: textfield7_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield7, 'RealValue', textfield7_RealValue_binding));

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t1 = space();
    			div1 = element("div");
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			create_component(textfield2.$$.fragment);
    			t4 = space();
    			create_component(textfield3.$$.fragment);
    			t5 = space();
    			create_component(textfield4.$$.fragment);
    			t6 = space();
    			create_component(textfield5.$$.fragment);
    			t7 = space();
    			create_component(textfield6.$$.fragment);
    			t8 = space();
    			create_component(textfield7.$$.fragment);
    			if (!src_url_equal(img.src, img_src_value = /*$CurrentStaff*/ ctx[3].image || "./images/mugshot.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			set_style(img, "width", "19vh");
    			set_style(img, "height", "19vh");
    			set_style(img, "border", "0.15vh solid black");
    			add_location(img, file$r, 128, 12, 4688);
    			set_style(div0, "height", "19.3vh");
    			set_style(div0, "width", "19.3vh");
    			add_location(div0, file$r, 127, 8, 4630);
    			set_style(div1, "margin-left", "0.7vh");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$r, 131, 8, 4847);
    			set_style(div2, "display", "flex");
    			set_style(div2, "flex-direction", "row");
    			set_style(div2, "width", "97%");
    			set_style(div2, "height", "19.4vh");
    			set_style(div2, "margin-left", "auto");
    			set_style(div2, "margin-right", "auto");
    			add_location(div2, file$r, 126, 4, 4504);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, img);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t2);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t3);
    			mount_component(textfield2, div1, null);
    			append_dev(div1, t4);
    			mount_component(textfield3, div1, null);
    			append_dev(div1, t5);
    			mount_component(textfield4, div1, null);
    			append_dev(div1, t6);
    			mount_component(textfield5, div1, null);
    			append_dev(div1, t7);
    			mount_component(textfield6, div1, null);
    			append_dev(div1, t8);
    			mount_component(textfield7, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (!current || dirty[0] & /*$CurrentStaff*/ 8 && !src_url_equal(img.src, img_src_value = /*$CurrentStaff*/ ctx[3].image || "./images/mugshot.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*$CurrentStaff*/ ctx[3].citizenid;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_RealValue_1 && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$CurrentStaff*/ ctx[3].name;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_RealValue_2 && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue_2 = true;
    				textfield2_changes.RealValue = /*$CurrentStaff*/ ctx[3].callsign;
    				add_flush_callback(() => updating_RealValue_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_RealValue_3 && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue_3 = true;
    				textfield3_changes.RealValue = /*$CurrentStaff*/ ctx[3].alias;
    				add_flush_callback(() => updating_RealValue_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_RealValue_4 && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue_4 = true;
    				textfield4_changes.RealValue = /*$CurrentStaff*/ ctx[3].phonenumber;
    				add_flush_callback(() => updating_RealValue_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const textfield5_changes = {};

    			if (!updating_RealValue_5 && dirty[0] & /*$CurrentStaff*/ 8) {
    				updating_RealValue_5 = true;
    				textfield5_changes.RealValue = /*$CurrentStaff*/ ctx[3].department;
    				add_flush_callback(() => updating_RealValue_5 = false);
    			}

    			textfield5.$set(textfield5_changes);
    			const textfield6_changes = {};

    			if (!updating_RealValue_6 && dirty[0] & /*CurrentRank*/ 4) {
    				updating_RealValue_6 = true;
    				textfield6_changes.RealValue = /*CurrentRank*/ ctx[2];
    				add_flush_callback(() => updating_RealValue_6 = false);
    			}

    			textfield6.$set(textfield6_changes);
    			const textfield7_changes = {};

    			if (!updating_RealValue_7 && dirty[0] & /*AmountOfStrikes*/ 2) {
    				updating_RealValue_7 = true;
    				textfield7_changes.RealValue = /*AmountOfStrikes*/ ctx[1];
    				add_flush_callback(() => updating_RealValue_7 = false);
    			}

    			textfield7.$set(textfield7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(textfield5.$$.fragment, local);
    			transition_in(textfield6.$$.fragment, local);
    			transition_in(textfield7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(textfield5.$$.fragment, local);
    			transition_out(textfield6.$$.fragment, local);
    			transition_out(textfield7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(textfield5);
    			destroy_component(textfield6);
    			destroy_component(textfield7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(122:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:12) {#if !$IsPublic && $IsHighcommand}
    function create_if_block_9$3(ctx) {
    	let div;
    	let if_block = /*$CurrentStaff*/ ctx[3].id && create_if_block_10$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$r, 150, 16, 6282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$CurrentStaff*/ ctx[3].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_10$3(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$3.name,
    		type: "if",
    		source: "(150:12) {#if !$IsPublic && $IsHighcommand}",
    		ctx
    	});

    	return block;
    }

    // (152:20) {#if $CurrentStaff.id}
    function create_if_block_10$3(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$r, 152, 24, 6385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[14], false, false, false, false),
    					listen_dev(i, "click", /*AddRole*/ ctx[11], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$3.name,
    		type: "if",
    		source: "(152:20) {#if $CurrentStaff.id}",
    		ctx
    	});

    	return block;
    }

    // (147:8) <MdwPanelHeader>
    function create_default_slot_7$3(ctx) {
    	let h6;
    	let t1;
    	let if_block_anchor;
    	let if_block = !/*$IsPublic*/ ctx[4] && /*$IsHighcommand*/ ctx[6] && create_if_block_9$3(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Roles";
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h6, file$r, 147, 12, 6196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$IsPublic*/ ctx[4] && /*$IsHighcommand*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_9$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(147:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (159:8) {#if $CurrentStaff.id && $CurrentStaff.roles}
    function create_if_block_7$4(ctx) {
    	let div;
    	let current;
    	let each_value_2 = /*$CurrentStaff*/ ctx[3].roles;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$r, 159, 12, 6608);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentStaff, RemoveRole, $IsHighcommand*/ 4168) {
    				each_value_2 = /*$CurrentStaff*/ ctx[3].roles;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$4.name,
    		type: "if",
    		source: "(159:8) {#if $CurrentStaff.id && $CurrentStaff.roles}",
    		ctx
    	});

    	return block;
    }

    // (164:20) {:else}
    function create_else_block_1$4(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				PrefixIcon: GetRoleById(/*Data*/ ctx[27]).icon,
    				Text: GetRoleById(/*Data*/ ctx[27]).name
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.PrefixIcon = GetRoleById(/*Data*/ ctx[27]).icon;
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Text = GetRoleById(/*Data*/ ctx[27]).name;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(164:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (162:20) {#if $IsHighcommand}
    function create_if_block_8$4(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[24](/*Key*/ ctx[29]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				PrefixIcon: GetRoleById(/*Data*/ ctx[27]).icon,
    				Color: GetRoleById(/*Data*/ ctx[27]).color,
    				Text: GetRoleById(/*Data*/ ctx[27]).name,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_1);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.PrefixIcon = GetRoleById(/*Data*/ ctx[27]).icon;
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Color = GetRoleById(/*Data*/ ctx[27]).color;
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Text = GetRoleById(/*Data*/ ctx[27]).name;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$4.name,
    		type: "if",
    		source: "(162:20) {#if $IsHighcommand}",
    		ctx
    	});

    	return block;
    }

    // (161:16) {#each $CurrentStaff.roles as Data, Key}
    function create_each_block_2$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_8$4, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$IsHighcommand*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(161:16) {#each $CurrentStaff.roles as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (146:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_6$5(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].roles && create_if_block_7$4(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsPublic, $IsHighcommand*/ 88 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].roles) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentStaff*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_7$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(146:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (176:12) {#if !$IsPublic}
    function create_if_block_5$6(ctx) {
    	let div;
    	let show_if = /*$CurrentStaff*/ ctx[3].id && HasCidPermission("Staff.GiveCerts");
    	let if_block = show_if && create_if_block_6$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$r, 176, 16, 7462);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentStaff*/ 8) show_if = /*$CurrentStaff*/ ctx[3].id && HasCidPermission("Staff.GiveCerts");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_6$4(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(176:12) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (178:20) {#if $CurrentStaff.id && HasCidPermission("Staff.GiveCerts")}
    function create_if_block_6$4(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$r, 178, 24, 7604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[13], false, false, false, false),
    					listen_dev(i, "click", /*AddCert*/ ctx[9], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(178:20) {#if $CurrentStaff.id && HasCidPermission(\\\"Staff.GiveCerts\\\")}",
    		ctx
    	});

    	return block;
    }

    // (173:8) <MdwPanelHeader>
    function create_default_slot_5$7(ctx) {
    	let h6;
    	let t1;
    	let if_block_anchor;
    	let if_block = !/*$IsPublic*/ ctx[4] && create_if_block_5$6(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Certifications";
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h6, file$r, 173, 12, 7385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$IsPublic*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(173:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (185:8) {#if $CurrentStaff.id && $CurrentStaff.certs}
    function create_if_block_3$7(ctx) {
    	let div;
    	let current;
    	let each_value_1 = /*$CurrentStaff*/ ctx[3].certs;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$r, 185, 12, 7827);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentStaff, RemoveCert*/ 1032) {
    				each_value_1 = /*$CurrentStaff*/ ctx[3].certs;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(185:8) {#if $CurrentStaff.id && $CurrentStaff.certs}",
    		ctx
    	});

    	return block;
    }

    // (190:20) {:else}
    function create_else_block$7(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				PrefixIcon: "certificate",
    				Text: GetCertById(/*Data*/ ctx[27]).certificate
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Text = GetCertById(/*Data*/ ctx[27]).certificate;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(190:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (188:20) {#if HasCidPermission("Staff.GiveCerts")}
    function create_if_block_4$6(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[25](/*Key*/ ctx[29]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				PrefixIcon: "certificate",
    				Color: GetCertById(/*Data*/ ctx[27]).color,
    				Text: GetCertById(/*Data*/ ctx[27]).certificate,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_2);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Color = GetCertById(/*Data*/ ctx[27]).color;
    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwchip_changes.Text = GetCertById(/*Data*/ ctx[27]).certificate;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(188:20) {#if HasCidPermission(\\\"Staff.GiveCerts\\\")}",
    		ctx
    	});

    	return block;
    }

    // (187:16) {#each $CurrentStaff.certs as Data, Key}
    function create_each_block_1$6(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4$6, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (HasCidPermission("Staff.GiveCerts")) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(187:16) {#each $CurrentStaff.certs as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (172:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_4$7(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].certs && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsPublic*/ 24 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].certs) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentStaff*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(172:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (198:4) {#if !$IsPublic && HasCidPermission("Staff.ShowStrikes")}
    function create_if_block$l(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsHighcommand*/ 72 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(198:4) {#if !$IsPublic && HasCidPermission(\\\"Staff.ShowStrikes\\\")}",
    		ctx
    	});

    	return block;
    }

    // (200:12) <MdwPanelHeader>
    function create_default_slot_3$7(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Strikes";
    			add_location(h6, file$r, 200, 16, 8692);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(200:12) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (205:16) {#if $CurrentStaff.id && $CurrentStaff.strikes}
    function create_if_block_1$b(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$CurrentStaff*/ ctx[3].strikes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$CurrentStaff, $IsHighcommand*/ 72) {
    				each_value = /*$CurrentStaff*/ ctx[3].strikes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(205:16) {#if $CurrentStaff.id && $CurrentStaff.strikes}",
    		ctx
    	});

    	return block;
    }

    // (207:24) {#if !Data.Deleted || $IsHighcommand}
    function create_if_block_2$9(ctx) {
    	let mdwcard;
    	let current;

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[
    						/*Data*/ ctx[27].Reason,
    						/*Data*/ ctx[27].Points > 1
    						? `${/*Data*/ ctx[27].Points} strikes`
    						: `${/*Data*/ ctx[27].Points} strike`
    					],
    					[
    						`ID: ${/*Key*/ ctx[29] + 1} ${/*Data*/ ctx[27].Deleted ? "(Revoked)" : ""}`,
    						`${/*Data*/ ctx[27].Issuer} - ${GetTimeLabel(/*Data*/ ctx[27].Timestamp)}`
    					]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwcard_changes = {};

    			if (dirty[0] & /*$CurrentStaff*/ 8) mdwcard_changes.Information = [
    				[
    					/*Data*/ ctx[27].Reason,
    					/*Data*/ ctx[27].Points > 1
    					? `${/*Data*/ ctx[27].Points} strikes`
    					: `${/*Data*/ ctx[27].Points} strike`
    				],
    				[
    					`ID: ${/*Key*/ ctx[29] + 1} ${/*Data*/ ctx[27].Deleted ? "(Revoked)" : ""}`,
    					`${/*Data*/ ctx[27].Issuer} - ${GetTimeLabel(/*Data*/ ctx[27].Timestamp)}`
    				]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(207:24) {#if !Data.Deleted || $IsHighcommand}",
    		ctx
    	});

    	return block;
    }

    // (206:20) {#each $CurrentStaff.strikes as Data, Key}
    function create_each_block$f(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (!/*Data*/ ctx[27].Deleted || /*$IsHighcommand*/ ctx[6]) && create_if_block_2$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*Data*/ ctx[27].Deleted || /*$IsHighcommand*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentStaff, $IsHighcommand*/ 72) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(206:20) {#each $CurrentStaff.strikes as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (204:12) <MdwPanelList>
    function create_default_slot_2$8(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].strikes && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$CurrentStaff*/ ctx[3].id && /*$CurrentStaff*/ ctx[3].strikes) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$CurrentStaff*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(204:12) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (199:8) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_1$b(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsHighcommand*/ 72 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(199:8) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:0) <MdwPanel>
    function create_default_slot$k(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let show_if = !/*$IsPublic*/ ctx[4] && HasCidPermission("Staff.ShowStrikes");
    	let if_block_anchor;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = show_if && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsHighcommand, $IsPublic*/ 88 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsPublic*/ 24 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			if (dirty[0] & /*$IsPublic*/ 16) show_if = !/*$IsPublic*/ ctx[4] && HasCidPermission("Staff.ShowStrikes");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$IsPublic*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(145:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*FilteredStaff, $IsPublic, $IsEms*/ 49 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*AmountOfStrikes, CurrentRank, $CurrentStaff*/ 14 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*$CurrentStaff, $IsHighcommand, $IsPublic*/ 88 | dirty[1] & /*$$scope*/ 4) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $CurrentStaff;
    	let $IsPublic;
    	let $IsEms;
    	let $IsHighcommand;
    	validate_store(CurrentStaff, 'CurrentStaff');
    	component_subscribe($$self, CurrentStaff, $$value => $$invalidate(3, $CurrentStaff = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(4, $IsPublic = $$value));
    	validate_store(IsEms, 'IsEms');
    	component_subscribe($$self, IsEms, $$value => $$invalidate(5, $IsEms = $$value));
    	validate_store(IsHighcommand, 'IsHighcommand');
    	component_subscribe($$self, IsHighcommand, $$value => $$invalidate(6, $IsHighcommand = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Staff', slots, []);
    	let Staff = [];
    	let FilteredStaff = [];
    	let AmountOfStrikes = 0;
    	let CurrentRank = '';

    	onMount(() => {
    		SendEvent("Staff/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Staff = Data;
    			$$invalidate(0, FilteredStaff = Data);
    		});
    	});

    	const FilterStaff = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredStaff = Staff.filter(Val => {
    			return Val.citizenid.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search) || Val.callsign.toLowerCase().includes(Search) || Val.alias.toLowerCase().includes(Search);
    		}));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Staff/FetchById", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentStaff.set(Data);
    			$$invalidate(1, AmountOfStrikes = 0);

    			for (let i = 0; i < Data.strikes.length; i++) {
    				if (!Data.strikes[i].Deleted) {
    					$$invalidate(1, AmountOfStrikes = AmountOfStrikes + Data.strikes[i].Points);
    				}
    			}
    			$$invalidate(2, CurrentRank = GetRankById(Data.rank)?.rank || 'Unknown');
    		});
    	};

    	const AddCert = () => {
    		MdwModalsCerts.set({
    			Show: true,
    			IgnoreFilter: $CurrentStaff.certs,
    			Cb: CertId => {
    				SendEvent("Staff/AddCert", { Id: $CurrentStaff.id, Cert: CertId }, (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentStaff, $CurrentStaff.certs = [...$CurrentStaff.certs, CertId], $CurrentStaff);
    				});
    			}
    		});
    	};

    	const RemoveCert = Id => {
    		ShowLoader.set(true);

    		SendEvent("Staff/RemoveCert", { Id: $CurrentStaff.id, Cert: Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			let NewStaff = { ...$CurrentStaff };
    			NewStaff.certs.splice(Id - 1, 1);
    			CurrentStaff.set(NewStaff);
    		});
    	};

    	const AddRole = () => {
    		MdwModalsRoles.set({
    			Show: true,
    			IgnoreFilter: $CurrentStaff.roles,
    			Cb: RoleId => {
    				SendEvent("Staff/AddRole", { Id: $CurrentStaff.id, Role: RoleId }, (Success, Data) => {
    					if (!Success) return;
    					set_store_value(CurrentStaff, $CurrentStaff.roles = [...$CurrentStaff.roles, RoleId], $CurrentStaff);
    				});
    			}
    		});
    	};

    	const RemoveRole = Id => {
    		ShowLoader.set(true);

    		SendEvent("Staff/RemoveRole", { Id: $CurrentStaff.id, Role: Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			let NewStaff = { ...$CurrentStaff };
    			NewStaff.roles.splice(Id - 1, 1);
    			CurrentStaff.set(NewStaff);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Staff> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	function textfield0_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.citizenid, value)) {
    			$CurrentStaff.citizenid = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.name, value)) {
    			$CurrentStaff.name = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield2_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.callsign, value)) {
    			$CurrentStaff.callsign = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield3_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.alias, value)) {
    			$CurrentStaff.alias = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield4_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.phonenumber, value)) {
    			$CurrentStaff.phonenumber = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield5_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentStaff.department, value)) {
    			$CurrentStaff.department = value;
    			CurrentStaff.set($CurrentStaff);
    		}
    	}

    	function textfield6_RealValue_binding(value) {
    		CurrentRank = value;
    		$$invalidate(2, CurrentRank);
    	}

    	function textfield7_RealValue_binding(value) {
    		AmountOfStrikes = value;
    		$$invalidate(1, AmountOfStrikes);
    	}

    	const click_handler_1 = Key => {
    		RemoveRole(Key + 1);
    	};

    	const click_handler_2 = Key => {
    		RemoveCert(Key + 1);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		MdwCard,
    		onMount,
    		GetCertById,
    		GetRankById,
    		GetRoleById,
    		GetTimeLabel,
    		HasCidPermission,
    		SendEvent,
    		CurrentStaff,
    		IsEms,
    		IsHighcommand,
    		IsPublic,
    		MdwModalsCerts,
    		MdwModalsRoles,
    		ShowLoader,
    		MdwChip,
    		Staff,
    		FilteredStaff,
    		AmountOfStrikes,
    		CurrentRank,
    		FilterStaff,
    		FetchById,
    		AddCert,
    		RemoveCert,
    		AddRole,
    		RemoveRole,
    		$CurrentStaff,
    		$IsPublic,
    		$IsEms,
    		$IsHighcommand
    	});

    	$$self.$inject_state = $$props => {
    		if ('Staff' in $$props) Staff = $$props.Staff;
    		if ('FilteredStaff' in $$props) $$invalidate(0, FilteredStaff = $$props.FilteredStaff);
    		if ('AmountOfStrikes' in $$props) $$invalidate(1, AmountOfStrikes = $$props.AmountOfStrikes);
    		if ('CurrentRank' in $$props) $$invalidate(2, CurrentRank = $$props.CurrentRank);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredStaff,
    		AmountOfStrikes,
    		CurrentRank,
    		$CurrentStaff,
    		$IsPublic,
    		$IsEms,
    		$IsHighcommand,
    		FilterStaff,
    		FetchById,
    		AddCert,
    		RemoveCert,
    		AddRole,
    		RemoveRole,
    		keyup_handler_1,
    		keyup_handler,
    		click_handler,
    		textfield0_RealValue_binding,
    		textfield1_RealValue_binding,
    		textfield2_RealValue_binding,
    		textfield3_RealValue_binding,
    		textfield4_RealValue_binding,
    		textfield5_RealValue_binding,
    		textfield6_RealValue_binding,
    		textfield7_RealValue_binding,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Staff_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$s, create_fragment$s, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Staff_1",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Legislation.svelte generated by Svelte v3.59.2 */

    const { console: console_1 } = globals;
    const file$q = "src\\apps\\Mdw\\apps\\Legislation.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[25] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[25] = i;
    	return child_ctx;
    }

    // (123:4) <MdwPanelHeader>
    function create_default_slot_7$2(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterLegislation*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Legislation";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$q, 123, 8, 4860);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(123:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (129:8) {#each FilteredLegislations as Data, Key}
    function create_each_block_1$5(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[14](/*Data*/ ctx[23]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [[/*Data*/ ctx[23].title], [`ID: ${/*Data*/ ctx[23].id}`]]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};
    			if (dirty & /*FilteredLegislations*/ 1) mdwcard_changes.Information = [[/*Data*/ ctx[23].title], [`ID: ${/*Data*/ ctx[23].id}`]];
    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(129:8) {#each FilteredLegislations as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (128:4) <MdwPanelList>
    function create_default_slot_6$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*FilteredLegislations*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredLegislations, FetchById*/ 33) {
    				each_value_1 = /*FilteredLegislations*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(128:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (122:0) <MdwPanel class="filled">
    function create_default_slot_5$6(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 134217728) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredLegislations*/ 134217729) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(122:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:8) {:else}
    function create_else_block_1$3(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Add Legislation";
    			add_location(h6, file$q, 142, 12, 5456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(142:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (140:8) {#if $CurrentLegislation.id}
    function create_if_block_10$2(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*$CurrentLegislation*/ ctx[2].id + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Edit Legislation (#");
    			t1 = text(t1_value);
    			t2 = text(")");
    			add_location(h6, file$q, 140, 12, 5372);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CurrentLegislation*/ 4 && t1_value !== (t1_value = /*$CurrentLegislation*/ ctx[2].id + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(140:8) {#if $CurrentLegislation.id}",
    		ctx
    	});

    	return block;
    }

    // (146:8) {#if !$IsPublic}
    function create_if_block_4$5(ctx) {
    	let div;
    	let show_if;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$CurrentLegislation*/ ctx[2].id) return create_if_block_5$5;
    		if (show_if == null) show_if = !!HasCidPermission("Legislation.Create");
    		if (show_if) return create_if_block_9$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$q, 146, 12, 5537);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(146:8) {#if !$IsPublic}",
    		ctx
    	});

    	return block;
    }

    // (153:20) {#if HasCidPermission("Legislation.Create")}
    function create_if_block_9$2(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$q, 152, 65, 6245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_3*/ ctx[13], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_4*/ ctx[18], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(153:20) {#if HasCidPermission(\\\"Legislation.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (148:16) {#if $CurrentLegislation.id}
    function create_if_block_5$5(ctx) {
    	let show_if_2 = HasCidPermission("Legislation.Create");
    	let t0;
    	let show_if_1 = HasCidPermission("Legislation.Delete");
    	let t1;
    	let show_if = HasCidPermission("Legislation.Edit");
    	let if_block2_anchor;
    	let if_block0 = show_if_2 && create_if_block_8$3(ctx);
    	let if_block1 = show_if_1 && create_if_block_7$3(ctx);
    	let if_block2 = show_if && create_if_block_6$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if_2) if_block0.p(ctx, dirty);
    			if (show_if_1) if_block1.p(ctx, dirty);
    			if (show_if) if_block2.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(148:16) {#if $CurrentLegislation.id}",
    		ctx
    	});

    	return block;
    }

    // (149:20) {#if HasCidPermission("Legislation.Create")}
    function create_if_block_8$3(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "New");
    			attr_dev(i, "class", "fas fa-sync");
    			add_location(i, file$q, 148, 65, 5683);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[12], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_1*/ ctx[15], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$3.name,
    		type: "if",
    		source: "(149:20) {#if HasCidPermission(\\\"Legislation.Create\\\")}",
    		ctx
    	});

    	return block;
    }

    // (150:20) {#if HasCidPermission("Legislation.Delete")}
    function create_if_block_7$3(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Delete");
    			attr_dev(i, "class", "fas fa-trash");
    			add_location(i, file$q, 149, 65, 5861);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[11], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_2*/ ctx[16], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(150:20) {#if HasCidPermission(\\\"Legislation.Delete\\\")}",
    		ctx
    	});

    	return block;
    }

    // (151:20) {#if HasCidPermission("Legislation.Edit")}
    function create_if_block_6$3(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "data-tooltip", "Save");
    			attr_dev(i, "class", "fas fa-save");
    			add_location(i, file$q, 150, 63, 6042);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_2*/ ctx[10], false, false, false, false),
    					listen_dev(i, "click", /*click_handler_3*/ ctx[17], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(151:20) {#if HasCidPermission(\\\"Legislation.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (139:4) <MdwPanelHeader>
    function create_default_slot_4$6(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$CurrentLegislation*/ ctx[2].id) return create_if_block_10$2;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*$IsPublic*/ ctx[3] && create_if_block_4$5(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (!/*$IsPublic*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$5(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(139:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (138:0) <MdwPanel class="filled">
    function create_default_slot_3$6(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div0;
    	let textfield;
    	let updating_RealValue;
    	let t1;
    	let div1;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield_RealValue_binding(value) {
    		/*textfield_RealValue_binding*/ ctx[19](value);
    	}

    	let textfield_props = {
    		style: "margin-bottom: 0px;",
    		Title: "Title",
    		Icon: "pencil-alt"
    	};

    	if (/*$CurrentLegislation*/ ctx[2].title !== void 0) {
    		textfield_props.RealValue = /*$CurrentLegislation*/ ctx[2].title;
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'RealValue', textfield_RealValue_binding));

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			set_style(div0, "width", "97%");
    			set_style(div0, "margin-left", "auto");
    			set_style(div0, "margin-right", "auto");
    			add_location(div0, file$q, 158, 4, 6445);
    			attr_dev(div1, "class", "mdw-legislation-editor svelte-d5rmxr");
    			add_location(div1, file$q, 162, 4, 6655);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(textfield, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			/*div1_binding*/ ctx[20](div1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, $CurrentLegislation, $IsPublic*/ 134217740) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const textfield_changes = {};

    			if (!updating_RealValue && dirty & /*$CurrentLegislation*/ 4) {
    				updating_RealValue = true;
    				textfield_changes.RealValue = /*$CurrentLegislation*/ ctx[2].title;
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			/*div1_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(138:0) <MdwPanel class=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (171:12) {#if HasCidPermission("Legislation.Edit")}
    function create_if_block_2$8(ctx) {
    	let div;
    	let if_block = /*$CurrentLegislation*/ ctx[2].id && create_if_block_3$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-box-title-icons");
    			add_location(div, file$q, 171, 16, 6982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$CurrentLegislation*/ ctx[2].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$6(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(171:12) {#if HasCidPermission(\\\"Legislation.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (173:20) {#if $CurrentLegislation.id}
    function create_if_block_3$6(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$q, 173, 24, 7091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_4*/ ctx[9], false, false, false, false),
    					listen_dev(i, "click", /*AddTag*/ ctx[7], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(173:20) {#if $CurrentLegislation.id}",
    		ctx
    	});

    	return block;
    }

    // (168:8) <MdwPanelHeader>
    function create_default_slot_2$7(ctx) {
    	let h6;
    	let t1;
    	let show_if = HasCidPermission("Legislation.Edit");
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_2$8(ctx);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Tags";
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h6, file$q, 168, 12, 6889);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (show_if) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(168:8) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (180:8) {#if $CurrentLegislation.id && $CurrentLegislation.tags}
    function create_if_block$k(ctx) {
    	let div;
    	let current;
    	let each_value = /*$CurrentLegislation*/ ctx[2].tags;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "padding", "0.37vh");
    			set_style(div, "padding-top", "0");
    			set_style(div, "display", "flex");
    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "box-sizing", "border-box");
    			add_location(div, file$q, 180, 12, 7324);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*GetTagById, $CurrentLegislation, RemoveTag, HasCidPermission*/ 260) {
    				each_value = /*$CurrentLegislation*/ ctx[2].tags;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(180:8) {#if $CurrentLegislation.id && $CurrentLegislation.tags}",
    		ctx
    	});

    	return block;
    }

    // (185:20) {:else}
    function create_else_block$6(ctx) {
    	let mdwchip;
    	let current;

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[23]).tag,
    				Color: GetTagById(/*Data*/ ctx[23]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[23]).icon
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwchip_changes = {};
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[23]).tag;
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[23]).color;
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[23]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(185:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (183:20) {#if HasCidPermission("Legislation.Edit")}
    function create_if_block_1$a(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[21](/*Key*/ ctx[25]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: GetTagById(/*Data*/ ctx[23]).tag,
    				Color: GetTagById(/*Data*/ ctx[23]).color,
    				PrefixIcon: GetTagById(/*Data*/ ctx[23]).icon,
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler_5);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.Text = GetTagById(/*Data*/ ctx[23]).tag;
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.Color = GetTagById(/*Data*/ ctx[23]).color;
    			if (dirty & /*$CurrentLegislation*/ 4) mdwchip_changes.PrefixIcon = GetTagById(/*Data*/ ctx[23]).icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(183:20) {#if HasCidPermission(\\\"Legislation.Edit\\\")}",
    		ctx
    	});

    	return block;
    }

    // (182:16) {#each $CurrentLegislation.tags as Data, Key}
    function create_each_block$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$a, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (HasCidPermission("Legislation.Edit")) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(182:16) {#each $CurrentLegislation.tags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (167:4) <MdwPanel class="filled" style="width: 100%; height: max-content; margin-bottom: 0.5vh;">
    function create_default_slot_1$a(ctx) {
    	let mdwpanelheader;
    	let t;
    	let if_block_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentLegislation*/ ctx[2].id && /*$CurrentLegislation*/ ctx[2].tags && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, $CurrentLegislation*/ 134217732) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (/*$CurrentLegislation*/ ctx[2].id && /*$CurrentLegislation*/ ctx[2].tags) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$CurrentLegislation*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(167:4) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; height: max-content; margin-bottom: 0.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (166:0) <MdwPanel>
    function create_default_slot$j(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; height: max-content; margin-bottom: 0.5vh;",
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, $CurrentLegislation*/ 134217732) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(166:0) <MdwPanel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel0_changes = {};

    			if (dirty & /*$$scope, FilteredLegislations*/ 134217729) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty & /*$$scope, LegislationEditor, $CurrentLegislation, $IsPublic*/ 134217742) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty & /*$$scope, $CurrentLegislation*/ 134217732) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $CurrentLegislation;
    	let $IsPublic;
    	validate_store(CurrentLegislation, 'CurrentLegislation');
    	component_subscribe($$self, CurrentLegislation, $$value => $$invalidate(2, $CurrentLegislation = $$value));
    	validate_store(IsPublic, 'IsPublic');
    	component_subscribe($$self, IsPublic, $$value => $$invalidate(3, $IsPublic = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Legislation', slots, []);
    	let Legislations = [];
    	let FilteredLegislations = [];
    	let LegislationEditor;

    	onMount(() => {
    		if (LegislationEditor) {
    			BalloonEditor.create(LegislationEditor, {
    				supportAllValues: true,
    				toolbar: {
    					items: [
    						'heading',
    						'|',
    						'bold',
    						'italic',
    						'|',
    						'blockQuote',
    						'|',
    						'undo',
    						'redo',
    						'|',
    						'numberedList',
    						'bulletedList',
    						'|',
    						'insertTable'
    					],
    					shouldNotGroupWhenFull: true
    				},
    				placeholder: "Begin met typen..."
    			}).then(Editor => {
    				window.editor = Editor;
    				if ($CurrentLegislation.content) window.editor.setData($CurrentLegislation.content);
    			}).catch(Error => {
    				console.error(Error);
    			});
    		}

    		SendEvent("Legislation/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Legislations = Data;
    			$$invalidate(0, FilteredLegislations = Data);
    		});
    	});

    	const FilterLegislation = Value => {
    		const Search = Value.toLowerCase();
    		$$invalidate(0, FilteredLegislations = Legislations.filter(Val => Val.title.toLowerCase().includes(Search)));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Legislation/FetchById", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentLegislation.set(Data);
    			window.editor.setData($CurrentLegislation.content);
    		});
    	};

    	const OnLegislationAction = Type => {
    		if (Type == "Reset") {
    			CurrentLegislation.set({ title: "", content: "" });
    			window.editor.setData("");
    		} else if (Type == "Save") {
    			ShowLoader.set(true);

    			SendEvent(
    				"Legislation/SaveLegislation",
    				{
    					content: window.editor.getData(),
    					title: $CurrentLegislation.title,
    					id: $CurrentLegislation.id
    				},
    				(Success, Data) => {
    					ShowLoader.set(false);
    					if (!Success) return;

    					if (Data) {
    						let LegislationsIndex = Legislations.findIndex(Val => Val.id == $CurrentLegislation.id);

    						if (LegislationsIndex > -1) {
    							Legislations[LegislationsIndex] = Data;
    						} else {
    							Legislations = [Data, ...Legislations];
    						}

    						FetchById(Data.id);
    						$$invalidate(0, FilteredLegislations = Legislations);
    					}
    				}
    			);
    		} else if (Type == "Delete") {
    			ShowLoader.set(true);

    			SendEvent("Legislation/DeleteLegislation", { Id: $CurrentLegislation.id }, () => {
    				let LegislationsIndex = Legislations.findIndex(Val => Val.id == $CurrentLegislation.id);
    				if (LegislationsIndex > -1) Legislations.splice(LegislationsIndex, 1);
    				$$invalidate(0, FilteredLegislations = Legislations);
    				ShowLoader.set(false);
    				OnLegislationAction("Reset");
    			});
    		}
    	};

    	const AddTag = () => {
    		MdwModalsTags.set({
    			Show: true,
    			IgnoreFilter: $CurrentLegislation.tags,
    			Cb: TagId => {
    				SendEvent(
    					"Legislation/AddTag",
    					{
    						LegislationId: $CurrentLegislation.id,
    						TagId
    					},
    					(Success, Data) => {
    						if (!Success) return;
    						set_store_value(CurrentLegislation, $CurrentLegislation.tags = [...$CurrentLegislation.tags, TagId], $CurrentLegislation);
    					}
    				);
    			}
    		});
    	};

    	const RemoveTag = TagId => {
    		SendEvent(
    			"Legislation/RemoveTag",
    			{
    				LegislationId: $CurrentLegislation.id,
    				TagId
    			},
    			(Success, Data) => {
    				if (!Success) return;
    				let NewLegislation = { ...$CurrentLegislation };
    				NewLegislation.tags.splice(TagId, 1);
    				CurrentLegislation.set(NewLegislation);
    			}
    		);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Legislation> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	const click_handler_1 = () => {
    		OnLegislationAction("Reset");
    	};

    	const click_handler_2 = () => {
    		OnLegislationAction("Delete");
    	};

    	const click_handler_3 = () => {
    		OnLegislationAction("Save");
    	};

    	const click_handler_4 = () => {
    		OnLegislationAction("Save");
    	};

    	function textfield_RealValue_binding(value) {
    		if ($$self.$$.not_equal($CurrentLegislation.title, value)) {
    			$CurrentLegislation.title = value;
    			CurrentLegislation.set($CurrentLegislation);
    		}
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			LegislationEditor = $$value;
    			$$invalidate(1, LegislationEditor);
    		});
    	}

    	const click_handler_5 = Key => {
    		RemoveTag(Key);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		MdwCard,
    		onMount,
    		GetTagById,
    		HasCidPermission,
    		SendEvent,
    		CurrentLegislation,
    		IsHighcommand,
    		IsJudge,
    		IsPublic,
    		MdwModalsTags,
    		ShowLoader,
    		BalloonEditor,
    		MdwChip,
    		Legislations,
    		FilteredLegislations,
    		LegislationEditor,
    		FilterLegislation,
    		FetchById,
    		OnLegislationAction,
    		AddTag,
    		RemoveTag,
    		$CurrentLegislation,
    		$IsPublic
    	});

    	$$self.$inject_state = $$props => {
    		if ('Legislations' in $$props) Legislations = $$props.Legislations;
    		if ('FilteredLegislations' in $$props) $$invalidate(0, FilteredLegislations = $$props.FilteredLegislations);
    		if ('LegislationEditor' in $$props) $$invalidate(1, LegislationEditor = $$props.LegislationEditor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredLegislations,
    		LegislationEditor,
    		$CurrentLegislation,
    		$IsPublic,
    		FilterLegislation,
    		FetchById,
    		OnLegislationAction,
    		AddTag,
    		RemoveTag,
    		keyup_handler_4,
    		keyup_handler_2,
    		keyup_handler_1,
    		keyup_handler,
    		keyup_handler_3,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		textfield_RealValue_binding,
    		div1_binding,
    		click_handler_5
    	];
    }

    class Legislation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Legislation",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Businesses.svelte generated by Svelte v3.59.2 */
    const file$p = "src\\apps\\Mdw\\apps\\Businesses.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (55:4) <MdwPanelHeader>
    function create_default_slot_5$5(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterBusinesses*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Business Directory";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$p, 55, 8, 1902);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(55:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (61:8) {#each FilteredBusinesses as Data, Key}
    function create_each_block_1$4(ctx) {
    	let mdwcard;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*Data*/ ctx[8]);
    	}

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[
    						/*Data*/ ctx[8].business_name,
    						/*Data*/ ctx[8].business_account
    						? `Bank Account: ${/*Data*/ ctx[8].business_account}`
    						: ""
    					],
    					[""]
    				]
    			},
    			$$inline: true
    		});

    	mdwcard.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwcard_changes = {};

    			if (dirty & /*FilteredBusinesses*/ 1) mdwcard_changes.Information = [
    				[
    					/*Data*/ ctx[8].business_name,
    					/*Data*/ ctx[8].business_account
    					? `Bank Account: ${/*Data*/ ctx[8].business_account}`
    					: ""
    				],
    				[""]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(61:8) {#each FilteredBusinesses as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (60:4) <MdwPanelList>
    function create_default_slot_4$5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*FilteredBusinesses*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredBusinesses, FetchById*/ 33) {
    				each_value_1 = /*FilteredBusinesses*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(60:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (54:0) <MdwPanel class="filled" style="width: 50%">
    function create_default_slot_3$5(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredBusinesses*/ 4097) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(54:0) <MdwPanel class=\\\"filled\\\" style=\\\"width: 50%\\\">",
    		ctx
    	});

    	return block;
    }

    // (71:4) <MdwPanelHeader>
    function create_default_slot_2$6(ctx) {
    	let h6;
    	let t0;
    	let t1_value = /*$CurrentBusiness*/ ctx[2].Employees.length + "";
    	let t1;
    	let t2;
    	let t3;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterEmployees*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Employee List (");
    			t1 = text(t1_value);
    			t2 = text(")");
    			t3 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$p, 71, 8, 2460);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$CurrentBusiness*/ 4) && t1_value !== (t1_value = /*$CurrentBusiness*/ ctx[2].Employees.length + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t3);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(71:4) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (77:8) {#each FilteredEmployees as Data, Key}
    function create_each_block$d(ctx) {
    	let mdwcard;
    	let current;

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[/*Data*/ ctx[8].Name, `Role: ${/*Data*/ ctx[8].Role}`],
    					[`SSN: ${/*Data*/ ctx[8].Cid}`]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwcard_changes = {};

    			if (dirty & /*FilteredEmployees*/ 2) mdwcard_changes.Information = [
    				[/*Data*/ ctx[8].Name, `Role: ${/*Data*/ ctx[8].Role}`],
    				[`SSN: ${/*Data*/ ctx[8].Cid}`]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(77:8) {#each FilteredEmployees as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (76:4) <MdwPanelList>
    function create_default_slot_1$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*FilteredEmployees*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredEmployees*/ 2) {
    				each_value = /*FilteredEmployees*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(76:4) <MdwPanelList>",
    		ctx
    	});

    	return block;
    }

    // (70:0) <MdwPanel class="filled" style="width: 50%">
    function create_default_slot$i(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, $CurrentBusiness*/ 4100) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, FilteredEmployees*/ 4098) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(70:0) <MdwPanel class=\\\"filled\\\" style=\\\"width: 50%\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let mdwpanel0;
    	let t;
    	let mdwpanel1;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 50%",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 50%",
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t = space();
    			create_component(mdwpanel1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel0_changes = {};

    			if (dirty & /*$$scope, FilteredBusinesses*/ 4097) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty & /*$$scope, FilteredEmployees, $CurrentBusiness*/ 4102) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanel1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $CurrentBusiness;
    	validate_store(CurrentBusiness, 'CurrentBusiness');
    	component_subscribe($$self, CurrentBusiness, $$value => $$invalidate(2, $CurrentBusiness = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Businesses', slots, []);
    	let Businesses = [];
    	let FilteredBusinesses = [];
    	let FilteredEmployees = [];

    	onMount(() => {
    		SendEvent("Businesses/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Businesses = Data;
    			$$invalidate(0, FilteredBusinesses = Data);
    		});
    	});

    	const FilterEmployees = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(1, FilteredEmployees = $CurrentBusiness.Employees.filter(Val => {
    			return Val.Cid.toLowerCase().includes(Search) || Val.Role.toLowerCase().includes(Search) || Val.Name.toLowerCase().includes(Search);
    		}));
    	};

    	const FilterBusinesses = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredBusinesses = Businesses.filter(Val => {
    			return Val.business_name.toLowerCase().includes(Search) || Val.business_account.toLowerCase().includes(Search);
    		}));
    	};

    	const FetchById = Id => {
    		ShowLoader.set(true);

    		SendEvent("Businesses/FetchEmployees", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			CurrentBusiness.set(Data);
    			$$invalidate(1, FilteredEmployees = $CurrentBusiness.Employees);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Businesses> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		FetchById(Data.id);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		TextField,
    		MdwCard,
    		onMount,
    		SendEvent,
    		CurrentBusiness,
    		ShowLoader,
    		Businesses,
    		FilteredBusinesses,
    		FilteredEmployees,
    		FilterEmployees,
    		FilterBusinesses,
    		FetchById,
    		$CurrentBusiness
    	});

    	$$self.$inject_state = $$props => {
    		if ('Businesses' in $$props) Businesses = $$props.Businesses;
    		if ('FilteredBusinesses' in $$props) $$invalidate(0, FilteredBusinesses = $$props.FilteredBusinesses);
    		if ('FilteredEmployees' in $$props) $$invalidate(1, FilteredEmployees = $$props.FilteredEmployees);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredBusinesses,
    		FilteredEmployees,
    		$CurrentBusiness,
    		FilterEmployees,
    		FilterBusinesses,
    		FetchById,
    		click_handler
    	];
    }

    class Businesses_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Businesses_1",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Roster.svelte generated by Svelte v3.59.2 */

    const file$o = "src\\apps\\Mdw\\apps\\Roster.svelte";

    function create_fragment$p(ctx) {
    	let iframe;
    	let iframe_src_value;

    	const block = {
    		c: function create() {
    			iframe = element("iframe");
    			if (!src_url_equal(iframe.src, iframe_src_value = "https://docs.google.com/spreadsheets/d/1eZXbzMG0Ag8yKur6nzDud4IPbIWRMKuANw9j8w3GMRA/edit?usp=sharing")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "width", "100%");
    			attr_dev(iframe, "height", "100%");
    			attr_dev(iframe, "title", "");
    			add_location(iframe, file$o, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, iframe, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(iframe);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Roster', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Roster> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Roster extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Roster",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    const globalWindow = window;
    function CodeJar$1(editor, highlight, opt = {}) {
        const options = Object.assign({ tab: '\t', indentOn: /[({\[]$/, moveToNewLine: /^[)}\]]/, spellcheck: false, catchTab: true, preserveIdent: true, addClosing: true, history: true, window: globalWindow }, opt);
        const window = options.window;
        const document = window.document;
        let listeners = [];
        let history = [];
        let at = -1;
        let focus = false;
        let callback;
        let prev; // code content prior keydown event
        editor.setAttribute('contenteditable', 'plaintext-only');
        editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');
        editor.style.outline = 'none';
        editor.style.overflowWrap = 'break-word';
        editor.style.overflowY = 'auto';
        editor.style.whiteSpace = 'pre-wrap';
        let isLegacy = false; // true if plaintext-only is not supported
        highlight(editor);
        if (editor.contentEditable !== 'plaintext-only')
            isLegacy = true;
        if (isLegacy)
            editor.setAttribute('contenteditable', 'true');
        const debounceHighlight = debounce(() => {
            const pos = save();
            highlight(editor, pos);
            restore(pos);
        }, 30);
        let recording = false;
        const shouldRecord = (event) => {
            return !isUndo(event) && !isRedo(event)
                && event.key !== 'Meta'
                && event.key !== 'Control'
                && event.key !== 'Alt'
                && !event.key.startsWith('Arrow');
        };
        const debounceRecordHistory = debounce((event) => {
            if (shouldRecord(event)) {
                recordHistory();
                recording = false;
            }
        }, 300);
        const on = (type, fn) => {
            listeners.push([type, fn]);
            editor.addEventListener(type, fn);
        };
        on('keydown', event => {
            if (event.defaultPrevented)
                return;
            prev = toString();
            if (options.preserveIdent)
                handleNewLine(event);
            else
                legacyNewLineFix(event);
            if (options.catchTab)
                handleTabCharacters(event);
            if (options.addClosing)
                handleSelfClosingCharacters(event);
            if (options.history) {
                handleUndoRedo(event);
                if (shouldRecord(event) && !recording) {
                    recordHistory();
                    recording = true;
                }
            }
            if (isLegacy && !isCopy(event))
                restore(save());
        });
        on('keyup', event => {
            if (event.defaultPrevented)
                return;
            if (event.isComposing)
                return;
            if (prev !== toString())
                debounceHighlight();
            debounceRecordHistory(event);
            if (callback)
                callback(toString());
        });
        on('focus', _event => {
            focus = true;
        });
        on('blur', _event => {
            focus = false;
        });
        on('paste', event => {
            recordHistory();
            handlePaste(event);
            recordHistory();
            if (callback)
                callback(toString());
        });
        function save() {
            const s = getSelection();
            const pos = { start: 0, end: 0, dir: undefined };
            let { anchorNode, anchorOffset, focusNode, focusOffset } = s;
            if (!anchorNode || !focusNode)
                throw 'error1';
            // If the anchor and focus are the editor element, return either a full
            // highlight or a start/end cursor position depending on the selection
            if (anchorNode === editor && focusNode === editor) {
                pos.start = (anchorOffset > 0 && editor.textContent) ? editor.textContent.length : 0;
                pos.end = (focusOffset > 0 && editor.textContent) ? editor.textContent.length : 0;
                pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';
                return pos;
            }
            // Selection anchor and focus are expected to be text nodes,
            // so normalize them.
            if (anchorNode.nodeType === Node.ELEMENT_NODE) {
                const node = document.createTextNode('');
                anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);
                anchorNode = node;
                anchorOffset = 0;
            }
            if (focusNode.nodeType === Node.ELEMENT_NODE) {
                const node = document.createTextNode('');
                focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);
                focusNode = node;
                focusOffset = 0;
            }
            visit(editor, el => {
                if (el === anchorNode && el === focusNode) {
                    pos.start += anchorOffset;
                    pos.end += focusOffset;
                    pos.dir = anchorOffset <= focusOffset ? '->' : '<-';
                    return 'stop';
                }
                if (el === anchorNode) {
                    pos.start += anchorOffset;
                    if (!pos.dir) {
                        pos.dir = '->';
                    }
                    else {
                        return 'stop';
                    }
                }
                else if (el === focusNode) {
                    pos.end += focusOffset;
                    if (!pos.dir) {
                        pos.dir = '<-';
                    }
                    else {
                        return 'stop';
                    }
                }
                if (el.nodeType === Node.TEXT_NODE) {
                    if (pos.dir != '->')
                        pos.start += el.nodeValue.length;
                    if (pos.dir != '<-')
                        pos.end += el.nodeValue.length;
                }
            });
            // collapse empty text nodes
            editor.normalize();
            return pos;
        }
        function restore(pos) {
            const s = getSelection();
            let startNode, startOffset = 0;
            let endNode, endOffset = 0;
            if (!pos.dir)
                pos.dir = '->';
            if (pos.start < 0)
                pos.start = 0;
            if (pos.end < 0)
                pos.end = 0;
            // Flip start and end if the direction reversed
            if (pos.dir == '<-') {
                const { start, end } = pos;
                pos.start = end;
                pos.end = start;
            }
            let current = 0;
            visit(editor, el => {
                if (el.nodeType !== Node.TEXT_NODE)
                    return;
                const len = (el.nodeValue || '').length;
                if (current + len > pos.start) {
                    if (!startNode) {
                        startNode = el;
                        startOffset = pos.start - current;
                    }
                    if (current + len > pos.end) {
                        endNode = el;
                        endOffset = pos.end - current;
                        return 'stop';
                    }
                }
                current += len;
            });
            if (!startNode)
                startNode = editor, startOffset = editor.childNodes.length;
            if (!endNode)
                endNode = editor, endOffset = editor.childNodes.length;
            // Flip back the selection
            if (pos.dir == '<-') {
                [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];
            }
            s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);
        }
        function beforeCursor() {
            const s = getSelection();
            const r0 = s.getRangeAt(0);
            const r = document.createRange();
            r.selectNodeContents(editor);
            r.setEnd(r0.startContainer, r0.startOffset);
            return r.toString();
        }
        function afterCursor() {
            const s = getSelection();
            const r0 = s.getRangeAt(0);
            const r = document.createRange();
            r.selectNodeContents(editor);
            r.setStart(r0.endContainer, r0.endOffset);
            return r.toString();
        }
        function handleNewLine(event) {
            if (event.key === 'Enter') {
                const before = beforeCursor();
                const after = afterCursor();
                let [padding] = findPadding(before);
                let newLinePadding = padding;
                // If last symbol is "{" ident new line
                if (options.indentOn.test(before)) {
                    newLinePadding += options.tab;
                }
                // Preserve padding
                if (newLinePadding.length > 0) {
                    preventDefault(event);
                    event.stopPropagation();
                    insert('\n' + newLinePadding);
                }
                else {
                    legacyNewLineFix(event);
                }
                // Place adjacent "}" on next line
                if (newLinePadding !== padding && options.moveToNewLine.test(after)) {
                    const pos = save();
                    insert('\n' + padding);
                    restore(pos);
                }
            }
        }
        function legacyNewLineFix(event) {
            // Firefox does not support plaintext-only mode
            // and puts <div><br></div> on Enter. Let's help.
            if (isLegacy && event.key === 'Enter') {
                preventDefault(event);
                event.stopPropagation();
                if (afterCursor() == '') {
                    insert('\n ');
                    const pos = save();
                    pos.start = --pos.end;
                    restore(pos);
                }
                else {
                    insert('\n');
                }
            }
        }
        function handleSelfClosingCharacters(event) {
            const open = `([{'"`;
            const close = `)]}'"`;
            const codeAfter = afterCursor();
            const codeBefore = beforeCursor();
            const escapeCharacter = codeBefore.substr(codeBefore.length - 1) === '\\';
            const charAfter = codeAfter.substr(0, 1);
            if (close.includes(event.key) && !escapeCharacter && charAfter === event.key) {
                // We already have closing char next to cursor.
                // Move one char to right.
                const pos = save();
                preventDefault(event);
                pos.start = ++pos.end;
                restore(pos);
            }
            else if (open.includes(event.key)
                && !escapeCharacter
                && (`"'`.includes(event.key) || ['', ' ', '\n'].includes(charAfter))) {
                preventDefault(event);
                const pos = save();
                const wrapText = pos.start == pos.end ? '' : getSelection().toString();
                const text = event.key + wrapText + close[open.indexOf(event.key)];
                insert(text);
                pos.start++;
                pos.end++;
                restore(pos);
            }
        }
        function handleTabCharacters(event) {
            if (event.key === 'Tab') {
                preventDefault(event);
                if (event.shiftKey) {
                    const before = beforeCursor();
                    let [padding, start,] = findPadding(before);
                    if (padding.length > 0) {
                        const pos = save();
                        // Remove full length tab or just remaining padding
                        const len = Math.min(options.tab.length, padding.length);
                        restore({ start, end: start + len });
                        document.execCommand('delete');
                        pos.start -= len;
                        pos.end -= len;
                        restore(pos);
                    }
                }
                else {
                    insert(options.tab);
                }
            }
        }
        function handleUndoRedo(event) {
            if (isUndo(event)) {
                preventDefault(event);
                at--;
                const record = history[at];
                if (record) {
                    editor.innerHTML = record.html;
                    restore(record.pos);
                }
                if (at < 0)
                    at = 0;
            }
            if (isRedo(event)) {
                preventDefault(event);
                at++;
                const record = history[at];
                if (record) {
                    editor.innerHTML = record.html;
                    restore(record.pos);
                }
                if (at >= history.length)
                    at--;
            }
        }
        function recordHistory() {
            if (!focus)
                return;
            const html = editor.innerHTML;
            const pos = save();
            const lastRecord = history[at];
            if (lastRecord) {
                if (lastRecord.html === html
                    && lastRecord.pos.start === pos.start
                    && lastRecord.pos.end === pos.end)
                    return;
            }
            at++;
            history[at] = { html, pos };
            history.splice(at + 1);
            const maxHistory = 300;
            if (at > maxHistory) {
                at = maxHistory;
                history.splice(0, 1);
            }
        }
        function handlePaste(event) {
            preventDefault(event);
            const text = (event.originalEvent || event)
                .clipboardData
                .getData('text/plain')
                .replace(/\r/g, '');
            const pos = save();
            insert(text);
            highlight(editor);
            restore({
                start: Math.min(pos.start, pos.end) + text.length,
                end: Math.min(pos.start, pos.end) + text.length,
                dir: '<-',
            });
        }
        function visit(editor, visitor) {
            const queue = [];
            if (editor.firstChild)
                queue.push(editor.firstChild);
            let el = queue.pop();
            while (el) {
                if (visitor(el) === 'stop')
                    break;
                if (el.nextSibling)
                    queue.push(el.nextSibling);
                if (el.firstChild)
                    queue.push(el.firstChild);
                el = queue.pop();
            }
        }
        function isCtrl(event) {
            return event.metaKey || event.ctrlKey;
        }
        function isUndo(event) {
            return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';
        }
        function isRedo(event) {
            return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';
        }
        function isCopy(event) {
            return isCtrl(event) && getKeyCode(event) === 'C';
        }
        function getKeyCode(event) {
            let key = event.key || event.keyCode || event.which;
            if (!key)
                return undefined;
            return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();
        }
        function insert(text) {
            text = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            document.execCommand('insertHTML', false, text);
        }
        function debounce(cb, wait) {
            let timeout = 0;
            return (...args) => {
                clearTimeout(timeout);
                timeout = window.setTimeout(() => cb(...args), wait);
            };
        }
        function findPadding(text) {
            // Find beginning of previous line.
            let i = text.length - 1;
            while (i >= 0 && text[i] !== '\n')
                i--;
            i++;
            // Find padding of the line.
            let j = i;
            while (j < text.length && /[ \t]/.test(text[j]))
                j++;
            return [text.substring(i, j) || '', i, j];
        }
        function toString() {
            return editor.textContent || '';
        }
        function preventDefault(event) {
            event.preventDefault();
        }
        function getSelection() {
            var _a;
            if (((_a = editor.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == Node.DOCUMENT_FRAGMENT_NODE) {
                return editor.parentNode.getSelection();
            }
            return window.getSelection();
        }
        return {
            updateOptions(newOptions) {
                Object.assign(options, newOptions);
            },
            updateCode(code) {
                editor.textContent = code;
                highlight(editor);
            },
            onUpdate(cb) {
                callback = cb;
            },
            toString,
            save,
            restore,
            recordHistory,
            destroy() {
                for (let [type, fn] of listeners) {
                    editor.removeEventListener(type, fn);
                }
            },
        };
    }

    function withLineNumbers(highlight, options = {}) {
        const opts = Object.assign({ class: "codejar-linenumbers", wrapClass: "codejar-wrap", width: "35px", backgroundColor: "rgba(128, 128, 128, 0.15)", color: "" }, options);
        let lineNumbers;
        return function (editor) {
            highlight(editor);
            if (!lineNumbers) {
                lineNumbers = init(editor, opts);
                editor.addEventListener("scroll", () => lineNumbers.style.top = `-${editor.scrollTop}px`);
            }
            const code = editor.textContent || "";
            const linesCount = code.replace(/\n+$/, "\n").split("\n").length + 1;
            let text = "";
            for (let i = 1; i < linesCount; i++) {
                text += `${i}\n`;
            }
            lineNumbers.innerText = text;
        };
    }
    function init(editor, opts) {
        const css = getComputedStyle(editor);
        const wrap = document.createElement("div");
        wrap.className = opts.wrapClass;
        wrap.style.position = "relative";
        const gutter = document.createElement("div");
        gutter.className = opts.class;
        wrap.appendChild(gutter);
        // Add own styles
        gutter.style.position = "absolute";
        gutter.style.top = "0px";
        gutter.style.left = "0px";
        gutter.style.bottom = "0px";
        gutter.style.width = opts.width;
        gutter.style.overflow = "hidden";
        gutter.style.backgroundColor = opts.backgroundColor;
        gutter.style.color = opts.color || css.color;
        gutter.style.setProperty("mix-blend-mode", "difference");
        // Copy editor styles
        gutter.style.fontFamily = css.fontFamily;
        gutter.style.fontSize = css.fontSize;
        gutter.style.lineHeight = css.lineHeight;
        gutter.style.paddingTop = css.paddingTop;
        gutter.style.paddingLeft = css.paddingLeft;
        gutter.style.borderTopLeftRadius = css.borderTopLeftRadius;
        gutter.style.borderBottomLeftRadius = css.borderBottomLeftRadius;
        // Add line numbers
        const lineNumbers = document.createElement("div");
        lineNumbers.style.position = "relative";
        lineNumbers.style.top = "0px";
        gutter.appendChild(lineNumbers);
        // Tweak editor styles
        editor.style.paddingLeft = `calc(${opts.width} + ${gutter.style.paddingLeft})`;
        editor.style.whiteSpace = "pre";
        // Swap editor with a wrap
        editor.parentNode.insertBefore(wrap, editor);
        wrap.appendChild(editor);
        return lineNumbers;
    }

    function codejar(element, options) {
        let { highlight, onUpdate, syntax, value, withLineNumbers: withLineNumbers$1, ...extendedOptions } = options;
        let jar = CodeJar$1(element, wrapHighlight(highlight), extendedOptions);
        function destroy() {
            jar.destroy();
            const wrap = element.parentElement;
            if (wrap && wrap.classList.contains("codejar-wrap")) {
                const parent = wrap.parentElement;
                element.style.padding = "";
                parent.appendChild(element);
                wrap.remove();
            }
        }
        function onInput(event) {
            if (onUpdate)
                onUpdate(jar.toString());
        }
        function wrapHighlight(highlight) {
            const _highlight = highlight
                ? (element) => {
                    var _a;
                    element.innerHTML = highlight((_a = element.textContent) !== null && _a !== void 0 ? _a : "", syntax);
                }
                : (element) => void 0;
            return withLineNumbers$1 ? withLineNumbers(_highlight) : _highlight;
        }
        element.addEventListener("input", onInput);
        return {
            destroy() {
                destroy();
                element.removeEventListener("input", onInput);
            },
            update(newOptions) {
                ({
                    highlight,
                    onUpdate,
                    syntax,
                    value,
                    withLineNumbers: withLineNumbers$1,
                    ...extendedOptions
                } = newOptions);
                if (options.highlight !== highlight || options.withLineNumbers !== withLineNumbers$1) {
                    destroy();
                    jar = CodeJar$1(element, wrapHighlight(highlight), options);
                }
                else
                    jar.updateOptions(extendedOptions);
                if (value !== jar.toString())
                    jar.updateCode(value);
                options = { highlight, value, withLineNumbers: withLineNumbers$1, ...extendedOptions };
            },
        };
    }

    /* node_modules\@novacbn\svelte-codejar\components\CodeJar.svelte generated by Svelte v3.59.2 */
    const file$n = "node_modules\\@novacbn\\svelte-codejar\\components\\CodeJar.svelte";

    // (44:103) {:else}
    function create_else_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*value*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(44:103) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:56) {#if highlight}
    function create_if_block$j(ctx) {
    	let html_tag;
    	let raw_value = /*highlight*/ ctx[12](/*value*/ ctx[1], /*syntax*/ ctx[13]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*highlight, value, syntax*/ 12290 && raw_value !== (raw_value = /*highlight*/ ctx[12](/*value*/ ctx[1], /*syntax*/ ctx[13]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(44:56) {#if highlight}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let pre;
    	let code;
    	let code_class_value;
    	let pre_class_value;
    	let pre_style_value;
    	let codejar_action;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*highlight*/ ctx[12]) return create_if_block$j;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			pre = element("pre");
    			code = element("code");
    			if_block.c();

    			attr_dev(code, "class", code_class_value = /*syntax*/ ctx[13]
    			? `language-${/*syntax*/ ctx[13]}`
    			: '');

    			add_location(code, file$n, 43, 7, 1098);

    			attr_dev(pre, "class", pre_class_value = "" + ((/*syntax*/ ctx[13]
    			? `language-${/*syntax*/ ctx[13]}`
    			: '') + " " + (/*_class*/ ctx[2] ?? '')));

    			attr_dev(pre, "style", pre_style_value = /*style*/ ctx[3] ? /*style*/ ctx[3] : "");
    			add_location(pre, file$n, 26, 0, 727);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, pre, anchor);
    			append_dev(pre, code);
    			if_block.m(code, null);
    			/*pre_binding*/ ctx[15](pre);

    			if (!mounted) {
    				dispose = action_destroyer(codejar_action = codejar.call(null, pre, {
    					addClosing: /*addClosing*/ ctx[4],
    					catchTab: /*catchTab*/ ctx[5],
    					highlight: /*highlight*/ ctx[12],
    					history: /*history*/ ctx[6],
    					indentOn: /*indentOn*/ ctx[7],
    					onUpdate: /*onUpdate*/ ctx[14],
    					preserveIdent: /*preserveIdent*/ ctx[8],
    					spellcheck: /*spellcheck*/ ctx[9],
    					syntax: /*syntax*/ ctx[13],
    					tab: /*tab*/ ctx[10],
    					value: /*value*/ ctx[1],
    					withLineNumbers: /*withLineNumbers*/ ctx[11]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(code, null);
    				}
    			}

    			if (dirty & /*syntax*/ 8192 && code_class_value !== (code_class_value = /*syntax*/ ctx[13]
    			? `language-${/*syntax*/ ctx[13]}`
    			: '')) {
    				attr_dev(code, "class", code_class_value);
    			}

    			if (dirty & /*syntax, _class*/ 8196 && pre_class_value !== (pre_class_value = "" + ((/*syntax*/ ctx[13]
    			? `language-${/*syntax*/ ctx[13]}`
    			: '') + " " + (/*_class*/ ctx[2] ?? '')))) {
    				attr_dev(pre, "class", pre_class_value);
    			}

    			if (dirty & /*style*/ 8 && pre_style_value !== (pre_style_value = /*style*/ ctx[3] ? /*style*/ ctx[3] : "")) {
    				attr_dev(pre, "style", pre_style_value);
    			}

    			if (codejar_action && is_function(codejar_action.update) && dirty & /*addClosing, catchTab, highlight, history, indentOn, preserveIdent, spellcheck, syntax, tab, value, withLineNumbers*/ 16370) codejar_action.update.call(null, {
    				addClosing: /*addClosing*/ ctx[4],
    				catchTab: /*catchTab*/ ctx[5],
    				highlight: /*highlight*/ ctx[12],
    				history: /*history*/ ctx[6],
    				indentOn: /*indentOn*/ ctx[7],
    				onUpdate: /*onUpdate*/ ctx[14],
    				preserveIdent: /*preserveIdent*/ ctx[8],
    				spellcheck: /*spellcheck*/ ctx[9],
    				syntax: /*syntax*/ ctx[13],
    				tab: /*tab*/ ctx[10],
    				value: /*value*/ ctx[1],
    				withLineNumbers: /*withLineNumbers*/ ctx[11]
    			});
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(pre);
    			if_block.d();
    			/*pre_binding*/ ctx[15](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CodeJar', slots, []);
    	const dispatch = createEventDispatcher();
    	let { element = undefined } = $$props;
    	let { class: _class = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { addClosing = true } = $$props;
    	let { catchTab = true } = $$props;
    	let { history = true } = $$props;
    	let { indentOn = /{$/ } = $$props;
    	let { preserveIdent = true } = $$props;
    	let { spellcheck = false } = $$props;
    	let { tab = "\t" } = $$props;
    	let { withLineNumbers = undefined } = $$props;
    	let { highlight = undefined } = $$props;
    	let { syntax = undefined } = $$props;
    	let { value = "" } = $$props;

    	function onUpdate(new_value) {
    		$$invalidate(1, value = new_value);
    		dispatch("change", { value: new_value });
    	}

    	const writable_props = [
    		'element',
    		'class',
    		'style',
    		'addClosing',
    		'catchTab',
    		'history',
    		'indentOn',
    		'preserveIdent',
    		'spellcheck',
    		'tab',
    		'withLineNumbers',
    		'highlight',
    		'syntax',
    		'value'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CodeJar> was created with unknown prop '${key}'`);
    	});

    	function pre_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('class' in $$props) $$invalidate(2, _class = $$props.class);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('addClosing' in $$props) $$invalidate(4, addClosing = $$props.addClosing);
    		if ('catchTab' in $$props) $$invalidate(5, catchTab = $$props.catchTab);
    		if ('history' in $$props) $$invalidate(6, history = $$props.history);
    		if ('indentOn' in $$props) $$invalidate(7, indentOn = $$props.indentOn);
    		if ('preserveIdent' in $$props) $$invalidate(8, preserveIdent = $$props.preserveIdent);
    		if ('spellcheck' in $$props) $$invalidate(9, spellcheck = $$props.spellcheck);
    		if ('tab' in $$props) $$invalidate(10, tab = $$props.tab);
    		if ('withLineNumbers' in $$props) $$invalidate(11, withLineNumbers = $$props.withLineNumbers);
    		if ('highlight' in $$props) $$invalidate(12, highlight = $$props.highlight);
    		if ('syntax' in $$props) $$invalidate(13, syntax = $$props.syntax);
    		if ('value' in $$props) $$invalidate(1, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		codejar,
    		dispatch,
    		element,
    		_class,
    		style,
    		addClosing,
    		catchTab,
    		history,
    		indentOn,
    		preserveIdent,
    		spellcheck,
    		tab,
    		withLineNumbers,
    		highlight,
    		syntax,
    		value,
    		onUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('_class' in $$props) $$invalidate(2, _class = $$props._class);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('addClosing' in $$props) $$invalidate(4, addClosing = $$props.addClosing);
    		if ('catchTab' in $$props) $$invalidate(5, catchTab = $$props.catchTab);
    		if ('history' in $$props) $$invalidate(6, history = $$props.history);
    		if ('indentOn' in $$props) $$invalidate(7, indentOn = $$props.indentOn);
    		if ('preserveIdent' in $$props) $$invalidate(8, preserveIdent = $$props.preserveIdent);
    		if ('spellcheck' in $$props) $$invalidate(9, spellcheck = $$props.spellcheck);
    		if ('tab' in $$props) $$invalidate(10, tab = $$props.tab);
    		if ('withLineNumbers' in $$props) $$invalidate(11, withLineNumbers = $$props.withLineNumbers);
    		if ('highlight' in $$props) $$invalidate(12, highlight = $$props.highlight);
    		if ('syntax' in $$props) $$invalidate(13, syntax = $$props.syntax);
    		if ('value' in $$props) $$invalidate(1, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		value,
    		_class,
    		style,
    		addClosing,
    		catchTab,
    		history,
    		indentOn,
    		preserveIdent,
    		spellcheck,
    		tab,
    		withLineNumbers,
    		highlight,
    		syntax,
    		onUpdate,
    		pre_binding
    	];
    }

    class CodeJar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			element: 0,
    			class: 2,
    			style: 3,
    			addClosing: 4,
    			catchTab: 5,
    			history: 6,
    			indentOn: 7,
    			preserveIdent: 8,
    			spellcheck: 9,
    			tab: 10,
    			withLineNumbers: 11,
    			highlight: 12,
    			syntax: 13,
    			value: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CodeJar",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get element() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addClosing() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addClosing(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get catchTab() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set catchTab(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get history() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set history(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentOn() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentOn(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preserveIdent() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preserveIdent(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spellcheck() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spellcheck(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withLineNumbers() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withLineNumbers(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get highlight() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set highlight(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get syntax() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set syntax(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<CodeJar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<CodeJar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var prism = createCommonjsModule(function (module) {
    /* **********************************************
         Begin prism-core.js
    ********************************************** */

    /// <reference lib="WebWorker"/>

    var _self = (typeof window !== 'undefined')
    	? window   // if in browser
    	: (
    		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
    			? self // if in worker
    			: {}   // if in node js
    	);

    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism = (function (_self) {

    	// Private helper vars
    	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    	var uniqueId = 0;

    	// The grammar object for plaintext
    	var plainTextGrammar = {};


    	var _ = {
    		/**
    		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
    		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
    		 * additional languages or plugins yourself.
    		 *
    		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
    		 *
    		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
    		 * empty Prism object into the global scope before loading the Prism script like this:
    		 *
    		 * ```js
    		 * window.Prism = window.Prism || {};
    		 * Prism.manual = true;
    		 * // add a new <script> to load Prism's script
    		 * ```
    		 *
    		 * @default false
    		 * @type {boolean}
    		 * @memberof Prism
    		 * @public
    		 */
    		manual: _self.Prism && _self.Prism.manual,
    		/**
    		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
    		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
    		 * own worker, you don't want it to do this.
    		 *
    		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
    		 *
    		 * You obviously have to change this value before Prism executes. To do this, you can add an
    		 * empty Prism object into the global scope before loading the Prism script like this:
    		 *
    		 * ```js
    		 * window.Prism = window.Prism || {};
    		 * Prism.disableWorkerMessageHandler = true;
    		 * // Load Prism's script
    		 * ```
    		 *
    		 * @default false
    		 * @type {boolean}
    		 * @memberof Prism
    		 * @public
    		 */
    		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

    		/**
    		 * A namespace for utility methods.
    		 *
    		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
    		 * change or disappear at any time.
    		 *
    		 * @namespace
    		 * @memberof Prism
    		 */
    		util: {
    			encode: function encode(tokens) {
    				if (tokens instanceof Token) {
    					return new Token(tokens.type, encode(tokens.content), tokens.alias);
    				} else if (Array.isArray(tokens)) {
    					return tokens.map(encode);
    				} else {
    					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
    				}
    			},

    			/**
    			 * Returns the name of the type of the given value.
    			 *
    			 * @param {any} o
    			 * @returns {string}
    			 * @example
    			 * type(null)      === 'Null'
    			 * type(undefined) === 'Undefined'
    			 * type(123)       === 'Number'
    			 * type('foo')     === 'String'
    			 * type(true)      === 'Boolean'
    			 * type([1, 2])    === 'Array'
    			 * type({})        === 'Object'
    			 * type(String)    === 'Function'
    			 * type(/abc+/)    === 'RegExp'
    			 */
    			type: function (o) {
    				return Object.prototype.toString.call(o).slice(8, -1);
    			},

    			/**
    			 * Returns a unique number for the given object. Later calls will still return the same number.
    			 *
    			 * @param {Object} obj
    			 * @returns {number}
    			 */
    			objId: function (obj) {
    				if (!obj['__id']) {
    					Object.defineProperty(obj, '__id', { value: ++uniqueId });
    				}
    				return obj['__id'];
    			},

    			/**
    			 * Creates a deep clone of the given object.
    			 *
    			 * The main intended use of this function is to clone language definitions.
    			 *
    			 * @param {T} o
    			 * @param {Record<number, any>} [visited]
    			 * @returns {T}
    			 * @template T
    			 */
    			clone: function deepClone(o, visited) {
    				visited = visited || {};

    				var clone; var id;
    				switch (_.util.type(o)) {
    					case 'Object':
    						id = _.util.objId(o);
    						if (visited[id]) {
    							return visited[id];
    						}
    						clone = /** @type {Record<string, any>} */ ({});
    						visited[id] = clone;

    						for (var key in o) {
    							if (o.hasOwnProperty(key)) {
    								clone[key] = deepClone(o[key], visited);
    							}
    						}

    						return /** @type {any} */ (clone);

    					case 'Array':
    						id = _.util.objId(o);
    						if (visited[id]) {
    							return visited[id];
    						}
    						clone = [];
    						visited[id] = clone;

    						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
    							clone[i] = deepClone(v, visited);
    						});

    						return /** @type {any} */ (clone);

    					default:
    						return o;
    				}
    			},

    			/**
    			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
    			 *
    			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
    			 *
    			 * @param {Element} element
    			 * @returns {string}
    			 */
    			getLanguage: function (element) {
    				while (element) {
    					var m = lang.exec(element.className);
    					if (m) {
    						return m[1].toLowerCase();
    					}
    					element = element.parentElement;
    				}
    				return 'none';
    			},

    			/**
    			 * Sets the Prism `language-xxxx` class of the given element.
    			 *
    			 * @param {Element} element
    			 * @param {string} language
    			 * @returns {void}
    			 */
    			setLanguage: function (element, language) {
    				// remove all `language-xxxx` classes
    				// (this might leave behind a leading space)
    				element.className = element.className.replace(RegExp(lang, 'gi'), '');

    				// add the new `language-xxxx` class
    				// (using `classList` will automatically clean up spaces for us)
    				element.classList.add('language-' + language);
    			},

    			/**
    			 * Returns the script element that is currently executing.
    			 *
    			 * This does __not__ work for line script element.
    			 *
    			 * @returns {HTMLScriptElement | null}
    			 */
    			currentScript: function () {
    				if (typeof document === 'undefined') {
    					return null;
    				}
    				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
    					return /** @type {any} */ (document.currentScript);
    				}

    				// IE11 workaround
    				// we'll get the src of the current script by parsing IE11's error stack trace
    				// this will not work for inline scripts

    				try {
    					throw new Error();
    				} catch (err) {
    					// Get file src url from stack. Specifically works with the format of stack traces in IE.
    					// A stack will look like this:
    					//
    					// Error
    					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
    					//    at Global code (http://localhost/components/prism-core.js:606:1)

    					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
    					if (src) {
    						var scripts = document.getElementsByTagName('script');
    						for (var i in scripts) {
    							if (scripts[i].src == src) {
    								return scripts[i];
    							}
    						}
    					}
    					return null;
    				}
    			},

    			/**
    			 * Returns whether a given class is active for `element`.
    			 *
    			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
    			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
    			 * given class is just the given class with a `no-` prefix.
    			 *
    			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
    			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
    			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
    			 *
    			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
    			 * version of it, the class is considered active.
    			 *
    			 * @param {Element} element
    			 * @param {string} className
    			 * @param {boolean} [defaultActivation=false]
    			 * @returns {boolean}
    			 */
    			isActive: function (element, className, defaultActivation) {
    				var no = 'no-' + className;

    				while (element) {
    					var classList = element.classList;
    					if (classList.contains(className)) {
    						return true;
    					}
    					if (classList.contains(no)) {
    						return false;
    					}
    					element = element.parentElement;
    				}
    				return !!defaultActivation;
    			}
    		},

    		/**
    		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
    		 *
    		 * @namespace
    		 * @memberof Prism
    		 * @public
    		 */
    		languages: {
    			/**
    			 * The grammar for plain, unformatted text.
    			 */
    			plain: plainTextGrammar,
    			plaintext: plainTextGrammar,
    			text: plainTextGrammar,
    			txt: plainTextGrammar,

    			/**
    			 * Creates a deep copy of the language with the given id and appends the given tokens.
    			 *
    			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
    			 * will be overwritten at its original position.
    			 *
    			 * ## Best practices
    			 *
    			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
    			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
    			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
    			 *
    			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
    			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
    			 *
    			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
    			 * @param {Grammar} redef The new tokens to append.
    			 * @returns {Grammar} The new language created.
    			 * @public
    			 * @example
    			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
    			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
    			 *     // at its original position
    			 *     'comment': { ... },
    			 *     // CSS doesn't have a 'color' token, so this token will be appended
    			 *     'color': /\b(?:red|green|blue)\b/
    			 * });
    			 */
    			extend: function (id, redef) {
    				var lang = _.util.clone(_.languages[id]);

    				for (var key in redef) {
    					lang[key] = redef[key];
    				}

    				return lang;
    			},

    			/**
    			 * Inserts tokens _before_ another token in a language definition or any other grammar.
    			 *
    			 * ## Usage
    			 *
    			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
    			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
    			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
    			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
    			 * this:
    			 *
    			 * ```js
    			 * Prism.languages.markup.style = {
    			 *     // token
    			 * };
    			 * ```
    			 *
    			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
    			 * before existing tokens. For the CSS example above, you would use it like this:
    			 *
    			 * ```js
    			 * Prism.languages.insertBefore('markup', 'cdata', {
    			 *     'style': {
    			 *         // token
    			 *     }
    			 * });
    			 * ```
    			 *
    			 * ## Special cases
    			 *
    			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
    			 * will be ignored.
    			 *
    			 * This behavior can be used to insert tokens after `before`:
    			 *
    			 * ```js
    			 * Prism.languages.insertBefore('markup', 'comment', {
    			 *     'comment': Prism.languages.markup.comment,
    			 *     // tokens after 'comment'
    			 * });
    			 * ```
    			 *
    			 * ## Limitations
    			 *
    			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
    			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
    			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
    			 * deleting properties which is necessary to insert at arbitrary positions.
    			 *
    			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
    			 * Instead, it will create a new object and replace all references to the target object with the new one. This
    			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
    			 *
    			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
    			 * you hold the target object in a variable, then the value of the variable will not change.
    			 *
    			 * ```js
    			 * var oldMarkup = Prism.languages.markup;
    			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
    			 *
    			 * assert(oldMarkup !== Prism.languages.markup);
    			 * assert(newMarkup === Prism.languages.markup);
    			 * ```
    			 *
    			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
    			 * object to be modified.
    			 * @param {string} before The key to insert before.
    			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
    			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
    			 * object to be modified.
    			 *
    			 * Defaults to `Prism.languages`.
    			 * @returns {Grammar} The new grammar object.
    			 * @public
    			 */
    			insertBefore: function (inside, before, insert, root) {
    				root = root || /** @type {any} */ (_.languages);
    				var grammar = root[inside];
    				/** @type {Grammar} */
    				var ret = {};

    				for (var token in grammar) {
    					if (grammar.hasOwnProperty(token)) {

    						if (token == before) {
    							for (var newToken in insert) {
    								if (insert.hasOwnProperty(newToken)) {
    									ret[newToken] = insert[newToken];
    								}
    							}
    						}

    						// Do not insert token which also occur in insert. See #1525
    						if (!insert.hasOwnProperty(token)) {
    							ret[token] = grammar[token];
    						}
    					}
    				}

    				var old = root[inside];
    				root[inside] = ret;

    				// Update references in other language definitions
    				_.languages.DFS(_.languages, function (key, value) {
    					if (value === old && key != inside) {
    						this[key] = ret;
    					}
    				});

    				return ret;
    			},

    			// Traverse a language definition with Depth First Search
    			DFS: function DFS(o, callback, type, visited) {
    				visited = visited || {};

    				var objId = _.util.objId;

    				for (var i in o) {
    					if (o.hasOwnProperty(i)) {
    						callback.call(o, i, o[i], type || i);

    						var property = o[i];
    						var propertyType = _.util.type(property);

    						if (propertyType === 'Object' && !visited[objId(property)]) {
    							visited[objId(property)] = true;
    							DFS(property, callback, null, visited);
    						} else if (propertyType === 'Array' && !visited[objId(property)]) {
    							visited[objId(property)] = true;
    							DFS(property, callback, i, visited);
    						}
    					}
    				}
    			}
    		},

    		plugins: {},

    		/**
    		 * This is the most high-level function in Prism’s API.
    		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
    		 * each one of them.
    		 *
    		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
    		 *
    		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
    		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightAll: function (async, callback) {
    			_.highlightAllUnder(document, async, callback);
    		},

    		/**
    		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
    		 * {@link Prism.highlightElement} on each one of them.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-highlightall`
    		 * 2. `before-all-elements-highlight`
    		 * 3. All hooks of {@link Prism.highlightElement} for each element.
    		 *
    		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
    		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
    		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightAllUnder: function (container, async, callback) {
    			var env = {
    				callback: callback,
    				container: container,
    				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    			};

    			_.hooks.run('before-highlightall', env);

    			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

    			_.hooks.run('before-all-elements-highlight', env);

    			for (var i = 0, element; (element = env.elements[i++]);) {
    				_.highlightElement(element, async === true, env.callback);
    			}
    		},

    		/**
    		 * Highlights the code inside a single element.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-sanity-check`
    		 * 2. `before-highlight`
    		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
    		 * 4. `before-insert`
    		 * 5. `after-highlight`
    		 * 6. `complete`
    		 *
    		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
    		 * the element's language.
    		 *
    		 * @param {Element} element The element containing the code.
    		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
    		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
    		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
    		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
    		 *
    		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
    		 * asynchronous highlighting to work. You can build your own bundle on the
    		 * [Download page](https://prismjs.com/download.html).
    		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
    		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightElement: function (element, async, callback) {
    			// Find language
    			var language = _.util.getLanguage(element);
    			var grammar = _.languages[language];

    			// Set language on the element, if not present
    			_.util.setLanguage(element, language);

    			// Set language on the parent, for styling
    			var parent = element.parentElement;
    			if (parent && parent.nodeName.toLowerCase() === 'pre') {
    				_.util.setLanguage(parent, language);
    			}

    			var code = element.textContent;

    			var env = {
    				element: element,
    				language: language,
    				grammar: grammar,
    				code: code
    			};

    			function insertHighlightedCode(highlightedCode) {
    				env.highlightedCode = highlightedCode;

    				_.hooks.run('before-insert', env);

    				env.element.innerHTML = env.highlightedCode;

    				_.hooks.run('after-highlight', env);
    				_.hooks.run('complete', env);
    				callback && callback.call(env.element);
    			}

    			_.hooks.run('before-sanity-check', env);

    			// plugins may change/add the parent/element
    			parent = env.element.parentElement;
    			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
    				parent.setAttribute('tabindex', '0');
    			}

    			if (!env.code) {
    				_.hooks.run('complete', env);
    				callback && callback.call(env.element);
    				return;
    			}

    			_.hooks.run('before-highlight', env);

    			if (!env.grammar) {
    				insertHighlightedCode(_.util.encode(env.code));
    				return;
    			}

    			if (async && _self.Worker) {
    				var worker = new Worker(_.filename);

    				worker.onmessage = function (evt) {
    					insertHighlightedCode(evt.data);
    				};

    				worker.postMessage(JSON.stringify({
    					language: env.language,
    					code: env.code,
    					immediateClose: true
    				}));
    			} else {
    				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
    			}
    		},

    		/**
    		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
    		 * and the language definitions to use, and returns a string with the HTML produced.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-tokenize`
    		 * 2. `after-tokenize`
    		 * 3. `wrap`: On each {@link Token}.
    		 *
    		 * @param {string} text A string with the code to be highlighted.
    		 * @param {Grammar} grammar An object containing the tokens to use.
    		 *
    		 * Usually a language definition like `Prism.languages.markup`.
    		 * @param {string} language The name of the language definition passed to `grammar`.
    		 * @returns {string} The highlighted HTML.
    		 * @memberof Prism
    		 * @public
    		 * @example
    		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
    		 */
    		highlight: function (text, grammar, language) {
    			var env = {
    				code: text,
    				grammar: grammar,
    				language: language
    			};
    			_.hooks.run('before-tokenize', env);
    			if (!env.grammar) {
    				throw new Error('The language "' + env.language + '" has no grammar.');
    			}
    			env.tokens = _.tokenize(env.code, env.grammar);
    			_.hooks.run('after-tokenize', env);
    			return Token.stringify(_.util.encode(env.tokens), env.language);
    		},

    		/**
    		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
    		 * and the language definitions to use, and returns an array with the tokenized code.
    		 *
    		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
    		 *
    		 * This method could be useful in other contexts as well, as a very crude parser.
    		 *
    		 * @param {string} text A string with the code to be highlighted.
    		 * @param {Grammar} grammar An object containing the tokens to use.
    		 *
    		 * Usually a language definition like `Prism.languages.markup`.
    		 * @returns {TokenStream} An array of strings and tokens, a token stream.
    		 * @memberof Prism
    		 * @public
    		 * @example
    		 * let code = `var foo = 0;`;
    		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
    		 * tokens.forEach(token => {
    		 *     if (token instanceof Prism.Token && token.type === 'number') {
    		 *         console.log(`Found numeric literal: ${token.content}`);
    		 *     }
    		 * });
    		 */
    		tokenize: function (text, grammar) {
    			var rest = grammar.rest;
    			if (rest) {
    				for (var token in rest) {
    					grammar[token] = rest[token];
    				}

    				delete grammar.rest;
    			}

    			var tokenList = new LinkedList();
    			addAfter(tokenList, tokenList.head, text);

    			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

    			return toArray(tokenList);
    		},

    		/**
    		 * @namespace
    		 * @memberof Prism
    		 * @public
    		 */
    		hooks: {
    			all: {},

    			/**
    			 * Adds the given callback to the list of callbacks for the given hook.
    			 *
    			 * The callback will be invoked when the hook it is registered for is run.
    			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
    			 *
    			 * One callback function can be registered to multiple hooks and the same hook multiple times.
    			 *
    			 * @param {string} name The name of the hook.
    			 * @param {HookCallback} callback The callback function which is given environment variables.
    			 * @public
    			 */
    			add: function (name, callback) {
    				var hooks = _.hooks.all;

    				hooks[name] = hooks[name] || [];

    				hooks[name].push(callback);
    			},

    			/**
    			 * Runs a hook invoking all registered callbacks with the given environment variables.
    			 *
    			 * Callbacks will be invoked synchronously and in the order in which they were registered.
    			 *
    			 * @param {string} name The name of the hook.
    			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
    			 * @public
    			 */
    			run: function (name, env) {
    				var callbacks = _.hooks.all[name];

    				if (!callbacks || !callbacks.length) {
    					return;
    				}

    				for (var i = 0, callback; (callback = callbacks[i++]);) {
    					callback(env);
    				}
    			}
    		},

    		Token: Token
    	};
    	_self.Prism = _;


    	// Typescript note:
    	// The following can be used to import the Token type in JSDoc:
    	//
    	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

    	/**
    	 * Creates a new token.
    	 *
    	 * @param {string} type See {@link Token#type type}
    	 * @param {string | TokenStream} content See {@link Token#content content}
    	 * @param {string|string[]} [alias] The alias(es) of the token.
    	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
    	 * @class
    	 * @global
    	 * @public
    	 */
    	function Token(type, content, alias, matchedStr) {
    		/**
    		 * The type of the token.
    		 *
    		 * This is usually the key of a pattern in a {@link Grammar}.
    		 *
    		 * @type {string}
    		 * @see GrammarToken
    		 * @public
    		 */
    		this.type = type;
    		/**
    		 * The strings or tokens contained by this token.
    		 *
    		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
    		 *
    		 * @type {string | TokenStream}
    		 * @public
    		 */
    		this.content = content;
    		/**
    		 * The alias(es) of the token.
    		 *
    		 * @type {string|string[]}
    		 * @see GrammarToken
    		 * @public
    		 */
    		this.alias = alias;
    		// Copy of the full string this token was created from
    		this.length = (matchedStr || '').length | 0;
    	}

    	/**
    	 * A token stream is an array of strings and {@link Token Token} objects.
    	 *
    	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
    	 * them.
    	 *
    	 * 1. No adjacent strings.
    	 * 2. No empty strings.
    	 *
    	 *    The only exception here is the token stream that only contains the empty string and nothing else.
    	 *
    	 * @typedef {Array<string | Token>} TokenStream
    	 * @global
    	 * @public
    	 */

    	/**
    	 * Converts the given token or token stream to an HTML representation.
    	 *
    	 * The following hooks will be run:
    	 * 1. `wrap`: On each {@link Token}.
    	 *
    	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
    	 * @param {string} language The name of current language.
    	 * @returns {string} The HTML representation of the token or token stream.
    	 * @memberof Token
    	 * @static
    	 */
    	Token.stringify = function stringify(o, language) {
    		if (typeof o == 'string') {
    			return o;
    		}
    		if (Array.isArray(o)) {
    			var s = '';
    			o.forEach(function (e) {
    				s += stringify(e, language);
    			});
    			return s;
    		}

    		var env = {
    			type: o.type,
    			content: stringify(o.content, language),
    			tag: 'span',
    			classes: ['token', o.type],
    			attributes: {},
    			language: language
    		};

    		var aliases = o.alias;
    		if (aliases) {
    			if (Array.isArray(aliases)) {
    				Array.prototype.push.apply(env.classes, aliases);
    			} else {
    				env.classes.push(aliases);
    			}
    		}

    		_.hooks.run('wrap', env);

    		var attributes = '';
    		for (var name in env.attributes) {
    			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    		}

    		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
    	};

    	/**
    	 * @param {RegExp} pattern
    	 * @param {number} pos
    	 * @param {string} text
    	 * @param {boolean} lookbehind
    	 * @returns {RegExpExecArray | null}
    	 */
    	function matchPattern(pattern, pos, text, lookbehind) {
    		pattern.lastIndex = pos;
    		var match = pattern.exec(text);
    		if (match && lookbehind && match[1]) {
    			// change the match to remove the text matched by the Prism lookbehind group
    			var lookbehindLength = match[1].length;
    			match.index += lookbehindLength;
    			match[0] = match[0].slice(lookbehindLength);
    		}
    		return match;
    	}

    	/**
    	 * @param {string} text
    	 * @param {LinkedList<string | Token>} tokenList
    	 * @param {any} grammar
    	 * @param {LinkedListNode<string | Token>} startNode
    	 * @param {number} startPos
    	 * @param {RematchOptions} [rematch]
    	 * @returns {void}
    	 * @private
    	 *
    	 * @typedef RematchOptions
    	 * @property {string} cause
    	 * @property {number} reach
    	 */
    	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    		for (var token in grammar) {
    			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
    				continue;
    			}

    			var patterns = grammar[token];
    			patterns = Array.isArray(patterns) ? patterns : [patterns];

    			for (var j = 0; j < patterns.length; ++j) {
    				if (rematch && rematch.cause == token + ',' + j) {
    					return;
    				}

    				var patternObj = patterns[j];
    				var inside = patternObj.inside;
    				var lookbehind = !!patternObj.lookbehind;
    				var greedy = !!patternObj.greedy;
    				var alias = patternObj.alias;

    				if (greedy && !patternObj.pattern.global) {
    					// Without the global flag, lastIndex won't work
    					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
    					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
    				}

    				/** @type {RegExp} */
    				var pattern = patternObj.pattern || patternObj;

    				for ( // iterate the token list and keep track of the current token/string position
    					var currentNode = startNode.next, pos = startPos;
    					currentNode !== tokenList.tail;
    					pos += currentNode.value.length, currentNode = currentNode.next
    				) {

    					if (rematch && pos >= rematch.reach) {
    						break;
    					}

    					var str = currentNode.value;

    					if (tokenList.length > text.length) {
    						// Something went terribly wrong, ABORT, ABORT!
    						return;
    					}

    					if (str instanceof Token) {
    						continue;
    					}

    					var removeCount = 1; // this is the to parameter of removeBetween
    					var match;

    					if (greedy) {
    						match = matchPattern(pattern, pos, text, lookbehind);
    						if (!match || match.index >= text.length) {
    							break;
    						}

    						var from = match.index;
    						var to = match.index + match[0].length;
    						var p = pos;

    						// find the node that contains the match
    						p += currentNode.value.length;
    						while (from >= p) {
    							currentNode = currentNode.next;
    							p += currentNode.value.length;
    						}
    						// adjust pos (and p)
    						p -= currentNode.value.length;
    						pos = p;

    						// the current node is a Token, then the match starts inside another Token, which is invalid
    						if (currentNode.value instanceof Token) {
    							continue;
    						}

    						// find the last node which is affected by this match
    						for (
    							var k = currentNode;
    							k !== tokenList.tail && (p < to || typeof k.value === 'string');
    							k = k.next
    						) {
    							removeCount++;
    							p += k.value.length;
    						}
    						removeCount--;

    						// replace with the new match
    						str = text.slice(pos, p);
    						match.index -= pos;
    					} else {
    						match = matchPattern(pattern, 0, str, lookbehind);
    						if (!match) {
    							continue;
    						}
    					}

    					// eslint-disable-next-line no-redeclare
    					var from = match.index;
    					var matchStr = match[0];
    					var before = str.slice(0, from);
    					var after = str.slice(from + matchStr.length);

    					var reach = pos + str.length;
    					if (rematch && reach > rematch.reach) {
    						rematch.reach = reach;
    					}

    					var removeFrom = currentNode.prev;

    					if (before) {
    						removeFrom = addAfter(tokenList, removeFrom, before);
    						pos += before.length;
    					}

    					removeRange(tokenList, removeFrom, removeCount);

    					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
    					currentNode = addAfter(tokenList, removeFrom, wrapped);

    					if (after) {
    						addAfter(tokenList, currentNode, after);
    					}

    					if (removeCount > 1) {
    						// at least one Token object was removed, so we have to do some rematching
    						// this can only happen if the current pattern is greedy

    						/** @type {RematchOptions} */
    						var nestedRematch = {
    							cause: token + ',' + j,
    							reach: reach
    						};
    						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

    						// the reach might have been extended because of the rematching
    						if (rematch && nestedRematch.reach > rematch.reach) {
    							rematch.reach = nestedRematch.reach;
    						}
    					}
    				}
    			}
    		}
    	}

    	/**
    	 * @typedef LinkedListNode
    	 * @property {T} value
    	 * @property {LinkedListNode<T> | null} prev The previous node.
    	 * @property {LinkedListNode<T> | null} next The next node.
    	 * @template T
    	 * @private
    	 */

    	/**
    	 * @template T
    	 * @private
    	 */
    	function LinkedList() {
    		/** @type {LinkedListNode<T>} */
    		var head = { value: null, prev: null, next: null };
    		/** @type {LinkedListNode<T>} */
    		var tail = { value: null, prev: head, next: null };
    		head.next = tail;

    		/** @type {LinkedListNode<T>} */
    		this.head = head;
    		/** @type {LinkedListNode<T>} */
    		this.tail = tail;
    		this.length = 0;
    	}

    	/**
    	 * Adds a new node with the given value to the list.
    	 *
    	 * @param {LinkedList<T>} list
    	 * @param {LinkedListNode<T>} node
    	 * @param {T} value
    	 * @returns {LinkedListNode<T>} The added node.
    	 * @template T
    	 */
    	function addAfter(list, node, value) {
    		// assumes that node != list.tail && values.length >= 0
    		var next = node.next;

    		var newNode = { value: value, prev: node, next: next };
    		node.next = newNode;
    		next.prev = newNode;
    		list.length++;

    		return newNode;
    	}
    	/**
    	 * Removes `count` nodes after the given node. The given node will not be removed.
    	 *
    	 * @param {LinkedList<T>} list
    	 * @param {LinkedListNode<T>} node
    	 * @param {number} count
    	 * @template T
    	 */
    	function removeRange(list, node, count) {
    		var next = node.next;
    		for (var i = 0; i < count && next !== list.tail; i++) {
    			next = next.next;
    		}
    		node.next = next;
    		next.prev = node;
    		list.length -= i;
    	}
    	/**
    	 * @param {LinkedList<T>} list
    	 * @returns {T[]}
    	 * @template T
    	 */
    	function toArray(list) {
    		var array = [];
    		var node = list.head.next;
    		while (node !== list.tail) {
    			array.push(node.value);
    			node = node.next;
    		}
    		return array;
    	}


    	if (!_self.document) {
    		if (!_self.addEventListener) {
    			// in Node.js
    			return _;
    		}

    		if (!_.disableWorkerMessageHandler) {
    			// In worker
    			_self.addEventListener('message', function (evt) {
    				var message = JSON.parse(evt.data);
    				var lang = message.language;
    				var code = message.code;
    				var immediateClose = message.immediateClose;

    				_self.postMessage(_.highlight(code, _.languages[lang], lang));
    				if (immediateClose) {
    					_self.close();
    				}
    			}, false);
    		}

    		return _;
    	}

    	// Get current script and highlight
    	var script = _.util.currentScript();

    	if (script) {
    		_.filename = script.src;

    		if (script.hasAttribute('data-manual')) {
    			_.manual = true;
    		}
    	}

    	function highlightAutomaticallyCallback() {
    		if (!_.manual) {
    			_.highlightAll();
    		}
    	}

    	if (!_.manual) {
    		// If the document state is "loading", then we'll use DOMContentLoaded.
    		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
    		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
    		// might take longer one animation frame to execute which can create a race condition where only some plugins have
    		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
    		// See https://github.com/PrismJS/prism/issues/2102
    		var readyState = document.readyState;
    		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
    			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
    		} else {
    			if (window.requestAnimationFrame) {
    				window.requestAnimationFrame(highlightAutomaticallyCallback);
    			} else {
    				window.setTimeout(highlightAutomaticallyCallback, 16);
    			}
    		}
    	}

    	return _;

    }(_self));

    if (module.exports) {
    	module.exports = Prism;
    }

    // hack for components to work correctly in node.js
    if (typeof commonjsGlobal !== 'undefined') {
    	commonjsGlobal.Prism = Prism;
    }

    // some additional documentation/types

    /**
     * The expansion of a simple `RegExp` literal to support additional properties.
     *
     * @typedef GrammarToken
     * @property {RegExp} pattern The regular expression of the token.
     * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
     * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
     * @property {boolean} [greedy=false] Whether the token is greedy.
     * @property {string|string[]} [alias] An optional alias or list of aliases.
     * @property {Grammar} [inside] The nested grammar of this token.
     *
     * The `inside` grammar will be used to tokenize the text value of each token of this kind.
     *
     * This can be used to make nested and even recursive language definitions.
     *
     * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
     * each another.
     * @global
     * @public
     */

    /**
     * @typedef Grammar
     * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
     * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
     * @global
     * @public
     */

    /**
     * A function which will invoked after an element was successfully highlighted.
     *
     * @callback HighlightCallback
     * @param {Element} element The element successfully highlighted.
     * @returns {void}
     * @global
     * @public
     */

    /**
     * @callback HookCallback
     * @param {Object<string, any>} env The environment variables of the hook.
     * @returns {void}
     * @global
     * @public
     */


    /* **********************************************
         Begin prism-markup.js
    ********************************************** */

    Prism.languages.markup = {
    	'comment': {
    		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    		greedy: true
    	},
    	'prolog': {
    		pattern: /<\?[\s\S]+?\?>/,
    		greedy: true
    	},
    	'doctype': {
    		// https://www.w3.org/TR/xml/#NT-doctypedecl
    		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    		greedy: true,
    		inside: {
    			'internal-subset': {
    				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
    				lookbehind: true,
    				greedy: true,
    				inside: null // see below
    			},
    			'string': {
    				pattern: /"[^"]*"|'[^']*'/,
    				greedy: true
    			},
    			'punctuation': /^<!|>$|[[\]]/,
    			'doctype-tag': /^DOCTYPE/i,
    			'name': /[^\s<>'"]+/
    		}
    	},
    	'cdata': {
    		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    		greedy: true
    	},
    	'tag': {
    		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    		greedy: true,
    		inside: {
    			'tag': {
    				pattern: /^<\/?[^\s>\/]+/,
    				inside: {
    					'punctuation': /^<\/?/,
    					'namespace': /^[^\s>\/:]+:/
    				}
    			},
    			'special-attr': [],
    			'attr-value': {
    				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
    				inside: {
    					'punctuation': [
    						{
    							pattern: /^=/,
    							alias: 'attr-equals'
    						},
    						{
    							pattern: /^(\s*)["']|["']$/,
    							lookbehind: true
    						}
    					]
    				}
    			},
    			'punctuation': /\/?>/,
    			'attr-name': {
    				pattern: /[^\s>\/]+/,
    				inside: {
    					'namespace': /^[^\s>\/:]+:/
    				}
    			}

    		}
    	},
    	'entity': [
    		{
    			pattern: /&[\da-z]{1,8};/i,
    			alias: 'named-entity'
    		},
    		/&#x?[\da-f]{1,8};/i
    	]
    };

    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    	Prism.languages.markup['entity'];
    Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    // Plugin to make entity title show the real entity, idea by Roman Komarov
    Prism.hooks.add('wrap', function (env) {

    	if (env.type === 'entity') {
    		env.attributes['title'] = env.content.replace(/&amp;/, '&');
    	}
    });

    Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    	/**
    	 * Adds an inlined language to markup.
    	 *
    	 * An example of an inlined language is CSS with `<style>` tags.
    	 *
    	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    	 * case insensitive.
    	 * @param {string} lang The language key.
    	 * @example
    	 * addInlined('style', 'css');
    	 */
    	value: function addInlined(tagName, lang) {
    		var includedCdataInside = {};
    		includedCdataInside['language-' + lang] = {
    			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    			lookbehind: true,
    			inside: Prism.languages[lang]
    		};
    		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    		var inside = {
    			'included-cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				inside: includedCdataInside
    			}
    		};
    		inside['language-' + lang] = {
    			pattern: /[\s\S]+/,
    			inside: Prism.languages[lang]
    		};

    		var def = {};
    		def[tagName] = {
    			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
    			lookbehind: true,
    			greedy: true,
    			inside: inside
    		};

    		Prism.languages.insertBefore('markup', 'cdata', def);
    	}
    });
    Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    	/**
    	 * Adds an pattern to highlight languages embedded in HTML attributes.
    	 *
    	 * An example of an inlined language is CSS with `style` attributes.
    	 *
    	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    	 * case insensitive.
    	 * @param {string} lang The language key.
    	 * @example
    	 * addAttribute('style', 'css');
    	 */
    	value: function (attrName, lang) {
    		Prism.languages.markup.tag.inside['special-attr'].push({
    			pattern: RegExp(
    				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
    				'i'
    			),
    			lookbehind: true,
    			inside: {
    				'attr-name': /^[^\s=]+/,
    				'attr-value': {
    					pattern: /=[\s\S]+/,
    					inside: {
    						'value': {
    							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
    							lookbehind: true,
    							alias: [lang, 'language-' + lang],
    							inside: Prism.languages[lang]
    						},
    						'punctuation': [
    							{
    								pattern: /^=/,
    								alias: 'attr-equals'
    							},
    							/"|'/
    						]
    					}
    				}
    			}
    		});
    	}
    });

    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;

    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;


    /* **********************************************
         Begin prism-css.js
    ********************************************** */

    (function (Prism) {

    	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

    	Prism.languages.css = {
    		'comment': /\/\*[\s\S]*?\*\//,
    		'atrule': {
    			pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
    			inside: {
    				'rule': /^@[\w-]+/,
    				'selector-function-argument': {
    					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
    					lookbehind: true,
    					alias: 'selector'
    				},
    				'keyword': {
    					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    					lookbehind: true
    				}
    				// See rest below
    			}
    		},
    		'url': {
    			// https://drafts.csswg.org/css-values-3/#urls
    			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
    			greedy: true,
    			inside: {
    				'function': /^url/i,
    				'punctuation': /^\(|\)$/,
    				'string': {
    					pattern: RegExp('^' + string.source + '$'),
    					alias: 'url'
    				}
    			}
    		},
    		'selector': {
    			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
    			lookbehind: true
    		},
    		'string': {
    			pattern: string,
    			greedy: true
    		},
    		'property': {
    			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
    			lookbehind: true
    		},
    		'important': /!important\b/i,
    		'function': {
    			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
    			lookbehind: true
    		},
    		'punctuation': /[(){};:,]/
    	};

    	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    	var markup = Prism.languages.markup;
    	if (markup) {
    		markup.tag.addInlined('style', 'css');
    		markup.tag.addAttribute('style', 'css');
    	}

    }(Prism));


    /* **********************************************
         Begin prism-clike.js
    ********************************************** */

    Prism.languages.clike = {
    	'comment': [
    		{
    			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    			lookbehind: true,
    			greedy: true
    		},
    		{
    			pattern: /(^|[^\\:])\/\/.*/,
    			lookbehind: true,
    			greedy: true
    		}
    	],
    	'string': {
    		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    		greedy: true
    	},
    	'class-name': {
    		pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    		lookbehind: true,
    		inside: {
    			'punctuation': /[.\\]/
    		}
    	},
    	'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    	'boolean': /\b(?:false|true)\b/,
    	'function': /\b\w+(?=\()/,
    	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    	'punctuation': /[{}[\];(),.:]/
    };


    /* **********************************************
         Begin prism-javascript.js
    ********************************************** */

    Prism.languages.javascript = Prism.languages.extend('clike', {
    	'class-name': [
    		Prism.languages.clike['class-name'],
    		{
    			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    			lookbehind: true
    		}
    	],
    	'keyword': [
    		{
    			pattern: /((?:^|\})\s*)catch\b/,
    			lookbehind: true
    		},
    		{
    			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    			lookbehind: true
    		},
    	],
    	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    	'number': {
    		pattern: RegExp(
    			/(^|[^\w$])/.source +
    			'(?:' +
    			(
    				// constant
    				/NaN|Infinity/.source +
    				'|' +
    				// binary integer
    				/0[bB][01]+(?:_[01]+)*n?/.source +
    				'|' +
    				// octal integer
    				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
    				'|' +
    				// hexadecimal integer
    				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
    				'|' +
    				// decimal bigint
    				/\d+(?:_\d+)*n/.source +
    				'|' +
    				// decimal number (integer or float) but no bigint
    				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
    			) +
    			')' +
    			/(?![\w$])/.source
    		),
    		lookbehind: true
    	},
    	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });

    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

    Prism.languages.insertBefore('javascript', 'keyword', {
    	'regex': {
    		pattern: RegExp(
    			// lookbehind
    			// eslint-disable-next-line regexp/no-dupe-characters-character-class
    			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
    			// Regex pattern:
    			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
    			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
    			// with the only syntax, so we have to define 2 different regex patterns.
    			/\//.source +
    			'(?:' +
    			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
    			'|' +
    			// `v` flag syntax. This supports 3 levels of nested character classes.
    			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
    			')' +
    			// lookahead
    			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    		),
    		lookbehind: true,
    		greedy: true,
    		inside: {
    			'regex-source': {
    				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
    				lookbehind: true,
    				alias: 'language-regex',
    				inside: Prism.languages.regex
    			},
    			'regex-delimiter': /^\/|\/$/,
    			'regex-flags': /^[a-z]+$/,
    		}
    	},
    	// This must be declared before keyword because we use "function" inside the look-forward
    	'function-variable': {
    		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    		alias: 'function'
    	},
    	'parameter': [
    		{
    			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		}
    	],
    	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });

    Prism.languages.insertBefore('javascript', 'string', {
    	'hashbang': {
    		pattern: /^#!.*/,
    		greedy: true,
    		alias: 'comment'
    	},
    	'template-string': {
    		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    		greedy: true,
    		inside: {
    			'template-punctuation': {
    				pattern: /^`|`$/,
    				alias: 'string'
    			},
    			'interpolation': {
    				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
    				lookbehind: true,
    				inside: {
    					'interpolation-punctuation': {
    						pattern: /^\$\{|\}$/,
    						alias: 'punctuation'
    					},
    					rest: Prism.languages.javascript
    				}
    			},
    			'string': /[\s\S]+/
    		}
    	},
    	'string-property': {
    		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    		lookbehind: true,
    		greedy: true,
    		alias: 'property'
    	}
    });

    Prism.languages.insertBefore('javascript', 'operator', {
    	'literal-property': {
    		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    		lookbehind: true,
    		alias: 'property'
    	},
    });

    if (Prism.languages.markup) {
    	Prism.languages.markup.tag.addInlined('script', 'javascript');

    	// add attribute support for all DOM events.
    	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    	Prism.languages.markup.tag.addAttribute(
    		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    		'javascript'
    	);
    }

    Prism.languages.js = Prism.languages.javascript;


    /* **********************************************
         Begin prism-file-highlight.js
    ********************************************** */

    (function () {

    	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    		return;
    	}

    	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    	if (!Element.prototype.matches) {
    		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    	}

    	var LOADING_MESSAGE = 'Loading…';
    	var FAILURE_MESSAGE = function (status, message) {
    		return '✖ Error ' + status + ' while fetching file: ' + message;
    	};
    	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

    	var EXTENSIONS = {
    		'js': 'javascript',
    		'py': 'python',
    		'rb': 'ruby',
    		'ps1': 'powershell',
    		'psm1': 'powershell',
    		'sh': 'bash',
    		'bat': 'batch',
    		'h': 'c',
    		'tex': 'latex'
    	};

    	var STATUS_ATTR = 'data-src-status';
    	var STATUS_LOADING = 'loading';
    	var STATUS_LOADED = 'loaded';
    	var STATUS_FAILED = 'failed';

    	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
    		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

    	/**
    	 * Loads the given file.
    	 *
    	 * @param {string} src The URL or path of the source file to load.
    	 * @param {(result: string) => void} success
    	 * @param {(reason: string) => void} error
    	 */
    	function loadFile(src, success, error) {
    		var xhr = new XMLHttpRequest();
    		xhr.open('GET', src, true);
    		xhr.onreadystatechange = function () {
    			if (xhr.readyState == 4) {
    				if (xhr.status < 400 && xhr.responseText) {
    					success(xhr.responseText);
    				} else {
    					if (xhr.status >= 400) {
    						error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
    					} else {
    						error(FAILURE_EMPTY_MESSAGE);
    					}
    				}
    			}
    		};
    		xhr.send(null);
    	}

    	/**
    	 * Parses the given range.
    	 *
    	 * This returns a range with inclusive ends.
    	 *
    	 * @param {string | null | undefined} range
    	 * @returns {[number, number | undefined] | undefined}
    	 */
    	function parseRange(range) {
    		var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
    		if (m) {
    			var start = Number(m[1]);
    			var comma = m[2];
    			var end = m[3];

    			if (!comma) {
    				return [start, start];
    			}
    			if (!end) {
    				return [start, undefined];
    			}
    			return [start, Number(end)];
    		}
    		return undefined;
    	}

    	Prism.hooks.add('before-highlightall', function (env) {
    		env.selector += ', ' + SELECTOR;
    	});

    	Prism.hooks.add('before-sanity-check', function (env) {
    		var pre = /** @type {HTMLPreElement} */ (env.element);
    		if (pre.matches(SELECTOR)) {
    			env.code = ''; // fast-path the whole thing and go to complete

    			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

    			// add code element with loading message
    			var code = pre.appendChild(document.createElement('CODE'));
    			code.textContent = LOADING_MESSAGE;

    			var src = pre.getAttribute('data-src');

    			var language = env.language;
    			if (language === 'none') {
    				// the language might be 'none' because there is no language set;
    				// in this case, we want to use the extension as the language
    				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
    				language = EXTENSIONS[extension] || extension;
    			}

    			// set language classes
    			Prism.util.setLanguage(code, language);
    			Prism.util.setLanguage(pre, language);

    			// preload the language
    			var autoloader = Prism.plugins.autoloader;
    			if (autoloader) {
    				autoloader.loadLanguages(language);
    			}

    			// load file
    			loadFile(
    				src,
    				function (text) {
    					// mark as loaded
    					pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

    					// handle data-range
    					var range = parseRange(pre.getAttribute('data-range'));
    					if (range) {
    						var lines = text.split(/\r\n?|\n/g);

    						// the range is one-based and inclusive on both ends
    						var start = range[0];
    						var end = range[1] == null ? lines.length : range[1];

    						if (start < 0) { start += lines.length; }
    						start = Math.max(0, Math.min(start - 1, lines.length));
    						if (end < 0) { end += lines.length; }
    						end = Math.max(0, Math.min(end, lines.length));

    						text = lines.slice(start, end).join('\n');

    						// add data-start for line numbers
    						if (!pre.hasAttribute('data-start')) {
    							pre.setAttribute('data-start', String(start + 1));
    						}
    					}

    					// highlight code
    					code.textContent = text;
    					Prism.highlightElement(code);
    				},
    				function (error) {
    					// mark as failed
    					pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

    					code.textContent = error;
    				}
    			);
    		}
    	});

    	Prism.plugins.fileHighlight = {
    		/**
    		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
    		 *
    		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
    		 *
    		 * @param {ParentNode} [container=document]
    		 */
    		highlight: function highlight(container) {
    			var elements = (container || document).querySelectorAll(SELECTOR);

    			for (var i = 0, element; (element = elements[i++]);) {
    				Prism.highlightElement(element);
    			}
    		}
    	};

    	var logged = false;
    	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
    	Prism.fileHighlight = function () {
    		if (!logged) {
    			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
    			logged = true;
    		}
    		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    	};

    }());
    });

    // https://www.json.org/json-en.html
    Prism.languages.json = {
    	'property': {
    		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    		lookbehind: true,
    		greedy: true
    	},
    	'string': {
    		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    		lookbehind: true,
    		greedy: true
    	},
    	'comment': {
    		pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    		greedy: true
    	},
    	'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    	'punctuation': /[{}[\],]/,
    	'operator': /:/,
    	'boolean': /\b(?:false|true)\b/,
    	'null': {
    		pattern: /\bnull\b/,
    		alias: 'keyword'
    	}
    };

    Prism.languages.webmanifest = Prism.languages.json;

    /* src\apps\Mdw\apps\Config.Tags.svelte generated by Svelte v3.59.2 */
    const file$m = "src\\apps\\Mdw\\apps\\Config.Tags.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	child_ctx[27] = list;
    	child_ctx[28] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	child_ctx[29] = list;
    	child_ctx[28] = i;
    	return child_ctx;
    }

    // (75:4) <MdwPanelHeader style="height: 6vh">
    function create_default_slot_11$1(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterTags*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Tags";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$m, 75, 8, 2657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(75:4) <MdwPanelHeader style=\\\"height: 6vh\\\">",
    		ctx
    	});

    	return block;
    }

    // (85:12) {:else}
    function create_else_block_5$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$m, 85, 16, 3165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5$1.name,
    		type: "else",
    		source: "(85:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (83:12) {#if IsJson(TagsTemplate)}
    function create_if_block_5$4(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func*/ ctx[13],
    				Color: "success",
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 1073741824) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(83:12) {#if IsJson(TagsTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (84:16) <Button click={() => { SaveTag(true) }} Color="success">
    function create_default_slot_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(84:16) <Button click={() => { SaveTag(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:16) {:else}
    function create_else_block_4$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$m, 102, 20, 4096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$1.name,
    		type: "else",
    		source: "(102:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (95:16) {#if IsJson(Data)}
    function create_if_block_3$5(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4$4, create_else_block_3$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (dirty & /*FilteredTags*/ 1) show_if = null;
    		if (show_if == null) show_if = !!JSON.parse(/*Data*/ ctx[26]).deleted;
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(95:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (98:20) {:else}
    function create_else_block_3$1(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	function func_2() {
    		return /*func_2*/ ctx[16](/*Data*/ ctx[26]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_2,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_3() {
    		return /*func_3*/ ctx[17](/*Data*/ ctx[26]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_3,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty & /*FilteredTags*/ 1) button0_changes.click = func_2;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*FilteredTags*/ 1) button1_changes.click = func_3;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(98:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (96:20) {#if JSON.parse(Data).deleted}
    function create_if_block_4$4(ctx) {
    	let button;
    	let current;

    	function func_1() {
    		return /*func_1*/ ctx[15](/*Data*/ ctx[26]);
    	}

    	button = new Button({
    			props: {
    				click: func_1,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty & /*FilteredTags*/ 1) button_changes.click = func_1;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(96:20) {#if JSON.parse(Data).deleted}",
    		ctx
    	});

    	return block;
    }

    // (99:24) <Button click={() => { SaveTag(false, Data) }} Color="warning">
    function create_default_slot_9$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(99:24) <Button click={() => { SaveTag(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:24) <Button click={() => { DeleteTag(JSON.parse(Data).id) }} Color="warning">
    function create_default_slot_8$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(100:24) <Button click={() => { DeleteTag(JSON.parse(Data).id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (97:24) <Button click={() => { SaveTag(false, Data) }} Color="warning">
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restore");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(97:24) <Button click={() => { SaveTag(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (91:4) {#each FilteredTags as Data, Key}
    function create_each_block_1$3(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_1(value) {
    		/*codejar_value_binding_1*/ ctx[14](value, /*Data*/ ctx[26], /*each_value_1*/ ctx[29], /*Key*/ ctx[28]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[4]
    	};

    	if (/*Data*/ ctx[26] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[26];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_1));
    	const if_block_creators = [create_if_block_3$5, create_else_block_4$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*FilteredTags*/ 1) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[5](/*Data*/ ctx[26]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$m, 93, 12, 3535);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$m, 91, 8, 3360);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*FilteredTags*/ 1) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[26];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(91:4) {#each FilteredTags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (74:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh;">
    function create_default_slot_6$3(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh",
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding(value) {
    		/*codejar_value_binding*/ ctx[12](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[4]
    	};

    	if (/*TagsTemplate*/ ctx[1] !== void 0) {
    		codejar_props.value = /*TagsTemplate*/ ctx[1];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding));
    	const if_block_creators = [create_if_block_5$4, create_else_block_5$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*TagsTemplate*/ 2) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[5](/*TagsTemplate*/ ctx[1]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value_1 = /*FilteredTags*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$m, 81, 8, 2948);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$m, 79, 4, 2773);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 1073741824) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*TagsTemplate*/ 2) {
    				updating_value = true;
    				codejar_changes.value = /*TagsTemplate*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty & /*SaveTag, FilteredTags, JSON, DeleteTag, IsJson, highlight*/ 433) {
    				each_value_1 = /*FilteredTags*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(74:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:4) <MdwPanelHeader style="height: 6vh">
    function create_default_slot_5$4(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterEvidenceTypes*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Evidence Types";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$m, 111, 8, 4385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(111:4) <MdwPanelHeader style=\\\"height: 6vh\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:12) {:else}
    function create_else_block_2$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$m, 121, 16, 4925);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(121:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (119:12) {#if IsJson(EvidenceTemplate)}
    function create_if_block_2$7(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func_4*/ ctx[19],
    				Color: "success",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 1073741824) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(119:12) {#if IsJson(EvidenceTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (120:16) <Button click={() => { SaveEvidence(true) }} Color="success">
    function create_default_slot_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(120:16) <Button click={() => { SaveEvidence(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:16) {:else}
    function create_else_block_1$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$m, 138, 20, 5875);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(138:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:16) {#if IsJson(Data)}
    function create_if_block$i(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$9, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (dirty & /*FilteredEvidence*/ 4) show_if = null;
    		if (show_if == null) show_if = !!JSON.parse(/*Data*/ ctx[26]).deleted;
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_5(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(131:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (134:20) {:else}
    function create_else_block$4(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	function func_6() {
    		return /*func_6*/ ctx[22](/*Data*/ ctx[26]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_6,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_7() {
    		return /*func_7*/ ctx[23](/*Data*/ ctx[26]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_7,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty & /*FilteredEvidence*/ 4) button0_changes.click = func_6;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*FilteredEvidence*/ 4) button1_changes.click = func_7;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(134:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:20) {#if JSON.parse(Data).deleted}
    function create_if_block_1$9(ctx) {
    	let button;
    	let current;

    	function func_5() {
    		return /*func_5*/ ctx[21](/*Data*/ ctx[26]);
    	}

    	button = new Button({
    			props: {
    				click: func_5,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty & /*FilteredEvidence*/ 4) button_changes.click = func_5;

    			if (dirty & /*$$scope*/ 1073741824) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(132:20) {#if JSON.parse(Data).deleted}",
    		ctx
    	});

    	return block;
    }

    // (135:24) <Button click={() => { SaveEvidence(false, Data) }} Color="warning">
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(135:24) <Button click={() => { SaveEvidence(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:24) <Button click={() => { DeleteEvidence(JSON.parse(Data).Id) }} Color="warning">
    function create_default_slot_2$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(136:24) <Button click={() => { DeleteEvidence(JSON.parse(Data).Id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:24) <Button click={() => { SaveEvidence(false, Data) }} Color="warning">
    function create_default_slot_1$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restore");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(133:24) <Button click={() => { SaveEvidence(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:4) {#each FilteredEvidence as Data, Key}
    function create_each_block$c(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_3(value) {
    		/*codejar_value_binding_3*/ ctx[20](value, /*Data*/ ctx[26], /*each_value*/ ctx[27], /*Key*/ ctx[28]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[4]
    	};

    	if (/*Data*/ ctx[26] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[26];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_3));
    	const if_block_creators = [create_if_block$i, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (dirty & /*FilteredEvidence*/ 4) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[5](/*Data*/ ctx[26]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$m, 129, 12, 5299);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$m, 127, 8, 5124);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*FilteredEvidence*/ 4) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[26];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(127:4) {#each FilteredEvidence as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (110:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh;">
    function create_default_slot$h(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding_2(value) {
    		/*codejar_value_binding_2*/ ctx[18](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[4]
    	};

    	if (/*EvidenceTemplate*/ ctx[3] !== void 0) {
    		codejar_props.value = /*EvidenceTemplate*/ ctx[3];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_2));
    	const if_block_creators = [create_if_block_2$7, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (dirty & /*EvidenceTemplate*/ 8) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[5](/*EvidenceTemplate*/ ctx[3]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*FilteredEvidence*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$m, 117, 8, 4699);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$m, 115, 4, 4520);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 1073741824) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*EvidenceTemplate*/ 8) {
    				updating_value = true;
    				codejar_changes.value = /*EvidenceTemplate*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty & /*SaveEvidence, FilteredEvidence, JSON, DeleteEvidence, IsJson, highlight*/ 3124) {
    				each_value = /*FilteredEvidence*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(110:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let mdwpanel0;
    	let t;
    	let mdwpanel1;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh;",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh;",
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t = space();
    			create_component(mdwpanel1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel0_changes = {};

    			if (dirty & /*$$scope, FilteredTags, TagsTemplate*/ 1073741827) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty & /*$$scope, FilteredEvidence, EvidenceTemplate*/ 1073741836) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanel1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $MdwEvidence;
    	let $MdwTags;
    	validate_store(MdwEvidence, 'MdwEvidence');
    	component_subscribe($$self, MdwEvidence, $$value => $$invalidate(24, $MdwEvidence = $$value));
    	validate_store(MdwTags, 'MdwTags');
    	component_subscribe($$self, MdwTags, $$value => $$invalidate(25, $MdwTags = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Config_Tags', slots, []);
    	const highlight = (code, syntax) => prism.highlight(code, prism.languages[syntax], syntax);

    	const IsJson = str => {
    		try {
    			JSON.parse(str);
    		} catch(e) {
    			return false;
    		}

    		return true;
    	};

    	// Tags
    	let FilteredTags = [];

    	let TagsTemplate = JSON.stringify({ tag: "", color: "#ffffff", icon: "" }, undefined, 2);

    	const FilterTags = Value => {
    		const Search = Value.toLowerCase();
    		const MatchedTags = $MdwTags.filter(Val => Val.tag.toLowerCase().includes(Search));

    		$$invalidate(0, FilteredTags = MatchedTags.map(Val => {
    			return JSON.stringify(Val, null, 2);
    		}));
    	};

    	const SaveTag = (Create, Data) => {
    		if (Create) {
    			SendEvent("Config/CreateTag", JSON.parse(TagsTemplate));
    		} else {
    			SendEvent("Config/SaveTag", JSON.parse(Data));
    		}
    	};

    	const DeleteTag = TagId => {
    		if (TagId) SendEvent("Config/DeleteTag", { id: TagId });
    	};

    	MdwTags.subscribe(Val => {
    		FilterTags("");
    	});

    	// Evidence Types
    	let FilteredEvidence = [];

    	let EvidenceTemplate = JSON.stringify({ Text: "" }, undefined, 2);

    	const FilterEvidenceTypes = Value => {
    		const Search = Value.toLowerCase();
    		const MatchedEvidence = $MdwEvidence.filter(Val => Val.Text.toLowerCase().includes(Search));

    		$$invalidate(2, FilteredEvidence = MatchedEvidence.map(Val => {
    			return JSON.stringify(Val, null, 2);
    		}));
    	};

    	const SaveEvidence = (Create, Data) => {
    		if (Create) {
    			SendEvent("Config/CreateEvidenceType", JSON.parse(EvidenceTemplate));
    		} else {
    			SendEvent("Config/SaveEvidenceType", JSON.parse(Data));
    		}
    	};

    	const DeleteEvidence = EvidenceId => {
    		if (EvidenceId) SendEvent("Config/DeleteEvidenceType", { Id: EvidenceId });
    	};

    	MdwEvidence.subscribe(Val => {
    		FilterEvidenceTypes("");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Config_Tags> was created with unknown prop '${key}'`);
    	});

    	function codejar_value_binding(value) {
    		TagsTemplate = value;
    		$$invalidate(1, TagsTemplate);
    	}

    	const func = () => {
    		SaveTag(true);
    	};

    	function codejar_value_binding_1(value, Data, each_value_1, Key) {
    		each_value_1[Key] = value;
    		$$invalidate(0, FilteredTags);
    	}

    	const func_1 = Data => {
    		SaveTag(false, Data);
    	};

    	const func_2 = Data => {
    		SaveTag(false, Data);
    	};

    	const func_3 = Data => {
    		DeleteTag(JSON.parse(Data).id);
    	};

    	function codejar_value_binding_2(value) {
    		EvidenceTemplate = value;
    		$$invalidate(3, EvidenceTemplate);
    	}

    	const func_4 = () => {
    		SaveEvidence(true);
    	};

    	function codejar_value_binding_3(value, Data, each_value, Key) {
    		each_value[Key] = value;
    		$$invalidate(2, FilteredEvidence);
    	}

    	const func_5 = Data => {
    		SaveEvidence(false, Data);
    	};

    	const func_6 = Data => {
    		SaveEvidence(false, Data);
    	};

    	const func_7 = Data => {
    		DeleteEvidence(JSON.parse(Data).Id);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		TextField,
    		onMount,
    		CodeJar,
    		Prism: prism,
    		SendEvent,
    		Button,
    		MdwTags,
    		MdwEvidence,
    		highlight,
    		IsJson,
    		FilteredTags,
    		TagsTemplate,
    		FilterTags,
    		SaveTag,
    		DeleteTag,
    		FilteredEvidence,
    		EvidenceTemplate,
    		FilterEvidenceTypes,
    		SaveEvidence,
    		DeleteEvidence,
    		$MdwEvidence,
    		$MdwTags
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredTags' in $$props) $$invalidate(0, FilteredTags = $$props.FilteredTags);
    		if ('TagsTemplate' in $$props) $$invalidate(1, TagsTemplate = $$props.TagsTemplate);
    		if ('FilteredEvidence' in $$props) $$invalidate(2, FilteredEvidence = $$props.FilteredEvidence);
    		if ('EvidenceTemplate' in $$props) $$invalidate(3, EvidenceTemplate = $$props.EvidenceTemplate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredTags,
    		TagsTemplate,
    		FilteredEvidence,
    		EvidenceTemplate,
    		highlight,
    		IsJson,
    		FilterTags,
    		SaveTag,
    		DeleteTag,
    		FilterEvidenceTypes,
    		SaveEvidence,
    		DeleteEvidence,
    		codejar_value_binding,
    		func,
    		codejar_value_binding_1,
    		func_1,
    		func_2,
    		func_3,
    		codejar_value_binding_2,
    		func_4,
    		codejar_value_binding_3,
    		func_5,
    		func_6,
    		func_7
    	];
    }

    class Config_Tags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Config_Tags",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Config.Staff.svelte generated by Svelte v3.59.2 */
    const file$l = "src\\apps\\Mdw\\apps\\Config.Staff.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[40] = list[i];
    	child_ctx[41] = list;
    	child_ctx[42] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[40] = list[i];
    	child_ctx[43] = list;
    	child_ctx[42] = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[40] = list[i];
    	child_ctx[44] = list;
    	child_ctx[42] = i;
    	return child_ctx;
    }

    // (197:4) <MdwPanelHeader style="height: 6vh">
    function create_default_slot_18(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterCerts*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Certifications";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$l, 197, 8, 6795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(197:4) <MdwPanelHeader style=\\\"height: 6vh\\\">",
    		ctx
    	});

    	return block;
    }

    // (207:12) {:else}
    function create_else_block_8(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 207, 16, 7316);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_8.name,
    		type: "else",
    		source: "(207:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (205:12) {#if IsJson(CertTemplate)}
    function create_if_block_8$2(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func*/ ctx[19],
    				Color: "success",
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(205:12) {#if IsJson(CertTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (206:16) <Button click={() => { SaveCerts(true) }} Color="success">
    function create_default_slot_17(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(206:16) <Button click={() => { SaveCerts(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (224:16) {:else}
    function create_else_block_7(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 224, 20, 8254);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_7.name,
    		type: "else",
    		source: "(224:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (217:16) {#if IsJson(Data)}
    function create_if_block_6$2(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_7$2, create_else_block_6];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (dirty[0] & /*FilteredCerts*/ 2) show_if = null;
    		if (show_if == null) show_if = !!JSON.parse(/*Data*/ ctx[40]).deleted;
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(217:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (220:20) {:else}
    function create_else_block_6(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	function func_2() {
    		return /*func_2*/ ctx[22](/*Data*/ ctx[40]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_2,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_3() {
    		return /*func_3*/ ctx[23](/*Data*/ ctx[40]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_3,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty[0] & /*FilteredCerts*/ 2) button0_changes.click = func_2;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty[0] & /*FilteredCerts*/ 2) button1_changes.click = func_3;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(220:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (218:20) {#if JSON.parse(Data).deleted}
    function create_if_block_7$2(ctx) {
    	let button;
    	let current;

    	function func_1() {
    		return /*func_1*/ ctx[21](/*Data*/ ctx[40]);
    	}

    	button = new Button({
    			props: {
    				click: func_1,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty[0] & /*FilteredCerts*/ 2) button_changes.click = func_1;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(218:20) {#if JSON.parse(Data).deleted}",
    		ctx
    	});

    	return block;
    }

    // (221:24) <Button click={() => { SaveCerts(false, Data) }} Color="warning">
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(221:24) <Button click={() => { SaveCerts(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (222:24) <Button click={() => { DeleteCerts(JSON.parse(Data).id) }} Color="warning">
    function create_default_slot_15(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(222:24) <Button click={() => { DeleteCerts(JSON.parse(Data).id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (219:24) <Button click={() => { SaveCerts(false, Data) }} Color="warning">
    function create_default_slot_14(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restore");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(219:24) <Button click={() => { SaveCerts(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (213:4) {#each FilteredCerts as Data, Key}
    function create_each_block_2$1(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_1(value) {
    		/*codejar_value_binding_1*/ ctx[20](value, /*Data*/ ctx[40], /*each_value_2*/ ctx[44], /*Key*/ ctx[42]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*Data*/ ctx[40] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[40];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_1));
    	const if_block_creators = [create_if_block_6$2, create_else_block_7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty[0] & /*FilteredCerts*/ 2) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*Data*/ ctx[40]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$l, 215, 12, 7687);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 213, 8, 7512);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*FilteredCerts*/ 2) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[40];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(213:4) {#each FilteredCerts as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (196:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh;">
    function create_default_slot_13(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding(value) {
    		/*codejar_value_binding*/ ctx[18](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*CertTemplate*/ ctx[2] !== void 0) {
    		codejar_props.value = /*CertTemplate*/ ctx[2];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding));
    	const if_block_creators = [create_if_block_8$2, create_else_block_8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*CertTemplate*/ 4) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*CertTemplate*/ ctx[2]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value_2 = /*FilteredCerts*/ ctx[1];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$l, 203, 8, 7097);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 201, 4, 6922);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*CertTemplate*/ 4) {
    				updating_value = true;
    				codejar_changes.value = /*CertTemplate*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty[0] & /*SaveCerts, FilteredCerts, DeleteCerts, IsJson, highlight*/ 1730) {
    				each_value_2 = /*FilteredCerts*/ ctx[1];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(196:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (233:4) <MdwPanelHeader style="height: 6vh">
    function create_default_slot_12(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterRoles*/ ctx[11]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Roles";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$l, 233, 8, 8543);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(233:4) <MdwPanelHeader style=\\\"height: 6vh\\\">",
    		ctx
    	});

    	return block;
    }

    // (243:12) {:else}
    function create_else_block_5(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 243, 16, 9056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(243:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (241:12) {#if IsJson(RolesTemplate)}
    function create_if_block_5$3(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func_4*/ ctx[25],
    				Color: "success",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(241:12) {#if IsJson(RolesTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (242:16) <Button click={() => { SaveRole(true) }} Color="success">
    function create_default_slot_11(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(242:16) <Button click={() => { SaveRole(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (260:16) {:else}
    function create_else_block_4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 260, 20, 9991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(260:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (253:16) {#if IsJson(Data)}
    function create_if_block_3$4(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4$3, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (dirty[0] & /*FilteredRoles*/ 8) show_if = null;
    		if (show_if == null) show_if = !!JSON.parse(/*Data*/ ctx[40]).deleted;
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_5(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(253:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (256:20) {:else}
    function create_else_block_3(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	function func_6() {
    		return /*func_6*/ ctx[28](/*Data*/ ctx[40]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_6,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_7() {
    		return /*func_7*/ ctx[29](/*Data*/ ctx[40]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_7,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty[0] & /*FilteredRoles*/ 8) button0_changes.click = func_6;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty[0] & /*FilteredRoles*/ 8) button1_changes.click = func_7;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(256:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (254:20) {#if JSON.parse(Data).deleted}
    function create_if_block_4$3(ctx) {
    	let button;
    	let current;

    	function func_5() {
    		return /*func_5*/ ctx[27](/*Data*/ ctx[40]);
    	}

    	button = new Button({
    			props: {
    				click: func_5,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty[0] & /*FilteredRoles*/ 8) button_changes.click = func_5;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(254:20) {#if JSON.parse(Data).deleted}",
    		ctx
    	});

    	return block;
    }

    // (257:24) <Button click={() => { SaveRole(false, Data) }} Color="warning">
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(257:24) <Button click={() => { SaveRole(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (258:24) <Button click={() => { DeleteRole(JSON.parse(Data).id) }} Color="warning">
    function create_default_slot_9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(258:24) <Button click={() => { DeleteRole(JSON.parse(Data).id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (255:24) <Button click={() => { SaveRole(false, Data) }} Color="warning">
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restore");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(255:24) <Button click={() => { SaveRole(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (249:4) {#each FilteredRoles as Data, Key}
    function create_each_block_1$2(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_3(value) {
    		/*codejar_value_binding_3*/ ctx[26](value, /*Data*/ ctx[40], /*each_value_1*/ ctx[43], /*Key*/ ctx[42]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*Data*/ ctx[40] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[40];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_3));
    	const if_block_creators = [create_if_block_3$4, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (dirty[0] & /*FilteredRoles*/ 8) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*Data*/ ctx[40]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$l, 251, 12, 9427);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 249, 8, 9252);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*FilteredRoles*/ 8) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[40];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(249:4) {#each FilteredRoles as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (232:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh;">
    function create_default_slot_7(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding_2(value) {
    		/*codejar_value_binding_2*/ ctx[24](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*RolesTemplate*/ ctx[4] !== void 0) {
    		codejar_props.value = /*RolesTemplate*/ ctx[4];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_2));
    	const if_block_creators = [create_if_block_5$3, create_else_block_5];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (dirty[0] & /*RolesTemplate*/ 16) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*RolesTemplate*/ ctx[4]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value_1 = /*FilteredRoles*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$l, 239, 8, 8837);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 237, 4, 8661);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*RolesTemplate*/ 16) {
    				updating_value = true;
    				codejar_changes.value = /*RolesTemplate*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty[0] & /*SaveRole, FilteredRoles, DeleteRole, IsJson, highlight*/ 12488) {
    				each_value_1 = /*FilteredRoles*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(232:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (269:4) <MdwPanelHeader style="height: 6vh">
    function create_default_slot_6$2(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterStaff*/ ctx[14]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Staff";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$l, 269, 8, 10280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(269:4) <MdwPanelHeader style=\\\"height: 6vh\\\">",
    		ctx
    	});

    	return block;
    }

    // (279:12) {:else}
    function create_else_block_2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 279, 16, 10794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(279:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (277:12) {#if IsJson(StaffTemplate)}
    function create_if_block_2$6(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func_8*/ ctx[31],
    				Color: "success",
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(277:12) {#if IsJson(StaffTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (278:16) <Button click={() => { SaveStaff(true) }} Color="success">
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(278:16) <Button click={() => { SaveStaff(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (299:16) {:else}
    function create_else_block_1$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$l, 299, 20, 11963);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(299:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (289:16) {#if IsJson(Data)}
    function create_if_block$h(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_8(ctx, dirty) {
    		if (dirty[0] & /*FilteredStaff*/ 1) show_if = null;
    		if (show_if == null) show_if = !!JSON.parse(/*Data*/ ctx[40]).deleted;
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_8(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_8(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(289:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (292:20) {:else}
    function create_else_block$3(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div;
    	let button2;
    	let current;

    	function func_10() {
    		return /*func_10*/ ctx[34](/*Data*/ ctx[40]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_10,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_11() {
    		return /*func_11*/ ctx[35](/*Data*/ ctx[40]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_11,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_12() {
    		return /*func_12*/ ctx[36](/*Data*/ ctx[40]);
    	}

    	button2 = new Button({
    			props: {
    				click: func_12,
    				Color: "default",
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(button2.$$.fragment);
    			set_style(div, "margin-left", "auto");
    			add_location(div, file$l, 294, 24, 11703);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(button2, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty[0] & /*FilteredStaff*/ 1) button0_changes.click = func_10;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty[0] & /*FilteredStaff*/ 1) button1_changes.click = func_11;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};
    			if (dirty[0] & /*FilteredStaff*/ 1) button2_changes.click = func_12;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(button2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(292:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (290:20) {#if JSON.parse(Data).deleted}
    function create_if_block_1$8(ctx) {
    	let button;
    	let current;

    	function func_9() {
    		return /*func_9*/ ctx[33](/*Data*/ ctx[40]);
    	}

    	button = new Button({
    			props: {
    				click: func_9,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty[0] & /*FilteredStaff*/ 1) button_changes.click = func_9;

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(290:20) {#if JSON.parse(Data).deleted}",
    		ctx
    	});

    	return block;
    }

    // (293:24) <Button click={() => { SaveStaff(false, Data) }} Color="warning">
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(293:24) <Button click={() => { SaveStaff(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (294:24) <Button click={() => { DeleteStaff(JSON.parse(Data).id) }} Color="warning">
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(294:24) <Button click={() => { DeleteStaff(JSON.parse(Data).id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (296:28) <Button click={() => { CreateBadge(JSON.parse(Data)) }} Color="default">
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create Badge");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(296:28) <Button click={() => { CreateBadge(JSON.parse(Data)) }} Color=\\\"default\\\">",
    		ctx
    	});

    	return block;
    }

    // (291:24) <Button click={() => { SaveStaff(false, Data, true) }} Color="warning">
    function create_default_slot_1$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restore");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(291:24) <Button click={() => { SaveStaff(false, Data, true) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (285:4) {#each FilteredStaff as Data, Key}
    function create_each_block$b(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_5(value) {
    		/*codejar_value_binding_5*/ ctx[32](value, /*Data*/ ctx[40], /*each_value*/ ctx[41], /*Key*/ ctx[42]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*Data*/ ctx[40] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[40];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_5));
    	const if_block_creators = [create_if_block$h, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_7(ctx, dirty) {
    		if (dirty[0] & /*FilteredStaff*/ 1) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*Data*/ ctx[40]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_7(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			set_style(div0, "width", "100%");
    			add_location(div0, file$l, 287, 12, 11165);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 285, 8, 10990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*FilteredStaff*/ 1) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[40];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_7(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(285:4) {#each FilteredStaff as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (268:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh;">
    function create_default_slot$g(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding_4(value) {
    		/*codejar_value_binding_4*/ ctx[30](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[6]
    	};

    	if (/*StaffTemplate*/ ctx[5] !== void 0) {
    		codejar_props.value = /*StaffTemplate*/ ctx[5];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_4));
    	const if_block_creators = [create_if_block_2$6, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_6(ctx, dirty) {
    		if (dirty[0] & /*StaffTemplate*/ 32) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[7](/*StaffTemplate*/ ctx[5]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_6(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*FilteredStaff*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$l, 275, 8, 10574);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$l, 273, 4, 10398);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty[0] & /*StaffTemplate*/ 32) {
    				updating_value = true;
    				codejar_changes.value = /*StaffTemplate*/ ctx[5];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_6(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty[0] & /*SaveStaff, FilteredStaff, CreateBadge, DeleteStaff, IsJson, highlight*/ 229569) {
    				each_value = /*FilteredStaff*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(268:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh;\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let mdwpanel0;
    	let t0;
    	let mdwpanel1;
    	let t1;
    	let mdwpanel2;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh;",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh;",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel2 = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh;",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel0.$$.fragment);
    			t0 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t1 = space();
    			create_component(mdwpanel2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdwpanel1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdwpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel0_changes = {};

    			if (dirty[0] & /*FilteredCerts, CertTemplate*/ 6 | dirty[1] & /*$$scope*/ 16384) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty[0] & /*FilteredRoles, RolesTemplate*/ 24 | dirty[1] & /*$$scope*/ 16384) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const mdwpanel2_changes = {};

    			if (dirty[0] & /*FilteredStaff, StaffTemplate*/ 33 | dirty[1] & /*$$scope*/ 16384) {
    				mdwpanel2_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel2.$set(mdwpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(mdwpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(mdwpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdwpanel1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdwpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $MdwRanks;
    	let $MdwCerts;
    	validate_store(MdwRanks, 'MdwRanks');
    	component_subscribe($$self, MdwRanks, $$value => $$invalidate(38, $MdwRanks = $$value));
    	validate_store(MdwCerts, 'MdwCerts');
    	component_subscribe($$self, MdwCerts, $$value => $$invalidate(39, $MdwCerts = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Config_Staff', slots, []);
    	const highlight = (code, syntax) => prism.highlight(code, prism.languages[syntax], syntax);
    	let Staff = [];
    	let FilteredStaff = [];

    	onMount(() => {
    		SendEvent("Config/FetchAllStaff", {}, (Success, Data) => {
    			if (!Success) return;
    			Staff = Data;
    			FilterStaff("");
    		});
    	});

    	const IsJson = str => {
    		try {
    			JSON.parse(str);
    		} catch(e) {
    			return false;
    		}

    		return true;
    	};

    	// Certs
    	let FilteredCerts = [];

    	let CertTemplate = JSON.stringify({ certificate: "", color: "" }, undefined, 2);

    	const FilterCerts = Value => {
    		const Search = Value.toLowerCase();
    		const MatchedCerts = $MdwCerts.filter(Val => Val.certificate.toLowerCase().includes(Search));

    		$$invalidate(1, FilteredCerts = MatchedCerts.map(Val => {
    			return JSON.stringify(Val, null, 2);
    		}));
    	};

    	const SaveCerts = (Create, Data) => {
    		if (Create) {
    			SendEvent("Config/CreateCert", JSON.parse(CertTemplate));
    		} else {
    			SendEvent("Config/SaveCert", JSON.parse(Data));
    		}
    	};

    	const DeleteCerts = TagId => {
    		if (TagId) SendEvent("Config/DeleteCert", { id: TagId });
    	};

    	MdwCerts.subscribe(Val => {
    		FilterCerts("");
    	});

    	// Roles
    	let FilteredRoles = [];

    	let RolesTemplate = JSON.stringify({ rank: "" }, undefined, 2);

    	const FilterRoles = Value => {
    		const Search = Value.toLowerCase();
    		const MatchedRoles = $MdwRanks.filter(Val => Val.rank.toLowerCase().includes(Search));

    		$$invalidate(3, FilteredRoles = MatchedRoles.map(Val => {
    			return JSON.stringify(Val, null, 2);
    		}));
    	};

    	const SaveRole = (Create, Data) => {
    		if (Create) {
    			SendEvent("Config/CreateRank", JSON.parse(RolesTemplate));
    		} else {
    			SendEvent("Config/SaveRank", JSON.parse(Data));
    		}
    	};

    	const DeleteRole = RoleId => {
    		if (RoleId) SendEvent("Config/DeleteRank", { id: RoleId });
    	};

    	MdwRanks.subscribe(Val => {
    		FilterRoles("");
    	});

    	// Staff
    	let StaffTemplate = JSON.stringify(
    		{
    			citizenid: "",
    			name: "",
    			image: "",
    			callsign: "",
    			alias: "",
    			phonenumber: "",
    			department: "",
    			rank: 1
    		},
    		undefined,
    		2
    	);

    	const FilterStaff = Value => {
    		const Search = Value.toLowerCase();

    		const MatchedStaff = Staff.filter(Val => {
    			return Val.citizenid.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search) || Val.callsign.toLowerCase().includes(Search) || Val.alias.toLowerCase().includes(Search);
    		});

    		$$invalidate(0, FilteredStaff = MatchedStaff.map(Val => {
    			return JSON.stringify(Val, null, 2);
    		}));
    	};

    	const SaveStaff = (Create, Data, Refetch) => {
    		if (Create) {
    			SendEvent("Config/CreateStaff", JSON.parse(StaffTemplate));
    		} else {
    			SendEvent("Config/SaveStaff", JSON.parse(Data), () => {
    				if (Refetch) {
    					SendEvent("Config/FetchAllStaff", {}, (Success, Data) => {
    						if (!Success) return;
    						Staff = Data;
    						FilterStaff("");
    					});
    				}
    			});
    		}
    	};

    	const DeleteStaff = StaffId => {
    		if (StaffId) {
    			SendEvent("Config/DeleteStaff", { id: StaffId }, () => {
    				SendEvent("Config/FetchAllStaff", {}, (Success, Data) => {
    					if (!Success) return;
    					Staff = Data;
    					FilterStaff("");
    				});
    			});
    		}
    	};

    	const CreateBadge = ({ callsign, image, name, rank: rankId }) => {
    		const { rank } = $MdwRanks.find(Val => Val.id == rankId);

    		if (!rank) return MdwModalsExport$1.set({
    			Show: true,
    			Msg: "Could not create badge: Rank not found."
    		});

    		if (!callsign) return MdwModalsExport$1.set({
    			Show: true,
    			Msg: "Could not create badge: Callsign not found."
    		});

    		if (!image) return MdwModalsExport$1.set({
    			Show: true,
    			Msg: "Could not create badge: Photo not found."
    		});

    		if (!name) return MdwModalsExport$1.set({
    			Show: true,
    			Msg: "Could not create badge: Name not found."
    		});

    		const callsignSerial = callsign.charAt(0);
    		let badgeType = false;
    		let departmentLabel = false;

    		switch (callsignSerial) {
    			case "2":
    				departmentLabel = "State Troopers";
    				badgeType = "pd";
    				break;
    			case "3":
    				departmentLabel = "Blaine County Sheriffs Office";
    				badgeType = "pd";
    				break;
    			case "4":
    				departmentLabel = "Los Santos PD";
    				badgeType = "pd";
    				break;
    			case "5":
    				departmentLabel = "State Park";
    				badgeType = "pd";
    				break;
    			case "6":
    				departmentLabel = "Unified PD";
    				badgeType = "pd";
    				break;
    			default:
    				departmentLabel = "Los Santos Medical Group";
    				badgeType = "ems";
    				break;
    		}

    		if (!badgeType || !departmentLabel) return MdwModalsExport$1.set({
    			Show: true,
    			Msg: "Could not create badge: Department not valid."
    		});

    		ShowLoader.set(true);

    		SendEvent(
    			"Config/CreateBadge",
    			{
    				callsign,
    				departmentLabel,
    				image,
    				name,
    				rank,
    				badgeType
    			},
    			(Success, Result) => {
    				ShowLoader.set(false);
    				if (!Success) return;

    				MdwModalsExport$1.set({
    					Show: true,
    					Msg: `Successfully created badge for ${departmentLabel} (#${callsign}) ${name}!`
    				});
    			}
    		);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Config_Staff> was created with unknown prop '${key}'`);
    	});

    	function codejar_value_binding(value) {
    		CertTemplate = value;
    		$$invalidate(2, CertTemplate);
    	}

    	const func = () => {
    		SaveCerts(true);
    	};

    	function codejar_value_binding_1(value, Data, each_value_2, Key) {
    		each_value_2[Key] = value;
    		$$invalidate(1, FilteredCerts);
    	}

    	const func_1 = Data => {
    		SaveCerts(false, Data);
    	};

    	const func_2 = Data => {
    		SaveCerts(false, Data);
    	};

    	const func_3 = Data => {
    		DeleteCerts(JSON.parse(Data).id);
    	};

    	function codejar_value_binding_2(value) {
    		RolesTemplate = value;
    		$$invalidate(4, RolesTemplate);
    	}

    	const func_4 = () => {
    		SaveRole(true);
    	};

    	function codejar_value_binding_3(value, Data, each_value_1, Key) {
    		each_value_1[Key] = value;
    		$$invalidate(3, FilteredRoles);
    	}

    	const func_5 = Data => {
    		SaveRole(false, Data);
    	};

    	const func_6 = Data => {
    		SaveRole(false, Data);
    	};

    	const func_7 = Data => {
    		DeleteRole(JSON.parse(Data).id);
    	};

    	function codejar_value_binding_4(value) {
    		StaffTemplate = value;
    		$$invalidate(5, StaffTemplate);
    	}

    	const func_8 = () => {
    		SaveStaff(true);
    	};

    	function codejar_value_binding_5(value, Data, each_value, Key) {
    		each_value[Key] = value;
    		$$invalidate(0, FilteredStaff);
    	}

    	const func_9 = Data => {
    		SaveStaff(false, Data, true);
    	};

    	const func_10 = Data => {
    		SaveStaff(false, Data);
    	};

    	const func_11 = Data => {
    		DeleteStaff(JSON.parse(Data).id);
    	};

    	const func_12 = Data => {
    		CreateBadge(JSON.parse(Data));
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		TextField,
    		SendEvent,
    		Button,
    		MdwCerts,
    		MdwModalsExport: MdwModalsExport$1,
    		MdwRanks,
    		ShowLoader,
    		onMount,
    		CodeJar,
    		Prism: prism,
    		highlight,
    		Staff,
    		FilteredStaff,
    		IsJson,
    		FilteredCerts,
    		CertTemplate,
    		FilterCerts,
    		SaveCerts,
    		DeleteCerts,
    		FilteredRoles,
    		RolesTemplate,
    		FilterRoles,
    		SaveRole,
    		DeleteRole,
    		StaffTemplate,
    		FilterStaff,
    		SaveStaff,
    		DeleteStaff,
    		CreateBadge,
    		$MdwRanks,
    		$MdwCerts
    	});

    	$$self.$inject_state = $$props => {
    		if ('Staff' in $$props) Staff = $$props.Staff;
    		if ('FilteredStaff' in $$props) $$invalidate(0, FilteredStaff = $$props.FilteredStaff);
    		if ('FilteredCerts' in $$props) $$invalidate(1, FilteredCerts = $$props.FilteredCerts);
    		if ('CertTemplate' in $$props) $$invalidate(2, CertTemplate = $$props.CertTemplate);
    		if ('FilteredRoles' in $$props) $$invalidate(3, FilteredRoles = $$props.FilteredRoles);
    		if ('RolesTemplate' in $$props) $$invalidate(4, RolesTemplate = $$props.RolesTemplate);
    		if ('StaffTemplate' in $$props) $$invalidate(5, StaffTemplate = $$props.StaffTemplate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredStaff,
    		FilteredCerts,
    		CertTemplate,
    		FilteredRoles,
    		RolesTemplate,
    		StaffTemplate,
    		highlight,
    		IsJson,
    		FilterCerts,
    		SaveCerts,
    		DeleteCerts,
    		FilterRoles,
    		SaveRole,
    		DeleteRole,
    		FilterStaff,
    		SaveStaff,
    		DeleteStaff,
    		CreateBadge,
    		codejar_value_binding,
    		func,
    		codejar_value_binding_1,
    		func_1,
    		func_2,
    		func_3,
    		codejar_value_binding_2,
    		func_4,
    		codejar_value_binding_3,
    		func_5,
    		func_6,
    		func_7,
    		codejar_value_binding_4,
    		func_8,
    		codejar_value_binding_5,
    		func_9,
    		func_10,
    		func_11,
    		func_12
    	];
    }

    class Config_Staff extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$m, create_fragment$m, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Config_Staff",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Config.Permissions.svelte generated by Svelte v3.59.2 */
    const file$k = "src\\apps\\Mdw\\apps\\Config.Permissions.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[16] = list;
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (65:4) <MdwPanelHeader style="height: 6vh; width: 98.6%;">
    function create_default_slot_5$2(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterRoles*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Roles";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$k, 65, 8, 2546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(65:4) <MdwPanelHeader style=\\\"height: 6vh; width: 98.6%;\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:12) {:else}
    function create_else_block_1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$k, 75, 16, 3057);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(75:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:12) {#if IsJson(RoleTemplate)}
    function create_if_block_1$7(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				click: /*func*/ ctx[9],
    				Color: "success",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(73:12) {#if IsJson(RoleTemplate)}",
    		ctx
    	});

    	return block;
    }

    // (74:16) <Button click={() => { SaveRole(true) }} Color="success">
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(74:16) <Button click={() => { SaveRole(true) }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:16) {:else}
    function create_else_block$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Invalid JSON! Please fix.";
    			set_style(p, "font-family", "monospace");
    			set_style(p, "font-size", "1.5vh");
    			set_style(p, "color", "#ff3d3d");
    			add_location(p, file$k, 89, 20, 3896);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(89:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:16) {#if IsJson(Data)}
    function create_if_block$g(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	function func_1() {
    		return /*func_1*/ ctx[11](/*Data*/ ctx[15]);
    	}

    	button0 = new Button({
    			props: {
    				click: func_1,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_2() {
    		return /*func_2*/ ctx[12](/*Data*/ ctx[15]);
    	}

    	button1 = new Button({
    			props: {
    				click: func_2,
    				Color: "warning",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function func_3() {
    		return /*func_3*/ ctx[13](/*Data*/ ctx[15]);
    	}

    	button2 = new Button({
    			props: {
    				click: func_3,
    				Color: "default",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button0_changes = {};
    			if (dirty & /*FilteredRoles*/ 1) button0_changes.click = func_1;

    			if (dirty & /*$$scope*/ 262144) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*FilteredRoles*/ 1) button1_changes.click = func_2;

    			if (dirty & /*$$scope*/ 262144) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};
    			if (dirty & /*FilteredRoles*/ 1) button2_changes.click = func_3;

    			if (dirty & /*$$scope*/ 262144) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(85:16) {#if IsJson(Data)}",
    		ctx
    	});

    	return block;
    }

    // (86:20) <Button click={() => { SaveRole(false, Data) }} Color="warning">
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(86:20) <Button click={() => { SaveRole(false, Data) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:20) <Button click={() => { DeleteRole(JSON.parse(Data).id) }} Color="warning">
    function create_default_slot_2$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(87:20) <Button click={() => { DeleteRole(JSON.parse(Data).id) }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (88:20) <Button click={() => { EditPermissions(JSON.parse(Data).id) }} Color="default">
    function create_default_slot_1$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Edit Permissions");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(88:20) <Button click={() => { EditPermissions(JSON.parse(Data).id) }} Color=\\\"default\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:4) {#each FilteredRoles as Data, Key}
    function create_each_block$a(ctx) {
    	let div1;
    	let codejar;
    	let updating_value;
    	let t0;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;

    	function codejar_value_binding_1(value) {
    		/*codejar_value_binding_1*/ ctx[10](value, /*Data*/ ctx[15], /*each_value*/ ctx[16], /*Key*/ ctx[17]);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[2]
    	};

    	if (/*Data*/ ctx[15] !== void 0) {
    		codejar_props.value = /*Data*/ ctx[15];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding_1));
    	const if_block_creators = [create_if_block$g, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*FilteredRoles*/ 1) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[3](/*Data*/ ctx[15]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$k, 83, 12, 3428);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$k, 81, 8, 3253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*FilteredRoles*/ 1) {
    				updating_value = true;
    				codejar_changes.value = /*Data*/ ctx[15];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(81:4) {#each FilteredRoles as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (64:0) <MdwPanel style="margin-top: 1vh; height: 72.5vh; width: 100%;">
    function create_default_slot$f(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div1;
    	let codejar;
    	let updating_value;
    	let t1;
    	let div0;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let each_1_anchor;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "height: 6vh; width: 98.6%;",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function codejar_value_binding(value) {
    		/*codejar_value_binding*/ ctx[8](value);
    	}

    	let codejar_props = {
    		spellcheck: true,
    		syntax: "json",
    		highlight: /*highlight*/ ctx[2]
    	};

    	if (/*RoleTemplate*/ ctx[1] !== void 0) {
    		codejar_props.value = /*RoleTemplate*/ ctx[1];
    	}

    	codejar = new CodeJar({ props: codejar_props, $$inline: true });
    	binding_callbacks.push(() => bind(codejar, 'value', codejar_value_binding));
    	const if_block_creators = [create_if_block_1$7, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*RoleTemplate*/ 2) show_if = null;
    		if (show_if == null) show_if = !!/*IsJson*/ ctx[3](/*RoleTemplate*/ ctx[1]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*FilteredRoles*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(codejar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "row");
    			add_location(div0, file$k, 71, 8, 2839);
    			set_style(div1, "border-top", "0.3vh solid rgb(30, 30, 30)");
    			set_style(div1, "margin-bottom", "1vh");
    			add_location(div1, file$k, 69, 4, 2664);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(codejar, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const codejar_changes = {};

    			if (!updating_value && dirty & /*RoleTemplate*/ 2) {
    				updating_value = true;
    				codejar_changes.value = /*RoleTemplate*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			codejar.$set(codejar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty & /*EditPermissions, JSON, FilteredRoles, DeleteRole, SaveRole, IsJson, highlight*/ 237) {
    				each_value = /*FilteredRoles*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(codejar.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(codejar.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(codejar);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(64:0) <MdwPanel style=\\\"margin-top: 1vh; height: 72.5vh; width: 100%;\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				style: "margin-top: 1vh; height: 72.5vh; width: 100%;",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredRoles, RoleTemplate*/ 262147) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $MdwRoles;
    	validate_store(MdwRoles, 'MdwRoles');
    	component_subscribe($$self, MdwRoles, $$value => $$invalidate(14, $MdwRoles = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Config_Permissions', slots, []);
    	const highlight = (code, syntax) => prism.highlight(code, prism.languages[syntax], syntax);

    	const IsJson = str => {
    		try {
    			JSON.parse(str);
    		} catch(e) {
    			return false;
    		}

    		return true;
    	};

    	// Roles
    	let FilteredRoles = [];

    	let RoleTemplate = JSON.stringify({ name: "", icon: "", color: "#ffffff" }, undefined, 2);

    	const FilterRoles = Value => {
    		const Search = Value.toLowerCase();
    		const MatchedRoles = $MdwRoles.filter(Val => Val.name.toLowerCase().includes(Search) || Val.id.toLowerCase().includes(Search));

    		$$invalidate(0, FilteredRoles = MatchedRoles.map(Val => {
    			return JSON.stringify(
    				{
    					id: Val.id,
    					name: Val.name,
    					icon: Val.icon,
    					color: Val.color
    				},
    				null,
    				2
    			);
    		}));
    	};

    	const SaveRole = (Create, Data) => {
    		if (Create) {
    			SendEvent("Config/CreateRole", JSON.parse(RoleTemplate));
    		} else {
    			const RoleIndex = $MdwRoles.findIndex(Val => Val.id == JSON.parse(Data).id);
    			if (RoleIndex == -1) return;

    			SendEvent("Config/SaveRole", {
    				...JSON.parse(Data),
    				permissions: $MdwRoles[RoleIndex].permissions
    			});
    		}
    	};

    	const DeleteRole = RoleId => {
    		if (RoleId) SendEvent("Config/DeleteRole", { id: RoleId });
    	};

    	const EditPermissions = RoleId => {
    		MdwModalsPermissions.set({
    			Show: true,
    			Role: $MdwRoles.filter(Val => Val.id == RoleId)[0],
    			Cb: Permissions => {
    				const RoleIndex = $MdwRoles.findIndex(Val => Val.id == RoleId);
    				if (RoleIndex == -1) return;
    				set_store_value(MdwRoles, $MdwRoles[RoleIndex].permissions = Permissions, $MdwRoles);
    			}
    		});
    	};

    	MdwRoles.subscribe(Val => {
    		FilterRoles("");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Config_Permissions> was created with unknown prop '${key}'`);
    	});

    	function codejar_value_binding(value) {
    		RoleTemplate = value;
    		$$invalidate(1, RoleTemplate);
    	}

    	const func = () => {
    		SaveRole(true);
    	};

    	function codejar_value_binding_1(value, Data, each_value, Key) {
    		each_value[Key] = value;
    		$$invalidate(0, FilteredRoles);
    	}

    	const func_1 = Data => {
    		SaveRole(false, Data);
    	};

    	const func_2 = Data => {
    		DeleteRole(JSON.parse(Data).id);
    	};

    	const func_3 = Data => {
    		EditPermissions(JSON.parse(Data).id);
    	};

    	$$self.$capture_state = () => ({
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		TextField,
    		SendEvent,
    		Button,
    		MdwModalsPermissions,
    		MdwRoles,
    		onMount,
    		CodeJar,
    		Prism: prism,
    		highlight,
    		IsJson,
    		FilteredRoles,
    		RoleTemplate,
    		FilterRoles,
    		SaveRole,
    		DeleteRole,
    		EditPermissions,
    		$MdwRoles
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredRoles' in $$props) $$invalidate(0, FilteredRoles = $$props.FilteredRoles);
    		if ('RoleTemplate' in $$props) $$invalidate(1, RoleTemplate = $$props.RoleTemplate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredRoles,
    		RoleTemplate,
    		highlight,
    		IsJson,
    		FilterRoles,
    		SaveRole,
    		DeleteRole,
    		EditPermissions,
    		codejar_value_binding,
    		func,
    		codejar_value_binding_1,
    		func_1,
    		func_2,
    		func_3
    	];
    }

    class Config_Permissions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Config_Permissions",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Config.Charges.svelte generated by Svelte v3.59.2 */
    const file$j = "src\\apps\\Mdw\\apps\\Config.Charges.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (19:4) {#if HasCidPermission("Config.EditCharges")}
    function create_if_block_2$5(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				Color: "success",
    				click: /*func*/ ctx[5],
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*$IsEms*/ 1) button_changes.click = /*func*/ ctx[5];

    			if (dirty & /*$$scope*/ 4096) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(19:4) {#if HasCidPermission(\\\"Config.EditCharges\\\")}",
    		ctx
    	});

    	return block;
    }

    // (20:8) <Button              Color="success"              click={() => MdwModalsChargeEditor.set({Show: true, Charge: {                  gov_type: $IsEms ? "ems" : "pd",                  category: "",                  fine: 0,                  jail: 0,                  points: 0,                  name: "",                  description: "",                  type: "",                  accomplice: {},                  attempted: {},              }})}          >
    function create_default_slot$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Straf creëren");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(20:8) <Button              Color=\\\"success\\\"              click={() => MdwModalsChargeEditor.set({Show: true, Charge: {                  gov_type: $IsEms ? \\\"ems\\\" : \\\"pd\\\",                  category: \\\"\\\",                  fine: 0,                  jail: 0,                  points: 0,                  name: \\\"\\\",                  description: \\\"\\\",                  type: \\\"\\\",                  accomplice: {},                  attempted: {},              }})}          >",
    		ctx
    	});

    	return block;
    }

    // (61:28) {#if HasCidPermission("Config.EditCharges")}
    function create_if_block_1$6(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*Data*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-edit svelte-1q2qrqd");
    			attr_dev(i, "data-tooltip", "Edit");
    			add_location(i, file$j, 61, 32, 2329);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler*/ ctx[4], false, false, false, false),
    					listen_dev(i, "click", click_handler, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(61:28) {#if HasCidPermission(\\\"Config.EditCharges\\\")}",
    		ctx
    	});

    	return block;
    }

    // (69:28) {#if HasCidPermission("Config.DeleteCharges")}
    function create_if_block$f(ctx) {
    	let i;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[8](/*Data*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-trash svelte-1q2qrqd");
    			attr_dev(i, "data-tooltip", "Delete");
    			add_location(i, file$j, 69, 32, 2745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "keyup", /*keyup_handler_1*/ ctx[3], false, false, false, false),
    					listen_dev(i, "click", click_handler_1, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(69:28) {#if HasCidPermission(\\\"Config.DeleteCharges\\\")}",
    		ctx
    	});

    	return block;
    }

    // (52:16) {#each $MdwCharges.filter(Val => Val != undefined && Val.deleted == 0) as Data (Data.id)}
    function create_each_block$9(key_1, ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*Data*/ ctx[9].id + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*Data*/ ctx[9].gov_type + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*Data*/ ctx[9].type + "";
    	let t4;
    	let td2_class_value;
    	let t5;
    	let td3;
    	let t6_value = /*Data*/ ctx[9].category + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*Data*/ ctx[9].name + "";
    	let t8;
    	let t9;
    	let td5;
    	let t10_value = /*Data*/ ctx[9].description + "";
    	let t10;
    	let t11;
    	let td6;
    	let show_if_1 = HasCidPermission("Config.EditCharges");
    	let t12;
    	let show_if = HasCidPermission("Config.DeleteCharges");
    	let t13;
    	let if_block0 = show_if_1 && create_if_block_1$6(ctx);
    	let if_block1 = show_if && create_if_block$f(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text(t10_value);
    			t11 = space();
    			td6 = element("td");
    			if (if_block0) if_block0.c();
    			t12 = space();
    			if (if_block1) if_block1.c();
    			t13 = space();
    			attr_dev(td0, "class", "svelte-1q2qrqd");
    			add_location(td0, file$j, 53, 24, 1896);
    			attr_dev(td1, "class", "svelte-1q2qrqd");
    			add_location(td1, file$j, 54, 24, 1940);
    			attr_dev(td2, "class", td2_class_value = "charge-type-" + /*Data*/ ctx[9].type + " svelte-1q2qrqd");
    			add_location(td2, file$j, 55, 24, 1990);
    			attr_dev(td3, "class", "svelte-1q2qrqd");
    			add_location(td3, file$j, 56, 24, 2068);
    			attr_dev(td4, "class", "svelte-1q2qrqd");
    			add_location(td4, file$j, 57, 24, 2118);
    			attr_dev(td5, "class", "svelte-1q2qrqd");
    			add_location(td5, file$j, 58, 24, 2164);
    			attr_dev(td6, "class", "svelte-1q2qrqd");
    			add_location(td6, file$j, 59, 24, 2217);
    			add_location(tr, file$j, 52, 20, 1866);
    			this.first = tr;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td6);
    			if (if_block0) if_block0.m(td6, null);
    			append_dev(td6, t12);
    			if (if_block1) if_block1.m(td6, null);
    			append_dev(tr, t13);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$MdwCharges*/ 2 && t0_value !== (t0_value = /*Data*/ ctx[9].id + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$MdwCharges*/ 2 && t2_value !== (t2_value = /*Data*/ ctx[9].gov_type + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$MdwCharges*/ 2 && t4_value !== (t4_value = /*Data*/ ctx[9].type + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$MdwCharges*/ 2 && td2_class_value !== (td2_class_value = "charge-type-" + /*Data*/ ctx[9].type + " svelte-1q2qrqd")) {
    				attr_dev(td2, "class", td2_class_value);
    			}

    			if (dirty & /*$MdwCharges*/ 2 && t6_value !== (t6_value = /*Data*/ ctx[9].category + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$MdwCharges*/ 2 && t8_value !== (t8_value = /*Data*/ ctx[9].name + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$MdwCharges*/ 2 && t10_value !== (t10_value = /*Data*/ ctx[9].description + "")) set_data_dev(t10, t10_value);
    			if (show_if_1) if_block0.p(ctx, dirty);
    			if (show_if) if_block1.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(52:16) {#each $MdwCharges.filter(Val => Val != undefined && Val.deleted == 0) as Data (Data.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div1;
    	let show_if = HasCidPermission("Config.EditCharges");
    	let t0;
    	let div0;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let th4;
    	let t10;
    	let th5;
    	let t12;
    	let th6;
    	let t14;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let if_block = show_if && create_if_block_2$5(ctx);
    	let each_value = /*$MdwCharges*/ ctx[1].filter(/*func_1*/ ctx[6]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*Data*/ ctx[9].id;
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "#";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Gov Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Charge Type";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Category";
    			t8 = space();
    			th4 = element("th");
    			th4.textContent = "Name";
    			t10 = space();
    			th5 = element("th");
    			th5.textContent = "Description";
    			t12 = space();
    			th6 = element("th");
    			th6.textContent = "Actions";
    			t14 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(th0, "width", "1.5vh");
    			attr_dev(th0, "class", "svelte-1q2qrqd");
    			add_location(th0, file$j, 40, 20, 1332);
    			set_style(th1, "width", "8vh");
    			attr_dev(th1, "class", "svelte-1q2qrqd");
    			add_location(th1, file$j, 41, 20, 1386);
    			set_style(th2, "width", "9vh");
    			attr_dev(th2, "class", "svelte-1q2qrqd");
    			add_location(th2, file$j, 42, 20, 1445);
    			attr_dev(th3, "class", "svelte-1q2qrqd");
    			add_location(th3, file$j, 43, 20, 1507);
    			attr_dev(th4, "class", "svelte-1q2qrqd");
    			add_location(th4, file$j, 44, 20, 1546);
    			attr_dev(th5, "class", "svelte-1q2qrqd");
    			add_location(th5, file$j, 45, 20, 1581);
    			set_style(th6, "width", "5.6vh");
    			attr_dev(th6, "class", "svelte-1q2qrqd");
    			add_location(th6, file$j, 46, 20, 1623);
    			add_location(tr, file$j, 39, 16, 1306);
    			attr_dev(thead, "class", "svelte-1q2qrqd");
    			add_location(thead, file$j, 38, 12, 1281);
    			add_location(tbody, file$j, 50, 12, 1730);
    			attr_dev(table, "class", "svelte-1q2qrqd");
    			add_location(table, file$j, 37, 8, 1260);
    			attr_dev(div0, "class", "charge-table-wrapper svelte-1q2qrqd");
    			add_location(div0, file$j, 36, 4, 1216);
    			set_style(div1, "width", "100%");
    			add_location(div1, file$j, 17, 0, 631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t2);
    			append_dev(tr, th1);
    			append_dev(tr, t4);
    			append_dev(tr, th2);
    			append_dev(tr, t6);
    			append_dev(tr, th3);
    			append_dev(tr, t8);
    			append_dev(tr, th4);
    			append_dev(tr, t10);
    			append_dev(tr, th5);
    			append_dev(tr, t12);
    			append_dev(tr, th6);
    			append_dev(table, t14);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(tbody, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (show_if) if_block.p(ctx, dirty);

    			if (dirty & /*DeleteCharge, $MdwCharges, undefined, HasCidPermission, MdwModalsChargeEditor*/ 6) {
    				each_value = /*$MdwCharges*/ ctx[1].filter(/*func_1*/ ctx[6]);
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, destroy_block, create_each_block$9, null, get_each_context$9);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $IsEms;
    	let $MdwCharges;
    	validate_store(IsEms, 'IsEms');
    	component_subscribe($$self, IsEms, $$value => $$invalidate(0, $IsEms = $$value));
    	validate_store(MdwCharges, 'MdwCharges');
    	component_subscribe($$self, MdwCharges, $$value => $$invalidate(1, $MdwCharges = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Config_Charges', slots, []);

    	const DeleteCharge = Id => {
    		ShowLoader.set(true);

    		SendEvent("Config/DeleteCharge", { Id }, (Success, Data) => {
    			ShowLoader.set(false);
    			if (!Success) return;
    			if (!Data.Success) MdwModalsExport$1.set({ Show: true, Msg: Data.Msg });
    			MdwCharges.set(Data.Charges);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Config_Charges> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const func = () => MdwModalsChargeEditor.set({
    		Show: true,
    		Charge: {
    			gov_type: $IsEms ? "ems" : "pd",
    			category: "",
    			fine: 0,
    			jail: 0,
    			points: 0,
    			name: "",
    			description: "",
    			type: "",
    			accomplice: {},
    			attempted: {}
    		}
    	});

    	const func_1 = Val => Val != undefined && Val.deleted == 0;
    	const click_handler = Data => MdwModalsChargeEditor.set({ Show: true, Charge: Data });
    	const click_handler_1 = Data => DeleteCharge(Data.id);

    	$$self.$capture_state = () => ({
    		Button,
    		IsEms,
    		MdwCharges,
    		MdwModalsChargeEditor,
    		MdwModalsExport: MdwModalsExport$1,
    		ShowLoader,
    		HasCidPermission,
    		SendEvent,
    		DeleteCharge,
    		$IsEms,
    		$MdwCharges
    	});

    	return [
    		$IsEms,
    		$MdwCharges,
    		DeleteCharge,
    		keyup_handler_1,
    		keyup_handler,
    		func,
    		func_1,
    		click_handler,
    		click_handler_1
    	];
    }

    class Config_Charges extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Config_Charges",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\apps\Mdw\apps\Config.svelte generated by Svelte v3.59.2 */
    const file$i = "src\\apps\\Mdw\\apps\\Config.svelte";

    // (12:0) {#if $IsHighcommand}
    function create_if_block$e(ctx) {
    	let div5;
    	let div3;
    	let div0;
    	let t0;
    	let div0_data_active_value;
    	let t1;
    	let div1;
    	let t2;
    	let div1_data_active_value;
    	let t3;
    	let div2;
    	let t4;
    	let div2_data_active_value;
    	let t5;
    	let show_if = HasCidPermission("Config.EditCharges") || HasCidPermission("Config.DeleteCharges");
    	let t6;
    	let div4;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if && create_if_block_5$2(ctx);
    	const if_block_creators = [create_if_block_1$5, create_if_block_2$4, create_if_block_3$3, create_if_block_4$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*CurrentTab*/ ctx[0] == 'Tags') return 0;
    		if (/*CurrentTab*/ ctx[0] == 'Staff') return 1;
    		if (/*CurrentTab*/ ctx[0] == 'Permissions') return 2;
    		if (/*CurrentTab*/ ctx[0] == 'Charges') return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text("Tags & Types");
    			t1 = space();
    			div1 = element("div");
    			t2 = text("Staff & Roles");
    			t3 = space();
    			div2 = element("div");
    			t4 = text("Permissions");
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			div4 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "mdw-config-tab svelte-11mwrqn");
    			attr_dev(div0, "data-active", div0_data_active_value = /*CurrentTab*/ ctx[0] == "Tags");
    			add_location(div0, file$i, 14, 12, 518);
    			attr_dev(div1, "class", "mdw-config-tab svelte-11mwrqn");
    			attr_dev(div1, "data-active", div1_data_active_value = /*CurrentTab*/ ctx[0] == "Staff");
    			add_location(div1, file$i, 15, 12, 659);
    			attr_dev(div2, "class", "mdw-config-tab svelte-11mwrqn");
    			attr_dev(div2, "data-active", div2_data_active_value = /*CurrentTab*/ ctx[0] == "Permissions");
    			add_location(div2, file$i, 16, 12, 803);
    			attr_dev(div3, "class", "mdw-config-tags svelte-11mwrqn");
    			add_location(div3, file$i, 13, 8, 475);
    			set_style(div4, "display", "flex");
    			set_style(div4, "flex-direction", "row");
    			add_location(div4, file$i, 22, 8, 1246);
    			set_style(div5, "display", "unset");
    			set_style(div5, "width", "100%");
    			add_location(div5, file$i, 12, 4, 423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div3);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, t4);
    			append_dev(div3, t5);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div5, t6);
    			append_dev(div5, div4);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div4, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "keyup", /*keyup_handler*/ ctx[5], false, false, false, false),
    					listen_dev(div0, "click", /*click_handler*/ ctx[6], false, false, false, false),
    					listen_dev(div1, "keyup", /*keyup_handler_1*/ ctx[4], false, false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[7], false, false, false, false),
    					listen_dev(div2, "keyup", /*keyup_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(div2, "click", /*click_handler_2*/ ctx[8], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*CurrentTab*/ 1 && div0_data_active_value !== (div0_data_active_value = /*CurrentTab*/ ctx[0] == "Tags")) {
    				attr_dev(div0, "data-active", div0_data_active_value);
    			}

    			if (!current || dirty & /*CurrentTab*/ 1 && div1_data_active_value !== (div1_data_active_value = /*CurrentTab*/ ctx[0] == "Staff")) {
    				attr_dev(div1, "data-active", div1_data_active_value);
    			}

    			if (!current || dirty & /*CurrentTab*/ 1 && div2_data_active_value !== (div2_data_active_value = /*CurrentTab*/ ctx[0] == "Permissions")) {
    				attr_dev(div2, "data-active", div2_data_active_value);
    			}

    			if (show_if) if_block0.p(ctx, dirty);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(div4, null);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(12:0) {#if $IsHighcommand}",
    		ctx
    	});

    	return block;
    }

    // (18:12) {#if HasCidPermission("Config.EditCharges") || HasCidPermission("Config.DeleteCharges")}
    function create_if_block_5$2(ctx) {
    	let div;
    	let t;
    	let div_data_active_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("Charges");
    			attr_dev(div, "class", "mdw-config-tab svelte-11mwrqn");
    			attr_dev(div, "data-active", div_data_active_value = /*CurrentTab*/ ctx[0] == "Charges");
    			add_location(div, file$i, 18, 16, 1063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler_3*/ ctx[2], false, false, false, false),
    					listen_dev(div, "click", /*click_handler_3*/ ctx[9], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*CurrentTab*/ 1 && div_data_active_value !== (div_data_active_value = /*CurrentTab*/ ctx[0] == "Charges")) {
    				attr_dev(div, "data-active", div_data_active_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(18:12) {#if HasCidPermission(\\\"Config.EditCharges\\\") || HasCidPermission(\\\"Config.DeleteCharges\\\")}",
    		ctx
    	});

    	return block;
    }

    // (30:46) 
    function create_if_block_4$2(ctx) {
    	let configcharges;
    	let current;
    	configcharges = new Config_Charges({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(configcharges.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(configcharges, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(configcharges.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(configcharges.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(configcharges, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(30:46) ",
    		ctx
    	});

    	return block;
    }

    // (28:50) 
    function create_if_block_3$3(ctx) {
    	let configpermissions;
    	let current;
    	configpermissions = new Config_Permissions({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(configpermissions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(configpermissions, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(configpermissions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(configpermissions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(configpermissions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(28:50) ",
    		ctx
    	});

    	return block;
    }

    // (26:44) 
    function create_if_block_2$4(ctx) {
    	let configstaff;
    	let current;
    	configstaff = new Config_Staff({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(configstaff.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(configstaff, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(configstaff.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(configstaff.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(configstaff, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(26:44) ",
    		ctx
    	});

    	return block;
    }

    // (24:12) {#if CurrentTab == 'Tags'}
    function create_if_block_1$5(ctx) {
    	let configtags;
    	let current;
    	configtags = new Config_Tags({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(configtags.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(configtags, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(configtags.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(configtags.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(configtags, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(24:12) {#if CurrentTab == 'Tags'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$IsHighcommand*/ ctx[1] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$IsHighcommand*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$IsHighcommand*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $IsHighcommand;
    	validate_store(IsHighcommand, 'IsHighcommand');
    	component_subscribe($$self, IsHighcommand, $$value => $$invalidate(1, $IsHighcommand = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Config', slots, []);
    	let CurrentTab = '';
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Config> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = () => $$invalidate(0, CurrentTab = "Tags");
    	const click_handler_1 = () => $$invalidate(0, CurrentTab = "Staff");
    	const click_handler_2 = () => $$invalidate(0, CurrentTab = "Permissions");
    	const click_handler_3 = () => $$invalidate(0, CurrentTab = "Charges");

    	$$self.$capture_state = () => ({
    		IsHighcommand,
    		CurrentTab,
    		ConfigTags: Config_Tags,
    		ConfigStaff: Config_Staff,
    		ConfigPermissions: Config_Permissions,
    		ConfigCharges: Config_Charges,
    		HasCidPermission,
    		$IsHighcommand
    	});

    	$$self.$inject_state = $$props => {
    		if ('CurrentTab' in $$props) $$invalidate(0, CurrentTab = $$props.CurrentTab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		CurrentTab,
    		$IsHighcommand,
    		keyup_handler_3,
    		keyup_handler_2,
    		keyup_handler_1,
    		keyup_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Config extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Config",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\apps\Mdw\MdwContainer.svelte generated by Svelte v3.59.2 */
    const file$h = "src\\apps\\Mdw\\MdwContainer.svelte";

    // (37:38) 
    function create_if_block_10$1(ctx) {
    	let config;
    	let current;
    	config = new Config({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(config.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(config, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(config.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(config.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(config, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(37:38) ",
    		ctx
    	});

    	return block;
    }

    // (35:38) 
    function create_if_block_9$1(ctx) {
    	let roster;
    	let current;
    	roster = new Roster({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(roster.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(roster, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(roster.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(roster.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(roster, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(35:38) ",
    		ctx
    	});

    	return block;
    }

    // (33:42) 
    function create_if_block_8$1(ctx) {
    	let businesses;
    	let current;
    	businesses = new Businesses_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(businesses.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(businesses, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(businesses.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(businesses.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(businesses, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(33:42) ",
    		ctx
    	});

    	return block;
    }

    // (31:43) 
    function create_if_block_7$1(ctx) {
    	let legislation;
    	let current;
    	legislation = new Legislation({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(legislation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(legislation, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(legislation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(legislation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(legislation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(31:43) ",
    		ctx
    	});

    	return block;
    }

    // (29:37) 
    function create_if_block_6$1(ctx) {
    	let staff;
    	let current;
    	staff = new Staff_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(staff.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(staff, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(staff.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(staff.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(staff, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(29:37) ",
    		ctx
    	});

    	return block;
    }

    // (27:39) 
    function create_if_block_5$1(ctx) {
    	let charges;
    	let current;
    	charges = new Charges({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(charges.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charges, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charges.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charges.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charges, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(27:39) ",
    		ctx
    	});

    	return block;
    }

    // (25:42) 
    function create_if_block_4$1(ctx) {
    	let properties;
    	let current;
    	properties = new Properties_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(properties.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(properties, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(properties.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(properties.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(properties, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(25:42) ",
    		ctx
    	});

    	return block;
    }

    // (23:40) 
    function create_if_block_3$2(ctx) {
    	let evidence;
    	let current;
    	evidence = new Evidence_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(evidence.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(evidence, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evidence.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evidence.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(evidence, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(23:40) ",
    		ctx
    	});

    	return block;
    }

    // (21:40) 
    function create_if_block_2$3(ctx) {
    	let profiles;
    	let current;
    	profiles = new Profiles_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(profiles.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(profiles, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(profiles.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(profiles.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(profiles, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(21:40) ",
    		ctx
    	});

    	return block;
    }

    // (19:39) 
    function create_if_block_1$4(ctx) {
    	let reports;
    	let current;
    	reports = new Reports_1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(reports.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(reports, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(reports.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(reports.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(reports, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(19:39) ",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if $CurrentTab == 'Dashboard'}
    function create_if_block$d(ctx) {
    	let dashboard;
    	let current;
    	dashboard = new Dashboard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dashboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(17:4) {#if $CurrentTab == 'Dashboard'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	const if_block_creators = [
    		create_if_block$d,
    		create_if_block_1$4,
    		create_if_block_2$3,
    		create_if_block_3$2,
    		create_if_block_4$1,
    		create_if_block_5$1,
    		create_if_block_6$1,
    		create_if_block_7$1,
    		create_if_block_8$1,
    		create_if_block_9$1,
    		create_if_block_10$1
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$CurrentTab*/ ctx[0] == 'Dashboard') return 0;
    		if (/*$CurrentTab*/ ctx[0] == 'Reports') return 1;
    		if (/*$CurrentTab*/ ctx[0] == 'Profiles') return 2;
    		if (/*$CurrentTab*/ ctx[0] == 'Evidence') return 3;
    		if (/*$CurrentTab*/ ctx[0] == 'Properties') return 4;
    		if (/*$CurrentTab*/ ctx[0] == 'Charges') return 5;
    		if (/*$CurrentTab*/ ctx[0] == 'Staff') return 6;
    		if (/*$CurrentTab*/ ctx[0] == 'Legislation') return 7;
    		if (/*$CurrentTab*/ ctx[0] == 'Businesses') return 8;
    		if (/*$CurrentTab*/ ctx[0] == 'Roster') return 9;
    		if (/*$CurrentTab*/ ctx[0] == 'Config') return 10;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "mdw-inside-container svelte-1gzfy32");
    			add_location(div, file$h, 15, 0, 641);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $CurrentTab;
    	validate_store(CurrentTab, 'CurrentTab');
    	component_subscribe($$self, CurrentTab, $$value => $$invalidate(0, $CurrentTab = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdwContainer', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MdwContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CurrentTab,
    		Dashboard,
    		Reports: Reports_1,
    		Profiles: Profiles_1,
    		Evidence: Evidence_1,
    		Properties: Properties_1,
    		Charges,
    		Staff: Staff_1,
    		Legislation,
    		Businesses: Businesses_1,
    		Roster,
    		Config,
    		$CurrentTab
    	});

    	return [$CurrentTab];
    }

    class MdwContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdwContainer",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Tags.svelte generated by Svelte v3.59.2 */
    const file$g = "src\\apps\\Mdw\\modals\\Modals.Tags.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (20:16) {#if !$MdwModalsTags.IgnoreFilter.includes(Data.id)}
    function create_if_block$c(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[6].tag,
    				Color: "#5F6161",
    				PrefixIcon: /*Data*/ ctx[6].icon
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*FilteredTags*/ 1) mdwchip_changes.Text = /*Data*/ ctx[6].tag;
    			if (dirty & /*FilteredTags*/ 1) mdwchip_changes.PrefixIcon = /*Data*/ ctx[6].icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(20:16) {#if !$MdwModalsTags.IgnoreFilter.includes(Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (19:12) {#each FilteredTags as Data, Key}
    function create_each_block$8(ctx) {
    	let show_if = !/*$MdwModalsTags*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwModalsTags, FilteredTags*/ 3) show_if = !/*$MdwModalsTags*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsTags, FilteredTags*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(19:12) {#each FilteredTags as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (30:12) <Button Color="warning" click={() => {                  MdwModalsTags.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>
    function create_default_slot$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(30:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsTags.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let textfield;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterTags*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredTags*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Add tag";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-saex33");
    			add_location(p, file$g, 15, 8, 584);
    			attr_dev(div0, "class", "mdw-modal-tags-list svelte-saex33");
    			add_location(div0, file$g, 17, 8, 680);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$g, 28, 8, 1181);
    			attr_dev(div2, "class", "mdw-modal-tags-container svelte-saex33");
    			add_location(div2, file$g, 14, 4, 536);
    			attr_dev(div3, "class", "mdw-modal-tags svelte-saex33");
    			add_location(div3, file$g, 13, 0, 502);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*FilteredTags, $MdwModalsTags*/ 3) {
    				each_value = /*FilteredTags*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $MdwTags;
    	let $MdwModalsTags;
    	validate_store(MdwTags, 'MdwTags');
    	component_subscribe($$self, MdwTags, $$value => $$invalidate(5, $MdwTags = $$value));
    	validate_store(MdwModalsTags, 'MdwModalsTags');
    	component_subscribe($$self, MdwModalsTags, $$value => $$invalidate(1, $MdwModalsTags = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Tags', slots, []);
    	let FilteredTags = [...$MdwTags];

    	const FilterTags = Value => {
    		const Search = Value.toLowerCase();
    		$$invalidate(0, FilteredTags = $MdwTags.filter(Val => Val.tag.toLowerCase().includes(Search)));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Tags> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		set_store_value(MdwModalsTags, $MdwModalsTags.IgnoreFilter = [...$MdwModalsTags.IgnoreFilter, Data.id], $MdwModalsTags);
    		$MdwModalsTags.Cb(Data.id);
    	};

    	const func = () => {
    		MdwModalsTags.set({
    			Show: false,
    			IgnoreFilter: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwChip,
    		MdwModalsTags,
    		MdwTags,
    		FilteredTags,
    		FilterTags,
    		$MdwTags,
    		$MdwModalsTags
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredTags' in $$props) $$invalidate(0, FilteredTags = $$props.FilteredTags);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredTags, $MdwModalsTags, FilterTags, click_handler, func];
    }

    class Modals_Tags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Tags",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Certs.svelte generated by Svelte v3.59.2 */
    const file$f = "src\\apps\\Mdw\\modals\\Modals.Certs.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (20:16) {#if !$MdwModalsCerts.IgnoreFilter.includes(Data.id)}
    function create_if_block$b(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[6].certificate,
    				Color: "#5F6161"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*FilteredCerts*/ 1) mdwchip_changes.Text = /*Data*/ ctx[6].certificate;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(20:16) {#if !$MdwModalsCerts.IgnoreFilter.includes(Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (19:12) {#each FilteredCerts as Data, Key}
    function create_each_block$7(ctx) {
    	let show_if = !/*$MdwModalsCerts*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwModalsCerts, FilteredCerts*/ 3) show_if = !/*$MdwModalsCerts*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsCerts, FilteredCerts*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(19:12) {#each FilteredCerts as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (30:12) <Button Color="warning" click={() => {                  MdwModalsCerts.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>
    function create_default_slot$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(30:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsCerts.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let textfield;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterCerts*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredCerts*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Specialisatie Toevoegen";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-rk3ejr");
    			add_location(p, file$f, 15, 8, 601);
    			attr_dev(div0, "class", "mdw-modal-certs-list svelte-rk3ejr");
    			add_location(div0, file$f, 17, 8, 714);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$f, 28, 8, 1209);
    			attr_dev(div2, "class", "mdw-modal-certs-container svelte-rk3ejr");
    			add_location(div2, file$f, 14, 4, 552);
    			attr_dev(div3, "class", "mdw-modal-certs svelte-rk3ejr");
    			add_location(div3, file$f, 13, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*FilteredCerts, $MdwModalsCerts*/ 3) {
    				each_value = /*FilteredCerts*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $MdwCerts;
    	let $MdwModalsCerts;
    	validate_store(MdwCerts, 'MdwCerts');
    	component_subscribe($$self, MdwCerts, $$value => $$invalidate(5, $MdwCerts = $$value));
    	validate_store(MdwModalsCerts, 'MdwModalsCerts');
    	component_subscribe($$self, MdwModalsCerts, $$value => $$invalidate(1, $MdwModalsCerts = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Certs', slots, []);
    	let FilteredCerts = [...$MdwCerts];

    	const FilterCerts = Value => {
    		const Search = Value.toLowerCase();
    		$$invalidate(0, FilteredCerts = $MdwCerts.filter(Val => Val.certificate.toLowerCase().includes(Search)));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Certs> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		set_store_value(MdwModalsCerts, $MdwModalsCerts.IgnoreFilter = [...$MdwModalsCerts.IgnoreFilter, Data.id], $MdwModalsCerts);
    		$MdwModalsCerts.Cb(Data.id);
    	};

    	const func = () => {
    		MdwModalsCerts.set({
    			Show: false,
    			IgnoreFilter: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwChip,
    		MdwModalsCerts,
    		MdwCerts,
    		FilteredCerts,
    		FilterCerts,
    		$MdwCerts,
    		$MdwModalsCerts
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredCerts' in $$props) $$invalidate(0, FilteredCerts = $$props.FilteredCerts);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredCerts, $MdwModalsCerts, FilterCerts, click_handler, func];
    }

    class Modals_Certs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Certs",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Roles.svelte generated by Svelte v3.59.2 */
    const file$e = "src\\apps\\Mdw\\modals\\Modals.Roles.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (20:16) {#if !$MdwModalsRoles.IgnoreFilter.includes(Data.id)}
    function create_if_block$a(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: /*Data*/ ctx[6].name,
    				Color: "#5F6161"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*FilteredRoles*/ 1) mdwchip_changes.Text = /*Data*/ ctx[6].name;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(20:16) {#if !$MdwModalsRoles.IgnoreFilter.includes(Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (19:12) {#each FilteredRoles as Data, Key}
    function create_each_block$6(ctx) {
    	let show_if = !/*$MdwModalsRoles*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwModalsRoles, FilteredRoles*/ 3) show_if = !/*$MdwModalsRoles*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsRoles, FilteredRoles*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(19:12) {#each FilteredRoles as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (30:12) <Button Color="warning" click={() => {                  MdwModalsRoles.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>
    function create_default_slot$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(30:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsRoles.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let textfield;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterRoles*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredRoles*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Rollen Toevoegen";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-rk3ejr");
    			add_location(p, file$e, 15, 8, 594);
    			attr_dev(div0, "class", "mdw-modal-certs-list svelte-rk3ejr");
    			add_location(div0, file$e, 17, 8, 700);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$e, 28, 8, 1188);
    			attr_dev(div2, "class", "mdw-modal-certs-container svelte-rk3ejr");
    			add_location(div2, file$e, 14, 4, 545);
    			attr_dev(div3, "class", "mdw-modal-certs svelte-rk3ejr");
    			add_location(div3, file$e, 13, 0, 510);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*FilteredRoles, $MdwModalsRoles*/ 3) {
    				each_value = /*FilteredRoles*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $MdwRoles;
    	let $MdwModalsRoles;
    	validate_store(MdwRoles, 'MdwRoles');
    	component_subscribe($$self, MdwRoles, $$value => $$invalidate(5, $MdwRoles = $$value));
    	validate_store(MdwModalsRoles, 'MdwModalsRoles');
    	component_subscribe($$self, MdwModalsRoles, $$value => $$invalidate(1, $MdwModalsRoles = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Roles', slots, []);
    	let FilteredRoles = [...$MdwRoles];

    	const FilterRoles = Value => {
    		const Search = Value.toLowerCase();
    		$$invalidate(0, FilteredRoles = $MdwRoles.filter(Val => Val.name.toLowerCase().includes(Search)));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Roles> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		set_store_value(MdwModalsRoles, $MdwModalsRoles.IgnoreFilter = [...$MdwModalsRoles.IgnoreFilter, Data.id], $MdwModalsRoles);
    		$MdwModalsRoles.Cb(Data.id);
    	};

    	const func = () => {
    		MdwModalsRoles.set({
    			Show: false,
    			IgnoreFilter: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwChip,
    		MdwModalsRoles,
    		MdwRoles,
    		FilteredRoles,
    		FilterRoles,
    		$MdwRoles,
    		$MdwModalsRoles
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredRoles' in $$props) $$invalidate(0, FilteredRoles = $$props.FilteredRoles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredRoles, $MdwModalsRoles, FilterRoles, click_handler, func];
    }

    class Modals_Roles extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Roles",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Units.svelte generated by Svelte v3.59.2 */
    const file$d = "src\\apps\\Mdw\\modals\\Modals.Units.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (35:16) {#if !$MdwModalsUnits.IgnoreFilter.includes(Data.id)}
    function create_if_block$9(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: "(" + /*Data*/ ctx[6].callsign + ") " + /*Data*/ ctx[6].name,
    				Color: "#5F6161",
    				PrefixIcon: /*Data*/ ctx[6].icon
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*FilteredUnits*/ 1) mdwchip_changes.Text = "(" + /*Data*/ ctx[6].callsign + ") " + /*Data*/ ctx[6].name;
    			if (dirty & /*FilteredUnits*/ 1) mdwchip_changes.PrefixIcon = /*Data*/ ctx[6].icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(35:16) {#if !$MdwModalsUnits.IgnoreFilter.includes(Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (34:12) {#each FilteredUnits as Data, Key}
    function create_each_block$5(ctx) {
    	let show_if = !/*$MdwModalsUnits*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwModalsUnits, FilteredUnits*/ 3) show_if = !/*$MdwModalsUnits*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsUnits, FilteredUnits*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(34:12) {#each FilteredUnits as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (45:12) <Button Color="warning" click={() => {                  MdwModalsUnits.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>
    function create_default_slot$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(45:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsUnits.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let textfield;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterUnits*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredUnits*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Add unit";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-1s08w2n");
    			add_location(p, file$d, 30, 8, 986);
    			attr_dev(div0, "class", "mdw-modal-units-list svelte-1s08w2n");
    			add_location(div0, file$d, 32, 8, 1084);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$d, 43, 8, 1612);
    			attr_dev(div2, "class", "mdw-modal-units-container svelte-1s08w2n");
    			add_location(div2, file$d, 29, 4, 937);
    			attr_dev(div3, "class", "mdw-modal-units svelte-1s08w2n");
    			add_location(div3, file$d, 28, 0, 902);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*FilteredUnits, $MdwModalsUnits*/ 3) {
    				each_value = /*FilteredUnits*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $MdwModalsUnits;
    	validate_store(MdwModalsUnits, 'MdwModalsUnits');
    	component_subscribe($$self, MdwModalsUnits, $$value => $$invalidate(1, $MdwModalsUnits = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Units', slots, []);
    	let Units = [];
    	let FilteredUnits = [];

    	onMount(() => {
    		SendEvent("Staff/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Units = Data;
    			$$invalidate(0, FilteredUnits = Data);
    		});
    	});

    	const FilterUnits = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredUnits = Units.filter(Val => {
    			return Val.callsign.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search);
    		}));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Units> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		set_store_value(MdwModalsUnits, $MdwModalsUnits.IgnoreFilter = [...$MdwModalsUnits.IgnoreFilter, Data.id], $MdwModalsUnits);
    		$MdwModalsUnits.Cb(Data.id);
    	};

    	const func = () => {
    		MdwModalsUnits.set({
    			Show: false,
    			IgnoreFilter: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwChip,
    		MdwModalsUnits,
    		onMount,
    		SendEvent,
    		Units,
    		FilteredUnits,
    		FilterUnits,
    		$MdwModalsUnits
    	});

    	$$self.$inject_state = $$props => {
    		if ('Units' in $$props) Units = $$props.Units;
    		if ('FilteredUnits' in $$props) $$invalidate(0, FilteredUnits = $$props.FilteredUnits);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredUnits, $MdwModalsUnits, FilterUnits, click_handler, func];
    }

    class Modals_Units extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Units",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Persons.svelte generated by Svelte v3.59.2 */
    const file$c = "src\\apps\\Mdw\\modals\\Modals.Persons.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (35:16) {#if !$MdwModalsPerson.IgnoreFilter.includes(Data.id)}
    function create_if_block$8(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: "" + (/*Data*/ ctx[6].name + " (#" + /*Data*/ ctx[6].citizenid + ")"),
    				Color: "#5F6161",
    				PrefixIcon: /*Data*/ ctx[6].icon
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};
    			if (dirty & /*FilteredPersons*/ 1) mdwchip_changes.Text = "" + (/*Data*/ ctx[6].name + " (#" + /*Data*/ ctx[6].citizenid + ")");
    			if (dirty & /*FilteredPersons*/ 1) mdwchip_changes.PrefixIcon = /*Data*/ ctx[6].icon;
    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(35:16) {#if !$MdwModalsPerson.IgnoreFilter.includes(Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (34:12) {#each FilteredPersons as Data, Key}
    function create_each_block$4(ctx) {
    	let show_if = !/*$MdwModalsPerson*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MdwModalsPerson, FilteredPersons*/ 3) show_if = !/*$MdwModalsPerson*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].id);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsPerson, FilteredPersons*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(34:12) {#each FilteredPersons as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (45:12) <Button Color="warning" click={() => {                  MdwModalsPerson.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>
    function create_default_slot$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(45:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsPerson.set({                      Show: false,                      IgnoreFilter: [],                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let textfield;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterPersons*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredPersons*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Add Person";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-1kqqpco");
    			add_location(p, file$c, 30, 8, 1009);
    			attr_dev(div0, "class", "mdw-modal-persons-list svelte-1kqqpco");
    			add_location(div0, file$c, 32, 8, 1111);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$c, 43, 8, 1649);
    			attr_dev(div2, "class", "mdw-modal-persons-container svelte-1kqqpco");
    			add_location(div2, file$c, 29, 4, 958);
    			attr_dev(div3, "class", "mdw-modal-persons svelte-1kqqpco");
    			add_location(div3, file$c, 28, 0, 921);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*FilteredPersons, $MdwModalsPerson*/ 3) {
    				each_value = /*FilteredPersons*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $MdwModalsPerson;
    	validate_store(MdwModalsPerson, 'MdwModalsPerson');
    	component_subscribe($$self, MdwModalsPerson, $$value => $$invalidate(1, $MdwModalsPerson = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Persons', slots, []);
    	let Persons = [];
    	let FilteredPersons = [];

    	onMount(() => {
    		SendEvent("Profiles/FetchAll", {}, (Success, Data) => {
    			if (!Success) return;
    			Persons = Data;
    			$$invalidate(0, FilteredPersons = Data);
    		});
    	});

    	const FilterPersons = Value => {
    		const Search = Value.toLowerCase();

    		$$invalidate(0, FilteredPersons = Persons.filter(Val => {
    			return Val.citizenid.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search);
    		}));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Persons> was created with unknown prop '${key}'`);
    	});

    	const click_handler = Data => {
    		set_store_value(MdwModalsPerson, $MdwModalsPerson.IgnoreFilter = [...$MdwModalsPerson.IgnoreFilter, Data.id], $MdwModalsPerson);
    		$MdwModalsPerson.Cb(Data.id);
    	};

    	const func = () => {
    		MdwModalsPerson.set({
    			Show: false,
    			IgnoreFilter: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwChip,
    		MdwModalsPerson,
    		onMount,
    		SendEvent,
    		Persons,
    		FilteredPersons,
    		FilterPersons,
    		$MdwModalsPerson
    	});

    	$$self.$inject_state = $$props => {
    		if ('Persons' in $$props) Persons = $$props.Persons;
    		if ('FilteredPersons' in $$props) $$invalidate(0, FilteredPersons = $$props.FilteredPersons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredPersons, $MdwModalsPerson, FilterPersons, click_handler, func];
    }

    class Modals_Persons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Persons",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Evidence.svelte generated by Svelte v3.59.2 */
    const file$b = "src\\apps\\Mdw\\modals\\Modals.Evidence.svelte";

    // (14:12) <Button Color="success" click={() => {                  if (Number(EvidenceId) > 0) {                      $MdwModalsEvidence.Cb(false, {Id: Number(EvidenceId)})                      MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });                  }              }}>
    function create_default_slot_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Add");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(14:12) <Button Color=\\\"success\\\" click={() => {                  if (Number(EvidenceId) > 0) {                      $MdwModalsEvidence.Cb(false, {Id: Number(EvidenceId)})                      MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });                  }              }}>",
    		ctx
    	});

    	return block;
    }

    // (28:12) <Button Color="success" click={() => {                  if ($MdwModalsEvidence.Form.Type && $MdwModalsEvidence.Form.Identifier && $MdwModalsEvidence.Form.Description) {                      if ($MdwModalsEvidence.Form.Identifier.includes(".discordapp.")) {                          MdwModalsExport.set({                              Show: true,                              Msg: `cdn.discordapp.com cannot be used as an identifier.`,                          });                            return;                      }                        $MdwModalsEvidence.Cb(true, $MdwModalsEvidence.Form)                      MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });                  }              }}>
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(28:12) <Button Color=\\\"success\\\" click={() => {                  if ($MdwModalsEvidence.Form.Type && $MdwModalsEvidence.Form.Identifier && $MdwModalsEvidence.Form.Description) {                      if ($MdwModalsEvidence.Form.Identifier.includes(\\\".discordapp.\\\")) {                          MdwModalsExport.set({                              Show: true,                              Msg: `cdn.discordapp.com cannot be used as an identifier.`,                          });                            return;                      }                        $MdwModalsEvidence.Cb(true, $MdwModalsEvidence.Form)                      MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });                  }              }}>",
    		ctx
    	});

    	return block;
    }

    // (46:12) <Button Color="warning" click={() => {                  MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });              }}>
    function create_default_slot$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(46:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsEvidence.set({ Show: false, Form: $MdwModalsEvidence.Form, Cb: () => {} });              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div4;
    	let div3;
    	let p0;
    	let t1;
    	let textfield0;
    	let updating_RealValue;
    	let t2;
    	let div0;
    	let button0;
    	let t3;
    	let p1;
    	let t5;
    	let textfield1;
    	let updating_RealValue_1;
    	let t6;
    	let textfield2;
    	let updating_RealValue_2;
    	let t7;
    	let textfield3;
    	let updating_RealValue_3;
    	let t8;
    	let textfield4;
    	let updating_RealValue_4;
    	let t9;
    	let div1;
    	let button1;
    	let t10;
    	let div2;
    	let button2;
    	let current;

    	function textfield0_RealValue_binding(value) {
    		/*textfield0_RealValue_binding*/ ctx[3](value);
    	}

    	let textfield0_props = {
    		style: "margin-bottom: .5vh;",
    		Title: "Evidence ID",
    		Icon: "fingerprint",
    		Type: "number"
    	};

    	if (/*EvidenceId*/ ctx[0] !== void 0) {
    		textfield0_props.RealValue = /*EvidenceId*/ ctx[0];
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'RealValue', textfield0_RealValue_binding));

    	button0 = new Button({
    			props: {
    				Color: "success",
    				click: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield1_RealValue_binding(value) {
    		/*textfield1_RealValue_binding*/ ctx[5](value);
    	}

    	let textfield1_props = {
    		style: "margin-bottom: .5vh;",
    		Title: "Type",
    		Select: /*$MdwEvidence*/ ctx[2]
    	};

    	if (/*$MdwModalsEvidence*/ ctx[1].Form.Type !== void 0) {
    		textfield1_props.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Type;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'RealValue', textfield1_RealValue_binding));

    	function textfield2_RealValue_binding(value) {
    		/*textfield2_RealValue_binding*/ ctx[6](value);
    	}

    	let textfield2_props = {
    		style: "margin-bottom: .5vh;",
    		Title: "Identifier",
    		Icon: "pencil-alt"
    	};

    	if (/*$MdwModalsEvidence*/ ctx[1].Form.Identifier !== void 0) {
    		textfield2_props.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Identifier;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'RealValue', textfield2_RealValue_binding));

    	function textfield3_RealValue_binding(value) {
    		/*textfield3_RealValue_binding*/ ctx[7](value);
    	}

    	let textfield3_props = {
    		style: "margin-bottom: .5vh;",
    		Title: "Description",
    		Icon: "clipboard"
    	};

    	if (/*$MdwModalsEvidence*/ ctx[1].Form.Description !== void 0) {
    		textfield3_props.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Description;
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'RealValue', textfield3_RealValue_binding));

    	function textfield4_RealValue_binding(value) {
    		/*textfield4_RealValue_binding*/ ctx[8](value);
    	}

    	let textfield4_props = {
    		style: "margin-bottom: .5vh;",
    		Title: "SSN",
    		Icon: "user"
    	};

    	if (/*$MdwModalsEvidence*/ ctx[1].Form.Cid !== void 0) {
    		textfield4_props.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Cid;
    	}

    	textfield4 = new TextField({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'RealValue', textfield4_RealValue_binding));

    	button1 = new Button({
    			props: {
    				Color: "success",
    				click: /*func_1*/ ctx[9],
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				Color: "warning",
    				click: /*func_2*/ ctx[10],
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			p0 = element("p");
    			p0.textContent = "Add Evidence";
    			t1 = space();
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Create New Evidence";
    			t5 = space();
    			create_component(textfield1.$$.fragment);
    			t6 = space();
    			create_component(textfield2.$$.fragment);
    			t7 = space();
    			create_component(textfield3.$$.fragment);
    			t8 = space();
    			create_component(textfield4.$$.fragment);
    			t9 = space();
    			div1 = element("div");
    			create_component(button1.$$.fragment);
    			t10 = space();
    			div2 = element("div");
    			create_component(button2.$$.fragment);
    			attr_dev(p0, "class", "svelte-hnng53");
    			add_location(p0, file$b, 10, 8, 372);
    			set_style(div0, "width", "100%");
    			set_style(div0, "display", "flex");
    			set_style(div0, "justify-content", "end");
    			add_location(div0, file$b, 12, 8, 534);
    			attr_dev(p1, "class", "svelte-hnng53");
    			add_location(p1, file$b, 21, 8, 954);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "end");
    			add_location(div1, file$b, 26, 8, 1527);
    			set_style(div2, "width", "100%");
    			set_style(div2, "display", "flex");
    			set_style(div2, "justify-content", "center");
    			set_style(div2, "margin-top", "2.4vh");
    			add_location(div2, file$b, 44, 8, 2383);
    			attr_dev(div3, "class", "mdw-modal-evidence-container svelte-hnng53");
    			add_location(div3, file$b, 9, 4, 320);
    			attr_dev(div4, "class", "mdw-modal-evidence svelte-hnng53");
    			add_location(div4, file$b, 8, 0, 282);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, p0);
    			append_dev(div3, t1);
    			mount_component(textfield0, div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, div0);
    			mount_component(button0, div0, null);
    			append_dev(div3, t3);
    			append_dev(div3, p1);
    			append_dev(div3, t5);
    			mount_component(textfield1, div3, null);
    			append_dev(div3, t6);
    			mount_component(textfield2, div3, null);
    			append_dev(div3, t7);
    			mount_component(textfield3, div3, null);
    			append_dev(div3, t8);
    			mount_component(textfield4, div3, null);
    			append_dev(div3, t9);
    			append_dev(div3, div1);
    			mount_component(button1, div1, null);
    			append_dev(div3, t10);
    			append_dev(div3, div2);
    			mount_component(button2, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const textfield0_changes = {};

    			if (!updating_RealValue && dirty & /*EvidenceId*/ 1) {
    				updating_RealValue = true;
    				textfield0_changes.RealValue = /*EvidenceId*/ ctx[0];
    				add_flush_callback(() => updating_RealValue = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const button0_changes = {};
    			if (dirty & /*EvidenceId, $MdwModalsEvidence*/ 3) button0_changes.click = /*func*/ ctx[4];

    			if (dirty & /*$$scope*/ 2048) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*$MdwEvidence*/ 4) textfield1_changes.Select = /*$MdwEvidence*/ ctx[2];

    			if (!updating_RealValue_1 && dirty & /*$MdwModalsEvidence*/ 2) {
    				updating_RealValue_1 = true;
    				textfield1_changes.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Type;
    				add_flush_callback(() => updating_RealValue_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_RealValue_2 && dirty & /*$MdwModalsEvidence*/ 2) {
    				updating_RealValue_2 = true;
    				textfield2_changes.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Identifier;
    				add_flush_callback(() => updating_RealValue_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_RealValue_3 && dirty & /*$MdwModalsEvidence*/ 2) {
    				updating_RealValue_3 = true;
    				textfield3_changes.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Description;
    				add_flush_callback(() => updating_RealValue_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_RealValue_4 && dirty & /*$MdwModalsEvidence*/ 2) {
    				updating_RealValue_4 = true;
    				textfield4_changes.RealValue = /*$MdwModalsEvidence*/ ctx[1].Form.Cid;
    				add_flush_callback(() => updating_RealValue_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const button1_changes = {};
    			if (dirty & /*$MdwModalsEvidence*/ 2) button1_changes.click = /*func_1*/ ctx[9];

    			if (dirty & /*$$scope*/ 2048) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};
    			if (dirty & /*$MdwModalsEvidence*/ 2) button2_changes.click = /*func_2*/ ctx[10];

    			if (dirty & /*$$scope*/ 2048) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(textfield0);
    			destroy_component(button0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(button1);
    			destroy_component(button2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $MdwModalsEvidence;
    	let $MdwEvidence;
    	validate_store(MdwModalsEvidence, 'MdwModalsEvidence');
    	component_subscribe($$self, MdwModalsEvidence, $$value => $$invalidate(1, $MdwModalsEvidence = $$value));
    	validate_store(MdwEvidence, 'MdwEvidence');
    	component_subscribe($$self, MdwEvidence, $$value => $$invalidate(2, $MdwEvidence = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Evidence', slots, []);
    	let EvidenceId = '';
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Evidence> was created with unknown prop '${key}'`);
    	});

    	function textfield0_RealValue_binding(value) {
    		EvidenceId = value;
    		$$invalidate(0, EvidenceId);
    	}

    	const func = () => {
    		if (Number(EvidenceId) > 0) {
    			$MdwModalsEvidence.Cb(false, { Id: Number(EvidenceId) });

    			MdwModalsEvidence.set({
    				Show: false,
    				Form: $MdwModalsEvidence.Form,
    				Cb: () => {
    					
    				}
    			});
    		}
    	};

    	function textfield1_RealValue_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsEvidence.Form.Type, value)) {
    			$MdwModalsEvidence.Form.Type = value;
    			MdwModalsEvidence.set($MdwModalsEvidence);
    		}
    	}

    	function textfield2_RealValue_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsEvidence.Form.Identifier, value)) {
    			$MdwModalsEvidence.Form.Identifier = value;
    			MdwModalsEvidence.set($MdwModalsEvidence);
    		}
    	}

    	function textfield3_RealValue_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsEvidence.Form.Description, value)) {
    			$MdwModalsEvidence.Form.Description = value;
    			MdwModalsEvidence.set($MdwModalsEvidence);
    		}
    	}

    	function textfield4_RealValue_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsEvidence.Form.Cid, value)) {
    			$MdwModalsEvidence.Form.Cid = value;
    			MdwModalsEvidence.set($MdwModalsEvidence);
    		}
    	}

    	const func_1 = () => {
    		if ($MdwModalsEvidence.Form.Type && $MdwModalsEvidence.Form.Identifier && $MdwModalsEvidence.Form.Description) {
    			if ($MdwModalsEvidence.Form.Identifier.includes(".discordapp.")) {
    				MdwModalsExport$1.set({
    					Show: true,
    					Msg: `cdn.discordapp.com cannot be used as an identifier.`
    				});

    				return;
    			}

    			$MdwModalsEvidence.Cb(true, $MdwModalsEvidence.Form);

    			MdwModalsEvidence.set({
    				Show: false,
    				Form: $MdwModalsEvidence.Form,
    				Cb: () => {
    					
    				}
    			});
    		}
    	};

    	const func_2 = () => {
    		MdwModalsEvidence.set({
    			Show: false,
    			Form: $MdwModalsEvidence.Form,
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwModalsEvidence,
    		MdwEvidence,
    		MdwModalsExport: MdwModalsExport$1,
    		EvidenceId,
    		$MdwModalsEvidence,
    		$MdwEvidence
    	});

    	$$self.$inject_state = $$props => {
    		if ('EvidenceId' in $$props) $$invalidate(0, EvidenceId = $$props.EvidenceId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		EvidenceId,
    		$MdwModalsEvidence,
    		$MdwEvidence,
    		textfield0_RealValue_binding,
    		func,
    		textfield1_RealValue_binding,
    		textfield2_RealValue_binding,
    		textfield3_RealValue_binding,
    		textfield4_RealValue_binding,
    		func_1,
    		func_2
    	];
    }

    class Modals_Evidence extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Evidence",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Profile.svelte generated by Svelte v3.59.2 */
    const file$a = "src\\apps\\Mdw\\modals\\Modals.Profile.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (28:16) {#if !$MdwModalsProfiles.IgnoreFilter.includes(Data.citizenid)}
    function create_if_block$7(ctx) {
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let textfield0;
    	let t1;
    	let textfield1;
    	let t2;
    	let button;
    	let t3;
    	let current;

    	textfield0 = new TextField({
    			props: {
    				Icon: "id-card",
    				Title: "BSN",
    				RealValue: /*Data*/ ctx[6].citizenid
    			},
    			$$inline: true
    		});

    	textfield1 = new TextField({
    			props: {
    				Icon: "user",
    				Title: "Naam",
    				RealValue: /*Data*/ ctx[6].name
    			},
    			$$inline: true
    		});

    	function func() {
    		return /*func*/ ctx[3](/*Data*/ ctx[6]);
    	}

    	button = new Button({
    			props: {
    				Color: "success",
    				click: func,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(button.$$.fragment);
    			t3 = space();
    			if (!src_url_equal(img.src, img_src_value = /*Data*/ ctx[6].image || "./images/mugshot.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			set_style(img, "width", "19vh");
    			set_style(img, "height", "19vh");
    			set_style(img, "border", "0.15vh solid black");
    			add_location(img, file$a, 30, 28, 1233);
    			set_style(div0, "height", "19.3vh");
    			set_style(div0, "width", "19.3vh");
    			add_location(div0, file$a, 29, 24, 1159);
    			set_style(div1, "margin-left", "0.7vh");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$a, 33, 24, 1439);
    			attr_dev(div2, "class", "mdw-profile-modal-item svelte-1l7fub9");
    			add_location(div2, file$a, 28, 20, 1097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t1);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t2);
    			mount_component(button, div1, null);
    			append_dev(div2, t3);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*FilteredProfiles*/ 1 && !src_url_equal(img.src, img_src_value = /*Data*/ ctx[6].image || "./images/mugshot.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			const textfield0_changes = {};
    			if (dirty & /*FilteredProfiles*/ 1) textfield0_changes.RealValue = /*Data*/ ctx[6].citizenid;
    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*FilteredProfiles*/ 1) textfield1_changes.RealValue = /*Data*/ ctx[6].name;
    			textfield1.$set(textfield1_changes);
    			const button_changes = {};
    			if (dirty & /*$MdwModalsProfiles, FilteredProfiles*/ 3) button_changes.click = func;

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(28:16) {#if !$MdwModalsProfiles.IgnoreFilter.includes(Data.citizenid)}",
    		ctx
    	});

    	return block;
    }

    // (37:28) <Button Color="success" click={() => {                                  $MdwModalsProfiles.Cb(Data);                                  $MdwModalsProfiles.IgnoreFilter = [...$MdwModalsProfiles.IgnoreFilter, Data.citizenid]                              }}>
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Toevoegen");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(37:28) <Button Color=\\\"success\\\" click={() => {                                  $MdwModalsProfiles.Cb(Data);                                  $MdwModalsProfiles.IgnoreFilter = [...$MdwModalsProfiles.IgnoreFilter, Data.citizenid]                              }}>",
    		ctx
    	});

    	return block;
    }

    // (27:12) {#each FilteredProfiles as Data (Data.id)}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let show_if = !/*$MdwModalsProfiles*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].citizenid);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$7(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$MdwModalsProfiles, FilteredProfiles*/ 3) show_if = !/*$MdwModalsProfiles*/ ctx[1].IgnoreFilter.includes(/*Data*/ ctx[6].citizenid);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsProfiles, FilteredProfiles*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(27:12) {#each FilteredProfiles as Data (Data.id)}",
    		ctx
    	});

    	return block;
    }

    // (48:12) <Button Color="warning" click={() => { $MdwModalsProfiles.Show = false }}>
    function create_default_slot$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(48:12) <Button Color=\\\"warning\\\" click={() => { $MdwModalsProfiles.Show = false }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div3;
    	let div2;
    	let textfield;
    	let t0;
    	let div0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let div1;
    	let button;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "user",
    				SubSet: /*FilterProfiles*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let each_value = /*FilteredProfiles*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*Data*/ ctx[6].id;
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func_1*/ ctx[4],
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			create_component(textfield.$$.fragment);
    			t0 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "mdw-profile-modal-result svelte-1l7fub9");
    			add_location(div0, file$a, 25, 8, 900);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "1vh");
    			add_location(div1, file$a, 46, 8, 2105);
    			attr_dev(div2, "class", "mdw-modal-profiles-container svelte-1l7fub9");
    			add_location(div2, file$a, 22, 4, 772);
    			attr_dev(div3, "class", "mdw-modal-profiles svelte-1l7fub9");
    			add_location(div3, file$a, 21, 0, 734);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			mount_component(textfield, div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$MdwModalsProfiles, FilteredProfiles*/ 3) {
    				each_value = /*FilteredProfiles*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
    				check_outros();
    			}

    			const button_changes = {};
    			if (dirty & /*$MdwModalsProfiles*/ 2) button_changes.click = /*func_1*/ ctx[4];

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(textfield);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $MdwModalsProfiles;
    	validate_store(MdwModalsProfiles, 'MdwModalsProfiles');
    	component_subscribe($$self, MdwModalsProfiles, $$value => $$invalidate(1, $MdwModalsProfiles = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Profile', slots, []);
    	let Profiles = [];
    	let FilteredProfiles = [];

    	SendEvent("Profiles/FetchAll", {}, (Success, Data) => {
    		if (!Success) return;
    		Profiles = Data;
    		$$invalidate(0, FilteredProfiles = Data);
    	});

    	const FilterProfiles = Value => {
    		const Search = Value.toLowerCase();
    		$$invalidate(0, FilteredProfiles = Profiles.filter(Val => Val.citizenid.toLowerCase().includes(Search) || Val.name.toLowerCase().includes(Search)));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Profile> was created with unknown prop '${key}'`);
    	});

    	const func = Data => {
    		$MdwModalsProfiles.Cb(Data);
    		set_store_value(MdwModalsProfiles, $MdwModalsProfiles.IgnoreFilter = [...$MdwModalsProfiles.IgnoreFilter, Data.citizenid], $MdwModalsProfiles);
    	};

    	const func_1 = () => {
    		set_store_value(MdwModalsProfiles, $MdwModalsProfiles.Show = false, $MdwModalsProfiles);
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		Button,
    		MdwModalsProfiles,
    		SendEvent,
    		Profiles,
    		FilteredProfiles,
    		FilterProfiles,
    		$MdwModalsProfiles
    	});

    	$$self.$inject_state = $$props => {
    		if ('Profiles' in $$props) Profiles = $$props.Profiles;
    		if ('FilteredProfiles' in $$props) $$invalidate(0, FilteredProfiles = $$props.FilteredProfiles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [FilteredProfiles, $MdwModalsProfiles, FilterProfiles, func, func_1];
    }

    class Modals_Profile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Profile",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Charges.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1$1 } = globals;
    const file$9 = "src\\apps\\Mdw\\modals\\Modals.Charges.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i][0];
    	child_ctx[12] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (102:16) <Button click={() => { $MdwModalsCharges.Show = false }} Color="warning">
    function create_default_slot_6$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(102:16) <Button click={() => { $MdwModalsCharges.Show = false }} Color=\\\"warning\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:16) <Button click={() => {                      $MdwModalsCharges.Cb($MdwModalsCharges.Charges)                      MdwModalsCharges.set({                          Show: false,                          Charges: [],                          Cb: () => {},                      })                  }} Color="success">
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(103:16) <Button click={() => {                      $MdwModalsCharges.Cb($MdwModalsCharges.Charges)                      MdwModalsCharges.set({                          Show: false,                          Charges: [],                          Cb: () => {},                      })                  }} Color=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:12) {#each $MdwModalsCharges.Charges as Data, Key}
    function create_each_block_2(ctx) {
    	let mdwchip;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*Key*/ ctx[17]);
    	}

    	mdwchip = new MdwChip({
    			props: {
    				Text: (/*Data*/ ctx[15].Type != "Principal"
    				? /*Data*/ ctx[15].Type == "Accomplice"
    					? "(Accomplice) "
    					: "(Attempted) "
    				: "") + GetChargeById(/*Data*/ ctx[15].Id).name,
    				Color: "#000000",
    				SuffixIcon: "times-circle"
    			},
    			$$inline: true
    		});

    	mdwchip.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(mdwchip.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchip, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdwchip_changes = {};

    			if (dirty & /*$MdwModalsCharges*/ 2) mdwchip_changes.Text = (/*Data*/ ctx[15].Type != "Principal"
    			? /*Data*/ ctx[15].Type == "Accomplice"
    				? "(Accomplice) "
    				: "(Attempted) "
    			: "") + GetChargeById(/*Data*/ ctx[15].Id).name;

    			mdwchip.$set(mdwchip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchip, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(115:12) {#each $MdwModalsCharges.Charges as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (128:16) <MdwPanelHeader style="width: 98.6%;">
    function create_default_slot_4$1(ctx) {
    	let h6;
    	let t1;
    	let textfield;
    	let current;

    	textfield = new TextField({
    			props: {
    				Title: "Search",
    				Icon: "search",
    				SubSet: /*FilterCharges*/ ctx[2],
    				style: "width: 20%;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Charges";
    			t1 = space();
    			create_component(textfield.$$.fragment);
    			add_location(h6, file$9, 128, 20, 5178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(128:16) <MdwPanelHeader style=\\\"width: 98.6%;\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:12) <MdwPanel class="filled" style="width: 100%; margin: 0.5vh auto 0px; height: 6vh;">
    function create_default_slot_3$1(ctx) {
    	let mdwpanelheader;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "width: 98.6%;",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(127:12) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; margin: 0.5vh auto 0px; height: 6vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:20) <MdwPanelHeader style="width: 98.6%;">
    function create_default_slot_2$1(ctx) {
    	let h6;
    	let t_value = /*Category*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t = text(t_value);
    			add_location(h6, file$9, 136, 24, 5634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*FilteredCharges*/ 1 && t_value !== (t_value = /*Category*/ ctx[11] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(136:20) <MdwPanelHeader style=\\\"width: 98.6%;\\\">",
    		ctx
    	});

    	return block;
    }

    // (141:24) {#each Charges as Data, Key}
    function create_each_block_1$1(ctx) {
    	let mdwchargecard;
    	let current;
    	const mdwchargecard_spread_levels = [/*Data*/ ctx[15]];

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*Data*/ ctx[15], ...args);
    	}

    	let mdwchargecard_props = {};

    	for (let i = 0; i < mdwchargecard_spread_levels.length; i += 1) {
    		mdwchargecard_props = assign(mdwchargecard_props, mdwchargecard_spread_levels[i]);
    	}

    	mdwchargecard = new MdwChargeCard({
    			props: mdwchargecard_props,
    			$$inline: true
    		});

    	mdwchargecard.$on("click", click_handler_1);

    	const block = {
    		c: function create() {
    			create_component(mdwchargecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwchargecard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			const mdwchargecard_changes = (dirty & /*Object, FilteredCharges*/ 1)
    			? get_spread_update(mdwchargecard_spread_levels, [get_spread_object(/*Data*/ ctx[15])])
    			: {};

    			mdwchargecard.$set(mdwchargecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwchargecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwchargecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwchargecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(141:24) {#each Charges as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (135:16) <MdwPanel class="filled" style="width: 100%; margin: 0.5vh auto 0px; height: max-content;">
    function create_default_slot_1$3(ctx) {
    	let mdwpanelheader;
    	let t0;
    	let div;
    	let t1;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				style: "width: 98.6%;",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*Charges*/ ctx[12];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t0 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			attr_dev(div, "class", "mdw-charges");
    			set_style(div, "width", "98.6%");
    			set_style(div, "margin", "0 auto");
    			add_location(div, file$9, 139, 20, 5716);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 524289) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);

    			if (dirty & /*Object, FilteredCharges, AddCharge*/ 9) {
    				each_value_1 = /*Charges*/ ctx[12];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(135:16) <MdwPanel class=\\\"filled\\\" style=\\\"width: 100%; margin: 0.5vh auto 0px; height: max-content;\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:12) {#each Object.entries(FilteredCharges) as [Category, Charges]}
    function create_each_block$2(ctx) {
    	let mdwpanel;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; margin: 0.5vh auto 0px; height: max-content;",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 524289) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(134:12) {#each Object.entries(FilteredCharges) as [Category, Charges]}",
    		ctx
    	});

    	return block;
    }

    // (126:8) <MdwPanel style="width: 100%; margin-right: 0">
    function create_default_slot$6(ctx) {
    	let mdwpanel;
    	let t;
    	let each_1_anchor;
    	let current;

    	mdwpanel = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 100%; margin: 0.5vh auto 0px; height: 6vh;",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = Object.entries(/*FilteredCharges*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(mdwpanel.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanel, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);

    			if (dirty & /*Object, FilteredCharges, AddCharge*/ 9) {
    				each_value = Object.entries(/*FilteredCharges*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanel, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(126:8) <MdwPanel style=\\\"width: 100%; margin-right: 0\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div4;
    	let div3;
    	let div1;
    	let p;
    	let t1;
    	let div0;
    	let button0;
    	let t2;
    	let button1;
    	let t3;
    	let div2;
    	let t4;
    	let hr;
    	let t5;
    	let mdwpanel;
    	let current;

    	button0 = new Button({
    			props: {
    				click: /*func*/ ctx[4],
    				Color: "warning",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				click: /*func_1*/ ctx[5],
    				Color: "success",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_2 = /*$MdwModalsCharges*/ ctx[1].Charges;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	mdwpanel = new MdwPanel({
    			props: {
    				style: "width: 100%; margin-right: 0",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			p = element("p");
    			p.textContent = "Current Charges";
    			t1 = space();
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t2 = space();
    			create_component(button1.$$.fragment);
    			t3 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			create_component(mdwpanel.$$.fragment);
    			attr_dev(p, "class", "svelte-1sh4mi2");
    			add_location(p, file$9, 99, 12, 3643);
    			add_location(div0, file$9, 100, 12, 3679);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-between");
    			add_location(div1, file$9, 98, 8, 3569);
    			set_style(div2, "margin-top", "0.5vh");
    			set_style(div2, "display", "flex");
    			set_style(div2, "flex-wrap", "wrap");
    			set_style(div2, "box-sizing", "border-box");
    			add_location(div2, file$9, 113, 8, 4179);
    			set_style(hr, "border-top", "none");
    			set_style(hr, "border-right", "none");
    			set_style(hr, "border-bottom", "0.1vh solid white");
    			set_style(hr, "border-left", "none");
    			set_style(hr, "border-image", "initial");
    			set_style(hr, "margin", "1.5vh 0px");
    			add_location(hr, file$9, 123, 8, 4798);
    			attr_dev(div3, "class", "mdw-modal-charges-container svelte-1sh4mi2");
    			add_location(div3, file$9, 97, 4, 3518);
    			attr_dev(div4, "class", "mdw-modal-charges svelte-1sh4mi2");
    			add_location(div4, file$9, 96, 0, 3481);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, p);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			mount_component(button0, div0, null);
    			append_dev(div0, t2);
    			mount_component(button1, div0, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			append_dev(div3, t4);
    			append_dev(div3, hr);
    			append_dev(div3, t5);
    			mount_component(mdwpanel, div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button0_changes = {};
    			if (dirty & /*$MdwModalsCharges*/ 2) button0_changes.click = /*func*/ ctx[4];

    			if (dirty & /*$$scope*/ 524288) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*$MdwModalsCharges*/ 2) button1_changes.click = /*func_1*/ ctx[5];

    			if (dirty & /*$$scope*/ 524288) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty & /*$MdwModalsCharges, GetChargeById*/ 2) {
    				each_value_2 = /*$MdwModalsCharges*/ ctx[1].Charges;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const mdwpanel_changes = {};

    			if (dirty & /*$$scope, FilteredCharges*/ 524289) {
    				mdwpanel_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel.$set(mdwpanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(mdwpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(mdwpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(mdwpanel);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $MdwModalsCharges;
    	let $IsEms;
    	let $MdwCharges;
    	validate_store(MdwModalsCharges, 'MdwModalsCharges');
    	component_subscribe($$self, MdwModalsCharges, $$value => $$invalidate(1, $MdwModalsCharges = $$value));
    	validate_store(IsEms, 'IsEms');
    	component_subscribe($$self, IsEms, $$value => $$invalidate(8, $IsEms = $$value));
    	validate_store(MdwCharges, 'MdwCharges');
    	component_subscribe($$self, MdwCharges, $$value => $$invalidate(9, $MdwCharges = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Charges', slots, []);
    	let FilteredCharges = {};

    	onMount(() => {
    		FilterCharges("");
    	});

    	const FilterCharges = Value => {
    		const Search = Value.toLowerCase();

    		const FilteredResult = $MdwCharges.filter(Val => {
    			return (Val.name.toLowerCase().includes(Search) || Val.category.toLowerCase().includes(Search)) & Val.deleted == 0;
    		});

    		let NewCharges = {};

    		for (let i = 0; i < FilteredResult.length; i++) {
    			const Charge = FilteredResult[i];

    			if (NewCharges[Charge.category] == undefined) {
    				NewCharges[Charge.category] = [];
    			}
    			NewCharges[Charge.category].push(Charge);
    		}
    		$$invalidate(0, FilteredCharges = NewCharges);
    	};

    	const IsChargeValid = Data => {
    		if (!Data || Data == "" || (!Data.jail || Data.jail == "" || Data.jail == "0" || Data.jail <= 0) && (!Data.fine || Data.fine == "" || Data.fine == "0" || Data.fine <= 0) && (!Data.points || Data.points == "" || Data.points == "0" || Data.points <= 0)) return false;
    		return true;
    	};

    	const AddCharge = (Element, ChargeData) => {
    		var Container = jquery(Element.target).closest(".mdw-charge-container");
    		var DropdownLeft = Element.pageX;

    		if (DropdownLeft + jquery('body').height() * 25 / 100 > jquery('body').width()) {
    			DropdownLeft = jquery('body').width() - jquery('body').height() * 25 / 100;
    		}

    		let Options = [
    			{
    				Text: `${$IsEms ? "Factuur" : "Straf"} Toevoegen`,
    				Cb: () => {
    					set_store_value(MdwModalsCharges, $MdwModalsCharges.Charges = [...$MdwModalsCharges.Charges, { Id: ChargeData.id, Type: "Principal" }], $MdwModalsCharges);
    				}
    			}
    		];

    		const accomplice = ChargeData.accomplice;
    		const attempted = ChargeData.attempted;

    		if (IsChargeValid(accomplice)) {
    			Options.push({
    				Text: `${$IsEms ? "Factuur" : "Straf"} Toevoegen (Medeplichtigheid)`,
    				Cb: () => {
    					set_store_value(
    						MdwModalsCharges,
    						$MdwModalsCharges.Charges = [
    							...$MdwModalsCharges.Charges,
    							{ Id: ChargeData.id, Type: "Accomplice" }
    						],
    						$MdwModalsCharges
    					);
    				}
    			});
    		}

    		if (IsChargeValid(attempted)) {
    			Options.push({
    				Text: `${$IsEms ? "Factuur" : "Straf"} Toevoegen (Poging Tot)`,
    				Cb: () => {
    					set_store_value(MdwModalsCharges, $MdwModalsCharges.Charges = [...$MdwModalsCharges.Charges, { Id: ChargeData.id, Type: "Attempted" }], $MdwModalsCharges);
    				}
    			});
    		}

    		SetDropdown(true, Options, {
    			Top: jquery(Container).offset().top + jquery(Container).height() + 5,
    			Left: DropdownLeft
    		});
    	};

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Charges> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		set_store_value(MdwModalsCharges, $MdwModalsCharges.Show = false, $MdwModalsCharges);
    	};

    	const func_1 = () => {
    		$MdwModalsCharges.Cb($MdwModalsCharges.Charges);

    		MdwModalsCharges.set({
    			Show: false,
    			Charges: [],
    			Cb: () => {
    				
    			}
    		});
    	};

    	const click_handler = Key => {
    		let NewCharges = [...$MdwModalsCharges.Charges];
    		NewCharges.splice(Key, 1);
    		set_store_value(MdwModalsCharges, $MdwModalsCharges.Charges = NewCharges, $MdwModalsCharges);
    	};

    	const click_handler_1 = (Data, e) => {
    		AddCharge(e, Data);
    	};

    	$$self.$capture_state = () => ({
    		_$: jquery,
    		TextField,
    		Button,
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwChip,
    		MdwChargeCard,
    		IsEms,
    		MdwCharges,
    		MdwModalsCharges,
    		GetChargeById,
    		SetDropdown,
    		onMount,
    		FilteredCharges,
    		FilterCharges,
    		IsChargeValid,
    		AddCharge,
    		$MdwModalsCharges,
    		$IsEms,
    		$MdwCharges
    	});

    	$$self.$inject_state = $$props => {
    		if ('FilteredCharges' in $$props) $$invalidate(0, FilteredCharges = $$props.FilteredCharges);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		FilteredCharges,
    		$MdwModalsCharges,
    		FilterCharges,
    		AddCharge,
    		func,
    		func_1,
    		click_handler,
    		click_handler_1
    	];
    }

    class Modals_Charges extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Charges",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Permissions.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1 } = globals;
    const file$8 = "src\\apps\\Mdw\\modals\\Modals.Permissions.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i][0];
    	child_ctx[6] = list[i][1];
    	child_ctx[7] = list;
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (17:16) {#if $MdwModalsPermissions.Role}
    function create_if_block$6(ctx) {
    	let checkbox;
    	let updating_Checked;
    	let current;

    	function checkbox_Checked_binding(value) {
    		/*checkbox_Checked_binding*/ ctx[2](value, /*Key*/ ctx[5]);
    	}

    	let checkbox_props = {
    		Title: PermissionsLocale[/*Key*/ ctx[5]] || /*Key*/ ctx[5]
    	};

    	if (/*$MdwModalsPermissions*/ ctx[1].Role.permissions[/*Key*/ ctx[5]] !== void 0) {
    		checkbox_props.Checked = /*$MdwModalsPermissions*/ ctx[1].Role.permissions[/*Key*/ ctx[5]];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'Checked', checkbox_Checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const checkbox_changes = {};
    			if (dirty & /*Permissions*/ 1) checkbox_changes.Title = PermissionsLocale[/*Key*/ ctx[5]] || /*Key*/ ctx[5];

    			if (!updating_Checked && dirty & /*$MdwModalsPermissions, Permissions*/ 3) {
    				updating_Checked = true;
    				checkbox_changes.Checked = /*$MdwModalsPermissions*/ ctx[1].Role.permissions[/*Key*/ ctx[5]];
    				add_flush_callback(() => updating_Checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(17:16) {#if $MdwModalsPermissions.Role}",
    		ctx
    	});

    	return block;
    }

    // (16:12) {#each Permissions as [Key, Data]}
    function create_each_block$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$MdwModalsPermissions*/ ctx[1].Role && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$MdwModalsPermissions*/ ctx[1].Role) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsPermissions*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(16:12) {#each Permissions as [Key, Data]}",
    		ctx
    	});

    	return block;
    }

    // (24:12) <Button Color="success" click={() => {                  const Cb = $MdwModalsPermissions.Cb                  MdwModalsPermissions.set({ Show: false });                  Cb($MdwModalsPermissions.Role.permissions)              }}>
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(24:12) <Button Color=\\\"success\\\" click={() => {                  const Cb = $MdwModalsPermissions.Cb                  MdwModalsPermissions.set({ Show: false });                  Cb($MdwModalsPermissions.Role.permissions)              }}>",
    		ctx
    	});

    	return block;
    }

    // (29:12) <Button Color="warning" click={() => {                  MdwModalsPermissions.set({                      Show: false,                      Role: false,                      Cb: () => {}                  })              }}>
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(29:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsPermissions.set({                      Show: false,                      Role: false,                      Cb: () => {}                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let div0;
    	let t2;
    	let div1;
    	let button0;
    	let t3;
    	let button1;
    	let current;
    	let each_value = /*Permissions*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button0 = new Button({
    			props: {
    				Color: "success",
    				click: /*func*/ ctx[3],
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				Color: "warning",
    				click: /*func_1*/ ctx[4],
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Edit Permissions";
    			t1 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t3 = space();
    			create_component(button1.$$.fragment);
    			attr_dev(p, "class", "svelte-m4exmx");
    			add_location(p, file$8, 12, 8, 533);
    			attr_dev(div0, "class", "mdw-modal-permissions-grid svelte-m4exmx");
    			add_location(div0, file$8, 14, 8, 568);
    			set_style(div1, "width", "50%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-between");
    			set_style(div1, "margin", "0 auto");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$8, 22, 8, 909);
    			attr_dev(div2, "class", "mdw-modal-permissions-container svelte-m4exmx");
    			add_location(div2, file$8, 11, 4, 478);
    			attr_dev(div3, "class", "mdw-modal-permissions svelte-m4exmx");
    			add_location(div3, file$8, 10, 0, 437);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			mount_component(button0, div1, null);
    			append_dev(div1, t3);
    			mount_component(button1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*PermissionsLocale, Permissions, $MdwModalsPermissions*/ 3) {
    				each_value = /*Permissions*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button0_changes = {};
    			if (dirty & /*$MdwModalsPermissions*/ 2) button0_changes.click = /*func*/ ctx[3];

    			if (dirty & /*$$scope*/ 512) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $MdwModalsPermissions;
    	validate_store(MdwModalsPermissions, 'MdwModalsPermissions');
    	component_subscribe($$self, MdwModalsPermissions, $$value => $$invalidate(1, $MdwModalsPermissions = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Permissions', slots, []);
    	let Permissions = Object.entries($MdwModalsPermissions.Role.permissions);
    	Permissions = Permissions.sort((a, b) => a[0].localeCompare(b[0]));
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Permissions> was created with unknown prop '${key}'`);
    	});

    	function checkbox_Checked_binding(value, Key) {
    		if ($$self.$$.not_equal($MdwModalsPermissions.Role.permissions[Key], value)) {
    			$MdwModalsPermissions.Role.permissions[Key] = value;
    			MdwModalsPermissions.set($MdwModalsPermissions);
    		}
    	}

    	const func = () => {
    		const Cb = $MdwModalsPermissions.Cb;
    		MdwModalsPermissions.set({ Show: false });
    		Cb($MdwModalsPermissions.Role.permissions);
    	};

    	const func_1 = () => {
    		MdwModalsPermissions.set({
    			Show: false,
    			Role: false,
    			Cb: () => {
    				
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		Checkbox,
    		PermissionsLocale,
    		MdwModalsPermissions,
    		Permissions,
    		$MdwModalsPermissions
    	});

    	$$self.$inject_state = $$props => {
    		if ('Permissions' in $$props) $$invalidate(0, Permissions = $$props.Permissions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [Permissions, $MdwModalsPermissions, checkbox_Checked_binding, func, func_1];
    }

    class Modals_Permissions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Permissions",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\components\TextArea\TextArea.svelte generated by Svelte v3.59.2 */
    const file$7 = "src\\components\\TextArea\\TextArea.svelte";

    // (47:4) {#if MaxLength}
    function create_if_block$5(ctx) {
    	let p;
    	let t0_value = /*Value*/ ctx[0].length + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text("/255");
    			attr_dev(p, "class", "subtext svelte-io0qx5");
    			add_location(p, file$7, 47, 8, 1280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Value*/ 1 && t0_value !== (t0_value = /*Value*/ ctx[0].length + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(47:4) {#if MaxLength}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div2;
    	let p;
    	let t0;
    	let t1;
    	let textarea;
    	let t2;
    	let div1;
    	let div0;
    	let t3;
    	let mounted;
    	let dispose;
    	let if_block = /*MaxLength*/ ctx[3] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			p = element("p");
    			t0 = text(/*Title*/ ctx[1]);
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(p, "class", "svelte-io0qx5");
    			add_location(p, file$7, 24, 4, 699);
    			attr_dev(textarea, "rows", /*Rows*/ ctx[4]);
    			attr_dev(textarea, "placeholder", /*Placeholder*/ ctx[2]);
    			attr_dev(textarea, "maxlength", /*MaxLength*/ ctx[3]);
    			textarea.value = /*Value*/ ctx[0];
    			attr_dev(textarea, "class", "svelte-io0qx5");
    			add_location(textarea, file$7, 25, 4, 719);
    			attr_dev(div0, "class", "textarea-underline-fill svelte-io0qx5");
    			set_style(div0, "width", (/*Focused*/ ctx[6] ? 100 : 0) + "%");
    			add_location(div0, file$7, 40, 8, 1125);
    			attr_dev(div1, "class", "textarea-underline svelte-io0qx5");
    			set_style(div1, "height", "0.1vh");
    			add_location(div1, file$7, 39, 4, 1061);
    			attr_dev(div2, "class", "textarea-component-container svelte-io0qx5");
    			add_location(div2, file$7, 23, 0, 651);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, p);
    			append_dev(p, t0);
    			append_dev(div2, t1);
    			append_dev(div2, textarea);
    			/*textarea_binding*/ ctx[8](textarea);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div2, t3);
    			if (if_block) if_block.m(div2, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focusin", /*focusin_handler*/ ctx[9], false, false, false, false),
    					listen_dev(textarea, "focusout", /*focusout_handler*/ ctx[10], false, false, false, false),
    					listen_dev(textarea, "input", /*updateTextareaHeight*/ ctx[7], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Title*/ 2) set_data_dev(t0, /*Title*/ ctx[1]);

    			if (dirty & /*Rows*/ 16) {
    				attr_dev(textarea, "rows", /*Rows*/ ctx[4]);
    			}

    			if (dirty & /*Placeholder*/ 4) {
    				attr_dev(textarea, "placeholder", /*Placeholder*/ ctx[2]);
    			}

    			if (dirty & /*MaxLength*/ 8) {
    				attr_dev(textarea, "maxlength", /*MaxLength*/ ctx[3]);
    			}

    			if (dirty & /*Value*/ 1) {
    				prop_dev(textarea, "value", /*Value*/ ctx[0]);
    			}

    			if (dirty & /*Focused*/ 64) {
    				set_style(div0, "width", (/*Focused*/ ctx[6] ? 100 : 0) + "%");
    			}

    			if (/*MaxLength*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			/*textarea_binding*/ ctx[8](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextArea', slots, []);
    	let { Title = "No Title" } = $$props;
    	let { Placeholder = "" } = $$props;
    	let { MaxLength = 255 } = $$props;
    	let { Value = "" } = $$props;
    	let { Rows = 1 } = $$props;
    	let TextArea;
    	let Focused = false;

    	function updateTextareaHeight(event) {
    		$$invalidate(0, Value = TextArea.value);
    		$$invalidate(5, TextArea.style.height = "auto", TextArea); // reset the height to auto to avoid a scrollbar
    		$$invalidate(5, TextArea.style.height = TextArea.scrollHeight + 10 + "px", TextArea); // set the height to the scroll height
    	}

    	onMount(() => {
    		$$invalidate(5, TextArea.style.height = TextArea.scrollHeight + 10 + 'px', TextArea);
    	});

    	const writable_props = ['Title', 'Placeholder', 'MaxLength', 'Value', 'Rows'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextArea> was created with unknown prop '${key}'`);
    	});

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			TextArea = $$value;
    			$$invalidate(5, TextArea);
    		});
    	}

    	const focusin_handler = () => {
    		$$invalidate(6, Focused = true);
    	};

    	const focusout_handler = () => {
    		$$invalidate(6, Focused = false);
    	};

    	$$self.$$set = $$props => {
    		if ('Title' in $$props) $$invalidate(1, Title = $$props.Title);
    		if ('Placeholder' in $$props) $$invalidate(2, Placeholder = $$props.Placeholder);
    		if ('MaxLength' in $$props) $$invalidate(3, MaxLength = $$props.MaxLength);
    		if ('Value' in $$props) $$invalidate(0, Value = $$props.Value);
    		if ('Rows' in $$props) $$invalidate(4, Rows = $$props.Rows);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Title,
    		Placeholder,
    		MaxLength,
    		Value,
    		Rows,
    		TextArea,
    		Focused,
    		updateTextareaHeight
    	});

    	$$self.$inject_state = $$props => {
    		if ('Title' in $$props) $$invalidate(1, Title = $$props.Title);
    		if ('Placeholder' in $$props) $$invalidate(2, Placeholder = $$props.Placeholder);
    		if ('MaxLength' in $$props) $$invalidate(3, MaxLength = $$props.MaxLength);
    		if ('Value' in $$props) $$invalidate(0, Value = $$props.Value);
    		if ('Rows' in $$props) $$invalidate(4, Rows = $$props.Rows);
    		if ('TextArea' in $$props) $$invalidate(5, TextArea = $$props.TextArea);
    		if ('Focused' in $$props) $$invalidate(6, Focused = $$props.Focused);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Value,
    		Title,
    		Placeholder,
    		MaxLength,
    		Rows,
    		TextArea,
    		Focused,
    		updateTextareaHeight,
    		textarea_binding,
    		focusin_handler,
    		focusout_handler
    	];
    }

    class TextArea_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			Title: 1,
    			Placeholder: 2,
    			MaxLength: 3,
    			Value: 0,
    			Rows: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextArea_1",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get Title() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Title(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Placeholder() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Placeholder(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MaxLength() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MaxLength(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Value() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Value(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Rows() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Rows(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\modals\Modals.ChargeEditor.svelte generated by Svelte v3.59.2 */
    const file$6 = "src\\apps\\Mdw\\modals\\Modals.ChargeEditor.svelte";

    // (10:0) {#if $MdwModalsChargeEditor.Show && $MdwModalsChargeEditor.Charge != undefined && $MdwModalsChargeEditor.Charge.category != undefined}
    function create_if_block$4(ctx) {
    	let div5;
    	let div4;
    	let p0;
    	let t1;
    	let div0;
    	let textfield0;
    	let updating_Value;
    	let t2;
    	let textfield1;
    	let updating_Value_1;
    	let t3;
    	let textarea;
    	let updating_Value_2;
    	let t4;
    	let div1;
    	let textfield2;
    	let updating_Value_3;
    	let t5;
    	let textfield3;
    	let updating_Value_4;
    	let t6;
    	let hr;
    	let t7;
    	let p1;
    	let t9;
    	let div2;
    	let textfield4;
    	let updating_Value_5;
    	let t10;
    	let textfield5;
    	let updating_Value_6;
    	let t11;
    	let textfield6;
    	let updating_Value_7;
    	let t12;
    	let t13;
    	let div3;
    	let button0;
    	let t14;
    	let button1;
    	let current;

    	function textfield0_Value_binding(value) {
    		/*textfield0_Value_binding*/ ctx[2](value);
    	}

    	let textfield0_props = { Title: "Categorie", style: "width: 49%;" };

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.category !== void 0) {
    		textfield0_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.category;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'Value', textfield0_Value_binding));

    	function textfield1_Value_binding(value) {
    		/*textfield1_Value_binding*/ ctx[3](value);
    	}

    	let textfield1_props = { Title: "Naam", style: "width: 49%;" };

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.name !== void 0) {
    		textfield1_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.name;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'Value', textfield1_Value_binding));

    	function textarea_Value_binding(value) {
    		/*textarea_Value_binding*/ ctx[4](value);
    	}

    	let textarea_props = {
    		Title: "Beschrijving",
    		Rows: 3,
    		MaxLength: false
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.description !== void 0) {
    		textarea_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.description;
    	}

    	textarea = new TextArea_1({ props: textarea_props, $$inline: true });
    	binding_callbacks.push(() => bind(textarea, 'Value', textarea_Value_binding));

    	function textfield2_Value_binding(value) {
    		/*textfield2_Value_binding*/ ctx[5](value);
    	}

    	let textfield2_props = {
    		Title: "Gov Type",
    		style: "width: 49%;",
    		Select: [{ Text: "pd" }, { Text: "ems" }]
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.gov_type !== void 0) {
    		textfield2_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.gov_type;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'Value', textfield2_Value_binding));

    	function textfield3_Value_binding(value) {
    		/*textfield3_Value_binding*/ ctx[6](value);
    	}

    	let textfield3_props = {
    		Title: "Charge Type",
    		style: "width: 49%;",
    		Select: [{ Text: "normal" }, { Text: "major" }, { Text: "extreme" }]
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.type !== void 0) {
    		textfield3_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.type;
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'Value', textfield3_Value_binding));

    	function textfield4_Value_binding(value) {
    		/*textfield4_Value_binding*/ ctx[7](value);
    	}

    	let textfield4_props = {
    		Title: "Boete",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.fine !== void 0) {
    		textfield4_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.fine;
    	}

    	textfield4 = new TextField({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'Value', textfield4_Value_binding));

    	function textfield5_Value_binding(value) {
    		/*textfield5_Value_binding*/ ctx[8](value);
    	}

    	let textfield5_props = {
    		Title: "Celstraf",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.jail !== void 0) {
    		textfield5_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.jail;
    	}

    	textfield5 = new TextField({ props: textfield5_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield5, 'Value', textfield5_Value_binding));

    	function textfield6_Value_binding(value) {
    		/*textfield6_Value_binding*/ ctx[9](value);
    	}

    	let textfield6_props = {
    		Title: "Punten",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.points !== void 0) {
    		textfield6_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.points;
    	}

    	textfield6 = new TextField({ props: textfield6_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield6, 'Value', textfield6_Value_binding));
    	let if_block = /*$MdwModalsChargeEditor*/ ctx[0].Charge.gov_type == "pd" && create_if_block_1$3(ctx);

    	button0 = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[16],
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				Color: "success",
    				click: /*func_1*/ ctx[17],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			p0 = element("p");
    			p0.textContent = "Straf Bewerken";
    			t1 = space();
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			create_component(textarea.$$.fragment);
    			t4 = space();
    			div1 = element("div");
    			create_component(textfield2.$$.fragment);
    			t5 = space();
    			create_component(textfield3.$$.fragment);
    			t6 = space();
    			hr = element("hr");
    			t7 = space();
    			p1 = element("p");
    			p1.textContent = "Straf Doenpleger";
    			t9 = space();
    			div2 = element("div");
    			create_component(textfield4.$$.fragment);
    			t10 = space();
    			create_component(textfield5.$$.fragment);
    			t11 = space();
    			create_component(textfield6.$$.fragment);
    			t12 = space();
    			if (if_block) if_block.c();
    			t13 = space();
    			div3 = element("div");
    			create_component(button0.$$.fragment);
    			t14 = space();
    			create_component(button1.$$.fragment);
    			attr_dev(p0, "class", "svelte-rb60c9");
    			add_location(p0, file$6, 12, 12, 647);
    			set_style(div0, "display", "flex");
    			set_style(div0, "justify-content", "space-around");
    			set_style(div0, "width", "100%");
    			add_location(div0, file$6, 14, 12, 684);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-around");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$6, 34, 12, 1397);
    			set_style(hr, "margin", "2vh 0");
    			add_location(hr, file$6, 56, 12, 2222);
    			attr_dev(p1, "class", "svelte-rb60c9");
    			add_location(p1, file$6, 58, 12, 2266);
    			set_style(div2, "display", "flex");
    			set_style(div2, "justify-content", "space-around");
    			set_style(div2, "width", "100%");
    			add_location(div2, file$6, 59, 12, 2303);
    			set_style(div3, "width", "100%");
    			set_style(div3, "display", "flex");
    			set_style(div3, "justify-content", "center");
    			set_style(div3, "margin-top", "2.4vh");
    			add_location(div3, file$6, 126, 12, 5129);
    			attr_dev(div4, "class", "mdw-modal-chargeEditor-container svelte-rb60c9");
    			add_location(div4, file$6, 11, 8, 587);
    			attr_dev(div5, "class", "mdw-modal-chargeEditor svelte-rb60c9");
    			add_location(div5, file$6, 10, 4, 541);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, p0);
    			append_dev(div4, t1);
    			append_dev(div4, div0);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t2);
    			mount_component(textfield1, div0, null);
    			append_dev(div4, t3);
    			mount_component(textarea, div4, null);
    			append_dev(div4, t4);
    			append_dev(div4, div1);
    			mount_component(textfield2, div1, null);
    			append_dev(div1, t5);
    			mount_component(textfield3, div1, null);
    			append_dev(div4, t6);
    			append_dev(div4, hr);
    			append_dev(div4, t7);
    			append_dev(div4, p1);
    			append_dev(div4, t9);
    			append_dev(div4, div2);
    			mount_component(textfield4, div2, null);
    			append_dev(div2, t10);
    			mount_component(textfield5, div2, null);
    			append_dev(div2, t11);
    			mount_component(textfield6, div2, null);
    			append_dev(div4, t12);
    			if (if_block) if_block.m(div4, null);
    			append_dev(div4, t13);
    			append_dev(div4, div3);
    			mount_component(button0, div3, null);
    			append_dev(div3, t14);
    			mount_component(button1, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_Value && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value = true;
    				textfield0_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.category;
    				add_flush_callback(() => updating_Value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_Value_1 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_1 = true;
    				textfield1_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.name;
    				add_flush_callback(() => updating_Value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textarea_changes = {};

    			if (!updating_Value_2 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_2 = true;
    				textarea_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.description;
    				add_flush_callback(() => updating_Value_2 = false);
    			}

    			textarea.$set(textarea_changes);
    			const textfield2_changes = {};

    			if (!updating_Value_3 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_3 = true;
    				textfield2_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.gov_type;
    				add_flush_callback(() => updating_Value_3 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_Value_4 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_4 = true;
    				textfield3_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.type;
    				add_flush_callback(() => updating_Value_4 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_Value_5 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_5 = true;
    				textfield4_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.fine;
    				add_flush_callback(() => updating_Value_5 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const textfield5_changes = {};

    			if (!updating_Value_6 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_6 = true;
    				textfield5_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.jail;
    				add_flush_callback(() => updating_Value_6 = false);
    			}

    			textfield5.$set(textfield5_changes);
    			const textfield6_changes = {};

    			if (!updating_Value_7 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_7 = true;
    				textfield6_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.points;
    				add_flush_callback(() => updating_Value_7 = false);
    			}

    			textfield6.$set(textfield6_changes);

    			if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.gov_type == "pd") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsChargeEditor*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div4, t13);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*$MdwModalsChargeEditor, $MdwCharges*/ 3) button1_changes.click = /*func_1*/ ctx[17];

    			if (dirty & /*$$scope*/ 262144) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textarea.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(textfield5.$$.fragment, local);
    			transition_in(textfield6.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textarea.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(textfield5.$$.fragment, local);
    			transition_out(textfield6.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textarea);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(textfield5);
    			destroy_component(textfield6);
    			if (if_block) if_block.d();
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(10:0) {#if $MdwModalsChargeEditor.Show && $MdwModalsChargeEditor.Charge != undefined && $MdwModalsChargeEditor.Charge.category != undefined}",
    		ctx
    	});

    	return block;
    }

    // (81:12) {#if $MdwModalsChargeEditor.Charge.gov_type == "pd"}
    function create_if_block_1$3(ctx) {
    	let p0;
    	let t1;
    	let div0;
    	let textfield0;
    	let updating_Value;
    	let t2;
    	let textfield1;
    	let updating_Value_1;
    	let t3;
    	let textfield2;
    	let updating_Value_2;
    	let t4;
    	let p1;
    	let t6;
    	let div1;
    	let textfield3;
    	let updating_Value_3;
    	let t7;
    	let textfield4;
    	let updating_Value_4;
    	let t8;
    	let textfield5;
    	let updating_Value_5;
    	let current;

    	function textfield0_Value_binding_1(value) {
    		/*textfield0_Value_binding_1*/ ctx[10](value);
    	}

    	let textfield0_props = {
    		Title: "Boete",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.fine !== void 0) {
    		textfield0_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.fine;
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'Value', textfield0_Value_binding_1));

    	function textfield1_Value_binding_1(value) {
    		/*textfield1_Value_binding_1*/ ctx[11](value);
    	}

    	let textfield1_props = {
    		Title: "Celstraf",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.jail !== void 0) {
    		textfield1_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.jail;
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'Value', textfield1_Value_binding_1));

    	function textfield2_Value_binding_1(value) {
    		/*textfield2_Value_binding_1*/ ctx[12](value);
    	}

    	let textfield2_props = {
    		Title: "Punten",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.points !== void 0) {
    		textfield2_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.points;
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'Value', textfield2_Value_binding_1));

    	function textfield3_Value_binding_1(value) {
    		/*textfield3_Value_binding_1*/ ctx[13](value);
    	}

    	let textfield3_props = {
    		Title: "Boete",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.fine !== void 0) {
    		textfield3_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.fine;
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'Value', textfield3_Value_binding_1));

    	function textfield4_Value_binding_1(value) {
    		/*textfield4_Value_binding_1*/ ctx[14](value);
    	}

    	let textfield4_props = {
    		Title: "Celstraf",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.jail !== void 0) {
    		textfield4_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.jail;
    	}

    	textfield4 = new TextField({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'Value', textfield4_Value_binding_1));

    	function textfield5_Value_binding_1(value) {
    		/*textfield5_Value_binding_1*/ ctx[15](value);
    	}

    	let textfield5_props = {
    		Title: "Punten",
    		style: "width: 32.33%;",
    		Type: "number"
    	};

    	if (/*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.points !== void 0) {
    		textfield5_props.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.points;
    	}

    	textfield5 = new TextField({ props: textfield5_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield5, 'Value', textfield5_Value_binding_1));

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Straf Medeplichtige";
    			t1 = space();
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			create_component(textfield2.$$.fragment);
    			t4 = space();
    			p1 = element("p");
    			p1.textContent = "Straf Poging Tot";
    			t6 = space();
    			div1 = element("div");
    			create_component(textfield3.$$.fragment);
    			t7 = space();
    			create_component(textfield4.$$.fragment);
    			t8 = space();
    			create_component(textfield5.$$.fragment);
    			attr_dev(p0, "class", "svelte-rb60c9");
    			add_location(p0, file$6, 81, 16, 3180);
    			set_style(div0, "display", "flex");
    			set_style(div0, "justify-content", "space-around");
    			set_style(div0, "width", "100%");
    			add_location(div0, file$6, 82, 16, 3224);
    			attr_dev(p1, "class", "svelte-rb60c9");
    			add_location(p1, file$6, 103, 16, 4156);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "space-around");
    			set_style(div1, "width", "100%");
    			add_location(div1, file$6, 104, 16, 4197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t2);
    			mount_component(textfield1, div0, null);
    			append_dev(div0, t3);
    			mount_component(textfield2, div0, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(textfield3, div1, null);
    			append_dev(div1, t7);
    			mount_component(textfield4, div1, null);
    			append_dev(div1, t8);
    			mount_component(textfield5, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_Value && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value = true;
    				textfield0_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.fine;
    				add_flush_callback(() => updating_Value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_Value_1 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_1 = true;
    				textfield1_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.jail;
    				add_flush_callback(() => updating_Value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_Value_2 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_2 = true;
    				textfield2_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.accomplice.points;
    				add_flush_callback(() => updating_Value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_Value_3 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_3 = true;
    				textfield3_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.fine;
    				add_flush_callback(() => updating_Value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_Value_4 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_4 = true;
    				textfield4_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.jail;
    				add_flush_callback(() => updating_Value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const textfield5_changes = {};

    			if (!updating_Value_5 && dirty & /*$MdwModalsChargeEditor*/ 1) {
    				updating_Value_5 = true;
    				textfield5_changes.Value = /*$MdwModalsChargeEditor*/ ctx[0].Charge.attempted.points;
    				add_flush_callback(() => updating_Value_5 = false);
    			}

    			textfield5.$set(textfield5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(textfield5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(textfield5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div1);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(textfield5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(81:12) {#if $MdwModalsChargeEditor.Charge.gov_type == \\\"pd\\\"}",
    		ctx
    	});

    	return block;
    }

    // (128:16) <Button Color="warning" click={() => {                      MdwModalsChargeEditor.set({                          Show: false,                      })                  }}>
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Annuleren");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(128:16) <Button Color=\\\"warning\\\" click={() => {                      MdwModalsChargeEditor.set({                          Show: false,                      })                  }}>",
    		ctx
    	});

    	return block;
    }

    // (134:16) <Button Color="success" click={() => {                      ShowLoader.set(true);                        SendEvent("Config/EditCharge", {...$MdwModalsChargeEditor.Charge}, (Success, Data) => {                          const newCharges = $MdwCharges;                          const Index = newCharges.findIndex(Val => Val.id == $MdwModalsChargeEditor.Charge.id)                          if (Index == -1) {                              newCharges.push($MdwModalsChargeEditor.Charge);                          } else {                              newCharges[Index] = $MdwModalsChargeEditor.Charge;                          }                            MdwCharges.set(newCharges);                            ShowLoader.set(false);                          MdwModalsChargeEditor.set({                              Show: false,                          })                            if (!Success) return;                            if (!Data.Success) {                              MdwModalsExport.set({Show: true, Msg: Data.Msg});                          }                      });                  }}>
    function create_default_slot$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Opslaan");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(134:16) <Button Color=\\\"success\\\" click={() => {                      ShowLoader.set(true);                        SendEvent(\\\"Config/EditCharge\\\", {...$MdwModalsChargeEditor.Charge}, (Success, Data) => {                          const newCharges = $MdwCharges;                          const Index = newCharges.findIndex(Val => Val.id == $MdwModalsChargeEditor.Charge.id)                          if (Index == -1) {                              newCharges.push($MdwModalsChargeEditor.Charge);                          } else {                              newCharges[Index] = $MdwModalsChargeEditor.Charge;                          }                            MdwCharges.set(newCharges);                            ShowLoader.set(false);                          MdwModalsChargeEditor.set({                              Show: false,                          })                            if (!Success) return;                            if (!Data.Success) {                              MdwModalsExport.set({Show: true, Msg: Data.Msg});                          }                      });                  }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$MdwModalsChargeEditor*/ ctx[0].Show && /*$MdwModalsChargeEditor*/ ctx[0].Charge != undefined && /*$MdwModalsChargeEditor*/ ctx[0].Charge.category != undefined && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$MdwModalsChargeEditor*/ ctx[0].Show && /*$MdwModalsChargeEditor*/ ctx[0].Charge != undefined && /*$MdwModalsChargeEditor*/ ctx[0].Charge.category != undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$MdwModalsChargeEditor*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $MdwModalsChargeEditor;
    	let $MdwCharges;
    	validate_store(MdwModalsChargeEditor, 'MdwModalsChargeEditor');
    	component_subscribe($$self, MdwModalsChargeEditor, $$value => $$invalidate(0, $MdwModalsChargeEditor = $$value));
    	validate_store(MdwCharges, 'MdwCharges');
    	component_subscribe($$self, MdwCharges, $$value => $$invalidate(1, $MdwCharges = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_ChargeEditor', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_ChargeEditor> was created with unknown prop '${key}'`);
    	});

    	function textfield0_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.category, value)) {
    			$MdwModalsChargeEditor.Charge.category = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield1_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.name, value)) {
    			$MdwModalsChargeEditor.Charge.name = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textarea_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.description, value)) {
    			$MdwModalsChargeEditor.Charge.description = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield2_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.gov_type, value)) {
    			$MdwModalsChargeEditor.Charge.gov_type = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield3_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.type, value)) {
    			$MdwModalsChargeEditor.Charge.type = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield4_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.fine, value)) {
    			$MdwModalsChargeEditor.Charge.fine = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield5_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.jail, value)) {
    			$MdwModalsChargeEditor.Charge.jail = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield6_Value_binding(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.points, value)) {
    			$MdwModalsChargeEditor.Charge.points = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield0_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.accomplice.fine, value)) {
    			$MdwModalsChargeEditor.Charge.accomplice.fine = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield1_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.accomplice.jail, value)) {
    			$MdwModalsChargeEditor.Charge.accomplice.jail = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield2_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.accomplice.points, value)) {
    			$MdwModalsChargeEditor.Charge.accomplice.points = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield3_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.attempted.fine, value)) {
    			$MdwModalsChargeEditor.Charge.attempted.fine = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield4_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.attempted.jail, value)) {
    			$MdwModalsChargeEditor.Charge.attempted.jail = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	function textfield5_Value_binding_1(value) {
    		if ($$self.$$.not_equal($MdwModalsChargeEditor.Charge.attempted.points, value)) {
    			$MdwModalsChargeEditor.Charge.attempted.points = value;
    			MdwModalsChargeEditor.set($MdwModalsChargeEditor);
    		}
    	}

    	const func = () => {
    		MdwModalsChargeEditor.set({ Show: false });
    	};

    	const func_1 = () => {
    		ShowLoader.set(true);

    		SendEvent("Config/EditCharge", { ...$MdwModalsChargeEditor.Charge }, (Success, Data) => {
    			const newCharges = $MdwCharges;
    			const Index = newCharges.findIndex(Val => Val.id == $MdwModalsChargeEditor.Charge.id);

    			if (Index == -1) {
    				newCharges.push($MdwModalsChargeEditor.Charge);
    			} else {
    				newCharges[Index] = $MdwModalsChargeEditor.Charge;
    			}

    			MdwCharges.set(newCharges);
    			ShowLoader.set(false);
    			MdwModalsChargeEditor.set({ Show: false });
    			if (!Success) return;

    			if (!Data.Success) {
    				MdwModalsExport$1.set({ Show: true, Msg: Data.Msg });
    			}
    		});
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		TextField,
    		TextArea: TextArea_1,
    		MdwCharges,
    		MdwModalsChargeEditor,
    		MdwModalsExport: MdwModalsExport$1,
    		ShowLoader,
    		SendEvent,
    		$MdwModalsChargeEditor,
    		$MdwCharges
    	});

    	return [
    		$MdwModalsChargeEditor,
    		$MdwCharges,
    		textfield0_Value_binding,
    		textfield1_Value_binding,
    		textarea_Value_binding,
    		textfield2_Value_binding,
    		textfield3_Value_binding,
    		textfield4_Value_binding,
    		textfield5_Value_binding,
    		textfield6_Value_binding,
    		textfield0_Value_binding_1,
    		textfield1_Value_binding_1,
    		textfield2_Value_binding_1,
    		textfield3_Value_binding_1,
    		textfield4_Value_binding_1,
    		textfield5_Value_binding_1,
    		func,
    		func_1
    	];
    }

    class Modals_ChargeEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_ChargeEditor",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.VehicleHistory.svelte generated by Svelte v3.59.2 */
    const file$5 = "src\\apps\\Mdw\\modals\\Modals.VehicleHistory.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (43:16) <MdwPanelHeader>
    function create_default_slot_6(ctx) {
    	let h6;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text("Impound History (");
    			t1 = text(/*TotalStrikes*/ ctx[0]);
    			t2 = text(" strikes)");
    			add_location(h6, file$5, 43, 20, 1576);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*TotalStrikes*/ 1) set_data_dev(t1, /*TotalStrikes*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(43:16) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (48:20) {#each ImpoundHistory as Data, Key}
    function create_each_block_1(ctx) {
    	let mdwcard;
    	let current;

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[`Issuer: ${/*Data*/ ctx[5].actor} - Reason: ${/*Data*/ ctx[5].reason}`],
    					[
    						`Relleasecost: ${FormatCurrency.format(/*Data*/ ctx[5].fee)} - Strikes: ${/*Data*/ ctx[5].strikes}`
    					],
    					[
    						`Date of impound: ${GetLongTimeLabel(/*Data*/ ctx[5].retained_date)} - Date of release: ${GetLongTimeLabel(/*Data*/ ctx[5].retained_until)}`
    					],
    					[`ID: ${/*Data*/ ctx[5].id}`]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwcard_changes = {};

    			if (dirty & /*ImpoundHistory*/ 2) mdwcard_changes.Information = [
    				[`Issuer: ${/*Data*/ ctx[5].actor} - Reason: ${/*Data*/ ctx[5].reason}`],
    				[
    					`Relleasecost: ${FormatCurrency.format(/*Data*/ ctx[5].fee)} - Strikes: ${/*Data*/ ctx[5].strikes}`
    				],
    				[
    					`Date of impound: ${GetLongTimeLabel(/*Data*/ ctx[5].retained_date)} - Date of release: ${GetLongTimeLabel(/*Data*/ ctx[5].retained_until)}`
    				],
    				[`ID: ${/*Data*/ ctx[5].id}`]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(48:20) {#each ImpoundHistory as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (47:16) <MdwPanelList style="max-height: 35vh;">
    function create_default_slot_5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*ImpoundHistory*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ImpoundHistory, FormatCurrency, GetLongTimeLabel*/ 2) {
    				each_value_1 = /*ImpoundHistory*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(47:16) <MdwPanelList style=\\\"max-height: 35vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:12) <MdwPanel class="filled" style="width: 49.25%">
    function create_default_slot_4(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				style: "max-height: 35vh;",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope, TotalStrikes*/ 513) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, ImpoundHistory*/ 514) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(42:12) <MdwPanel class=\\\"filled\\\" style=\\\"width: 49.25%\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:16) <MdwPanelHeader>
    function create_default_slot_3(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "Owner history";
    			add_location(h6, file$5, 60, 20, 2465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(60:16) <MdwPanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (67:20) {#each OwnershipHistory as Data, Key}
    function create_each_block(ctx) {
    	let mdwcard;
    	let current;

    	mdwcard = new MdwCard({
    			props: {
    				Information: [
    					[`From: ${/*Data*/ ctx[5].from}`],
    					[
    						`Sale price: ${FormatCurrency.format(/*Data*/ ctx[5].price)} - Sold on: ${GetLongTimeLabel(/*Data*/ ctx[5].timestamp)}`
    					],
    					[`ID: ${/*Data*/ ctx[5].id}`]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwcard_changes = {};

    			if (dirty & /*OwnershipHistory*/ 4) mdwcard_changes.Information = [
    				[`From: ${/*Data*/ ctx[5].from}`],
    				[
    					`Sale price: ${FormatCurrency.format(/*Data*/ ctx[5].price)} - Sold on: ${GetLongTimeLabel(/*Data*/ ctx[5].timestamp)}`
    				],
    				[`ID: ${/*Data*/ ctx[5].id}`]
    			];

    			mdwcard.$set(mdwcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(67:20) {#each OwnershipHistory as Data, Key}",
    		ctx
    	});

    	return block;
    }

    // (64:16) <MdwPanelList style="max-height: 35vh;">
    function create_default_slot_2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*OwnershipHistory*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*OwnershipHistory, FormatCurrency, GetLongTimeLabel*/ 4) {
    				each_value = /*OwnershipHistory*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(64:16) <MdwPanelList style=\\\"max-height: 35vh;\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:12) <MdwPanel class="filled" style="width: 49.25%">
    function create_default_slot_1(ctx) {
    	let mdwpanelheader;
    	let t;
    	let mdwpanellist;
    	let current;

    	mdwpanelheader = new MdwPanel_Header({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanellist = new MdwPanel_List({
    			props: {
    				style: "max-height: 35vh;",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdwpanelheader.$$.fragment);
    			t = space();
    			create_component(mdwpanellist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwpanelheader, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwpanellist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdwpanelheader_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				mdwpanelheader_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanelheader.$set(mdwpanelheader_changes);
    			const mdwpanellist_changes = {};

    			if (dirty & /*$$scope, OwnershipHistory*/ 516) {
    				mdwpanellist_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanellist.$set(mdwpanellist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanelheader.$$.fragment, local);
    			transition_in(mdwpanellist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanelheader.$$.fragment, local);
    			transition_out(mdwpanellist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwpanelheader, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwpanellist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(59:12) <MdwPanel class=\\\"filled\\\" style=\\\"width: 49.25%\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:12) <Button Color="warning" click={() => {                  MdwModalsVehicleHistory.set({                      Show: false,                      Plate: ""                  })              }}>
    function create_default_slot$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(79:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsVehicleHistory.set({                      Show: false,                      Plate: \\\"\\\"                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div3;
    	let div2;
    	let p;
    	let t1;
    	let div0;
    	let mdwpanel0;
    	let t2;
    	let mdwpanel1;
    	let t3;
    	let div1;
    	let button;
    	let current;

    	mdwpanel0 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 49.25%",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdwpanel1 = new MdwPanel({
    			props: {
    				class: "filled",
    				style: "width: 49.25%",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[3],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			p = element("p");
    			p.textContent = "Actions";
    			t1 = space();
    			div0 = element("div");
    			create_component(mdwpanel0.$$.fragment);
    			t2 = space();
    			create_component(mdwpanel1.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-h54egk");
    			add_location(p, file$5, 39, 8, 1391);
    			attr_dev(div0, "class", "mdw-modal-vehicle-history-list svelte-h54egk");
    			add_location(div0, file$5, 40, 8, 1415);
    			set_style(div1, "width", "100%");
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			set_style(div1, "margin-top", "2.4vh");
    			add_location(div1, file$5, 77, 8, 3272);
    			attr_dev(div2, "class", "mdw-modal-vehicle-history-container svelte-h54egk");
    			add_location(div2, file$5, 38, 4, 1332);
    			attr_dev(div3, "class", "mdw-modal-vehicle-history svelte-h54egk");
    			add_location(div3, file$5, 37, 0, 1287);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, p);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			mount_component(mdwpanel0, div0, null);
    			append_dev(div0, t2);
    			mount_component(mdwpanel1, div0, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdwpanel0_changes = {};

    			if (dirty & /*$$scope, ImpoundHistory, TotalStrikes*/ 515) {
    				mdwpanel0_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel0.$set(mdwpanel0_changes);
    			const mdwpanel1_changes = {};

    			if (dirty & /*$$scope, OwnershipHistory*/ 516) {
    				mdwpanel1_changes.$$scope = { dirty, ctx };
    			}

    			mdwpanel1.$set(mdwpanel1_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwpanel0.$$.fragment, local);
    			transition_in(mdwpanel1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwpanel0.$$.fragment, local);
    			transition_out(mdwpanel1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(mdwpanel0);
    			destroy_component(mdwpanel1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $MdwModalsVehicleHistory;
    	validate_store(MdwModalsVehicleHistory, 'MdwModalsVehicleHistory');
    	component_subscribe($$self, MdwModalsVehicleHistory, $$value => $$invalidate(4, $MdwModalsVehicleHistory = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_VehicleHistory', slots, []);
    	let TotalStrikes = 0;
    	let ImpoundHistory = [];
    	let OwnershipHistory = [];

    	onMount(() => {
    		SendEvent("Vehicles/FetchImpoundHistory", { Plate: $MdwModalsVehicleHistory.Plate }, (Success, Data) => {
    			if (!Success) return;
    			$$invalidate(1, ImpoundHistory = Data);

    			for (let i = 0; i < ImpoundHistory.length; i++) {
    				const { strikes } = ImpoundHistory[i];
    				$$invalidate(0, TotalStrikes += strikes);
    			}
    		});

    		SendEvent("Vehicles/FetchOwnershipHistory", { Plate: $MdwModalsVehicleHistory.Plate }, (Success, Data) => {
    			if (!Success) return;
    			$$invalidate(2, OwnershipHistory = Data);
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_VehicleHistory> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		MdwModalsVehicleHistory.set({ Show: false, Plate: "" });
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		MdwModalsVehicleHistory,
    		MdwPanel,
    		MdwPanelHeader: MdwPanel_Header,
    		MdwPanelList: MdwPanel_List,
    		MdwCard,
    		FormatCurrency,
    		GetLongTimeLabel,
    		SendEvent,
    		onMount,
    		TotalStrikes,
    		ImpoundHistory,
    		OwnershipHistory,
    		$MdwModalsVehicleHistory
    	});

    	$$self.$inject_state = $$props => {
    		if ('TotalStrikes' in $$props) $$invalidate(0, TotalStrikes = $$props.TotalStrikes);
    		if ('ImpoundHistory' in $$props) $$invalidate(1, ImpoundHistory = $$props.ImpoundHistory);
    		if ('OwnershipHistory' in $$props) $$invalidate(2, OwnershipHistory = $$props.OwnershipHistory);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [TotalStrikes, ImpoundHistory, OwnershipHistory, func];
    }

    class Modals_VehicleHistory extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_VehicleHistory",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\apps\Mdw\modals\Modals.Export.svelte generated by Svelte v3.59.2 */
    const file$4 = "src\\apps\\Mdw\\modals\\Modals.Export.svelte";

    // (11:12) <Button Color="warning" click={() => {                  MdwModalsExport.set({                      Show: false,                      Msg: '',                  })              }}>
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sluiten");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(11:12) <Button Color=\\\"warning\\\" click={() => {                  MdwModalsExport.set({                      Show: false,                      Msg: '',                  })              }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div2;
    	let div1;
    	let p;
    	let raw_value = /*$MdwModalsExport*/ ctx[0].Msg + "";
    	let t;
    	let div0;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				Color: "warning",
    				click: /*func*/ ctx[1],
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			p = element("p");
    			t = space();
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "svelte-ej01o4");
    			add_location(p, file$4, 7, 8, 232);
    			set_style(div0, "width", "100%");
    			set_style(div0, "display", "flex");
    			set_style(div0, "justify-content", "center");
    			set_style(div0, "margin-top", "2.4vh");
    			add_location(div0, file$4, 9, 8, 279);
    			attr_dev(div1, "class", "mdw-modal-export-container svelte-ej01o4");
    			add_location(div1, file$4, 6, 4, 182);
    			attr_dev(div2, "class", "mdw-modal-export svelte-ej01o4");
    			add_location(div2, file$4, 5, 0, 146);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			p.innerHTML = raw_value;
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$MdwModalsExport*/ 1) && raw_value !== (raw_value = /*$MdwModalsExport*/ ctx[0].Msg + "")) p.innerHTML = raw_value;			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $MdwModalsExport;
    	validate_store(MdwModalsExport$1, 'MdwModalsExport');
    	component_subscribe($$self, MdwModalsExport$1, $$value => $$invalidate(0, $MdwModalsExport = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modals_Export', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modals_Export> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		MdwModalsExport$1.set({ Show: false, Msg: '' });
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		MdwModalsExport: MdwModalsExport$1,
    		$MdwModalsExport
    	});

    	return [$MdwModalsExport, func];
    }

    class Modals_Export extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modals_Export",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\components\Boundary\DefaultBoundary.svelte generated by Svelte v3.59.2 */

    // (8:0) {#if !$error}
    function create_if_block$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(8:0) {#if !$error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*$error*/ ctx[1] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*$error*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$error*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $error,
    		$$unsubscribe_error = noop,
    		$$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, $$value => $$invalidate(1, $error = $$value)), error);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_error());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DefaultBoundary', slots, ['default']);
    	let { error = null } = $$props;
    	validate_store(error, 'error');
    	$$subscribe_error();
    	let { onError = null } = $$props;
    	const writable_props = ['error', 'onError'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DefaultBoundary> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('error' in $$props) $$subscribe_error($$invalidate(0, error = $$props.error));
    		if ('onError' in $$props) $$invalidate(2, onError = $$props.onError);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ error, onError, $error });

    	$$self.$inject_state = $$props => {
    		if ('error' in $$props) $$subscribe_error($$invalidate(0, error = $$props.error));
    		if ('onError' in $$props) $$invalidate(2, onError = $$props.onError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$error, onError*/ 6) {
    			if ($error && onError) onError($error);
    		}
    	};

    	return [error, $error, onError, $$scope, slots];
    }

    class DefaultBoundary extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { error: 0, onError: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefaultBoundary",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get error() {
    		throw new Error("<DefaultBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<DefaultBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onError() {
    		throw new Error("<DefaultBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onError(value) {
    		throw new Error("<DefaultBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const GUARDED_BLOCK_FNS = ['c', 'l', 'h', 'm', 'p', 'a', 'i', 'o', 'd'];

    function createBoundary(Component) {
      if (Component.$$render) {
        let render = Component.$$render;
        Component.$$render = (result, props, bindings, slots) => {
          const error = writable(undefined);

          try {
            return render(result, { error, ...props }, bindings, slots);
          } catch (e) {
            error.set(e);
            return render(result, { error, ...props }, bindings, {});
          }
        };

        return Component;
      }

      function guard(fn, onError) {
        return function guarded(...args) {
          try {
            return fn(...args);
          } catch (err) {
            onError(err);
          }
        };
      }

      return class ErrorBoundaryComponent extends Component {
        constructor(config) {
          const error = writable(undefined);

          config.props.$$slots.default = config.props.$$slots.default.map(
            (slot) => (...args) => {
              let guarded = guard(slot, error.set);
              let block = guarded(...args);

              if (block) {
                for (let fn of GUARDED_BLOCK_FNS) {
                  if (block[fn]) block[fn] = guard(block[fn], error.set);
                }
              }

              return block;
            }
          );

          super(config);

          this.$$set({ error });
        }
      };
    }

    var Boundary = createBoundary(DefaultBoundary);

    /* src\components\AppWrapper.svelte generated by Svelte v3.59.2 */
    const file$3 = "src\\components\\AppWrapper.svelte";

    // (15:0) <Boundary onError={handleError}>
    function create_default_slot$1(ctx) {
    	let div;
    	let div_style_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "app-wrapper svelte-1atk8nr");
    			attr_dev(div, "style", div_style_value = "pointer-events: " + (/*Focused*/ ctx[0] ? "unset" : "none") + "; " + /*$$restProps*/ ctx[2]?.style);
    			add_location(div, file$3, 15, 4, 368);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*Focused, $$restProps*/ 5 && div_style_value !== (div_style_value = "pointer-events: " + (/*Focused*/ ctx[0] ? "unset" : "none") + "; " + /*$$restProps*/ ctx[2]?.style)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(15:0) <Boundary onError={handleError}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let boundary;
    	let current;

    	boundary = new Boundary({
    			props: {
    				onError: /*handleError*/ ctx[1],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(boundary.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(boundary, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const boundary_changes = {};

    			if (dirty & /*$$scope, Focused, $$restProps*/ 37) {
    				boundary_changes.$$scope = { dirty, ctx };
    			}

    			boundary.$set(boundary_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(boundary.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(boundary.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(boundary, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	const omit_props_names = ["AppName","Focused"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AppWrapper', slots, ['default']);
    	let { AppName = 'Undefined' } = $$props;
    	let { Focused = false } = $$props;

    	const handleError = () => {
    		localStorage.setItem("isUiCrashed", "yes");
    		localStorage.setItem("crashedAppName", AppName);
    		window.location.reload();
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('AppName' in $$new_props) $$invalidate(3, AppName = $$new_props.AppName);
    		if ('Focused' in $$new_props) $$invalidate(0, Focused = $$new_props.Focused);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Boundary, AppName, Focused, handleError });

    	$$self.$inject_state = $$new_props => {
    		if ('AppName' in $$props) $$invalidate(3, AppName = $$new_props.AppName);
    		if ('Focused' in $$props) $$invalidate(0, Focused = $$new_props.Focused);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [Focused, handleError, $$restProps, AppName, slots, $$scope];
    }

    class AppWrapper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, { AppName: 3, Focused: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppWrapper",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get AppName() {
    		throw new Error("<AppWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set AppName(value) {
    		throw new Error("<AppWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Focused() {
    		throw new Error("<AppWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Focused(value) {
    		throw new Error("<AppWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\apps\Mdw\Mdw.svelte generated by Svelte v3.59.2 */
    const file$2 = "src\\apps\\Mdw\\Mdw.svelte";

    // (70:8) {#if $MdwModalsExport.Show}
    function create_if_block_13(ctx) {
    	let modalsexport;
    	let current;
    	modalsexport = new Modals_Export({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsexport.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsexport, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsexport.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsexport.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsexport, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(70:8) {#if $MdwModalsExport.Show}",
    		ctx
    	});

    	return block;
    }

    // (71:8) {#if $MdwModalsTags.Show}
    function create_if_block_12(ctx) {
    	let modalstags;
    	let current;
    	modalstags = new Modals_Tags({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalstags.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalstags, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalstags.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalstags.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalstags, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(71:8) {#if $MdwModalsTags.Show}",
    		ctx
    	});

    	return block;
    }

    // (72:8) {#if $MdwModalsCerts.Show}
    function create_if_block_11(ctx) {
    	let modalscerts;
    	let current;
    	modalscerts = new Modals_Certs({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalscerts.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalscerts, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalscerts.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalscerts.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalscerts, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(72:8) {#if $MdwModalsCerts.Show}",
    		ctx
    	});

    	return block;
    }

    // (73:8) {#if $MdwModalsRoles.Show}
    function create_if_block_10(ctx) {
    	let modalsroles;
    	let current;
    	modalsroles = new Modals_Roles({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsroles.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsroles, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsroles.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsroles.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsroles, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(73:8) {#if $MdwModalsRoles.Show}",
    		ctx
    	});

    	return block;
    }

    // (74:8) {#if $MdwModalsUnits.Show}
    function create_if_block_9(ctx) {
    	let modalsunits;
    	let current;
    	modalsunits = new Modals_Units({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsunits.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsunits, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsunits.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsunits.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsunits, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(74:8) {#if $MdwModalsUnits.Show}",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#if $MdwModalsPerson.Show}
    function create_if_block_8(ctx) {
    	let modalsperson;
    	let current;
    	modalsperson = new Modals_Persons({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsperson.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsperson, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsperson.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsperson.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsperson, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(75:8) {#if $MdwModalsPerson.Show}",
    		ctx
    	});

    	return block;
    }

    // (76:8) {#if $MdwModalsEvidence.Show}
    function create_if_block_7(ctx) {
    	let modalsevidence;
    	let current;
    	modalsevidence = new Modals_Evidence({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsevidence.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsevidence, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsevidence.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsevidence.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsevidence, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(76:8) {#if $MdwModalsEvidence.Show}",
    		ctx
    	});

    	return block;
    }

    // (77:8) {#if $MdwModalsProfiles.Show}
    function create_if_block_6(ctx) {
    	let modalsprofiles;
    	let current;
    	modalsprofiles = new Modals_Profile({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsprofiles.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsprofiles, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsprofiles.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsprofiles.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsprofiles, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(77:8) {#if $MdwModalsProfiles.Show}",
    		ctx
    	});

    	return block;
    }

    // (78:8) {#if $MdwModalsCharges.Show}
    function create_if_block_5(ctx) {
    	let modalscharges;
    	let current;
    	modalscharges = new Modals_Charges({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalscharges.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalscharges, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalscharges.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalscharges.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalscharges, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(78:8) {#if $MdwModalsCharges.Show}",
    		ctx
    	});

    	return block;
    }

    // (79:8) {#if $MdwModalsPermissions.Show}
    function create_if_block_4(ctx) {
    	let modalspermissions;
    	let current;
    	modalspermissions = new Modals_Permissions({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalspermissions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalspermissions, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalspermissions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalspermissions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalspermissions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(79:8) {#if $MdwModalsPermissions.Show}",
    		ctx
    	});

    	return block;
    }

    // (80:8) {#if $MdwModalsChargeEditor.Show}
    function create_if_block_3$1(ctx) {
    	let modalschargeeditor;
    	let current;
    	modalschargeeditor = new Modals_ChargeEditor({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalschargeeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalschargeeditor, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalschargeeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalschargeeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalschargeeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(80:8) {#if $MdwModalsChargeEditor.Show}",
    		ctx
    	});

    	return block;
    }

    // (81:8) {#if $MdwModalsVehicleHistory.Show}
    function create_if_block_2$2(ctx) {
    	let modalsvehiclehistory;
    	let current;
    	modalsvehiclehistory = new Modals_VehicleHistory({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(modalsvehiclehistory.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalsvehiclehistory, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalsvehiclehistory.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalsvehiclehistory.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalsvehiclehistory, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(81:8) {#if $MdwModalsVehicleHistory.Show}",
    		ctx
    	});

    	return block;
    }

    // (83:8) {#if $ShowLoader}
    function create_if_block_1$2(ctx) {
    	let div1;
    	let div0;
    	let svg;
    	let g0;
    	let rect0;
    	let animate0;
    	let g1;
    	let rect1;
    	let animate1;
    	let g2;
    	let rect2;
    	let animate2;
    	let g3;
    	let rect3;
    	let animate3;
    	let g4;
    	let rect4;
    	let animate4;
    	let g5;
    	let rect5;
    	let animate5;
    	let g6;
    	let rect6;
    	let animate6;
    	let g7;
    	let rect7;
    	let animate7;
    	let g8;
    	let rect8;
    	let animate8;
    	let g9;
    	let rect9;
    	let animate9;
    	let g10;
    	let rect10;
    	let animate10;
    	let g11;
    	let rect11;
    	let animate11;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			animate0 = svg_element("animate");
    			g1 = svg_element("g");
    			rect1 = svg_element("rect");
    			animate1 = svg_element("animate");
    			g2 = svg_element("g");
    			rect2 = svg_element("rect");
    			animate2 = svg_element("animate");
    			g3 = svg_element("g");
    			rect3 = svg_element("rect");
    			animate3 = svg_element("animate");
    			g4 = svg_element("g");
    			rect4 = svg_element("rect");
    			animate4 = svg_element("animate");
    			g5 = svg_element("g");
    			rect5 = svg_element("rect");
    			animate5 = svg_element("animate");
    			g6 = svg_element("g");
    			rect6 = svg_element("rect");
    			animate6 = svg_element("animate");
    			g7 = svg_element("g");
    			rect7 = svg_element("rect");
    			animate7 = svg_element("animate");
    			g8 = svg_element("g");
    			rect8 = svg_element("rect");
    			animate8 = svg_element("animate");
    			g9 = svg_element("g");
    			rect9 = svg_element("rect");
    			animate9 = svg_element("animate");
    			g10 = svg_element("g");
    			rect10 = svg_element("rect");
    			animate10 = svg_element("animate");
    			g11 = svg_element("g");
    			rect11 = svg_element("rect");
    			animate11 = svg_element("animate");
    			attr_dev(animate0, "attributeName", "opacity");
    			attr_dev(animate0, "values", "1;0");
    			attr_dev(animate0, "keyTimes", "0;1");
    			attr_dev(animate0, "dur", "1s");
    			attr_dev(animate0, "begin", "-0.9166666666666666s");
    			attr_dev(animate0, "repeatCount", "indefinite");
    			add_location(animate0, file$2, 88, 32, 4247);
    			attr_dev(rect0, "x", "47.5");
    			attr_dev(rect0, "y", "24");
    			attr_dev(rect0, "rx", "1.92");
    			attr_dev(rect0, "ry", "1.92");
    			attr_dev(rect0, "width", "5");
    			attr_dev(rect0, "height", "12");
    			attr_dev(rect0, "fill", "#ffffff");
    			add_location(rect0, file$2, 87, 28, 4134);
    			attr_dev(g0, "transform", "rotate(0 50 50)");
    			add_location(g0, file$2, 86, 24, 4073);
    			attr_dev(animate1, "attributeName", "opacity");
    			attr_dev(animate1, "values", "1;0");
    			attr_dev(animate1, "keyTimes", "0;1");
    			attr_dev(animate1, "dur", "1s");
    			attr_dev(animate1, "begin", "-0.8333333333333334s");
    			attr_dev(animate1, "repeatCount", "indefinite");
    			add_location(animate1, file$2, 93, 32, 4649);
    			attr_dev(rect1, "x", "47.5");
    			attr_dev(rect1, "y", "24");
    			attr_dev(rect1, "rx", "1.92");
    			attr_dev(rect1, "ry", "1.92");
    			attr_dev(rect1, "width", "5");
    			attr_dev(rect1, "height", "12");
    			attr_dev(rect1, "fill", "#ffffff");
    			add_location(rect1, file$2, 92, 28, 4536);
    			attr_dev(g1, "transform", "rotate(30 50 50)");
    			add_location(g1, file$2, 91, 24, 4474);
    			attr_dev(animate2, "attributeName", "opacity");
    			attr_dev(animate2, "values", "1;0");
    			attr_dev(animate2, "keyTimes", "0;1");
    			attr_dev(animate2, "dur", "1s");
    			attr_dev(animate2, "begin", "-0.75s");
    			attr_dev(animate2, "repeatCount", "indefinite");
    			add_location(animate2, file$2, 98, 32, 5051);
    			attr_dev(rect2, "x", "47.5");
    			attr_dev(rect2, "y", "24");
    			attr_dev(rect2, "rx", "1.92");
    			attr_dev(rect2, "ry", "1.92");
    			attr_dev(rect2, "width", "5");
    			attr_dev(rect2, "height", "12");
    			attr_dev(rect2, "fill", "#ffffff");
    			add_location(rect2, file$2, 97, 28, 4938);
    			attr_dev(g2, "transform", "rotate(60 50 50)");
    			add_location(g2, file$2, 96, 24, 4876);
    			attr_dev(animate3, "attributeName", "opacity");
    			attr_dev(animate3, "values", "1;0");
    			attr_dev(animate3, "keyTimes", "0;1");
    			attr_dev(animate3, "dur", "1s");
    			attr_dev(animate3, "begin", "-0.6666666666666666s");
    			attr_dev(animate3, "repeatCount", "indefinite");
    			add_location(animate3, file$2, 103, 32, 5439);
    			attr_dev(rect3, "x", "47.5");
    			attr_dev(rect3, "y", "24");
    			attr_dev(rect3, "rx", "1.92");
    			attr_dev(rect3, "ry", "1.92");
    			attr_dev(rect3, "width", "5");
    			attr_dev(rect3, "height", "12");
    			attr_dev(rect3, "fill", "#ffffff");
    			add_location(rect3, file$2, 102, 28, 5326);
    			attr_dev(g3, "transform", "rotate(90 50 50)");
    			add_location(g3, file$2, 101, 24, 5264);
    			attr_dev(animate4, "attributeName", "opacity");
    			attr_dev(animate4, "values", "1;0");
    			attr_dev(animate4, "keyTimes", "0;1");
    			attr_dev(animate4, "dur", "1s");
    			attr_dev(animate4, "begin", "-0.5833333333333334s");
    			attr_dev(animate4, "repeatCount", "indefinite");
    			add_location(animate4, file$2, 108, 32, 5842);
    			attr_dev(rect4, "x", "47.5");
    			attr_dev(rect4, "y", "24");
    			attr_dev(rect4, "rx", "1.92");
    			attr_dev(rect4, "ry", "1.92");
    			attr_dev(rect4, "width", "5");
    			attr_dev(rect4, "height", "12");
    			attr_dev(rect4, "fill", "#ffffff");
    			add_location(rect4, file$2, 107, 28, 5729);
    			attr_dev(g4, "transform", "rotate(120 50 50)");
    			add_location(g4, file$2, 106, 24, 5666);
    			attr_dev(animate5, "attributeName", "opacity");
    			attr_dev(animate5, "values", "1;0");
    			attr_dev(animate5, "keyTimes", "0;1");
    			attr_dev(animate5, "dur", "1s");
    			attr_dev(animate5, "begin", "-0.5s");
    			attr_dev(animate5, "repeatCount", "indefinite");
    			add_location(animate5, file$2, 113, 32, 6245);
    			attr_dev(rect5, "x", "47.5");
    			attr_dev(rect5, "y", "24");
    			attr_dev(rect5, "rx", "1.92");
    			attr_dev(rect5, "ry", "1.92");
    			attr_dev(rect5, "width", "5");
    			attr_dev(rect5, "height", "12");
    			attr_dev(rect5, "fill", "#ffffff");
    			add_location(rect5, file$2, 112, 28, 6132);
    			attr_dev(g5, "transform", "rotate(150 50 50)");
    			add_location(g5, file$2, 111, 24, 6069);
    			attr_dev(animate6, "attributeName", "opacity");
    			attr_dev(animate6, "values", "1;0");
    			attr_dev(animate6, "keyTimes", "0;1");
    			attr_dev(animate6, "dur", "1s");
    			attr_dev(animate6, "begin", "-0.4166666666666667s");
    			attr_dev(animate6, "repeatCount", "indefinite");
    			add_location(animate6, file$2, 118, 32, 6633);
    			attr_dev(rect6, "x", "47.5");
    			attr_dev(rect6, "y", "24");
    			attr_dev(rect6, "rx", "1.92");
    			attr_dev(rect6, "ry", "1.92");
    			attr_dev(rect6, "width", "5");
    			attr_dev(rect6, "height", "12");
    			attr_dev(rect6, "fill", "#ffffff");
    			add_location(rect6, file$2, 117, 28, 6520);
    			attr_dev(g6, "transform", "rotate(180 50 50)");
    			add_location(g6, file$2, 116, 24, 6457);
    			attr_dev(animate7, "attributeName", "opacity");
    			attr_dev(animate7, "values", "1;0");
    			attr_dev(animate7, "keyTimes", "0;1");
    			attr_dev(animate7, "dur", "1s");
    			attr_dev(animate7, "begin", "-0.3333333333333333s");
    			attr_dev(animate7, "repeatCount", "indefinite");
    			add_location(animate7, file$2, 123, 32, 7036);
    			attr_dev(rect7, "x", "47.5");
    			attr_dev(rect7, "y", "24");
    			attr_dev(rect7, "rx", "1.92");
    			attr_dev(rect7, "ry", "1.92");
    			attr_dev(rect7, "width", "5");
    			attr_dev(rect7, "height", "12");
    			attr_dev(rect7, "fill", "#ffffff");
    			add_location(rect7, file$2, 122, 28, 6923);
    			attr_dev(g7, "transform", "rotate(210 50 50)");
    			add_location(g7, file$2, 121, 24, 6860);
    			attr_dev(animate8, "attributeName", "opacity");
    			attr_dev(animate8, "values", "1;0");
    			attr_dev(animate8, "keyTimes", "0;1");
    			attr_dev(animate8, "dur", "1s");
    			attr_dev(animate8, "begin", "-0.25s");
    			attr_dev(animate8, "repeatCount", "indefinite");
    			add_location(animate8, file$2, 128, 32, 7439);
    			attr_dev(rect8, "x", "47.5");
    			attr_dev(rect8, "y", "24");
    			attr_dev(rect8, "rx", "1.92");
    			attr_dev(rect8, "ry", "1.92");
    			attr_dev(rect8, "width", "5");
    			attr_dev(rect8, "height", "12");
    			attr_dev(rect8, "fill", "#ffffff");
    			add_location(rect8, file$2, 127, 28, 7326);
    			attr_dev(g8, "transform", "rotate(240 50 50)");
    			add_location(g8, file$2, 126, 24, 7263);
    			attr_dev(animate9, "attributeName", "opacity");
    			attr_dev(animate9, "values", "1;0");
    			attr_dev(animate9, "keyTimes", "0;1");
    			attr_dev(animate9, "dur", "1s");
    			attr_dev(animate9, "begin", "-0.16666666666666666s");
    			attr_dev(animate9, "repeatCount", "indefinite");
    			add_location(animate9, file$2, 133, 32, 7828);
    			attr_dev(rect9, "x", "47.5");
    			attr_dev(rect9, "y", "24");
    			attr_dev(rect9, "rx", "1.92");
    			attr_dev(rect9, "ry", "1.92");
    			attr_dev(rect9, "width", "5");
    			attr_dev(rect9, "height", "12");
    			attr_dev(rect9, "fill", "#ffffff");
    			add_location(rect9, file$2, 132, 28, 7715);
    			attr_dev(g9, "transform", "rotate(270 50 50)");
    			add_location(g9, file$2, 131, 24, 7652);
    			attr_dev(animate10, "attributeName", "opacity");
    			attr_dev(animate10, "values", "1;0");
    			attr_dev(animate10, "keyTimes", "0;1");
    			attr_dev(animate10, "dur", "1s");
    			attr_dev(animate10, "begin", "-0.08333333333333333s");
    			attr_dev(animate10, "repeatCount", "indefinite");
    			add_location(animate10, file$2, 138, 32, 8232);
    			attr_dev(rect10, "x", "47.5");
    			attr_dev(rect10, "y", "24");
    			attr_dev(rect10, "rx", "1.92");
    			attr_dev(rect10, "ry", "1.92");
    			attr_dev(rect10, "width", "5");
    			attr_dev(rect10, "height", "12");
    			attr_dev(rect10, "fill", "#ffffff");
    			add_location(rect10, file$2, 137, 28, 8119);
    			attr_dev(g10, "transform", "rotate(300 50 50)");
    			add_location(g10, file$2, 136, 24, 8056);
    			attr_dev(animate11, "attributeName", "opacity");
    			attr_dev(animate11, "values", "1;0");
    			attr_dev(animate11, "keyTimes", "0;1");
    			attr_dev(animate11, "dur", "1s");
    			attr_dev(animate11, "begin", "0s");
    			attr_dev(animate11, "repeatCount", "indefinite");
    			add_location(animate11, file$2, 143, 32, 8636);
    			attr_dev(rect11, "x", "47.5");
    			attr_dev(rect11, "y", "24");
    			attr_dev(rect11, "rx", "1.92");
    			attr_dev(rect11, "ry", "1.92");
    			attr_dev(rect11, "width", "5");
    			attr_dev(rect11, "height", "12");
    			attr_dev(rect11, "fill", "#ffffff");
    			add_location(rect11, file$2, 142, 28, 8523);
    			attr_dev(g11, "transform", "rotate(330 50 50)");
    			add_location(g11, file$2, 141, 24, 8460);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			set_style(svg, "margin", "auto");
    			set_style(svg, "background", "transparent");
    			set_style(svg, "display", "block");
    			set_style(svg, "shape-rendering", "auto");
    			attr_dev(svg, "width", "13.5vh");
    			attr_dev(svg, "height", "13.5vh");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "preserveAspectRatio", "xMidYMid");
    			add_location(svg, file$2, 85, 20, 3794);
    			attr_dev(div0, "class", "mdw-loader-modal-container svelte-jkakuq");
    			add_location(div0, file$2, 84, 16, 3732);
    			attr_dev(div1, "class", "mdw-loader-modal svelte-jkakuq");
    			add_location(div1, file$2, 83, 12, 3684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, svg);
    			append_dev(svg, g0);
    			append_dev(g0, rect0);
    			append_dev(rect0, animate0);
    			append_dev(svg, g1);
    			append_dev(g1, rect1);
    			append_dev(rect1, animate1);
    			append_dev(svg, g2);
    			append_dev(g2, rect2);
    			append_dev(rect2, animate2);
    			append_dev(svg, g3);
    			append_dev(g3, rect3);
    			append_dev(rect3, animate3);
    			append_dev(svg, g4);
    			append_dev(g4, rect4);
    			append_dev(rect4, animate4);
    			append_dev(svg, g5);
    			append_dev(g5, rect5);
    			append_dev(rect5, animate5);
    			append_dev(svg, g6);
    			append_dev(g6, rect6);
    			append_dev(rect6, animate6);
    			append_dev(svg, g7);
    			append_dev(g7, rect7);
    			append_dev(rect7, animate7);
    			append_dev(svg, g8);
    			append_dev(g8, rect8);
    			append_dev(rect8, animate8);
    			append_dev(svg, g9);
    			append_dev(g9, rect9);
    			append_dev(rect9, animate9);
    			append_dev(svg, g10);
    			append_dev(g10, rect10);
    			append_dev(rect10, animate10);
    			append_dev(svg, g11);
    			append_dev(g11, rect11);
    			append_dev(rect11, animate11);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(83:8) {#if $ShowLoader}",
    		ctx
    	});

    	return block;
    }

    // (153:8) {#if Opacity > 0.0}
    function create_if_block$2(ctx) {
    	let mdwnavbar;
    	let t;
    	let mdwcontainer;
    	let current;
    	mdwnavbar = new MdwNavbar({ $$inline: true });
    	mdwcontainer = new MdwContainer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mdwnavbar.$$.fragment);
    			t = space();
    			create_component(mdwcontainer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdwnavbar, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdwcontainer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdwnavbar.$$.fragment, local);
    			transition_in(mdwcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdwnavbar.$$.fragment, local);
    			transition_out(mdwcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdwnavbar, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdwcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(153:8) {#if Opacity > 0.0}",
    		ctx
    	});

    	return block;
    }

    // (68:0) <AppWrapper AppName="Mdw" Focused={MdwVisible}>
    function create_default_slot(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let mdwtopbar;
    	let t13;
    	let div_class_value;
    	let current;
    	let if_block0 = /*$MdwModalsExport*/ ctx[2].Show && create_if_block_13(ctx);
    	let if_block1 = /*$MdwModalsTags*/ ctx[3].Show && create_if_block_12(ctx);
    	let if_block2 = /*$MdwModalsCerts*/ ctx[4].Show && create_if_block_11(ctx);
    	let if_block3 = /*$MdwModalsRoles*/ ctx[5].Show && create_if_block_10(ctx);
    	let if_block4 = /*$MdwModalsUnits*/ ctx[6].Show && create_if_block_9(ctx);
    	let if_block5 = /*$MdwModalsPerson*/ ctx[7].Show && create_if_block_8(ctx);
    	let if_block6 = /*$MdwModalsEvidence*/ ctx[8].Show && create_if_block_7(ctx);
    	let if_block7 = /*$MdwModalsProfiles*/ ctx[9].Show && create_if_block_6(ctx);
    	let if_block8 = /*$MdwModalsCharges*/ ctx[10].Show && create_if_block_5(ctx);
    	let if_block9 = /*$MdwModalsPermissions*/ ctx[11].Show && create_if_block_4(ctx);
    	let if_block10 = /*$MdwModalsChargeEditor*/ ctx[12].Show && create_if_block_3$1(ctx);
    	let if_block11 = /*$MdwModalsVehicleHistory*/ ctx[13].Show && create_if_block_2$2(ctx);
    	let if_block12 = /*$ShowLoader*/ ctx[14] && create_if_block_1$2(ctx);
    	mdwtopbar = new MdwTopbar({ $$inline: true });
    	mdwtopbar.$on("mouseenter", /*mouseenter_handler*/ ctx[15]);
    	mdwtopbar.$on("mouseleave", /*mouseleave_handler*/ ctx[16]);
    	let if_block13 = /*Opacity*/ ctx[1] > 0.0 && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			t6 = space();
    			if (if_block7) if_block7.c();
    			t7 = space();
    			if (if_block8) if_block8.c();
    			t8 = space();
    			if (if_block9) if_block9.c();
    			t9 = space();
    			if (if_block10) if_block10.c();
    			t10 = space();
    			if (if_block11) if_block11.c();
    			t11 = space();
    			if (if_block12) if_block12.c();
    			t12 = space();
    			create_component(mdwtopbar.$$.fragment);
    			t13 = space();
    			if (if_block13) if_block13.c();

    			attr_dev(div, "class", div_class_value = "mdw-wrapper " + (/*MdwVisible*/ ctx[0]
    			? "mdw-wrapper-in"
    			: "mdw-wrapper-out") + " svelte-jkakuq");

    			set_style(div, "opacity", /*MdwVisible*/ ctx[0] ? /*Opacity*/ ctx[1] : 0.0);
    			add_location(div, file$2, 68, 4, 2768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t6);
    			if (if_block7) if_block7.m(div, null);
    			append_dev(div, t7);
    			if (if_block8) if_block8.m(div, null);
    			append_dev(div, t8);
    			if (if_block9) if_block9.m(div, null);
    			append_dev(div, t9);
    			if (if_block10) if_block10.m(div, null);
    			append_dev(div, t10);
    			if (if_block11) if_block11.m(div, null);
    			append_dev(div, t11);
    			if (if_block12) if_block12.m(div, null);
    			append_dev(div, t12);
    			mount_component(mdwtopbar, div, null);
    			append_dev(div, t13);
    			if (if_block13) if_block13.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$MdwModalsExport*/ ctx[2].Show) {
    				if (if_block0) {
    					if (dirty & /*$MdwModalsExport*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_13(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsTags*/ ctx[3].Show) {
    				if (if_block1) {
    					if (dirty & /*$MdwModalsTags*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_12(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsCerts*/ ctx[4].Show) {
    				if (if_block2) {
    					if (dirty & /*$MdwModalsCerts*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_11(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsRoles*/ ctx[5].Show) {
    				if (if_block3) {
    					if (dirty & /*$MdwModalsRoles*/ 32) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_10(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsUnits*/ ctx[6].Show) {
    				if (if_block4) {
    					if (dirty & /*$MdwModalsUnits*/ 64) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsPerson*/ ctx[7].Show) {
    				if (if_block5) {
    					if (dirty & /*$MdwModalsPerson*/ 128) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_8(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsEvidence*/ ctx[8].Show) {
    				if (if_block6) {
    					if (dirty & /*$MdwModalsEvidence*/ 256) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_7(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div, t6);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsProfiles*/ ctx[9].Show) {
    				if (if_block7) {
    					if (dirty & /*$MdwModalsProfiles*/ 512) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_6(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(div, t7);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsCharges*/ ctx[10].Show) {
    				if (if_block8) {
    					if (dirty & /*$MdwModalsCharges*/ 1024) {
    						transition_in(if_block8, 1);
    					}
    				} else {
    					if_block8 = create_if_block_5(ctx);
    					if_block8.c();
    					transition_in(if_block8, 1);
    					if_block8.m(div, t8);
    				}
    			} else if (if_block8) {
    				group_outros();

    				transition_out(if_block8, 1, 1, () => {
    					if_block8 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsPermissions*/ ctx[11].Show) {
    				if (if_block9) {
    					if (dirty & /*$MdwModalsPermissions*/ 2048) {
    						transition_in(if_block9, 1);
    					}
    				} else {
    					if_block9 = create_if_block_4(ctx);
    					if_block9.c();
    					transition_in(if_block9, 1);
    					if_block9.m(div, t9);
    				}
    			} else if (if_block9) {
    				group_outros();

    				transition_out(if_block9, 1, 1, () => {
    					if_block9 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsChargeEditor*/ ctx[12].Show) {
    				if (if_block10) {
    					if (dirty & /*$MdwModalsChargeEditor*/ 4096) {
    						transition_in(if_block10, 1);
    					}
    				} else {
    					if_block10 = create_if_block_3$1(ctx);
    					if_block10.c();
    					transition_in(if_block10, 1);
    					if_block10.m(div, t10);
    				}
    			} else if (if_block10) {
    				group_outros();

    				transition_out(if_block10, 1, 1, () => {
    					if_block10 = null;
    				});

    				check_outros();
    			}

    			if (/*$MdwModalsVehicleHistory*/ ctx[13].Show) {
    				if (if_block11) {
    					if (dirty & /*$MdwModalsVehicleHistory*/ 8192) {
    						transition_in(if_block11, 1);
    					}
    				} else {
    					if_block11 = create_if_block_2$2(ctx);
    					if_block11.c();
    					transition_in(if_block11, 1);
    					if_block11.m(div, t11);
    				}
    			} else if (if_block11) {
    				group_outros();

    				transition_out(if_block11, 1, 1, () => {
    					if_block11 = null;
    				});

    				check_outros();
    			}

    			if (/*$ShowLoader*/ ctx[14]) {
    				if (if_block12) ; else {
    					if_block12 = create_if_block_1$2(ctx);
    					if_block12.c();
    					if_block12.m(div, t12);
    				}
    			} else if (if_block12) {
    				if_block12.d(1);
    				if_block12 = null;
    			}

    			if (/*Opacity*/ ctx[1] > 0.0) {
    				if (if_block13) {
    					if (dirty & /*Opacity*/ 2) {
    						transition_in(if_block13, 1);
    					}
    				} else {
    					if_block13 = create_if_block$2(ctx);
    					if_block13.c();
    					transition_in(if_block13, 1);
    					if_block13.m(div, null);
    				}
    			} else if (if_block13) {
    				group_outros();

    				transition_out(if_block13, 1, 1, () => {
    					if_block13 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*MdwVisible*/ 1 && div_class_value !== (div_class_value = "mdw-wrapper " + (/*MdwVisible*/ ctx[0]
    			? "mdw-wrapper-in"
    			: "mdw-wrapper-out") + " svelte-jkakuq")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*MdwVisible, Opacity*/ 3) {
    				set_style(div, "opacity", /*MdwVisible*/ ctx[0] ? /*Opacity*/ ctx[1] : 0.0);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			transition_in(if_block9);
    			transition_in(if_block10);
    			transition_in(if_block11);
    			transition_in(mdwtopbar.$$.fragment, local);
    			transition_in(if_block13);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			transition_out(if_block9);
    			transition_out(if_block10);
    			transition_out(if_block11);
    			transition_out(mdwtopbar.$$.fragment, local);
    			transition_out(if_block13);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    			if (if_block10) if_block10.d();
    			if (if_block11) if_block11.d();
    			if (if_block12) if_block12.d();
    			destroy_component(mdwtopbar);
    			if (if_block13) if_block13.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(68:0) <AppWrapper AppName=\\\"Mdw\\\" Focused={MdwVisible}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let appwrapper;
    	let current;

    	appwrapper = new AppWrapper({
    			props: {
    				AppName: "Mdw",
    				Focused: /*MdwVisible*/ ctx[0],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(appwrapper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(appwrapper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const appwrapper_changes = {};
    			if (dirty & /*MdwVisible*/ 1) appwrapper_changes.Focused = /*MdwVisible*/ ctx[0];

    			if (dirty & /*$$scope, MdwVisible, Opacity, $ShowLoader, $MdwModalsVehicleHistory, $MdwModalsChargeEditor, $MdwModalsPermissions, $MdwModalsCharges, $MdwModalsProfiles, $MdwModalsEvidence, $MdwModalsPerson, $MdwModalsUnits, $MdwModalsRoles, $MdwModalsCerts, $MdwModalsTags, $MdwModalsExport*/ 294911) {
    				appwrapper_changes.$$scope = { dirty, ctx };
    			}

    			appwrapper.$set(appwrapper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appwrapper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appwrapper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(appwrapper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $ImageHoverData;
    	let $MdwModalsExport;
    	let $MdwModalsTags;
    	let $MdwModalsCerts;
    	let $MdwModalsRoles;
    	let $MdwModalsUnits;
    	let $MdwModalsPerson;
    	let $MdwModalsEvidence;
    	let $MdwModalsProfiles;
    	let $MdwModalsCharges;
    	let $MdwModalsPermissions;
    	let $MdwModalsChargeEditor;
    	let $MdwModalsVehicleHistory;
    	let $ShowLoader;
    	validate_store(ImageHoverData, 'ImageHoverData');
    	component_subscribe($$self, ImageHoverData, $$value => $$invalidate(17, $ImageHoverData = $$value));
    	validate_store(MdwModalsExport$1, 'MdwModalsExport');
    	component_subscribe($$self, MdwModalsExport$1, $$value => $$invalidate(2, $MdwModalsExport = $$value));
    	validate_store(MdwModalsTags, 'MdwModalsTags');
    	component_subscribe($$self, MdwModalsTags, $$value => $$invalidate(3, $MdwModalsTags = $$value));
    	validate_store(MdwModalsCerts, 'MdwModalsCerts');
    	component_subscribe($$self, MdwModalsCerts, $$value => $$invalidate(4, $MdwModalsCerts = $$value));
    	validate_store(MdwModalsRoles, 'MdwModalsRoles');
    	component_subscribe($$self, MdwModalsRoles, $$value => $$invalidate(5, $MdwModalsRoles = $$value));
    	validate_store(MdwModalsUnits, 'MdwModalsUnits');
    	component_subscribe($$self, MdwModalsUnits, $$value => $$invalidate(6, $MdwModalsUnits = $$value));
    	validate_store(MdwModalsPerson, 'MdwModalsPerson');
    	component_subscribe($$self, MdwModalsPerson, $$value => $$invalidate(7, $MdwModalsPerson = $$value));
    	validate_store(MdwModalsEvidence, 'MdwModalsEvidence');
    	component_subscribe($$self, MdwModalsEvidence, $$value => $$invalidate(8, $MdwModalsEvidence = $$value));
    	validate_store(MdwModalsProfiles, 'MdwModalsProfiles');
    	component_subscribe($$self, MdwModalsProfiles, $$value => $$invalidate(9, $MdwModalsProfiles = $$value));
    	validate_store(MdwModalsCharges, 'MdwModalsCharges');
    	component_subscribe($$self, MdwModalsCharges, $$value => $$invalidate(10, $MdwModalsCharges = $$value));
    	validate_store(MdwModalsPermissions, 'MdwModalsPermissions');
    	component_subscribe($$self, MdwModalsPermissions, $$value => $$invalidate(11, $MdwModalsPermissions = $$value));
    	validate_store(MdwModalsChargeEditor, 'MdwModalsChargeEditor');
    	component_subscribe($$self, MdwModalsChargeEditor, $$value => $$invalidate(12, $MdwModalsChargeEditor = $$value));
    	validate_store(MdwModalsVehicleHistory, 'MdwModalsVehicleHistory');
    	component_subscribe($$self, MdwModalsVehicleHistory, $$value => $$invalidate(13, $MdwModalsVehicleHistory = $$value));
    	validate_store(ShowLoader, 'ShowLoader');
    	component_subscribe($$self, ShowLoader, $$value => $$invalidate(14, $ShowLoader = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Mdw', slots, []);
    	let MdwVisible = IsEnvBrowser();
    	let Opacity = IsEnvBrowser() ? 1.0 : 0.0;

    	OnEvent("Mdw/SetVisiblity", Data => {
    		IsPublic.set(Data.IsPublic);
    		if (Data.IsPublic) CurrentTab.set("Profiles");
    		$$invalidate(0, MdwVisible = Data.Visible);

    		if (!Data.Visible && $ImageHoverData.Show) {
    			ImageHoverData.set({ Show: false, Source: "", Top: 0, Left: 0 });
    		}
    		$$invalidate(1, Opacity = Data.Visible ? 1.0 : 0.0);
    	});

    	OnEvent("Mdw/SetCharges", Data => {
    		MdwCharges.set(Data);
    	});

    	OnEvent("Mdw/SetTags", Data => {
    		MdwTags.set(Data);
    	});

    	OnEvent("Mdw/SetCerts", Data => {
    		MdwCerts.set(Data);
    	});

    	OnEvent("Mdw/SetRanks", Data => {
    		MdwRanks.set(Data);
    	});

    	OnEvent("Mdw/SetEvidence", Data => {
    		MdwEvidence.set(Data);
    	});

    	OnEvent("Mdw/SetRoles", Data => {
    		MdwRoles.set(Data);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mdw> was created with unknown prop '${key}'`);
    	});

    	const mouseenter_handler = () => {
    		$$invalidate(1, Opacity = 0.5);
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(1, Opacity = 1.0);
    	};

    	$$self.$capture_state = () => ({
    		CurrentTab,
    		IsPublic,
    		MdwCharges,
    		MdwTags,
    		MdwCerts,
    		ShowLoader,
    		MdwModalsTags,
    		MdwModalsCerts,
    		MdwModalsUnits,
    		MdwEvidence,
    		MdwModalsPerson,
    		ImageHoverData,
    		MdwModalsEvidence,
    		MdwModalsProfiles,
    		MdwModalsCharges,
    		MdwRanks,
    		MdwRoles,
    		MdwModalsPermissions,
    		MdwModalsRoles,
    		MdwModalsExport: MdwModalsExport$1,
    		MdwModalsChargeEditor,
    		MdwModalsVehicleHistory,
    		Debug: Debug$1,
    		IsEnvBrowser,
    		OnEvent,
    		MdwTopbar,
    		MdwNavbar,
    		MdwContainer,
    		ModalsTags: Modals_Tags,
    		ModalsCerts: Modals_Certs,
    		ModalsRoles: Modals_Roles,
    		ModalsUnits: Modals_Units,
    		ModalsPerson: Modals_Persons,
    		ModalsEvidence: Modals_Evidence,
    		ModalsProfiles: Modals_Profile,
    		ModalsCharges: Modals_Charges,
    		ModalsPermissions: Modals_Permissions,
    		ModalsChargeEditor: Modals_ChargeEditor,
    		ModalsVehicleHistory: Modals_VehicleHistory,
    		ModalsExport: Modals_Export,
    		AppWrapper,
    		MdwVisible,
    		Opacity,
    		$ImageHoverData,
    		$MdwModalsExport,
    		$MdwModalsTags,
    		$MdwModalsCerts,
    		$MdwModalsRoles,
    		$MdwModalsUnits,
    		$MdwModalsPerson,
    		$MdwModalsEvidence,
    		$MdwModalsProfiles,
    		$MdwModalsCharges,
    		$MdwModalsPermissions,
    		$MdwModalsChargeEditor,
    		$MdwModalsVehicleHistory,
    		$ShowLoader
    	});

    	$$self.$inject_state = $$props => {
    		if ('MdwVisible' in $$props) $$invalidate(0, MdwVisible = $$props.MdwVisible);
    		if ('Opacity' in $$props) $$invalidate(1, Opacity = $$props.Opacity);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		MdwVisible,
    		Opacity,
    		$MdwModalsExport,
    		$MdwModalsTags,
    		$MdwModalsCerts,
    		$MdwModalsRoles,
    		$MdwModalsUnits,
    		$MdwModalsPerson,
    		$MdwModalsEvidence,
    		$MdwModalsProfiles,
    		$MdwModalsCharges,
    		$MdwModalsPermissions,
    		$MdwModalsChargeEditor,
    		$MdwModalsVehicleHistory,
    		$ShowLoader,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Mdw extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mdw",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* src\providers\AppProvider.svelte generated by Svelte v3.59.2 */
    const file$1 = "src\\providers\\AppProvider.svelte";

    // (30:0) {#if IsEnvBrowser()}
    function create_if_block_3(ctx) {
    	let debug_1;
    	let current;
    	debug_1 = new Debug({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(debug_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(debug_1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debug_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debug_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(debug_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(30:0) {#if IsEnvBrowser()}",
    		ctx
    	});

    	return block;
    }

    // (32:0) {#if CrashedApp != "Mdw"}
    function create_if_block_2$1(ctx) {
    	let mdw;
    	let current;
    	mdw = new Mdw({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mdw.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdw, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdw.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdw.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdw, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(32:0) {#if CrashedApp != \\\"Mdw\\\"}",
    		ctx
    	});

    	return block;
    }

    // (36:0) {#if ShowCrashNotify}
    function create_if_block$1(ctx) {
    	let div;
    	let i;
    	let t;
    	let div_transition;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*CrashedApp*/ ctx[1] != "root") return create_if_block_1$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			t = space();
    			if_block.c();
    			attr_dev(i, "class", "fal fa-exclamation-circle svelte-1pecch8");
    			add_location(i, file$1, 40, 8, 1095);
    			attr_dev(div, "class", "crash-reload svelte-1pecch8");
    			add_location(div, file$1, 36, 4, 999);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t);
    			if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 250 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 250 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(36:0) {#if ShowCrashNotify}",
    		ctx
    	});

    	return block;
    }

    // (44:8) {:else}
    function create_else_block$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Error occured in root ui - restarting...";
    			attr_dev(p, "class", "svelte-1pecch8");
    			add_location(p, file$1, 44, 12, 1285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(44:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:8) {#if CrashedApp != "root"}
    function create_if_block_1$1(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*CrashedApp*/ ctx[1].toLowerCase() + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Error occured in app: ");
    			t1 = text(t1_value);
    			t2 = text(" - restarting...");
    			attr_dev(p, "class", "svelte-1pecch8");
    			add_location(p, file$1, 42, 12, 1183);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*CrashedApp*/ 2 && t1_value !== (t1_value = /*CrashedApp*/ ctx[1].toLowerCase() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(42:8) {#if CrashedApp != \\\"root\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let show_if = IsEnvBrowser();
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = show_if && create_if_block_3(ctx);
    	let if_block1 = /*CrashedApp*/ ctx[1] != "Mdw" && create_if_block_2$1(ctx);
    	let if_block2 = /*ShowCrashNotify*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*CrashedApp*/ ctx[1] != "Mdw") {
    				if (if_block1) {
    					if (dirty & /*CrashedApp*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*ShowCrashNotify*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*ShowCrashNotify*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AppProvider', slots, []);
    	let ShowCrashNotify = false;
    	let CrashedApp = "root";

    	onMount(() => {
    		$$invalidate(0, ShowCrashNotify = localStorage.getItem("isUiCrashed") == "yes");

    		if (ShowCrashNotify) {
    			$$invalidate(0, ShowCrashNotify = true);
    			$$invalidate(1, CrashedApp = localStorage.getItem("crashedAppName"));

    			setTimeout(
    				() => {
    					$$invalidate(0, ShowCrashNotify = false);
    					$$invalidate(1, CrashedApp = "root");
    				},
    				3000
    			);

    			localStorage.setItem("isUiCrashed", "no");
    			localStorage.setItem("crashedAppName", "root");
    			SendEvent("Mdw/Close");
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AppProvider> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		IsEnvBrowser,
    		SendEvent,
    		Debug,
    		Mdw,
    		fade,
    		onMount,
    		ShowCrashNotify,
    		CrashedApp
    	});

    	$$self.$inject_state = $$props => {
    		if ('ShowCrashNotify' in $$props) $$invalidate(0, ShowCrashNotify = $$props.ShowCrashNotify);
    		if ('CrashedApp' in $$props) $$invalidate(1, CrashedApp = $$props.CrashedApp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ShowCrashNotify, CrashedApp];
    }

    class AppProvider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppProvider",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.59.2 */
    const file = "src\\App.svelte";

    // (41:0) {:else}
    function create_else_block(ctx) {
    	let h6;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			h6.textContent = "loser";
    			set_style(h6, "width", "100%");
    			set_style(h6, "text-align", "center");
    			set_style(h6, "font-size", "40vh");
    			set_style(h6, "font-family", "Roboto");
    			set_style(h6, "color", "red");
    			add_location(h6, file, 41, 4, 1529);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(41:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:0) {#if !(window).GetParentResourceName || (window).GetParentResourceName() == "fw-mdw"}
    function create_if_block(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let appprovider;
    	let current;
    	let if_block0 = /*$ImageHoverData*/ ctx[0].Show && create_if_block_2(ctx);
    	let if_block1 = /*$DropdownData*/ ctx[1].Show && create_if_block_1(ctx);
    	appprovider = new AppProvider({ $$inline: true });

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div = element("div");
    			create_component(appprovider.$$.fragment);
    			attr_dev(div, "class", "root");
    			add_location(div, file, 37, 4, 1459);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(appprovider, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ImageHoverData*/ ctx[0].Show) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$DropdownData*/ ctx[1].Show) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$DropdownData*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(appprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(appprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(appprovider);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(23:0) {#if !(window).GetParentResourceName || (window).GetParentResourceName() == \\\"fw-mdw\\\"}",
    		ctx
    	});

    	return block;
    }

    // (24:4) {#if $ImageHoverData.Show}
    function create_if_block_2(ctx) {
    	let div;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = /*$ImageHoverData*/ ctx[0].Source)) attr_dev(img, "src", img_src_value);
    			set_style(img, "max-width", /*$ImageHoverData*/ ctx[0].MaxWidth + "%");
    			set_style(img, "height", "auto");
    			add_location(img, file, 25, 12, 1041);
    			set_style(div, "position", "absolute");
    			set_style(div, "top", /*$ImageHoverData*/ ctx[0].Top + "px");
    			set_style(div, "left", /*$ImageHoverData*/ ctx[0].Left + "px");
    			set_style(div, "z-index", "999");
    			set_style(div, "pointer-events", "none");
    			add_location(div, file, 24, 8, 896);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$ImageHoverData*/ 1 && !src_url_equal(img.src, img_src_value = /*$ImageHoverData*/ ctx[0].Source)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*$ImageHoverData*/ 1) {
    				set_style(img, "max-width", /*$ImageHoverData*/ ctx[0].MaxWidth + "%");
    			}

    			if (dirty & /*$ImageHoverData*/ 1) {
    				set_style(div, "top", /*$ImageHoverData*/ ctx[0].Top + "px");
    			}

    			if (dirty & /*$ImageHoverData*/ 1) {
    				set_style(div, "left", /*$ImageHoverData*/ ctx[0].Left + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(24:4) {#if $ImageHoverData.Show}",
    		ctx
    	});

    	return block;
    }

    // (30:4) {#if $DropdownData.Show}
    function create_if_block_1(ctx) {
    	let dropdown;
    	let current;

    	dropdown = new Dropdown({
    			props: {
    				Options: /*$DropdownData*/ ctx[1].Options,
    				Positioning: {
    					Width: /*$DropdownData*/ ctx[1].Positioning?.Width,
    					Top: /*$DropdownData*/ ctx[1].Positioning?.Top,
    					Left: /*$DropdownData*/ ctx[1].Positioning?.Left
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown_changes = {};
    			if (dirty & /*$DropdownData*/ 2) dropdown_changes.Options = /*$DropdownData*/ ctx[1].Options;

    			if (dirty & /*$DropdownData*/ 2) dropdown_changes.Positioning = {
    				Width: /*$DropdownData*/ ctx[1].Positioning?.Width,
    				Top: /*$DropdownData*/ ctx[1].Positioning?.Top,
    				Left: /*$DropdownData*/ ctx[1].Positioning?.Left
    			};

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(30:4) {#if $DropdownData.Show}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!window.GetParentResourceName || window.GetParentResourceName() == "fw-mdw") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $ImageHoverData;
    	let $DropdownData;
    	validate_store(ImageHoverData, 'ImageHoverData');
    	component_subscribe($$self, ImageHoverData, $$value => $$invalidate(0, $ImageHoverData = $$value));
    	validate_store(DropdownData, 'DropdownData');
    	component_subscribe($$self, DropdownData, $$value => $$invalidate(1, $DropdownData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	SetExitHandler("Close", "Mdw/Close", () => {
    		SetDropdown(false, [], {});
    		return true;
    	});

    	OnEvent("Mdw/SetGlobalData", Data => {
    		IsGov.set(Data.IsGov);
    		IsEms.set(Data.IsEms);
    		IsJudge.set(Data.IsJudge);
    		IsHighcommand.set(Data.IsHighcommand);
    		MdwProfile.set(Data.Profile);
    		Debug$1("SetGlobalData -> " + JSON.stringify(Data));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Dropdown,
    		AppProvider,
    		DropdownData,
    		IsGov,
    		IsEms,
    		IsJudge,
    		IsHighcommand,
    		ImageHoverData,
    		MdwProfile,
    		OnEvent,
    		Debug: Debug$1,
    		SetExitHandler,
    		SetDropdown,
    		$ImageHoverData,
    		$DropdownData
    	});

    	return [$ImageHoverData, $DropdownData];
    }

    class App$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App$1({
      target: document.body,
    });

    return app;

})();
